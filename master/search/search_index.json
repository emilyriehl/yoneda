{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Yoneda for \u221e-categories","text":"<p>This is a formalization library for simplicial Homotopy Type Theory (HoTT) with the aim of proving the Yoneda lemma for \u221e-categories following the paper \"A type theory for synthetic \u221e-categories\" <sup>1</sup>. This formalization project could be regarded as a companion to the article \"Could \u221e-category theory be taught to undergraduates?\" <sup>2</sup>.</p> <p>Info</p> <p>This project has been \u2744 frozen \u2744. For ongoing simplicial HoTT formalization see http://rzk-lang.github.io/sHoTT/.</p> <p>The formalizations are implemented using <code>rzk</code>, an experimental proof assistant for a variant of type theory with shapes developed by Nikolai Kudasov. Formalizations were contributed by Fredrik Bakke, Nikolai Kudasov, Emily Riehl, and Jonathan Weinberger. Our source files are available on github.</p> <p>Another aim of this project is to compare the proof of the Yoneda lemma for \u221e-categories in simplicial HoTT with proofs of the Yoneda lemma for 1-categories in other proof assistants. To that end Sina Hazratpour has contributed a formalization in <code>Lean3</code> extracted from materials he prepared to teach Introduction to Proofs at Johns Hopkins, which can be found here.</p> <p>We also contributed a proof of the Yoneda lemma for precategories to the Agda-Unimath library. Here we prove the Yoneda lemma for pre-\u221e-categories, since the univalence/completeness condition is not required for this result. By analogy, precategories are the non-univalent 1-categories in HoTT. See also other Yoneda formalizations.</p>"},{"location":"#checking-the-formalisations-locally","title":"Checking the Formalisations Locally","text":"<p>Install the <code>rzk</code> proof assistant. Then run the following command from the root of our repository:</p> <pre><code>rzk typecheck\n</code></pre> <ol> <li> <p>Emily Riehl &amp; Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9</p> </li> <li> <p>Emily Riehl. Could \u221e-category theory be taught to undergraduates? Notices of the AMS. May 2023. https://www.ams.org/journals/notices/202305/noti2692/noti2692.html \u21a9</p> </li> </ol>"},{"location":"STYLEGUIDE/","title":"Style guide and design principles","text":"<p>This guide provides a set of design principles and guidelines for the <code>yoneda</code> project. Our style and design principles borrows heavily from <code>agda-unimath</code>.</p>"},{"location":"STYLEGUIDE/#the-structure-of-code","title":"The structure of code","text":"<p>We enforce strict formatting rules. This formatting allows the type of the defined term to be easily readable, and aids in understanding the structure of the definition.</p> <p>The general format of a definition is as follows:</p> <pre><code>#def concat\n  ( p : x = y)\n  ( q : y = z)\n  : (x = z)\n  := idJ (A , y , \\ z' q' \u2192 (x = z') , p , z , q)\n</code></pre> <ul> <li> <p>We start with the name, and place every assumption on a new line.</p> </li> <li> <p>The conclusion of the definition is placed on its own line, which starts with   a colon (<code>:</code>).</p> </li> <li> <p>Then, on the next line, the walrus separator (<code>:=</code>) is placed, and after it   follows the actual construction of the definition. If the construction does   not fit on a single line, we immediately insert a new line after the walrus   separator and indent the code an extra level (2 spaces).</p> </li> </ul> <p>(Currently just taken from agda-unimath and adapted to Rzk) In Rzk, every construction is structured like a tree, where each operation can be seen as a branching point. We use indentation levels and parentheses to highlight this structure, which makes the code feel more organized and understandable. For example, when a definition part extends beyond a line, we introduce line breaks at the earliest branching point, clearly displaying the tree structure of the definition. This allows the reader to follow the branches of the tree, and to visually grasp the scope of each operation and argument. Consider the following example about Segal types:</p> <pre><code>#def is-segal-is-local-horn-inclusion\n  ( A : U)\n  ( is-local-horn-inclusion-A : is-local-horn-inclusion A)\n  : isSegal A\n  :=\n    \\ x y z f g \u2192\n    projection-equiv-contractible-fibers\n      ( \u039b \u2192 A)\n      ( \\ k \u2192\n        \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))) ,\n          ( hom2 A\n            ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n            ( \\ t \u2192 k (t , 0\u2082))\n            ( \\ t \u2192 k (1\u2082 , t))\n            ( h)))\n      ( second\n        ( comp-equiv\n          ( \u03a3 ( k : \u039b \u2192 A ) ,\n            \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))) ,\n              ( hom2 A\n                ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n                ( \\ t \u2192 k (t , 0\u2082))\n                ( \\ t \u2192 k (1\u2082 , t))\n                ( h)))\n          ( \u0394\u00b2 \u2192 A)\n          ( \u039b  \u2192 A)\n          ( inv-equiv\n            ( \u0394\u00b2 \u2192 A)\n            ( \u03a3 ( k : \u039b \u2192 A) ,\n              \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))) ,\n                ( hom2 A\n                  ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n                  ( \\ t \u2192 k (t , 0\u2082))\n                  ( \\ t \u2192 k (1\u2082 , t))\n                  ( h)))\n            ( equiv-horn-restriction A))\n          ( horn-restriction A , is-local-horn-inclusion-A)))\n      ( horn A x y z f g)\n</code></pre> <p>The root here is the function <code>projection-equiv-contractible-fibers</code>. It takes four arguments, each starting on a fresh line and is indented an extra level from the root. The first argument fits neatly on one line, but the second one is too large. In these cases, we add a line break right after the <code>\u2192</code>-symbol following the lambda-abstraction, which is the earliest branching point in this case. The next node is again <code>\u03a3</code>, with two arguments. The first one fits on a line, but the second does not, so we add a line break between them. This process is continued until the definition is complete.</p> <p>Note also that we use parentheses to mark the branches. The extra space after the opening parentheses marking a branch is there to visually emphasize the tree structure of the definition, and synergizes with our convention to have two-space indentation level increases.</p>"},{"location":"STYLEGUIDE/#naming-conventions","title":"Naming conventions","text":"<ul> <li>As a main strategy, we strive to keep a tight connection between names of   constructions and their types. Take for instance [...]. <ul> <li>Add example</li> <li>prepending assumptions and then conclusion</li> <li>See agda-unimath's description</li> <li> <p>We start with the initial assumption, then, working our way to the conclusion, prepending every central assumption to the name, and finally the conclusion. So for instance the name <code>iso-is-initial-is-segal</code> should read like we get an iso of something which is initial given that something is Segal. The true reading should then be obvious.</p> </li> </ul> <p>The naming conventions are aimed at improving the readability of the code, not to ensure the shortest possible names, nor to minimize the amount of typing by the implementers of the library.</p> </li> <li>We mainly use lower case names with words separated by hyphens.</li> <li>Capitalized names are reserved for subuniverses and similar collections. When   a construction is made internally to such a collection, we append its name.   For instance, the subuniverse of Segal types is called <code>Segal</code>, and its   internal hom, called <code>function-type-Segal,</code> has the following signature:</li> </ul> <pre><code>#def function-type-Segal\n  ( A B : Segal)\n  : Segal\n</code></pre> <ul> <li> <p>Use meaningful names that accurately represent the concepts applied. For   example, if a concept is known best by a special name, that name should   probably be used.</p> </li> <li> <p>For technical lemmas or definitions, where the chance they will be reused is   very low, the specific names do not matter as much. In these cases, one may   resort to a simplified naming scheme, like enumeration. Please note, however,   that if you find yourself appealing to this convention frequently, that is a   sign that your code should be refactored.</p> </li> <li> <p>We use Unicode symbols sparingly and only when they align with established   mathematical practice.</p> </li> </ul>"},{"location":"STYLEGUIDE/#use-of-unicode-characters","title":"Use of Unicode characters","text":"<p>In the defined names we use Unicode symbols sparingly and only when they align with established mathematical practice.</p> <p>For the builtin syntactic features of <code>rzk</code> we use the following Unicode symbols:</p> <ul> <li><code>-&gt;</code> should be always replaced with <code>\u2192</code> (<code>\\to</code>)</li> <li><code>|-&gt;</code> should be always replaced with <code>\u21a6</code> (<code>\\mapsto</code>)</li> <li><code>===</code> should be always replaced with <code>\u2261</code> (<code>\\equiv</code>)</li> <li><code>&lt;=</code> should be always replaced with <code>\u2264</code> (<code>\\&lt;=</code>)</li> <li><code>/\\</code> should be always replaced with <code>\u2227</code> (<code>\\and</code>)</li> <li><code>\\/</code> should be always replaced with <code>\u2228</code> (<code>\\or</code>)</li> <li><code>0_2</code> should be always replaced with <code>0\u2082</code> (<code>0\\2</code>)</li> <li><code>1_2</code> should be always replaced with <code>1\u2082</code> (<code>1\\2</code>)</li> <li><code>I * J</code> should be always replaced with <code>I \u00d7 J</code> (<code>\\x</code> or <code>\\times</code>)</li> </ul> <p>We use ASCII versions for <code>TOP</code> and <code>BOT</code> since <code>\u22a4</code> and <code>\u22a5</code> do not read better in the code. Same for <code>first</code> and <code>second</code> (<code>\u03c0\u2081</code> and <code>\u03c0\u2082</code> are not very readable). For the latter a lot of uses for projections should go away by using pattern matching (and <code>let</code>/<code>where</code> in the future).</p>"},{"location":"STYLEGUIDE/#use-of-comments","title":"Use of Comments","text":"<p>We do not explicitly ban code comments, but our other conventions should heavily limit their need.</p> <ul> <li> Literate file format for prose</li> <li> Descriptive definition names shouldn't need additional explanation</li> <li> Strictly organized code to ease reading and understanding</li> <li> Essential information should be carried by code, not only comments</li> </ul> <p>Still, code annotations may find their uses.</p> <p>Where to place literature references?</p> <ul> <li>Create and use named projections instead of using the <code>first</code> and <code>second</code>   projections. In many cases, their meaning is not immediately obvious, and so   one could be tempted to annotate the code with their meaning using comments.</li> </ul> <p>For instance, instead of writing <code>first (second is-invertible-f)</code>, we define a   named projection <code>is-section-is-invertible</code>. This may then be used as   <code>is-section-is-invertible A B f is-invertible-f</code> in other places. This way,   the code becomes self-documenting, and much easier to read.</p> <p>However, we recognize that in <code>rzk</code>, since we do not have the luxury of   implicit arguments, this may sometimes cause unnecessarily verbose code. In   such cases, you may revert to using <code>first</code> and <code>second</code>.</p>"},{"location":"STYLEGUIDE/#adapting-and-evolving-the-style-guide","title":"Adapting and Evolving the Style Guide","text":"<p>This style guide should evolve as Rzk develops and grows. If new features, like implicit arguments, <code>let</code>-expressions, or <code>where</code>-blocks are added to the language, or if there is made changes to the syntax of the language, their use should be incorporated into this style guide.</p> <p>At all times, the goal is to have code that is easy to read and navigate, even for those who are not the authors. We should also ensure that we maintain a consistent style across the entire repository.</p>"},{"location":"other/","title":"Other Yoneda formalizations","text":"<p>Below is an incomplete list of Yoneda lemma formalizations in different systems:</p> Library System Foundations Yoneda agda-categories Agda Traditional, proof relevant 1-categories<sup>1</sup> agda-unimath Agda HoTT/UF 1-categories UniMath Coq HoTT/UF 1-categories, bicategories<sup>2</sup> 1lab Cubical Agda HoTT/UF (cubical) 1-categories mathlib Lean 4 Traditional 1-categories  sinhp/CovariantYonedaLean3 Lean 3 Traditional 1-categories  sinhp/CovariantYonedaLean4 Lean 4 Traditional 1-categories Archive of Formal Proofs Isabelle/HOL Traditional 1-categories<sup>3</sup> <sup>4</sup> <sup>5</sup> This project Rzk HoTT/UF (simplicial) \u221e-categories <ol> <li> <p>The agda-categories library internalizes a version of Hom-equality to each category, resulting in a flavour of bicategory theory.\u00a0\u21a9</p> </li> <li> <p>B. Ahrens, D. Frumin, M. Maggesi, N. Veltri, and N. van der Weide. Bicategories in univalent foundations. Mathematical Structures in Computer Science, vol. 31, no. 10, pp. 1232\u20131269, 2021. https://arxiv.org/abs/1903.01152 \u21a9</p> </li> <li> <p>https://www.isa-afp.org/sessions/category/#Yoneda \u21a9</p> </li> <li> <p>https://www.isa-afp.org/sessions/category2/#Yoneda \u21a9</p> </li> <li> <p>https://www.isa-afp.org/sessions/category3/#Yoneda \u21a9</p> </li> </ol>"},{"location":"hott/00-common.rzk/","title":"Common","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/00-common.rzk/#products-of-types","title":"Products of types","text":"<pre><code>#def product\n  ( A B : U)\n  : U\n  := \u03a3 (x : A) , B\n</code></pre> <p>The following demonstrates the syntax for constructing terms in Sigma types:</p> <pre><code>#def diagonal\n  ( A : U)\n  ( a : A)\n  : product A A\n  := (a , a)\n</code></pre>"},{"location":"hott/00-common.rzk/#the-type-of-logical-equivalences-between-types","title":"The type of logical equivalences between types","text":"<pre><code>#def iff\n  ( A B : U)\n  : U\n  := product (A \u2192 B) (B \u2192 A)\n</code></pre>"},{"location":"hott/00-common.rzk/#basic-function-definitions","title":"Basic function definitions","text":"<pre><code>#section basic-functions\n\n#variables A B C D : U\n\n#def comp\n  ( g : B \u2192 C)\n  ( f : A \u2192 B)\n  : A \u2192 C\n  := \\ z \u2192 g (f z)\n\n#def triple-comp\n  ( h : C \u2192 D)\n  ( g : B \u2192 C)\n  ( f : A \u2192 B)\n  : A \u2192 D\n  := \\ z \u2192 h (g (f z))\n\n#def identity\n  : A \u2192 A\n  := \\ a \u2192 a\n\n#def constant\n  ( b : B)\n  : A \u2192 B\n  := \\ a \u2192 b\n\n#end basic-functions\n</code></pre>"},{"location":"hott/00-common.rzk/#substitution","title":"Substitution","text":"Reindexing a type family along a function into the base type<pre><code>#def reindex\n  ( A B : U)\n  ( f : B \u2192 A)\n  ( C : A \u2192 U)\n  : B \u2192 U\n  := \\ b \u2192 C (f b)\n</code></pre>"},{"location":"hott/01-paths.rzk/","title":"Paths","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/01-paths.rzk/#path-induction","title":"Path induction","text":"<p>We define path induction in terms of the built-in J rule (<code>idJ</code>), so that we can apply it like any other function.</p> <pre><code>#define ind-path\n  ( A : U)\n  ( a : A)\n  ( C : (x : A) \u2192 (a = x) \u2192 U)\n  ( d : C a refl)\n  ( x : A)\n  ( p : a = x)\n  : C x p\n  := idJ (A , a , C , d , x , p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#some-basic-path-algebra","title":"Some basic path algebra","text":"<pre><code>#section path-algebra\n\n#variable A : U\n#variables x y z : A\n</code></pre>"},{"location":"hott/01-paths.rzk/#path-reversal","title":"Path reversal","text":"<pre><code>#def rev\n  ( p : x = y)\n  : y = x\n  :=\n  ind-path A x\n    ( \\ y' p' \u2192 y' = x)\n    ( refl)\n    ( y)\n    ( p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#path-concatenation","title":"Path concatenation","text":"<p>We take path concatenation defined by induction on the second path variable as our main definition.</p> <pre><code>#def concat\n  ( p : x = y)\n  ( q : y = z)\n  : x = z\n  :=\n  ind-path A y\n    ( \\ z' q' \u2192 (x = z'))\n    ( p)\n    ( z)\n    ( q)\n</code></pre> <p>We also introduce a version defined by induction on the first path variable, for situations where it is easier to induct on the first path.</p> <pre><code>#def concat'\n  ( p : x = y)\n  : ( y = z)\n  \u2192 ( x = z)\n  :=\n  ind-path A x\n    ( \\ y' p' \u2192 (y' = z) \u2192 (x = z))\n    ( \\ q' \u2192 q')\n    ( y)\n    ( p)\n\n#end path-algebra\n</code></pre>"},{"location":"hott/01-paths.rzk/#some-basic-coherences-in-path-algebra","title":"Some basic coherences in path algebra","text":"<pre><code>#section basic-path-coherence\n\n#variable A : U\n#variables w x y z : A\n\n#def rev-rev\n  ( p : x = y)\n  : rev A y x (rev A x y p) = p\n  :=\n  ind-path A x\n    ( \\ y' p' \u2192 (rev A y' x (rev A x y' p')) = p')\n    ( refl)\n    ( y)\n    ( p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#left-unit-law-for-path-concatenation","title":"Left unit law for path concatenation","text":"<p>The left unit law for path concatenation does not hold definitionally due to our choice of definition.</p> <pre><code>#def left-unit-concat\n  ( p : x = y)\n  : concat A x x y refl p = p\n  :=\n  ind-path A x\n    ( \\ y' p' \u2192 (concat A x x y' refl p') = p')\n    ( refl)\n    ( y)\n    ( p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#associativity-of-path-concatenation","title":"Associativity of path concatenation","text":"<pre><code>#def associative-concat\n  ( p : w = x)\n  ( q : x = y)\n  ( r : y = z)\n  : concat A w y z (concat A w x y p q) r\n  = concat A w x z p (concat A x y z q r)\n  :=\n    ind-path A y\n      ( \\ z' r' \u2192\n        concat A w y z' (concat A w x y p q) r'\n      = concat A w x z' p (concat A x y z' q r'))\n      ( refl)\n      ( z)\n      ( r)\n\n#def rev-associative-concat\n  ( p : w = x)\n  ( q : x = y)\n  ( r : y = z)\n  : concat A w x z p (concat A x y z q r)\n  = concat A w y z (concat A w x y p q) r\n  :=\n    ind-path A y\n      ( \\ z' r' \u2192\n          concat A w x z' p (concat A x y z' q r')\n        = concat A w y z' (concat A w x y p q) r')\n      ( refl)\n      ( z)\n      ( r)\n\n#def right-inverse-concat\n  ( p : x = y)\n  : concat A x y x p (rev A x y p) = refl\n  :=\n    ind-path A x\n      ( \\ y' p' \u2192 concat A x y' x p' (rev A x y' p') = refl)\n      ( refl)\n      ( y)\n      ( p)\n\n#def left-inverse-concat\n  ( p : x = y)\n  : concat A y x y (rev A x y p) p = refl\n  :=\n    ind-path A x\n      ( \\ y' p' \u2192 concat A y' x y' (rev A x y' p') p' = refl)\n      ( refl)\n      ( y)\n      ( p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#concatenation-of-two-paths-with-common-codomain","title":"Concatenation of two paths with common codomain","text":"<p>Concatenation of two paths with common codomain; defined using <code>concat</code> and <code>rev</code>.</p> <pre><code>#def zig-zag-concat\n  ( p : x = y)\n  ( q : z = y)\n  : x = z\n  := concat A x y z p (rev A z y q)\n</code></pre>"},{"location":"hott/01-paths.rzk/#concatenation-of-two-paths-with-common-domain","title":"Concatenation of two paths with common domain","text":"<p>Concatenation of two paths with common domain; defined using <code>concat</code> and <code>rev</code>.</p> <pre><code>#def zag-zig-concat\n  ( p : y = x)\n  ( q : y = z)\n  : x = z\n  := concat A x y z (rev A y x p) q\n\n#def right-cancel-concat\n  ( p q : x = y)\n  ( r : y = z)\n  : ( concat A x y z p r = concat A x y z q r)\n  \u2192 ( p = q)\n  :=\n    ind-path A y\n      ( \\ z' r' \u2192\n          ( concat A x y z' p r' = concat A x y z' q r')\n        \u2192 ( p = q))\n      ( \\ H \u2192 H)\n      ( z)\n      ( r)\n\n#end basic-path-coherence\n</code></pre>"},{"location":"hott/01-paths.rzk/#some-derived-coherences-in-path-algebra","title":"Some derived coherences in path algebra","text":"<p>The statements or proofs of the following path algebra coherences reference one of the path algebra coherences defined above.</p> <pre><code>#section derived-path-coherence\n#variable A : U\n#variables x y z : A\n\n#def rev-concat\n  ( p : x = y)\n  ( q : y = z)\n  : rev A x z (concat A x y z p q)\n  = concat A z y x (rev A y z q) (rev A x y p)\n  :=\n    ind-path A y\n      ( \\ z' q' \u2192\n          rev A x z' (concat A x y z' p q')\n        = concat A z' y x (rev A y z' q') (rev A x y p))\n      ( rev\n          ( y = x)\n          ( concat A y y x refl (rev A x y p))\n          ( rev A x y p)\n          ( left-unit-concat A y x (rev A x y p)))\n      ( z)\n      ( q)\n</code></pre>"},{"location":"hott/01-paths.rzk/#postwhiskering-paths-of-paths","title":"Postwhiskering paths of paths","text":"<pre><code>#def concat-eq-left\n  ( p q : x = y)\n  ( H : p = q)\n  ( r : y = z)\n  : concat A x y z p r\n  = concat A x y z q r\n  :=\n    ind-path A y\n      ( \\ z' r' \u2192 (concat A x y z' p r') = (concat A x y z' q r'))\n      ( H)\n      ( z)\n      ( r)\n</code></pre>"},{"location":"hott/01-paths.rzk/#prewhiskering-paths-of-paths","title":"Prewhiskering paths of paths","text":"<p>Prewhiskering paths of paths is much harder.</p> <pre><code>#def concat-eq-right\n  ( p : x = y)\n  : ( q : y = z)\n  \u2192 ( r : y = z)\n  \u2192 ( H : q = r)\n  \u2192 concat A x y z p q\n  = concat A x y z p r\n  :=\n    ind-path A x\n      ( \\ y' p' \u2192\n        ( q : y' = z)\n      \u2192 ( r : y' = z)\n      \u2192 ( H : q = r)\n      \u2192 ( concat A x y' z p' q) = (concat A x y' z p' r))\n      ( \\ q r H \u2192\n        concat\n          ( x = z)\n          ( concat A x x z refl q)\n          ( r)\n          ( concat A x x z refl r)\n          ( concat (x = z) (concat A x x z refl q) q r (left-unit-concat A x z q) H)\n          ( rev (x = z) (concat A x x z refl r) r (left-unit-concat A x z r)))\n      ( y)\n      ( p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#identifying-the-two-definitions-of-path-concatenation","title":"Identifying the two definitions of path concatenation","text":"<pre><code>#def concat-concat'\n  ( p : x = y)\n  : ( q : y = z)\n  \u2192 concat A x y z p q\n  = concat' A x y z p q\n  :=\n    ind-path A x\n      ( \\ y' p' \u2192\n          ( q' : y' =_{A} z)\n        \u2192 ( concat A x y' z p' q') =_{x =_{A} z} concat' A x y' z p' q')\n      ( \\ q' \u2192 left-unit-concat A x z q')\n      ( y)\n      ( p)\n\n#def concat'-concat\n  ( p : x = y)\n  ( q : y = z)\n  : concat' A x y z p q\n  = concat A x y z p q\n  :=\n    rev\n      ( x = z)\n      ( concat A x y z p q)\n      ( concat' A x y z p q)\n      ( concat-concat' p q)\n</code></pre> <p>This is easier to prove for <code>concat'</code> than for <code>concat</code>.</p> <pre><code>#def alt-triangle-rotation\n  ( p : x = z)\n  ( q : x = y)\n  : ( r : y = z)\n  \u2192 ( H : p = concat' A x y z q r)\n  \u2192 concat' A y x z (rev A x y q) p = r\n  :=\n    ind-path A x\n      ( \\ y' q' \u2192\n        ( r' : y' =_{A} z)\n      \u2192 ( H' : p = concat' A x y' z q' r')\n      \u2192 ( concat' A y' x z (rev A x y' q') p) = r')\n      ( \\ r' H' \u2192 H')\n      ( y)\n      ( q)\n</code></pre> <p>The following needs to be outside the previous section because of the usage of <code>concat-concat' A y x</code>.</p> <pre><code>#end derived-path-coherence\n\n#def triangle-rotation\n  ( A : U)\n  ( x y z : A)\n  ( p : x = z)\n  ( q : x = y)\n  ( r : y = z)\n  ( H : p = concat A x y z q r)\n  : concat A y x z (rev A x y q) p = r\n  :=\n    concat\n      ( y = z)\n      ( concat A y x z (rev A x y q) p)\n      ( concat' A y x z (rev A x y q) p)\n      ( r)\n      ( concat-concat' A y x z (rev A x y q) p)\n      ( alt-triangle-rotation\n        ( A) (x) (y) (z) (p) (q) (r)\n        ( concat\n          ( x = z)\n          ( p)\n          ( concat A x y z q r)\n          ( concat' A x y z q r)\n          ( H)\n          ( concat-concat' A x y z q r)))\n</code></pre>"},{"location":"hott/01-paths.rzk/#application-of-functions-to-paths","title":"Application of functions to paths","text":"<pre><code>#def ap\n  ( A B : U)\n  ( x y : A)\n  ( f : A \u2192 B)\n  ( p : x = y)\n  : ( f x = f y)\n  := ind-path (A) (x) (\\ y' p' \u2192 (f x = f y')) (refl) (y) (p)\n\n#def ap-rev\n  ( A B : U)\n  ( x y : A)\n  ( f : A \u2192 B)\n  ( p : x = y)\n  : ( ap A B y x f (rev A x y p)) = (rev B (f x) (f y) (ap A B x y f p))\n  :=\n    ind-path A x\n      ( \\ y' p' \u2192\n        ap A B y' x f (rev A x y' p') = rev B (f x) (f y') (ap A B x y' f p'))\n      ( refl)\n      ( y)\n      ( p)\n\n#def ap-concat\n  ( A B : U)\n  ( x y z : A)\n  ( f : A \u2192 B)\n  ( p : x = y)\n  ( q : y = z)\n  : ( ap A B x z f (concat A x y z p q))\n  = ( concat B (f x) (f y) (f z) (ap A B x y f p) (ap A B y z f q))\n  :=\n    ind-path A y\n      ( \\ z' q' \u2192\n        ( ap A B x z' f (concat A x y z' p q'))\n      = ( concat B (f x) (f y) (f z') (ap A B x y f p) (ap A B y z' f q')))\n      ( refl)\n      ( z)\n      ( q)\n\n#def rev-ap-rev\n  ( A B : U)\n  ( x y : A)\n  ( f : A \u2192 B)\n  ( p : x = y)\n  : ( rev B (f y) (f x) (ap A B y x f (rev A x y p))) = (ap A B x y f p)\n  :=\n    ind-path A x\n      ( \\ y' p' \u2192\n        ( rev B (f y') (f x) (ap A B y' x f (rev A x y' p')))\n      = ( ap A B x y' f p'))\n      ( refl)\n      ( y)\n      ( p)\n</code></pre> <p>The following is for a specific use.</p> <pre><code>#def concat-ap-rev-ap-id\n  ( A B : U)\n  ( x y : A)\n  ( f : A \u2192 B)\n  ( p : x = y)\n  : ( concat\n      ( B) (f y) (f x) (f y)\n      ( ap A B y x f (rev A x y p))\n      ( ap A B x y f p))\n  = ( refl)\n  :=\n    ind-path A x\n      ( \\ y' p' \u2192\n        ( concat\n          ( B) (f y') (f x) (f y')\n          ( ap A B y' x f (rev A x y' p')) (ap A B x y' f p'))\n      = ( refl))\n      ( refl)\n      ( y)\n      ( p)\n\n#def ap-id\n  ( A : U)\n  ( x y : A)\n  ( p : x = y)\n  : ( ap A A x y (identity A) p) = p\n  := ind-path (A) (x) (\\ y' p' \u2192 (ap A A x y' (\\ z \u2192 z) p') = p') (refl) (y) (p)\n</code></pre> <p>Application of a function to homotopic paths yields homotopic paths.</p> <pre><code>#def ap-eq\n  ( A B : U)\n  ( x y : A)\n  ( f : A \u2192 B)\n  ( p q : x = y)\n  ( H : p = q)\n  : ap A B x y f p\n  = ap A B x y f q\n  :=\n    ind-path\n      ( x = y)\n      ( p)\n      ( \\ q' H' \u2192 (ap A B x y f p) = (ap A B x y f q'))\n      ( refl)\n      ( q)\n      ( H)\n\n#def ap-comp\n  ( A B C : U)\n  ( x y : A)\n  ( f : A \u2192 B)\n  ( g : B \u2192 C)\n  ( p : x = y)\n  : ( ap A C x y (comp A B C g f) p)\n  = ( ap B C (f x) (f y) g (ap A B x y f p))\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192\n        ( ap A C x y' (\\ z \u2192 g (f z)) p')\n      = ( ap B C (f x) (f y') g (ap A B x y' f p')))\n      ( refl)\n      ( y)\n      ( p)\n\n#def rev-ap-comp\n  ( A B C : U)\n  ( x y : A)\n  ( f : A \u2192 B)\n  ( g : B \u2192 C)\n  ( p : x = y)\n  : ( ap B C (f x) (f y) g (ap A B x y f p))\n  = ( ap A C x y (comp A B C g f) p)\n  :=\n    rev\n      ( g (f x) = g (f y))\n      ( ap A C x y (\\ z \u2192 g (f z)) p)\n      ( ap B C (f x) (f y) g (ap A B x y f p))\n      ( ap-comp A B C x y f g p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#transport","title":"Transport","text":"<pre><code>#section transport\n\n#variable A : U\n#variable B : A \u2192 U\n</code></pre>"},{"location":"hott/01-paths.rzk/#transport-in-a-type-family-along-a-path-in-the-base","title":"Transport in a type family along a path in the base","text":"<pre><code>#def transport\n  ( x y : A)\n  ( p : x = y)\n  ( u : B x)\n  : B y\n  := ind-path (A) (x) (\\ y' p' \u2192 B y') (u) (y) (p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#the-lift-of-a-base-path-to-a-path-from-a-term-in-the-total-space-to-its-transport","title":"The lift of a base path to a path from a term in the total space to its transport","text":"<pre><code>#def transport-lift\n  ( x y : A)\n  ( p : x = y)\n  ( u : B x)\n  : ( x , u) =_{\u03a3 (z : A) , B z} (y , transport x y p u)\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192 (x , u) =_{\u03a3 (z : A) , B z} (y' , transport x y' p' u))\n      ( refl)\n      ( y)\n      ( p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#transport-along-concatenated-paths","title":"Transport along concatenated paths","text":"<pre><code>#def transport-concat\n  ( x y z : A)\n  ( p : x = y)\n  ( q : y = z)\n  ( u : B x)\n  : ( transport x z (concat A x y z p q) u)\n  = ( transport y z q (transport x y p u))\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ z' q' \u2192\n        ( transport x z' (concat A x y z' p q') u)\n      = ( transport y z' q' (transport x y p u)))\n      ( refl)\n      ( z)\n      ( q)\n\n#def transport-concat-rev\n  ( x y z : A)\n  ( p : x = y)\n  ( q : y = z)\n  ( u : B x)\n  : ( transport y z q (transport x y p u))\n  = ( transport x z (concat A x y z p q) u)\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ z' q' \u2192\n        ( transport y z' q' (transport x y p u))\n      = ( transport x z' (concat A x y z' p q') u))\n      ( refl)\n      ( z)\n      ( q)\n</code></pre>"},{"location":"hott/01-paths.rzk/#transport-along-homotopic-paths","title":"Transport along homotopic paths","text":"<pre><code>#def transport2\n  ( x y : A)\n  ( p q : x = y)\n  ( H : p = q)\n  ( u : B x)\n  : ( transport x y p u) = (transport x y q u)\n  :=\n    ind-path\n      ( x = y)\n      ( p)\n      ( \\ q' H' \u2192 (transport x y p u) = (transport x y q' u))\n      ( refl)\n      ( q)\n      ( H)\n</code></pre>"},{"location":"hott/01-paths.rzk/#transport-along-a-loop","title":"Transport along a loop","text":"<pre><code>#def transport-loop\n  ( a : A)\n  ( b : B a)\n  : ( a = a) \u2192 B a\n  := \\ p \u2192 (transport a a p b)\n</code></pre> <pre><code>#end transport\n</code></pre>"},{"location":"hott/01-paths.rzk/#dependent-application","title":"Dependent application","text":"<pre><code>#def apd\n  ( A : U)\n  ( B : A \u2192 U)\n  ( x y : A)\n  ( f : (z : A) \u2192 B z)\n  ( p : x = y)\n  : ( transport A B x y p (f x)) = f y\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( ( \\ y' p' \u2192 (transport A B x y' p' (f x)) = f y'))\n      ( refl)\n      ( y)\n      ( p)\n</code></pre>"},{"location":"hott/01-paths.rzk/#higher-order-concatenation","title":"Higher-order concatenation","text":"<p>For convenience, we record lemmas for higher-order concatenation here.</p> <pre><code>#section higher-concatenation\n#variable A : U\n\n#def triple-concat\n  ( a0 a1 a2 a3 : A)\n  ( p1 : a0 = a1)\n  ( p2 : a1 = a2)\n  ( p3 : a2 = a3)\n  : a0 = a3\n  := concat A a0 a1 a3 p1 (concat A a1 a2 a3 p2 p3)\n\n#def quadruple-concat\n  ( a0 a1 a2 a3 a4 : A)\n  ( p1 : a0 = a1)\n  ( p2 : a1 = a2)\n  ( p3 : a2 = a3)\n  ( p4 : a3 = a4)\n  : a0 = a4\n  := triple-concat a0 a1 a2 a4 p1 p2 (concat A a2 a3 a4 p3 p4)\n\n#def quintuple-concat\n  ( a0 a1 a2 a3 a4 a5 : A)\n  ( p1 : a0 = a1)\n  ( p2 : a1 = a2)\n  ( p3 : a2 = a3)\n  ( p4 : a3 = a4)\n  ( p5 : a4 = a5)\n  : a0 = a5\n  := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5)\n\n#def alternating-quintuple-concat\n  ( a0 : A)\n  ( a1 : A) (p1 : a0 = a1)\n  ( a2 : A) (p2 : a1 = a2)\n  ( a3 : A) (p3 : a2 = a3)\n  ( a4 : A) (p4 : a3 = a4)\n  ( a5 : A) (p5 : a4 = a5)\n  : a0 = a5\n  := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5)\n\n#def 12ary-concat\n  ( a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 : A)\n  ( p1 : a0 = a1)\n  ( p2 : a1 = a2)\n  ( p3 : a2 = a3)\n  ( p4 : a3 = a4)\n  ( p5 : a4 = a5)\n  ( p6 : a5 = a6)\n  ( p7 : a6 = a7)\n  ( p8 : a7 = a8)\n  ( p9 : a8 = a9)\n  ( p10 : a9 = a10)\n  ( p11 : a10 = a11)\n  ( p12 : a11 = a12)\n  : a0 = a12\n  :=\n    quintuple-concat\n      a0 a1 a2 a3 a4 a12\n      p1 p2 p3 p4\n      ( quintuple-concat\n        a4 a5 a6 a7 a8 a12\n        p5 p6 p7 p8\n        ( quadruple-concat\n          a8 a9 a10 a11 a12\n          p9 p10 p11 p12))\n</code></pre> <p>The following is the same as above but with alternating arguments.</p> <pre><code>#def alternating-12ary-concat\n  ( a0 : A)\n  ( a1 : A) (p1 : a0 = a1)\n  ( a2 : A) (p2 : a1 = a2)\n  ( a3 : A) (p3 : a2 = a3)\n  ( a4 : A) (p4 : a3 = a4)\n  ( a5 : A) (p5 : a4 = a5)\n  ( a6 : A) (p6 : a5 = a6)\n  ( a7 : A) (p7 : a6 = a7)\n  ( a8 : A) (p8 : a7 = a8)\n  ( a9 : A) (p9 : a8 = a9)\n  ( a10 : A) (p10 : a9 = a10)\n  ( a11 : A) (p11 : a10 = a11)\n  ( a12 : A) (p12 : a11 = a12)\n  : a0 = a12\n  :=\n    12ary-concat\n      a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12\n      p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12\n\n#end higher-concatenation\n</code></pre>"},{"location":"hott/01-paths.rzk/#higher-order-coherences","title":"Higher-order coherences","text":"<pre><code>#def rev-refl-id-triple-concat\n  ( A : U)\n  ( x y : A)\n  ( p : x = y)\n  : triple-concat A y x x y (rev A x y p) refl p = refl\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192 triple-concat A y' x x y' (rev A x y' p') refl p' = refl)\n      ( refl)\n      ( y)\n      ( p)\n\n#def ap-rev-refl-id-triple-concat\n  ( A B : U)\n  ( x y : A)\n  ( f : A \u2192 B)\n  ( p : x = y)\n  : ( ap A B y y f (triple-concat A y x x y (rev A x y p) refl p)) = refl\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192\n        ( ap A B y' y' f (triple-concat A y' x x y' (rev A x y' p') refl p'))\n      = ( refl))\n      ( refl)\n      ( y)\n      ( p)\n\n#def ap-triple-concat\n  ( A B : U)\n  ( w x y z : A)\n  ( f : A \u2192 B)\n  ( p : w = x)\n  ( q : x = y)\n  ( r : y = z)\n  : ( ap A B w z f (triple-concat A w x y z p q r))\n  = ( triple-concat\n      ( B)\n      ( f w)\n      ( f x)\n      ( f y)\n      ( f z)\n      ( ap A B w x f p)\n      ( ap A B x y f q)\n      ( ap A B y z f r))\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ z' r' \u2192\n        ( ap A B w z' f (triple-concat A w x y z' p q r'))\n      = ( triple-concat\n          ( B)\n          ( f w) (f x) (f y) (f z')\n          ( ap A B w x f p)\n          ( ap A B x y f q)\n          ( ap A B y z' f r')))\n      ( ap-concat A B w x y f p q)\n      ( z)\n      ( r)\n\n#def triple-concat-eq-first\n  ( A : U)\n  ( w x y z : A)\n  ( p q : w = x)\n  ( r : x = y)\n  ( s : y = z)\n  ( H : p = q)\n  : ( triple-concat A w x y z p r s) = (triple-concat A w x y z q r s)\n  := concat-eq-left A w x z p q H (concat A x y z r s)\n\n#def triple-concat-eq-second\n  ( A : U)\n  ( w x y z : A)\n  ( p : w = x)\n  ( q r : x = y)\n  ( s : y = z)\n  ( H : q = r)\n  : ( triple-concat A w x y z p q s) = (triple-concat A w x y z p r s)\n  :=\n    ind-path\n      ( x = y)\n      ( q)\n      ( \\ r' H' \u2192\n        triple-concat A w x y z p q s = triple-concat A w x y z p r' s)\n      ( refl)\n      ( r)\n      ( H)\n</code></pre>"},{"location":"hott/02-homotopies.rzk/","title":"Homotopies","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/02-homotopies.rzk/#homotopies-and-their-algebra","title":"Homotopies and their algebra","text":"<pre><code>#section homotopies\n\n#variables A B : U\n</code></pre> The type of homotopies between parallel functions<pre><code>#def homotopy\n  ( f g : A \u2192 B)\n  : U\n  := (a : A) \u2192 (f a = g a)\n</code></pre> The reversal of a homotopy<pre><code>#def rev-homotopy\n  ( f g : A \u2192 B)\n  ( H : homotopy f g)\n  : homotopy g f\n  := \\ a \u2192 rev B (f a) (g a) (H a)\n</code></pre> <pre><code>#def concat-homotopy\n  ( f g h : A \u2192 B)\n  ( H : homotopy f g)\n  ( K : homotopy g h)\n  : homotopy f h\n  := \\ a \u2192 concat B (f a) (g a) (h a) (H a) (K a)\n</code></pre> <p>Homotopy composition is defined in diagrammatic order like <code>concat</code> but unlike composition.</p> <pre><code>#end homotopies\n</code></pre>"},{"location":"hott/02-homotopies.rzk/#whiskering-homotopies","title":"Whiskering homotopies","text":"<pre><code>#section homotopy-whiskering\n\n#variables A B C : U\n\n#def postwhisker-homotopy\n  ( f g : A \u2192 B)\n  ( H : homotopy A B f g)\n  ( h : B \u2192 C)\n  : homotopy A C (comp A B C h f) (comp A B C h g)\n  := \\ a \u2192 ap B C (f a) (g a) h (H a)\n\n#def prewhisker-homotopy\n  ( f g : B \u2192 C)\n  ( H : homotopy B C f g)\n  ( h : A \u2192 B)\n  : homotopy A C (comp A B C f h) (comp A B C g h)\n  := \\ a \u2192 H (h a)\n\n#end homotopy-whiskering\n\n#def whisker-homotopy\n  ( A B C D : U)\n  ( h k : B \u2192 C)\n  ( H : homotopy B C h k)\n  ( f : A \u2192 B)\n  ( g : C \u2192 D)\n  : homotopy\n      A\n      D\n      ( triple-comp A B C D g h f)\n      ( triple-comp A B C D g k f)\n  :=\n    postwhisker-homotopy\n      A\n      C\n      D\n      ( comp A B C h f)\n      ( comp A B C k f)\n      ( prewhisker-homotopy A B C h k H f)\n      g\n</code></pre>"},{"location":"hott/02-homotopies.rzk/#naturality","title":"Naturality","text":"The naturality square associated to a homotopy and a path<pre><code>#def nat-htpy\n  ( A B : U)\n  ( f g : A \u2192 B)\n  ( H : homotopy A B f g)\n  ( x y : A)\n  ( p : x = y)\n  : ( concat B (f x) (f y) (g y) (ap A B x y f p) (H y))\n  = ( concat B (f x) (g x) (g y) (H x) (ap A B x y g p))\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192\n        ( concat B (f x) (f y') (g y') (ap A B x y' f p') (H y'))\n      = ( concat B (f x) (g x) (g y') (H x) (ap A B x y' g p')))\n      ( left-unit-concat B (f x) (g x) (H x))\n      ( y)\n      ( p)\n</code></pre> Naturality in another form<pre><code>#def triple-concat-nat-htpy\n  ( A B : U)\n  ( f g : A \u2192 B)\n  ( H : homotopy A B f g)\n  ( x y : A)\n  ( p : x = y)\n  : triple-concat\n      ( B) (g x) (f x) (f y) (g y)\n      ( rev B (f x) (g x) (H x)) (ap A B x y f p) (H y)\n  = ap A B x y g p\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192\n          triple-concat\n            ( B)\n            ( g x)\n            ( f x)\n            ( f y')\n            ( g y')\n            ( rev B (f x) (g x) (H x))\n            ( ap A B x y' f p')\n            ( H y')\n        = ap A B x y' g p')\n      ( rev-refl-id-triple-concat B (f x) (g x) (H x))\n      ( y)\n      ( p)\n</code></pre>"},{"location":"hott/02-homotopies.rzk/#an-application","title":"An application","text":"<pre><code>#section cocone-naturality\n\n#variable A : U\n#variable f : A \u2192 A\n#variable H : homotopy A A f (identity A)\n#variable a : A\n</code></pre> <p>In the case of a homotopy <code>H</code> from <code>f</code> to the identity the previous square applies to the path <code>H a</code> to produce the following naturality square.</p> <pre><code>#def cocone-naturality\n  : ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a))\n  = ( concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a)))\n  := nat-htpy A A f (identity A) H (f a) a (H a)\n</code></pre> <p>After composing with <code>ap-id</code>, this naturality square transforms to the following:</p> <pre><code>#def reduced-cocone-naturality\n  : ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a))\n  = ( concat A (f (f a)) (f a) (a) (H (f a)) (H a))\n  :=\n    concat\n      ( ( f (f a)) = a)\n      ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a))\n      ( concat\n        ( A)\n        ( f (f a))\n        ( f a)\n        ( a)\n        ( H (f a))\n        ( ap A A (f a) a (identity A) (H a)))\n      ( concat A (f (f a)) (f a) (a) (H (f a)) (H a))\n      ( cocone-naturality)\n      ( concat-eq-right\n        ( A)\n        ( f (f a))\n        ( f a)\n        ( a)\n        ( H (f a))\n        ( ap A A (f a) a (identity A) (H a))\n        ( H a)\n        ( ap-id A (f a) a (H a)))\n</code></pre> <p>Cancelling the path <code>H a</code> on the right and reversing yields a path we need:</p> <pre><code>#def cocone-naturality-coherence\n  : ( H (f a)) = (ap A A (f a) a f (H a))\n  :=\n    rev\n      ( f (f a) = f a)\n      ( ap A A (f a) a f (H a)) (H (f a))\n      ( right-cancel-concat\n        ( A)\n        ( f (f a))\n        ( f a)\n        ( a)\n        ( ap A A (f a) a f (H a))\n        ( H (f a))\n        ( H a)\n        ( reduced-cocone-naturality))\n\n#end cocone-naturality\n</code></pre>"},{"location":"hott/02-homotopies.rzk/#conjugation-with-higher-homotopies","title":"Conjugation with higher homotopies","text":"<pre><code>#def triple-concat-higher-homotopy\n  ( A B : U)\n  ( f g : A \u2192 B)\n  ( H K : homotopy A B f g)\n  ( \u03b1 : (a : A) \u2192 H a = K a)\n  ( x y : A)\n  ( p : f x = f y)\n  : triple-concat B (g x) (f x) (f y) (g y) (rev B (f x) (g x) (H x)) p (H y)\n  = triple-concat B (g x) (f x) (f y) (g y) (rev B (f x) (g x) (K x)) p (K y)\n  :=\n    ind-path\n      ( f y = g y)\n      ( H y)\n      ( \\ Ky \u03b1' \u2192\n        ( triple-concat\n          ( B) (g x) (f x) (f y) (g y)\n          ( rev B (f x) (g x) (H x)) (p) (H y))\n      = ( triple-concat\n          ( B) (g x) (f x) (f y) (g y)\n          ( rev B (f x) (g x) (K x)) (p) (Ky)))\n      ( triple-concat-eq-first\n        ( B) (g x) (f x) (f y) (g y)\n        ( rev B (f x) (g x) (H x))\n        ( rev B (f x) (g x) (K x))\n        ( p)\n        ( H y)\n        ( ap\n          ( f x = g x)\n          ( g x = f x)\n          ( H x)\n          ( K x)\n          ( rev B (f x) (g x))\n          ( \u03b1 x)))\n      ( K y)\n      ( \u03b1 y)\n</code></pre>"},{"location":"hott/03-equivalences.rzk/","title":"Equivalences","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#sections-retractions-and-equivalences","title":"Sections, retractions, and equivalences","text":"<pre><code>#section is-equiv\n\n#variables A B : U\n\n#def witness-section\n  ( f : A \u2192 B)\n  ( s : B \u2192 A)\n  : U\n  := (homotopy B B (comp B A B f s) (identity B))\n\n#def has-section\n  ( f : A \u2192 B)\n  : U\n  := \u03a3 (s : B \u2192 A) , (witness-section f s)\n\n#def witness-retraction\n  ( f : A \u2192 B)\n  ( r : B \u2192 A)\n  : U\n  := (homotopy A A (comp A B A r f) (identity A))\n\n#def has-retraction\n  ( f : A \u2192 B)\n  : U\n  := \u03a3 (r : B \u2192 A) , (witness-retraction f r)\n</code></pre> <p>We define equivalences to be bi-invertible maps.</p> <pre><code>#def is-equiv\n  ( f : A \u2192 B)\n  : U\n  := product (has-retraction f) (has-section f)\n\n#end is-equiv\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#equivalence-data","title":"Equivalence data","text":"<pre><code>#section equivalence-data\n\n#variables A B : U\n#variable f : A \u2192 B\n#variable is-equiv-f : is-equiv A B f\n\n#def section-is-equiv uses (f)\n  : B \u2192 A\n  := first (second is-equiv-f)\n\n#def retraction-is-equiv uses (f)\n  : B \u2192 A\n  := first (first is-equiv-f)\n</code></pre> The homotopy between the section and retraction of an equivalence<pre><code>#def homotopy-section-retraction-is-equiv uses (f)\n  : homotopy B A section-is-equiv retraction-is-equiv\n  :=\n    concat-homotopy B A\n      ( section-is-equiv)\n      ( triple-comp B A B A retraction-is-equiv f section-is-equiv)\n      ( retraction-is-equiv)\n      ( rev-homotopy B A\n        ( triple-comp B A B A retraction-is-equiv f section-is-equiv)\n        ( section-is-equiv)\n        ( prewhisker-homotopy B A A\n          ( comp A B A retraction-is-equiv f)\n          ( identity A)\n          ( second (first is-equiv-f))\n          ( section-is-equiv)))\n      ( postwhisker-homotopy B B A\n        ( comp B A B f section-is-equiv)\n        ( identity B)\n        ( second (second is-equiv-f))\n        ( retraction-is-equiv))\n\n#end equivalence-data\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#invertible-maps","title":"Invertible maps","text":"<p>The following type of more coherent equivalences is not a proposition.</p> <pre><code>#def has-inverse\n  ( A B : U)\n  ( f : A \u2192 B)\n  : U\n  :=\n    \u03a3 ( g : B \u2192 A)\n    , ( product\n        ( homotopy A A (comp A B A g f) (identity A))\n        ( homotopy B B (comp B A B f g) (identity B)))\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#equivalences-are-invertible-maps","title":"Equivalences are invertible maps","text":"Invertible maps are equivalences<pre><code>#def is-equiv-has-inverse\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( has-inverse-f : has-inverse A B f)\n  : is-equiv A B f\n  :=\n    ( ( first has-inverse-f , first (second has-inverse-f))\n    , ( first has-inverse-f , second (second has-inverse-f)))\n</code></pre> Equivalences are invertible<pre><code>#def has-inverse-is-equiv\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( is-equiv-f : is-equiv A B f)\n  : has-inverse A B f\n  :=\n    ( section-is-equiv A B f is-equiv-f\n    , ( concat-homotopy A A\n        ( comp A B A (section-is-equiv A B f is-equiv-f) f)\n        ( comp A B A (retraction-is-equiv A B f is-equiv-f) f)\n        ( identity A)\n        ( prewhisker-homotopy A B A\n          ( section-is-equiv A B f is-equiv-f)\n          ( retraction-is-equiv A B f is-equiv-f)\n          ( homotopy-section-retraction-is-equiv A B f is-equiv-f)\n          ( f))\n        ( second (first is-equiv-f))\n    , ( second (second is-equiv-f))))\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#invertible-map-data","title":"Invertible map data","text":"<pre><code>#section has-inverse-data\n\n#variables A B : U\n#variable f : A \u2192 B\n#variable has-inverse-f : has-inverse A B f\n</code></pre> The inverse of a map with an inverse<pre><code>#def map-inverse-has-inverse uses (f)\n  : B \u2192 A\n  := first (has-inverse-f)\n</code></pre> <p>The following are some iterated composites associated to a pair of invertible maps.</p> <pre><code>#def retraction-composite-has-inverse uses (B has-inverse-f)\n  : A \u2192 A\n  := comp A B A map-inverse-has-inverse f\n\n#def section-composite-has-inverse uses (A has-inverse-f)\n  : B \u2192 B\n  := comp B A B f map-inverse-has-inverse\n</code></pre> <p>This composite is parallel to <code>f</code>; we won't need the dual notion.</p> <pre><code>#def triple-composite-has-inverse uses (has-inverse-f)\n  : A \u2192 B\n  := triple-comp A B A B f map-inverse-has-inverse f\n</code></pre> <p>This composite is also parallel to <code>f</code>; again we won't need the dual notion.</p> <pre><code>#def quintuple-composite-has-inverse uses (has-inverse-f)\n  : A \u2192 B\n  := \\ a \u2192 f (map-inverse-has-inverse (f (map-inverse-has-inverse (f a))))\n\n#end has-inverse-data\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#composing-equivalences","title":"Composing equivalences","text":"<p>The type of equivalences between types uses <code>is-equiv</code> rather than <code>has-inverse</code>.</p> <pre><code>#def Equiv\n  ( A B : U)\n  : U\n  := \u03a3 (f : A \u2192 B) , (is-equiv A B f)\n</code></pre> <p>The data of an equivalence is not symmetric so we promote an equivalence to an invertible map to prove symmetry:</p> <pre><code>#def inv-equiv\n  ( A B : U)\n  ( e : Equiv A B)\n  : Equiv B A\n  :=\n    ( first (has-inverse-is-equiv A B (first e) (second e))\n    , ( ( first e\n        , second (second (has-inverse-is-equiv A B (first e) (second e))))\n      , ( first e\n      , first (second (has-inverse-is-equiv A B (first e) (second e))))))\n</code></pre> <pre><code>#def section-inv-equiv\n  ( A B : U)\n  ( e : Equiv A B)\n  : ( witness-section A B (first e) (first (inv-equiv A B e)))\n  := (second (first (second (inv-equiv A B e))))\n</code></pre> <pre><code>#def retraction-inv-equiv\n  ( A B : U)\n  ( e : Equiv A B)\n  : ( witness-retraction A B (first e) (first (inv-equiv A B e)))\n  := (second (second (second (inv-equiv A B e))))\n</code></pre> Composition of equivalences in diagrammatic order<pre><code>#def equiv-comp\n  ( A B C : U)\n  ( A\u2243B : Equiv A B)\n  ( B\u2243C : Equiv B C)\n  : Equiv A C\n  :=\n    ( ( \\ a \u2192 first B\u2243C (first A\u2243B a))\n    , ( ( ( \\ c \u2192 first (first (second A\u2243B)) (first (first (second (B\u2243C))) c))\n        , ( \\ a \u2192\n            concat A\n              ( first\n                ( first (second A\u2243B))\n                ( first\n                  ( first (second B\u2243C))\n                  ( first B\u2243C (first A\u2243B a))))\n              ( first (first (second A\u2243B)) (first A\u2243B a))\n              ( a)\n              ( ap B A\n                ( first (first (second B\u2243C)) (first B\u2243C (first A\u2243B a)))\n                ( first A\u2243B a)\n                ( first (first (second A\u2243B)))\n                ( second (first (second B\u2243C)) (first A\u2243B a)))\n              ( second (first (second A\u2243B)) a)))\n      , ( ( \\ c \u2192\n          first\n            ( second (second A\u2243B))\n            ( first (second (second (B\u2243C))) c))\n        , ( \\ c \u2192\n            concat C\n              ( first B\u2243C\n                ( first A\u2243B\n                  ( first\n                    ( second (second A\u2243B))\n                    ( first (second (second B\u2243C)) c))))\n              ( first B\u2243C (first (second (second B\u2243C)) c))\n              ( c)\n              ( ap B C\n                ( first A\u2243B\n                  ( first\n                    ( second (second A\u2243B))\n                    ( first (second (second B\u2243C)) c)))\n                ( first (second (second B\u2243C)) c)\n                ( first B\u2243C)\n                ( second\n                  ( second (second A\u2243B))\n                  ( first (second (second B\u2243C)) c)))\n              ( second (second (second B\u2243C)) c)))))\n</code></pre> <p>Now we compose the functions that are equivalences.</p> <pre><code>#def is-equiv-comp\n  ( A B C : U)\n  ( f : A \u2192 B)\n  ( is-equiv-f : is-equiv A B f)\n  ( g : B \u2192 C)\n  ( is-equiv-g : is-equiv B C g)\n  : is-equiv A C (comp A B C g f)\n  :=\n    ( ( comp C B A\n        ( retraction-is-equiv A B f is-equiv-f)\n        ( retraction-is-equiv B C g is-equiv-g)\n      , ( \\ a \u2192\n          concat A\n            ( retraction-is-equiv A B f is-equiv-f\n              ( retraction-is-equiv B C g is-equiv-g (g (f a))))\n            ( retraction-is-equiv A B f is-equiv-f (f a))\n            ( a)\n            ( ap B A\n              ( retraction-is-equiv B C g is-equiv-g (g (f a)))\n              ( f a)\n              ( retraction-is-equiv A B f is-equiv-f)\n              ( second (first is-equiv-g) (f a)))\n            ( second (first is-equiv-f) a)))\n    , ( comp C B A\n        ( section-is-equiv A B f is-equiv-f)\n        ( section-is-equiv B C g is-equiv-g)\n      , ( \\ c \u2192\n          concat C\n            ( g (f (first (second is-equiv-f) (first (second is-equiv-g) c))))\n            ( g (first (second is-equiv-g) c))\n            ( c)\n            ( ap B C\n              ( f (first (second is-equiv-f) (first (second is-equiv-g) c)))\n              ( first (second is-equiv-g) c)\n              ( g)\n              ( second (second is-equiv-f) (first (second is-equiv-g) c)))\n            ( second (second is-equiv-g) c))))\n</code></pre> Right cancellation of equivalences in diagrammatic order<pre><code>#def equiv-right-cancel\n  ( A B C : U)\n  ( A\u2243C : Equiv A C)\n  ( B\u2243C : Equiv B C)\n  : Equiv A B\n  := equiv-comp A C B (A\u2243C) (inv-equiv B C B\u2243C)\n</code></pre> Left cancellation of equivalences in diagrammatic order<pre><code>#def equiv-left-cancel\n  ( A B C : U)\n  ( A\u2243B : Equiv A B)\n  ( A\u2243C : Equiv A C)\n  : Equiv B C\n  := equiv-comp B A C (inv-equiv A B A\u2243B) (A\u2243C)\n</code></pre> A composition of three equivalences<pre><code>#def equiv-triple-comp\n  ( A B C D : U)\n  ( A\u2243B : Equiv A B)\n  ( B\u2243C : Equiv B C)\n  ( C\u2243D : Equiv C D)\n  : Equiv A D\n  := equiv-comp A B D (A\u2243B) (equiv-comp B C D B\u2243C C\u2243D)\n\n#def is-equiv-triple-comp\n  ( A B C D : U)\n  ( f : A \u2192 B)\n  ( is-equiv-f : is-equiv A B f)\n  ( g : B \u2192 C)\n  ( is-equiv-g : is-equiv B C g)\n  ( h : C \u2192 D)\n  ( is-equiv-h : is-equiv C D h)\n  : is-equiv A D (triple-comp A B C D h g f)\n  :=\n    is-equiv-comp A B D\n      ( f)\n      ( is-equiv-f)\n      ( comp B C D h g)\n      ( is-equiv-comp B C D g is-equiv-g h is-equiv-h)\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#equivalences-and-homotopy","title":"Equivalences and homotopy","text":"<p>If a map is homotopic to an equivalence it is an equivalence.</p> <pre><code>#def is-equiv-homotopy\n  ( A B : U)\n  ( f g : A \u2192 B)\n  ( H : homotopy A B f g)\n  ( is-equiv-g : is-equiv A B g)\n  : is-equiv A B f\n  :=\n    ( ( ( first (first is-equiv-g))\n      , ( \\ a \u2192\n          concat A\n            ( first (first is-equiv-g) (f a))\n            ( first (first is-equiv-g) (g a))\n            ( a)\n            ( ap B A (f a) (g a) (first (first is-equiv-g)) (H a))\n            ( second (first is-equiv-g) a)))\n    , ( ( first (second is-equiv-g))\n      , ( \\ b \u2192\n          concat B\n            ( f (first (second is-equiv-g) b))\n            ( g (first (second is-equiv-g) b))\n            ( b)\n            ( H (first (second is-equiv-g) b))\n            ( second (second is-equiv-g) b))))\n\n#def is-equiv-rev-homotopy\n  ( A B : U)\n  ( f g : A \u2192 B)\n  ( H : homotopy A B f g)\n  ( is-equiv-f : is-equiv A B f)\n  : is-equiv A B g\n  := is-equiv-homotopy A B g f (rev-homotopy A B f g H) is-equiv-f\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#function-extensionality","title":"Function extensionality","text":"<p>By path induction, an identification between functions defines a homotopy.</p> <pre><code>#def htpy-eq\n  ( X : U)\n  ( A : X \u2192 U)\n  ( f g : (x : X) \u2192 A x)\n  ( p : f = g)\n  : ( x : X) \u2192 (f x = g x)\n  :=\n    ind-path\n      ( ( x : X) \u2192 A x)\n      ( f)\n      ( \\ g' p' \u2192 (x : X) \u2192 (f x = g' x))\n      ( \\ x \u2192 refl)\n      ( g)\n      ( p)\n</code></pre> <p>The function extensionality axiom asserts that this map defines a family of equivalences.</p> The type that encodes the function extensionality axiom<pre><code>#def FunExt\n  : U\n  :=\n    ( X : U)\n  \u2192 ( A : X \u2192 U)\n  \u2192 ( f : (x : X) \u2192 A x)\n  \u2192 ( g : (x : X) \u2192 A x)\n  \u2192 is-equiv (f = g) ((x : X) \u2192 f x = g x) (htpy-eq X A f g)\n</code></pre> <p>In the formalisations below, some definitions will assume function extensionality:</p> <pre><code>#assume funext : FunExt\n</code></pre> <p>Whenever a definition (implicitly) uses function extensionality, we write <code>uses (funext)</code>. In particular, the following definitions rely on function extensionality:</p> The equivalence provided by function extensionality<pre><code>#def equiv-FunExt uses (funext)\n  ( X : U)\n  ( A : X \u2192 U)\n  ( f g : (x : X) \u2192 A x)\n  : Equiv (f = g) ((x : X) \u2192 f x = g x)\n  := (htpy-eq X A f g , funext X A f g)\n</code></pre> <p>In particular, function extensionality implies that homotopies give rise to identifications. This defines <code>eq-htpy</code> to be the retraction to <code>htpy-eq</code>.</p> <pre><code>#def eq-htpy uses (funext)\n  ( X : U)\n  ( A : X \u2192 U)\n  ( f g : (x : X) \u2192 A x)\n  : ( ( x : X) \u2192 f x = g x) \u2192 (f = g)\n  := first (first (funext X A f g))\n</code></pre> <p>Using function extensionality, a fiberwise equivalence defines an equivalence of dependent function types.</p> <pre><code>#def equiv-function-equiv-family uses (funext)\n  ( X : U)\n  ( A B : X \u2192 U)\n  ( famequiv : (x : X) \u2192 Equiv (A x) (B x))\n  : Equiv ((x : X) \u2192 A x) ((x : X) \u2192 B x)\n  :=\n    ( ( \\ a x \u2192 first (famequiv x) (a x))\n    , ( ( ( \\ b x \u2192 first (first (second (famequiv x))) (b x))\n        , ( \\ a \u2192\n            eq-htpy\n              X A\n              ( \\ x \u2192\n                first\n                  ( first (second (famequiv x)))\n                  ( first (famequiv x) (a x)))\n              ( a)\n              ( \\ x \u2192 second (first (second (famequiv x))) (a x))))\n      , ( ( \\ b x \u2192 first (second (second (famequiv x))) (b x))\n        , ( \\ b \u2192\n            eq-htpy\n              X B\n              ( \\ x \u2192\n                first (famequiv x) (first (second (second (famequiv x))) (b x)))\n              ( b)\n              ( \\ x \u2192 second (second (second (famequiv x))) (b x))))))\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#embeddings","title":"Embeddings","text":"<pre><code>#def is-emb\n  ( A B : U)\n  ( f : A \u2192 B)\n  : U\n  := (x : A) \u2192 (y : A) \u2192 is-equiv (x = y) (f x = f y) (ap A B x y f)\n\n#def Emb\n  ( A B : U)\n  : U\n  := (\u03a3 (f : A \u2192 B) , is-emb A B f)\n\n#def is-emb-is-inhabited-emb\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( e : A \u2192 is-emb A B f)\n  : is-emb A B f\n  := \\ x y \u2192 e x x y\n\n#def inv-ap-is-emb\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( is-emb-f : is-emb A B f)\n  ( x y : A)\n  ( p : f x = f y)\n  : ( x = y)\n  := first (first (is-emb-f x y)) p\n</code></pre>"},{"location":"hott/03-equivalences.rzk/#reversal-is-an-equivalence","title":"Reversal is an equivalence","text":"<pre><code>#def has-retraction-rev\n  ( A : U)\n  ( y : A)\n  : ( x : A) \u2192 has-retraction (x = y) (y = x) (rev A x y)\n  :=\n    \\ x \u2192\n    ( ( rev A y x)\n    , ( \\ p \u2192\n        ind-path\n          ( A)\n          ( x)\n          ( \\ y' p' \u2192\n            ( comp\n              ( x = y') (y' = x) (x = y') (rev A y' x) (rev A x y') (p'))\n            =_{x = y'}\n            ( p'))\n            ( refl)\n            ( y)\n            ( p)))\n\n#def has-section-rev\n  ( A : U)\n  ( y x : A)\n  : has-section (x = y) (y = x) (rev A x y)\n  :=\n    ( ( rev A y x)\n    , ( ind-path\n        ( A)\n        ( y)\n        ( \\ x' p' \u2192\n          ( comp\n            ( y = x') (x' = y) (y = x') (rev A x' y) (rev A y x') (p'))\n          =_{y = x'}\n          ( p'))\n        ( refl)\n        ( x)))\n\n#def is-equiv-rev\n  ( A : U)\n  ( x y : A)\n  : is-equiv (x = y) (y = x) (rev A x y)\n  := ((has-retraction-rev A y x) , (has-section-rev A y x))\n</code></pre>"},{"location":"hott/04-half-adjoint-equivalences.rzk/","title":"Half Adjoint Equivalences","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/04-half-adjoint-equivalences.rzk/#half-adjoint-equivalences_1","title":"Half adjoint equivalences","text":"<p>We'll require a more coherent notion of equivalence. Namely, the notion of half adjoint equivalences.</p> <pre><code>#def is-half-adjoint-equiv\n  ( A B : U)\n  ( f : A \u2192 B)\n  : U\n  :=\n    \u03a3 ( has-inverse-f : (has-inverse A B f))\n    , ( ( a : A)\n      \u2192 ( second (second has-inverse-f) (f a))\n      = ( ap A B\n          ( retraction-composite-has-inverse A B f has-inverse-f a)\n          ( a)\n          ( f)\n          ( first (second has-inverse-f) a)))\n</code></pre> <p>By function extensionality, the previous definition coincides with the following one:</p> <pre><code>#def is-half-adjoint-equiv'\n  ( A B : U)\n  ( f : A \u2192 B)\n  : U\n  :=\n    \u03a3 ( has-inverse-f : (has-inverse A B f))\n    , ( ( a : A)\n      \u2192 ( second (second has-inverse-f) (f a))\n      = ( ap A B\n          ( retraction-composite-has-inverse A B f has-inverse-f a)\n          ( a)\n          ( f)\n          ( first (second has-inverse-f) a)))\n</code></pre>"},{"location":"hott/04-half-adjoint-equivalences.rzk/#coherence-data-from-an-invertible-map","title":"Coherence data from an invertible map","text":"<p>To promote an invertible map to a half adjoint equivalence we keep one homotopy and discard the other.</p> <pre><code>#def has-inverse-kept-htpy\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( has-inverse-f : has-inverse A B f)\n  : homotopy A A\n    ( retraction-composite-has-inverse A B f has-inverse-f) (identity A)\n  := (first (second has-inverse-f))\n\n#def has-inverse-discarded-htpy\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( has-inverse-f : has-inverse A B f)\n  : homotopy B B\n    ( section-composite-has-inverse A B f has-inverse-f) (identity B)\n  := (second (second has-inverse-f))\n</code></pre> <p>The required coherence will be built by transforming an instance of the following naturality square.</p> <pre><code>#section has-inverse-coherence\n\n#variables A B : U\n#variable f : A \u2192 B\n#variable has-inverse-f : has-inverse A B f\n#variable a : A\n\n#def has-inverse-discarded-naturality-square\n  : concat B\n    ( quintuple-composite-has-inverse A B f has-inverse-f a)\n    ( triple-composite-has-inverse A B f has-inverse-f a)\n    ( f a)\n    ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a\n      ( triple-composite-has-inverse A B f has-inverse-f)\n      ( has-inverse-kept-htpy A B f has-inverse-f a))\n    ( has-inverse-discarded-htpy A B f has-inverse-f (f a))\n  = concat B\n    ( quintuple-composite-has-inverse A B f has-inverse-f a)\n      ( triple-composite-has-inverse A B f has-inverse-f a)\n      ( f a)\n      ( has-inverse-discarded-htpy A B f has-inverse-f\n        ( triple-composite-has-inverse A B f has-inverse-f a))\n      ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a\n        f (has-inverse-kept-htpy A B f has-inverse-f a))\n  :=\n    nat-htpy A B\n    ( triple-composite-has-inverse A B f has-inverse-f)\n    ( f)\n    ( \\ x \u2192 has-inverse-discarded-htpy A B f has-inverse-f (f x))\n    ( retraction-composite-has-inverse A B f has-inverse-f a)\n    ( a)\n    ( has-inverse-kept-htpy A B f has-inverse-f a)\n</code></pre> <p>We build a path that will be whiskered into the naturality square above:</p> <pre><code>#def has-inverse-cocone-homotopy-coherence\n  : has-inverse-kept-htpy A B f has-inverse-f\n      ( retraction-composite-has-inverse A B f has-inverse-f a)\n  = ap A A (retraction-composite-has-inverse A B f has-inverse-f a) a\n      ( retraction-composite-has-inverse A B f has-inverse-f)\n      ( has-inverse-kept-htpy A B f has-inverse-f a)\n  :=\n    cocone-naturality-coherence\n      ( A)\n      ( retraction-composite-has-inverse A B f has-inverse-f)\n      ( has-inverse-kept-htpy A B f has-inverse-f)\n      ( a)\n\n#def has-inverse-ap-cocone-homotopy-coherence\n  : ap A B\n    ( retraction-composite-has-inverse A B f has-inverse-f\n      ( retraction-composite-has-inverse A B f has-inverse-f a))\n    ( retraction-composite-has-inverse A B f has-inverse-f a)\n    ( f)\n    ( has-inverse-kept-htpy A B f has-inverse-f\n      ( retraction-composite-has-inverse A B f has-inverse-f a))\n  = ap A B\n    ( retraction-composite-has-inverse A B f has-inverse-f\n      ( retraction-composite-has-inverse A B f has-inverse-f a))\n    ( retraction-composite-has-inverse A B f has-inverse-f a)\n    ( f)\n    ( ap A A (retraction-composite-has-inverse A B f has-inverse-f a) a\n      ( retraction-composite-has-inverse A B f has-inverse-f)\n      ( has-inverse-kept-htpy A B f has-inverse-f a))\n  :=\n    ap-eq A B\n      ( retraction-composite-has-inverse A B f has-inverse-f\n        ( retraction-composite-has-inverse A B f has-inverse-f a))\n      ( retraction-composite-has-inverse A B f has-inverse-f a)\n      ( f)\n      ( has-inverse-kept-htpy A B f has-inverse-f\n        ( retraction-composite-has-inverse A B f has-inverse-f a))\n      ( ap A A (retraction-composite-has-inverse A B f has-inverse-f a) a\n        ( retraction-composite-has-inverse A B f has-inverse-f)\n        ( has-inverse-kept-htpy A B f has-inverse-f a))\n      ( has-inverse-cocone-homotopy-coherence)\n\n#def has-inverse-cocone-coherence\n  : ap A B\n    ( retraction-composite-has-inverse A B f has-inverse-f\n      ( retraction-composite-has-inverse A B f has-inverse-f a))\n    ( retraction-composite-has-inverse A B f has-inverse-f a)\n    ( f)\n    ( has-inverse-kept-htpy A B f has-inverse-f\n      ( retraction-composite-has-inverse A B f has-inverse-f a))\n  = ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a\n      ( triple-composite-has-inverse A B f has-inverse-f)\n      ( has-inverse-kept-htpy A B f has-inverse-f a))\n  :=\n    concat\n      ( quintuple-composite-has-inverse A B f has-inverse-f a\n      = triple-composite-has-inverse A B f has-inverse-f a)\n      ( ap A B\n        ( retraction-composite-has-inverse A B f has-inverse-f\n          ( retraction-composite-has-inverse A B f has-inverse-f a))\n        ( retraction-composite-has-inverse A B f has-inverse-f a)\n        ( f)\n        ( has-inverse-kept-htpy A B f has-inverse-f\n          ( retraction-composite-has-inverse A B f has-inverse-f a)))\n      ( ap A B\n        ( retraction-composite-has-inverse A B f has-inverse-f\n          ( retraction-composite-has-inverse A B f has-inverse-f a))\n        ( retraction-composite-has-inverse A B f has-inverse-f a)\n        ( f)\n        ( ap A A\n          ( retraction-composite-has-inverse A B f has-inverse-f a) a\n          ( retraction-composite-has-inverse A B f has-inverse-f)\n          ( has-inverse-kept-htpy A B f has-inverse-f a)))\n      ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a\n        ( triple-composite-has-inverse A B f has-inverse-f)\n        ( has-inverse-kept-htpy A B f has-inverse-f a))\n      ( has-inverse-ap-cocone-homotopy-coherence)\n      ( rev-ap-comp A A B\n        ( retraction-composite-has-inverse A B f has-inverse-f a) a\n        ( retraction-composite-has-inverse A B f has-inverse-f)\n        ( f)\n        ( has-inverse-kept-htpy A B f has-inverse-f a))\n</code></pre> <p>This morally gives the half adjoint inverse coherence. It just requires rotation.</p> <pre><code>#def has-inverse-replaced-naturality-square\n  : concat B\n    ( quintuple-composite-has-inverse A B f has-inverse-f a)\n    ( triple-composite-has-inverse A B f has-inverse-f a)\n    ( f a)\n    ( ap A B\n      ( retraction-composite-has-inverse A B f has-inverse-f\n        ( retraction-composite-has-inverse A B f has-inverse-f a))\n      ( retraction-composite-has-inverse A B f has-inverse-f a)\n      ( f)\n      ( has-inverse-kept-htpy A B f has-inverse-f\n        ( retraction-composite-has-inverse A B f has-inverse-f a)))\n    ( has-inverse-discarded-htpy A B f has-inverse-f (f a))\n  = concat B\n    ( quintuple-composite-has-inverse A B f has-inverse-f a)\n    ( triple-composite-has-inverse A B f has-inverse-f a)\n    ( f a)\n    ( has-inverse-discarded-htpy A B f has-inverse-f\n      ( triple-composite-has-inverse A B f has-inverse-f a))\n    ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f\n      ( has-inverse-kept-htpy A B f has-inverse-f a))\n  :=\n    concat\n      ( quintuple-composite-has-inverse A B f has-inverse-f a = f a)\n      ( concat B\n        ( quintuple-composite-has-inverse A B f has-inverse-f a)\n        ( triple-composite-has-inverse A B f has-inverse-f a)\n        ( f a)\n        ( ap A B\n          ( retraction-composite-has-inverse A B f has-inverse-f\n            ( retraction-composite-has-inverse A B f has-inverse-f a))\n          ( retraction-composite-has-inverse A B f has-inverse-f a) f\n          ( has-inverse-kept-htpy A B f has-inverse-f\n            ( retraction-composite-has-inverse A B f has-inverse-f a)))\n        ( has-inverse-discarded-htpy A B f has-inverse-f (f a)))\n      ( concat B\n        ( quintuple-composite-has-inverse A B f has-inverse-f a)\n        ( triple-composite-has-inverse A B f has-inverse-f a)\n        ( f a)\n        ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a\n          ( triple-composite-has-inverse A B f has-inverse-f)\n          ( has-inverse-kept-htpy A B f has-inverse-f a))\n        ( has-inverse-discarded-htpy A B f has-inverse-f (f a)))\n      ( concat B\n        ( quintuple-composite-has-inverse A B f has-inverse-f a)\n        ( triple-composite-has-inverse A B f has-inverse-f a) (f a)\n        ( has-inverse-discarded-htpy A B f has-inverse-f\n          ( triple-composite-has-inverse A B f has-inverse-f a))\n        ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f\n          ( has-inverse-kept-htpy A B f has-inverse-f a)))\n      ( concat-eq-left B\n        ( quintuple-composite-has-inverse A B f has-inverse-f a)\n        ( triple-composite-has-inverse A B f has-inverse-f a)\n        ( f a)\n        ( ap A B\n          ( retraction-composite-has-inverse A B f has-inverse-f\n            ( retraction-composite-has-inverse A B f has-inverse-f a))\n          ( retraction-composite-has-inverse A B f has-inverse-f a)\n          ( f)\n          ( has-inverse-kept-htpy A B f has-inverse-f\n            ( retraction-composite-has-inverse A B f has-inverse-f a)))\n        ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a\n          ( triple-composite-has-inverse A B f has-inverse-f)\n          ( has-inverse-kept-htpy A B f has-inverse-f a))\n        ( has-inverse-cocone-coherence)\n        ( has-inverse-discarded-htpy A B f has-inverse-f (f a)))\n      ( has-inverse-discarded-naturality-square)\n</code></pre> <p>This will replace the discarded homotopy.</p> <pre><code>#def has-inverse-corrected-htpy\n  : homotopy B B (section-composite-has-inverse A B f has-inverse-f) (\\ b \u2192 b)\n  :=\n    \\ b \u2192\n      concat B\n        ( ( section-composite-has-inverse A B f has-inverse-f) b)\n        ( ( section-composite-has-inverse A B f has-inverse-f)\n          ( ( section-composite-has-inverse A B f has-inverse-f) b))\n        ( b)\n        ( rev B\n          ( ( section-composite-has-inverse A B f has-inverse-f)\n            ( ( section-composite-has-inverse A B f has-inverse-f) b))\n          ( ( section-composite-has-inverse A B f has-inverse-f) b)\n          ( has-inverse-discarded-htpy A B f has-inverse-f\n            ( ( section-composite-has-inverse A B f has-inverse-f) b)))\n        ( concat B\n          ( ( section-composite-has-inverse A B f has-inverse-f)\n            ( ( section-composite-has-inverse A B f has-inverse-f) b))\n          ( ( section-composite-has-inverse A B f has-inverse-f) b)\n          ( b)\n          ( ap A B\n            ( ( retraction-composite-has-inverse A B f has-inverse-f)\n              ( map-inverse-has-inverse A B f has-inverse-f b))\n            ( map-inverse-has-inverse A B f has-inverse-f b) f\n            ( ( first (second has-inverse-f))\n              ( map-inverse-has-inverse A B f has-inverse-f b)))\n          ( ( has-inverse-discarded-htpy A B f has-inverse-f b)))\n</code></pre> <p>The following is the half adjoint coherence.</p> <pre><code>#def has-inverse-coherence\n  : ( has-inverse-corrected-htpy (f a))\n  = ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f\n      ( has-inverse-kept-htpy A B f has-inverse-f a))\n  :=\n    triangle-rotation B\n      ( quintuple-composite-has-inverse A B f has-inverse-f a)\n      ( triple-composite-has-inverse A B f has-inverse-f a)\n      ( f a)\n      ( concat B\n        ( ( section-composite-has-inverse A B f has-inverse-f)\n          ( ( section-composite-has-inverse A B f has-inverse-f) (f a)))\n        ( ( section-composite-has-inverse A B f has-inverse-f) (f a))\n        ( f a)\n        ( ap A B\n          ( ( retraction-composite-has-inverse A B f has-inverse-f)\n            ( map-inverse-has-inverse A B f has-inverse-f (f a)))\n          ( map-inverse-has-inverse A B f has-inverse-f (f a))\n            ( f)\n            ( ( first (second has-inverse-f))\n              ( map-inverse-has-inverse A B f has-inverse-f (f a))))\n        ( ( has-inverse-discarded-htpy A B f has-inverse-f (f a))))\n      ( has-inverse-discarded-htpy A B f has-inverse-f\n        ( triple-composite-has-inverse A B f has-inverse-f a))\n      ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f\n        ( has-inverse-kept-htpy A B f has-inverse-f a))\n      ( has-inverse-replaced-naturality-square)\n</code></pre> <pre><code>#end has-inverse-coherence\n</code></pre>"},{"location":"hott/04-half-adjoint-equivalences.rzk/#invertible-maps-are-half-adjoint-equivalences","title":"Invertible maps are half adjoint equivalences","text":"<p>To promote an invertible map to a half adjoint equivalence we change the data of the invertible map by discarding the homotopy and replacing it with a corrected one.</p> <pre><code>#def corrected-has-inverse-has-inverse\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( has-inverse-f : has-inverse A B f)\n  : has-inverse A B f\n  :=\n    ( map-inverse-has-inverse A B f has-inverse-f\n    , ( has-inverse-kept-htpy A B f has-inverse-f\n      , has-inverse-corrected-htpy A B f has-inverse-f))\n</code></pre> Invertible maps are half adjoint equivalences!<pre><code>#def is-half-adjoint-equiv-has-inverse\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( has-inverse-f : has-inverse A B f)\n  : is-half-adjoint-equiv A B f\n  :=\n    ( corrected-has-inverse-has-inverse A B f has-inverse-f\n    , has-inverse-coherence A B f has-inverse-f)\n</code></pre> Equivalences are half adjoint equivalences!<pre><code>#def is-half-adjoint-equiv-is-equiv\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( is-equiv-f : is-equiv A B f)\n  : is-half-adjoint-equiv A B f\n  :=\n    is-half-adjoint-equiv-has-inverse A B f\n      ( has-inverse-is-equiv A B f is-equiv-f)\n</code></pre>"},{"location":"hott/04-half-adjoint-equivalences.rzk/#equivalences-of-identity-types","title":"Equivalences of identity types","text":"<p>We use the notion of half adjoint equivalence to prove that equivalent types have equivalent identity types.</p> <pre><code>#section equiv-identity-types-equiv\n\n#variables A B : U\n#variable f : A \u2192 B\n#variable is-hae-f : is-half-adjoint-equiv A B f\n\n#def iff-ap-is-half-adjoint-equiv\n  ( x y : A)\n  : iff (x = y) (f x = f y)\n  :=\n    ( ap A B x y f\n    , \\ q \u2192\n      triple-concat A\n        ( x)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n        ( y)\n        ( rev A (retraction-composite-has-inverse A B f (first is-hae-f) x) x\n          ( ( first (second (first is-hae-f))) x))\n        ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q)\n        ( ( first (second (first is-hae-f))) y))\n\n#def has-retraction-ap-is-half-adjoint-equiv\n  ( x y : A)\n  : has-retraction (x = y) (f x = f y) (ap A B x y f)\n  :=\n    ( ( second (iff-ap-is-half-adjoint-equiv x y))\n    , ( ind-path\n          ( A)\n          ( x)\n          ( \\ y' p' \u2192\n            ( second (iff-ap-is-half-adjoint-equiv x y')) (ap A B x y' f p')\n          = ( p'))\n          ( rev-refl-id-triple-concat A\n            ( map-inverse-has-inverse A B f (first is-hae-f) (f x))\n            ( x)\n            ( first (second (first is-hae-f)) x))\n          ( y)))\n\n#def ap-triple-concat-is-half-adjoint-equiv\n  ( x y : A)\n  ( q : f x = f y)\n  : ap A B x y f ((second (iff-ap-is-half-adjoint-equiv x y)) q)\n  = ( triple-concat B\n      ( f x)\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n      ( f y)\n      ( ap A B x ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) f\n        ( rev A (retraction-composite-has-inverse A B f (first is-hae-f) x) x\n          ( ( first (second (first is-hae-f))) x)))\n      ( ap A B\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n        ( f)\n        ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n        ( ( first (second (first is-hae-f))) y)))\n  :=\n    ap-triple-concat A B\n      ( x)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n      ( y)\n      ( f)\n      ( rev A (retraction-composite-has-inverse A B f (first is-hae-f) x) x\n        ( ( first (second (first is-hae-f))) x))\n      ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q)\n      ( ( first (second (first is-hae-f))) y)\n\n#def ap-rev-triple-concat-eq-first-is-half-adjoint-equiv\n  ( x y : A)\n  ( q : f x = f y)\n  : triple-concat B\n    ( f x)\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n    ( f y)\n    ( ap A B x ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) f\n      ( rev A (retraction-composite-has-inverse A B f (first is-hae-f) x) x\n        ( ( first (second (first is-hae-f))) x)))\n    ( ap A B\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n      ( f)\n      ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n    ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n      ( ( first (second (first is-hae-f))) y))\n  = triple-concat B\n    ( f x)\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n    ( f y)\n    ( rev B (f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n        ( ( first (second (first is-hae-f))) x)))\n    ( ap A B\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n      ( f)\n      ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n    ( ap A B\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n      ( y)\n      ( f)\n      ( ( first (second (first is-hae-f))) y))\n  :=\n    triple-concat-eq-first B\n    ( f x)\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n    ( f y)\n    ( ap A B\n      ( x) ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) f\n      ( rev A (retraction-composite-has-inverse A B f (first is-hae-f) x) x\n        ( ( first (second (first is-hae-f))) x)))\n    ( rev B (f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n        ( ( first (second (first is-hae-f))) x)))\n    ( ap A B\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n      ( f)\n      ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n    ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n      ( ( first (second (first is-hae-f))) y))\n    ( ap-rev A B (retraction-composite-has-inverse A B f (first is-hae-f) x) x f\n      ( ( first (second (first is-hae-f))) x))\n\n#def ap-ap-triple-concat-eq-first-is-half-adjoint-equiv\n  ( x y : A)\n  ( q : f x = f y)\n  : ( triple-concat B\n      ( f x)\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n      ( f y)\n      ( rev B\n        ( f (retraction-composite-has-inverse A B f (first is-hae-f) x))\n        ( f x)\n        ( ap A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n          ( ( first (second (first is-hae-f))) x)))\n      ( ap A B\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n        ( f)\n        ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n        ( ( first (second (first is-hae-f))) y)))\n  = ( triple-concat B\n      ( f x)\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n      ( f y)\n      ( rev B\n        ( f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n          ( ( first (second (first is-hae-f))) x)))\n      ( ap B B (f x) (f y)\n        ( section-composite-has-inverse A B f (first is-hae-f)) q)\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y\n        ( f) ((first (second (first is-hae-f))) y)))\n  :=\n    triple-concat-eq-second B\n      ( f x)\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n      ( f y)\n      ( rev B (f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n          ( ( first (second (first is-hae-f))) x)))\n      ( ap A B\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f y))\n        ( f)\n        ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n      ( ap B B (f x) (f y) (section-composite-has-inverse A B f (first is-hae-f)) q)\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n        ( ( first (second (first is-hae-f))) y))\n      ( rev-ap-comp B A B (f x) (f y)\n        ( map-inverse-has-inverse A B f (first is-hae-f)) f q)\n\n-- This needs to be reversed later.\n#def triple-concat-higher-homotopy-is-half-adjoint-equiv\n  ( x y : A)\n  ( q : f x = f y)\n  : triple-concat B\n      ( f x)\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n      ( f y)\n      ( rev B (f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n        ( ( second (second (first is-hae-f))) (f x)))\n      ( ap B B (f x) (f y)\n        ( section-composite-has-inverse A B f (first is-hae-f)) q)\n      ( ( second (second (first is-hae-f))) (f y))\n  = triple-concat B\n      ( f x)\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n      ( f y)\n      ( rev B (f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f ((first (second (first is-hae-f))) x)))\n        ( ap B B (f x) (f y) (section-composite-has-inverse A B f (first is-hae-f)) q)\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f ((first (second (first is-hae-f))) y))\n  :=\n    triple-concat-higher-homotopy A B\n      ( triple-composite-has-inverse A B f (first is-hae-f)) f\n      ( \\ a \u2192 (((second (second (first is-hae-f)))) (f a)))\n      ( \\ a \u2192\n        ( ap A B (retraction-composite-has-inverse A B f (first is-hae-f) a) a f\n          ( ( ( first (second (first is-hae-f)))) a)))\n      ( second is-hae-f)\n      ( x)\n      ( y)\n      ( ap B B (f x) (f y)\n        ( section-composite-has-inverse A B f (first is-hae-f)) q)\n\n#def triple-concat-nat-htpy-is-half-adjoint-equiv\n  ( x y : A)\n  ( q : f x = f y)\n  : triple-concat B\n    ( f x)\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n    ( f y)\n    ( rev B (f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n      ( ( ( second (second (first is-hae-f)))) (f x)))\n    ( ap B B (f x) (f y) (section-composite-has-inverse A B f (first is-hae-f)) q)\n    ( ( ( second (second (first is-hae-f)))) (f y))\n    = ap B B (f x) (f y) (identity B) q\n  :=\n    triple-concat-nat-htpy B B\n      ( section-composite-has-inverse A B f (first is-hae-f))\n      ( identity B)\n      ( ( second (second (first is-hae-f))))\n      ( f x)\n      ( f y)\n      q\n\n#def zag-zig-concat-triple-concat-is-half-adjoint-equiv\n  ( x y : A)\n  ( q : f x = f y)\n  : triple-concat B\n    ( f x)\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n    ( f y)\n    ( rev B (f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n      ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n        ( ( first (second (first is-hae-f))) x)))\n    ( ap B B (f x) (f y) (section-composite-has-inverse A B f (first is-hae-f)) q)\n    ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n      ( ( first (second (first is-hae-f))) y))\n  = ap B B (f x) (f y) (identity B) q\n  :=\n    zag-zig-concat (f x = f y)\n      ( triple-concat B\n        ( f x)\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n        ( f y)\n        ( rev B\n          ( f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n          ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n            ( ( first (second (first is-hae-f))) x)))\n        ( ap B B (f x) (f y)\n          ( section-composite-has-inverse A B f (first is-hae-f)) q)\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y\n          f ((first (second (first is-hae-f))) y)))\n      ( triple-concat B\n        ( f x)\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n        ( f y)\n        ( rev B\n          ( f (retraction-composite-has-inverse A B f (first is-hae-f) x))\n          ( f x)\n          ( ( ( second (second (first is-hae-f)))) (f x)))\n        ( ap B B (f x) (f y)\n          ( section-composite-has-inverse A B f (first is-hae-f)) q)\n        ( ( ( second (second (first is-hae-f)))) (f y)))\n      ( ap B B (f x) (f y) (identity B) q)\n      ( triple-concat-higher-homotopy-is-half-adjoint-equiv x y q)\n      ( triple-concat-nat-htpy-is-half-adjoint-equiv x y q)\n\n#def triple-concat-reduction-is-half-adjoint-equiv\n  ( x y : A)\n  ( q : f x = f y)\n  : ap B B (f x) (f y) (identity B) q = q\n  := ap-id B (f x) (f y) q\n\n#def section-htpy-ap-is-half-adjoint-equiv\n  ( x y : A)\n  ( q : f x = f y)\n  : ap A B x y f ((second (iff-ap-is-half-adjoint-equiv x y)) q) = q\n  :=\n    alternating-quintuple-concat (f x = f y)\n      ( ap A B x y f ((second (iff-ap-is-half-adjoint-equiv x y)) q))\n      ( triple-concat B\n        ( f x)\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n        ( f y)\n        ( ap A B x ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) f\n          ( rev A (retraction-composite-has-inverse A B f (first is-hae-f) x) x\n            ( ( first (second (first is-hae-f))) x)))\n        ( ap A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f y)) f\n          ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n          ( ( first (second (first is-hae-f))) y)))\n      ( ap-triple-concat-is-half-adjoint-equiv x y q)\n      ( triple-concat B\n        ( f x)\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n        ( f y)\n        ( rev B\n          ( f (retraction-composite-has-inverse A B f (first is-hae-f) x)) (f x)\n          ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n            ( ( first (second (first is-hae-f))) x)))\n        ( ap A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f x))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f y)) f\n          ( ap B A (f x) (f y) (map-inverse-has-inverse A B f (first is-hae-f)) q))\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y f\n          ( ( first (second (first is-hae-f))) y)))\n      ( ap-rev-triple-concat-eq-first-is-half-adjoint-equiv x y q)\n      ( triple-concat B\n        ( f x)\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)))\n        ( f y)\n        ( rev B\n          ( f (retraction-composite-has-inverse A B f (first is-hae-f) x))\n          ( f x)\n          ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f x)) x f\n            ( ( first (second (first is-hae-f))) x)))\n        ( ap B B (f x) (f y)\n          ( section-composite-has-inverse A B f (first is-hae-f)) q)\n        ( ap A B ((map-inverse-has-inverse A B f (first is-hae-f)) (f y)) y\n          f ((first (second (first is-hae-f))) y)))\n      ( ap-ap-triple-concat-eq-first-is-half-adjoint-equiv x y q)\n      ( ap B B (f x) (f y) (identity B) q)\n      ( zag-zig-concat-triple-concat-is-half-adjoint-equiv x y q)\n      ( q)\n      ( triple-concat-reduction-is-half-adjoint-equiv x y q)\n\n#def has-section-ap-is-half-adjoint-equiv uses (is-hae-f)\n  ( x y : A)\n  : has-section (x = y) (f x = f y) (ap A B x y f)\n  :=\n    ( second (iff-ap-is-half-adjoint-equiv x y)\n    , section-htpy-ap-is-half-adjoint-equiv x y)\n\n#def is-equiv-ap-is-half-adjoint-equiv uses (is-hae-f)\n  ( x y : A)\n  : is-equiv (x = y) (f x = f y) (ap A B x y f)\n  :=\n    ( has-retraction-ap-is-half-adjoint-equiv x y\n    , has-section-ap-is-half-adjoint-equiv x y)\n\n#end equiv-identity-types-equiv\n\n#def is-emb-is-equiv\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( is-equiv-f : is-equiv A B f)\n  : is-emb A B f\n  :=\n    is-equiv-ap-is-half-adjoint-equiv A B f\n    ( is-half-adjoint-equiv-is-equiv A B f is-equiv-f)\n\n#def emb-is-equiv\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( is-equiv-f : is-equiv A B f)\n  : Emb A B\n  := (f , is-emb-is-equiv A B f is-equiv-f)\n\n#def equiv-ap-is-equiv\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( is-equiv-f : is-equiv A B f)\n  ( x y : A)\n  : Equiv (x = y) (f x = f y)\n  := (ap A B x y f , is-emb-is-equiv A B f is-equiv-f x y)\n</code></pre>"},{"location":"hott/05-sigma.rzk/","title":"Sigma types","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/05-sigma.rzk/#paths-involving-products","title":"Paths involving products","text":"<pre><code>#section paths-in-products\n\n#variables A B : U\n\n#def path-product\n  ( a a' : A)\n  ( b b' : B)\n  ( e_A : a = a')\n  ( e_B : b = b')\n  : ( a , b) =_{product A B} (a' , b')\n  :=\n    transport A (\\ x \u2192 (a , b) =_{product A B} (x , b')) a a' e_A\n      ( transport B (\\ y \u2192 (a , b) =_{product A B} (a , y)) b b' e_B refl)\n\n#def first-path-product\n  ( x y : product A B)\n  ( e : x =_{product A B} y)\n  : first x = first y\n  := ap (product A B) A x y (\\ z \u2192 first z) e\n\n#def second-path-product\n  ( x y : product A B)\n  ( e : x =_{product A B} y)\n  : second x = second y\n  := ap (product A B) B x y (\\ z \u2192 second z) e\n\n#end paths-in-products\n</code></pre> <pre><code>#def proj-base\n  ( B : U)\n  ( P : B \u2192 U)\n  : ( \u03a3 ( b : B) , P b) \u2192 B\n  := \\ (b , x) \u2192 b\n</code></pre>"},{"location":"hott/05-sigma.rzk/#identity-types-of-sigma-types","title":"Identity types of Sigma types","text":"<pre><code>#section paths-in-sigma\n\n#variable A : U\n#variable B : A \u2192 U\n\n#def first-path-\u03a3\n  ( s t : \u03a3 (a : A) , B a)\n  ( e : s = t)\n  : first s = first t\n  := ap (\u03a3 (a : A) , B a) A s t (\\ z \u2192 first z) e\n\n#def second-path-\u03a3\n  ( s t : \u03a3 (a : A) , B a)\n  ( e : s = t)\n  : ( transport A B (first s) (first t) (first-path-\u03a3 s t e) (second s))\n  = ( second t)\n  :=\n    ind-path\n      ( \u03a3 ( a : A) , B a)\n      ( s)\n      ( \\ t' e' \u2192\n        ( transport A B\n          ( first s) (first t') (first-path-\u03a3 s t' e') (second s))\n      = ( second t'))\n      ( refl)\n      ( t)\n      ( e)\n</code></pre> Rijke 22, Definition 9.3.1<pre><code>#def Eq-\u03a3\n  ( s t : \u03a3 (a : A) , B a)\n  : U\n  :=\n    \u03a3 ( p : (first s) = (first t))\n    , ( transport A B (first s) (first t) p (second s)) = (second t)\n</code></pre> Rijke 22, Definition 9.3.3<pre><code>#def pair-eq\n  ( s t : \u03a3 (a : A) , B a)\n  ( e : s = t)\n  : Eq-\u03a3 s t\n  := (first-path-\u03a3 s t e , second-path-\u03a3 s t e)\n</code></pre> <p>A path in a fiber defines a path in the total space.</p> <pre><code>#def eq-eq-fiber-\u03a3\n  ( x : A)\n  ( u v : B x)\n  ( p : u = v)\n  : ( x , u) =_{\u03a3 (a : A) , B a} (x , v)\n  := ind-path (B x) (u) (\\ v' p' \u2192 (x , u) = (x , v')) (refl) (v) (p)\n</code></pre> <p>The following is essentially <code>eq-pair</code> but with explicit arguments.</p> <pre><code>#def path-of-pairs-pair-of-paths\n  ( x y : A)\n  ( p : x = y)\n  : ( u : B x)\n  \u2192 ( v : B y)\n  \u2192 ( ( transport A B x y p u) = v)\n  \u2192 ( x , u) =_{\u03a3 (z : A) , B z} (y , v)\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192 (u' : B x) \u2192 (v' : B y')\n      \u2192 ( ( transport A B x y' p' u') = v')\n      \u2192 ( x , u') =_{\u03a3 (z : A) , B z} (y' , v'))\n      ( \\ u' v' q' \u2192 (eq-eq-fiber-\u03a3 x u' v' q'))\n      ( y)\n      ( p)\n</code></pre> The inverse to pair-eq<pre><code>#def eq-pair\n  ( s t : \u03a3 (a : A) , B a)\n  ( e : Eq-\u03a3 s t)\n  : ( s = t)\n  :=\n    path-of-pairs-pair-of-paths\n      ( first s) (first t) (first e) (second s) (second t) (second e)\n\n#def eq-pair-pair-eq\n  ( s t : \u03a3 (a : A) , B a)\n  ( e : s = t)\n  : ( eq-pair s t (pair-eq s t e)) = e\n  :=\n    ind-path\n      ( \u03a3 ( a : A) , (B a))\n      ( s)\n      ( \\ t' e' \u2192 (eq-pair s t' (pair-eq s t' e')) = e')\n      ( refl)\n      ( t)\n      ( e)\n</code></pre> <p>Here we've decomposed <code>e : Eq-\u03a3 s t</code> as <code>(e0, e1)</code> and decomposed <code>s</code> and <code>t</code> similarly for induction purposes.</p> <pre><code>#def pair-eq-eq-pair-split\n  ( s0 : A)\n  ( s1 : B s0)\n  ( t0 : A)\n  ( e0 : s0 = t0)\n  : ( t1 : B t0)\n  \u2192 ( e1 : (transport A B s0 t0 e0 s1) = t1)\n  \u2192 ( ( pair-eq (s0 , s1) (t0 , t1) (eq-pair (s0 , s1) (t0 , t1) (e0 , e1)))\n      =_{Eq-\u03a3 (s0 , s1) (t0 , t1)}\n      ( e0 , e1))\n  :=\n    ind-path\n      ( A)\n      ( s0)\n      ( \\ t0' e0' \u2192\n        ( t1 : B t0')\n      \u2192 ( e1 : (transport A B s0 t0' e0' s1) = t1)\n      \u2192 ( pair-eq (s0 , s1) (t0' , t1) (eq-pair (s0 , s1) (t0' , t1) (e0' , e1)))\n        =_{Eq-\u03a3 (s0 , s1) (t0' , t1)}\n        ( e0' , e1))\n      ( ind-path\n        ( B s0)\n        ( s1)\n        ( \\ t1' e1' \u2192\n          ( pair-eq\n            ( s0 , s1)\n            ( s0 , t1')\n            ( eq-pair (s0 , s1) (s0 , t1') (refl , e1')))\n          =_{Eq-\u03a3 (s0 , s1) (s0 , t1')}\n          ( refl , e1'))\n        ( refl))\n      ( t0)\n      ( e0)\n\n#def pair-eq-eq-pair\n  ( s t : \u03a3 (a : A) , B a)\n  ( e : Eq-\u03a3 s t)\n  : ( pair-eq s t (eq-pair s t e)) =_{Eq-\u03a3 s t} e\n  :=\n    pair-eq-eq-pair-split\n      ( first s) (second s) (first t) (first e) (second t) (second e)\n\n#def extensionality-\u03a3\n  ( s t : \u03a3 (a : A) , B a)\n  : Equiv (s = t) (Eq-\u03a3 s t)\n  :=\n    ( pair-eq s t\n    , ( ( eq-pair s t , eq-pair-pair-eq s t)\n      , ( eq-pair s t , pair-eq-eq-pair s t)))\n\n#end paths-in-sigma\n</code></pre>"},{"location":"hott/05-sigma.rzk/#identity-types-of-sigma-types-over-a-product","title":"Identity types of Sigma types over a product","text":"<pre><code>#section paths-in-sigma-over-product\n\n#variables A B : U\n#variable C : A \u2192 B \u2192 U\n\n#def product-transport\n  ( a a' : A)\n  ( b b' : B)\n  ( p : a = a')\n  ( q : b = b')\n  ( c : C a b)\n  : C a' b'\n  :=\n    ind-path\n      ( B)\n      ( b)\n      ( \\ b'' q' \u2192 C a' b'')\n      ( ind-path (A) (a) (\\ a'' p' \u2192 C a'' b) (c) (a') (p))\n      ( b')\n      ( q)\n\n#def Eq-\u03a3-over-product\n  ( s t : \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n  : U\n  :=\n    \u03a3 ( p : (first s) = (first t))\n    , ( \u03a3 ( q : (first (second s)) = (first (second t)))\n        , ( product-transport\n            ( first s) (first t)\n            ( first (second s)) (first (second t)) p q (second (second s))\n          = ( second (second t))))\n</code></pre> <p>Warning</p> <p>The following definition of <code>triple-eq</code> is the lazy definition with bad computational properties.</p> <pre><code>#def triple-eq\n  ( s t : \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n  ( e : s = t)\n  : Eq-\u03a3-over-product s t\n  :=\n    ind-path\n      ( \u03a3 ( a : A) , (\u03a3 (b : B) , C a b))\n      ( s)\n      ( \\ t' e' \u2192 (Eq-\u03a3-over-product s t'))\n      ( ( refl , (refl , refl)))\n      ( t)\n      ( e)\n</code></pre> <p>It's surprising that the following typechecks since we defined product-transport by a dual path induction over both <code>p</code> and <code>q</code>, rather than by saying that when <code>p</code> is <code>refl</code> this is ordinary transport.</p> The inverse with explicit arguments<pre><code>#def triple-of-paths-path-of-triples\n  ( a a' : A)\n  ( u u' : B)\n  ( c : C a u)\n  ( p : a = a')\n  : ( q : u = u')\n  \u2192 ( c' : C a' u')\n  \u2192 ( r : product-transport a a' u u' p q c = c')\n  \u2192 ( ( a , (u , c)) =_{(\u03a3 (x : A) , (\u03a3 (y : B) , C x y))} (a' , (u' , c')))\n  :=\n    ind-path\n      ( A)\n      ( a)\n      ( \\ a'' p' \u2192\n        ( q : u = u')\n      \u2192 ( c' : C a'' u')\n      \u2192 ( r : product-transport a a'' u u' p' q c = c')\n      \u2192 ( ( a , (u , c)) =_{(\u03a3 (x : A) , (\u03a3 (y : B) , C x y))} (a'' , (u' , c'))))\n      ( \\ q c' r \u2192\n        eq-eq-fiber-\u03a3\n          ( A) (\\ x \u2192 (\u03a3 (v : B) , C x v)) (a)\n          ( u , c) (u' , c')\n          ( path-of-pairs-pair-of-paths B (\\ y \u2192 C a y) u u' q c c' r))\n      ( a')\n      ( p)\n\n#def eq-triple\n  ( s t : \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n  ( e : Eq-\u03a3-over-product s t)\n  : ( s = t)\n  :=\n    triple-of-paths-path-of-triples\n    ( first s) (first t)\n    ( first (second s)) (first (second t))\n    ( second (second s)) (first e)\n    ( first (second e)) (second (second t))\n    ( second (second e))\n\n#def eq-triple-triple-eq\n  ( s t : \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n  ( e : s = t)\n  : ( eq-triple s t (triple-eq s t e)) = e\n  :=\n    ind-path\n      ( \u03a3 ( a : A) , (\u03a3 (b : B) , C a b))\n      ( s)\n      ( \\ t' e' \u2192 (eq-triple s t' (triple-eq s t' e')) = e')\n      ( refl)\n      ( t)\n      ( e)\n</code></pre> <p>Here we've decomposed <code>s</code>, <code>t</code> and <code>e</code> for induction purposes:</p> <pre><code>#def triple-eq-eq-triple-split\n  ( a a' : A)\n  ( b b' : B)\n  ( c : C a b)\n\n  : ( p : a = a')\n  \u2192 ( q : b = b')\n  \u2192 ( c' : C a' b')\n  \u2192 ( r : product-transport a a' b b' p q c = c')\n  \u2192 ( triple-eq\n      ( a , (b , c)) (a' , (b' , c'))\n      ( eq-triple (a , (b , c)) (a' , (b' , c')) (p , (q , r))))\n  = ( p , (q , r))\n  :=\n    ind-path\n      ( A)\n      ( a)\n      ( \\ a'' p' \u2192\n        ( q : b = b')\n      \u2192 ( c' : C a'' b')\n      \u2192 ( r : product-transport a a'' b b' p' q c = c')\n      \u2192 ( triple-eq\n          ( a , (b , c)) (a'' , (b' , c'))\n          ( eq-triple (a , (b , c)) (a'' , (b' , c')) (p' , (q , r))))\n      = ( p' , (q , r)))\n      ( ind-path\n        ( B)\n        ( b)\n        ( \\ b'' q' \u2192\n          ( c' : C a b'')\n        \u2192 ( r : product-transport a a b b'' refl q' c = c')\n        \u2192 ( triple-eq\n            ( a , (b , c)) (a , (b'' , c'))\n            ( eq-triple (a , (b , c)) (a , (b'' , c')) (refl , (q' , r))))\n        = ( refl , (q' , r)))\n        ( ind-path\n            ( C a b)\n            ( c)\n            ( \\ c'' r' \u2192\n              triple-eq\n                ( a , (b , c)) (a , (b , c''))\n                ( eq-triple\n                  ( a , (b , c)) (a , (b , c''))\n                  ( refl , (refl , r')))\n              = ( refl , (refl , r')))\n            ( refl))\n        ( b'))\n      ( a')\n\n#def triple-eq-eq-triple\n  ( s t : \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n  ( e : Eq-\u03a3-over-product s t)\n  : ( triple-eq s t (eq-triple s t e)) = e\n  :=\n    triple-eq-eq-triple-split\n      ( first s) (first t)\n      ( first (second s)) (first (second t))\n      ( second (second s)) (first e)\n      ( first (second e)) (second (second t))\n      ( second (second e))\n\n#def extensionality-\u03a3-over-product\n  ( s t : \u03a3 (a : A) , (\u03a3 (b : B) , C a b))\n  : Equiv (s = t) (Eq-\u03a3-over-product s t)\n  :=\n    ( triple-eq s t\n    , ( ( eq-triple s t , eq-triple-triple-eq s t)\n      , ( eq-triple s t , triple-eq-eq-triple s t)))\n\n#end paths-in-sigma-over-product\n</code></pre>"},{"location":"hott/05-sigma.rzk/#symmetry-of-products","title":"Symmetry of products","text":"<pre><code>#def sym-product\n  ( A B : U)\n  : Equiv (product A B) (product B A)\n  :=\n    ( \\ (a , b) \u2192 (b , a)\n    , ( ( \\ (b , a) \u2192 (a , b) , \\ p \u2192 refl)\n      , ( \\ (b , a) \u2192 (a , b) , \\ p \u2192 refl)))\n</code></pre>"},{"location":"hott/05-sigma.rzk/#fubini","title":"Fubini","text":"<p>Given a family over a pair of independent types, the order of summation is unimportant.</p> <pre><code>#def fubini-\u03a3\n  ( A B : U)\n  ( C : A \u2192 B \u2192 U)\n  : Equiv (\u03a3 (x : A) , \u03a3 (y : B) , C x y) (\u03a3 (y : B) , \u03a3 (x : A) , C x y)\n  :=\n    ( \\ t \u2192 (first (second t) , (first t , second (second t)))\n    , ( ( \\ t \u2192 (first (second t) , (first t , second (second t)))\n        , \\ t \u2192 refl)\n      , ( \\ t \u2192 (first (second t) , (first t , second (second t)))\n        , \\ t \u2192 refl)))\n</code></pre> Products distribute inside Sigma types<pre><code>#def distributive-product-\u03a3\n  ( A B : U)\n  ( C : B \u2192 U)\n  : Equiv (product A (\u03a3 (b : B) , C b)) (\u03a3 (b : B) , product A (C b))\n  :=\n    ( \\ (a , (b , c)) \u2192 (b , (a , c))\n    , ( ( \\ (b , (a , c)) \u2192 (a , (b , c)) , \\ z \u2192 refl)\n      , ( \\ (b , (a , c)) \u2192 (a , (b , c)) , \\ z \u2192 refl)))\n</code></pre>"},{"location":"hott/05-sigma.rzk/#associativity","title":"Associativity","text":"<pre><code>#def associative-\u03a3\n  ( A : U)\n  ( B : A \u2192 U)\n  ( C : (a : A) \u2192 B a \u2192 U)\n  : Equiv\n      ( \u03a3 ( a : A) , \u03a3 (b : B a) , C a b)\n      ( \u03a3 ( ab : \u03a3 (a : A) , B a) , C (first ab) (second ab))\n  :=\n    ( \\ (a , (b , c)) \u2192 ((a , b) , c)\n    , ( ( \\ ((a , b) , c) \u2192 (a , (b , c)) , \\ _ \u2192 refl)\n      , ( \\ ((a , b) , c) \u2192 (a , (b , c)) , \\ _ \u2192 refl)))\n</code></pre>"},{"location":"hott/05-sigma.rzk/#currying","title":"Currying","text":"<p>This is the dependent version of the currying equivalence.</p> <pre><code>#def equiv-dependent-curry\n  ( A : U)\n  ( B : A \u2192 U)\n  ( C : (a : A) \u2192 B a \u2192 U)\n  : Equiv\n      ( ( p : \u03a3 (a : A) , (B a)) \u2192 C (first p) (second p))\n      ( ( a : A) \u2192 (b : B a) \u2192 C a b)\n  :=\n    ( ( \\ s a b \u2192 s (a , b))\n    , ( ( ( \\ f (a , b) \u2192 f a b\n          , \\ f \u2192 refl)\n        , ( \\ f (a , b) \u2192 f a b\n          , \\ s \u2192 refl))))\n</code></pre>"},{"location":"hott/06-contractible.rzk/","title":"Contractible types","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/06-contractible.rzk/#contractible-types_1","title":"Contractible types","text":"The type of contractibility proofs<pre><code>#def is-contr (A : U)\n  : U\n  := \u03a3 (x : A) , ((y : A) \u2192 x = y)\n</code></pre>"},{"location":"hott/06-contractible.rzk/#contractible-type-data","title":"Contractible type data","text":"<pre><code>#section contractible-data\n\n#variable A : U\n#variable is-contr-A : is-contr A\n\n#def center-contraction\n  : A\n  := (first is-contr-A)\n</code></pre> The path from the contraction center to any point<pre><code>#def homotopy-contraction\n  : ( z : A) \u2192 center-contraction = z\n  := second is-contr-A\n\n#def realign-homotopy-contraction uses (is-contr-A)\n  : ( z : A) \u2192 center-contraction = z\n  :=\n    \\ z \u2192\n      ( concat A center-contraction center-contraction z\n          ( rev A center-contraction center-contraction\n            ( homotopy-contraction center-contraction))\n          ( homotopy-contraction z))\n\n#def path-realign-homotopy-contraction uses (is-contr-A)\n  : ( realign-homotopy-contraction center-contraction) = refl\n  :=\n    ( left-inverse-concat A center-contraction center-contraction\n      ( homotopy-contraction center-contraction))\n</code></pre> A path between any pair of terms in a contractible type<pre><code>#def eq-is-contr uses (is-contr-A)\n  ( x y : A)\n  : x = y\n  :=\n    zag-zig-concat A x center-contraction y\n      ( homotopy-contraction x) (homotopy-contraction y)\n\n#end contractible-data\n</code></pre>"},{"location":"hott/06-contractible.rzk/#unit-type","title":"Unit type","text":"<p>The prototypical contractible type is the unit type, which is built-in to rzk.</p> <pre><code>#def ind-unit\n  ( C : Unit \u2192 U)\n  ( C-unit : C unit)\n  ( x : Unit)\n  : C x\n  := C-unit\n\n#def is-prop-unit\n  ( x y : Unit)\n  : x = y\n  := refl\n</code></pre> The terminal projection as a constant map<pre><code>#def terminal-map\n  ( A : U)\n  : A \u2192 Unit\n  := constant A Unit unit\n</code></pre>"},{"location":"hott/06-contractible.rzk/#identity-types-of-unit-types","title":"Identity types of unit types","text":"<pre><code>#def terminal-map-of-path-types-of-Unit-has-retr\n  ( x y : Unit)\n  : has-retraction (x = y) Unit (terminal-map (x = y))\n  :=\n    ( \\ a \u2192 refl\n    , \\ p \u2192 ind-path (Unit) (x) (\\ y' p' \u2192 refl =_{x = y'} p') (refl) (y) (p))\n\n#def terminal-map-of-path-types-of-Unit-has-sec\n  ( x y : Unit)\n  : has-section (x = y) Unit (terminal-map (x = y))\n  := (\\ a \u2192 refl , \\ a \u2192 refl)\n\n#def terminal-map-of-path-types-of-Unit-is-equiv\n  ( x y : Unit)\n  : is-equiv (x = y) Unit (terminal-map (x = y))\n  :=\n    ( terminal-map-of-path-types-of-Unit-has-retr x y\n    , terminal-map-of-path-types-of-Unit-has-sec x y)\n</code></pre>"},{"location":"hott/06-contractible.rzk/#characterization-of-contractibility","title":"Characterization of contractibility","text":"<p>A type is contractible if and only if its terminal map is an equivalence.</p> <pre><code>#def terminal-map-is-equiv\n  ( A : U)\n  : U\n  := is-equiv A Unit (terminal-map A)\n\n#def contr-implies-terminal-map-is-equiv-retr\n  ( A : U)\n  ( is-contr-A : is-contr A)\n  : has-retraction A Unit (terminal-map A)\n  :=\n    ( constant Unit A (center-contraction A is-contr-A)\n    , \\ y \u2192 (homotopy-contraction A is-contr-A) y)\n\n#def contr-implies-terminal-map-is-equiv-sec\n  ( A : U)\n  ( is-contr-A : is-contr A)\n  : has-section A Unit (terminal-map A)\n  := (constant Unit A (center-contraction A is-contr-A) , \\ z \u2192 refl)\n\n#def contr-implies-terminal-map-is-equiv\n  ( A : U)\n  ( is-contr-A : is-contr A)\n  : is-equiv A Unit (terminal-map A)\n  :=\n    ( contr-implies-terminal-map-is-equiv-retr A is-contr-A\n    , contr-implies-terminal-map-is-equiv-sec A is-contr-A)\n\n#def terminal-map-is-equiv-implies-contr\n  ( A : U)\n  ( e : terminal-map-is-equiv A)\n  : is-contr A\n  := ((first (first e)) unit , (second (first e)))\n\n#def contr-iff-terminal-map-is-equiv\n  ( A : U)\n  : iff (is-contr A) (terminal-map-is-equiv A)\n  :=\n    ( ( contr-implies-terminal-map-is-equiv A)\n    , ( terminal-map-is-equiv-implies-contr A))\n\n#def equiv-with-contractible-domain-implies-contractible-codomain\n  ( A B : U)\n  ( f : Equiv A B)\n  ( is-contr-A : is-contr A)\n  : is-contr B\n  :=\n    ( terminal-map-is-equiv-implies-contr B\n      ( second\n        ( equiv-comp B A Unit\n          ( inv-equiv A B f)\n          ( ( terminal-map A)\n          , ( contr-implies-terminal-map-is-equiv A is-contr-A)))))\n\n#def equiv-with-contractible-codomain-implies-contractible-domain\n  ( A B : U)\n  ( f : Equiv A B)\n  ( is-contr-B : is-contr B)\n  : is-contr A\n  :=\n    ( equiv-with-contractible-domain-implies-contractible-codomain B A\n      ( inv-equiv A B f) is-contr-B)\n\n#def equiv-then-domain-contractible-iff-codomain-contractible\n  ( A B : U)\n  ( f : Equiv A B)\n  : ( iff (is-contr A) (is-contr B))\n  :=\n    ( \\ is-contr-A \u2192\n      ( equiv-with-contractible-domain-implies-contractible-codomain\n        A B f is-contr-A)\n    , \\ is-contr-B \u2192\n      ( equiv-with-contractible-codomain-implies-contractible-domain\n        A B f is-contr-B))\n\n#def path-types-of-Unit-are-contractible\n  ( x y : Unit)\n  : is-contr (x = y)\n  :=\n    ( terminal-map-is-equiv-implies-contr\n      ( x = y) (terminal-map-of-path-types-of-Unit-is-equiv x y))\n</code></pre>"},{"location":"hott/06-contractible.rzk/#retracts-of-contractible-types","title":"Retracts of contractible types","text":"<p>A retract of contractible types is contractible.</p> The type of proofs that A is a retract of B<pre><code>#def is-retract-of\n  ( A B : U)\n  : U\n  := \u03a3 (s : A \u2192 B) , has-retraction A B s\n\n#section retraction-data\n\n#variables A B : U\n#variable is-retract-of-A-B : is-retract-of A B\n\n#def is-retract-of-section\n  : A \u2192 B\n  := first is-retract-of-A-B\n\n#def is-retract-of-retraction\n  : B \u2192 A\n  := first (second is-retract-of-A-B)\n\n#def is-retract-of-homotopy\n  : homotopy A A (comp A B A is-retract-of-retraction is-retract-of-section) (identity A)\n  := second (second is-retract-of-A-B)\n</code></pre> If A is a retract of a contractible type it has a term<pre><code>#def is-retract-of-is-contr-isInhabited uses (is-retract-of-A-B)\n  ( is-contr-B : is-contr B)\n  : A\n  := is-retract-of-retraction (center-contraction B is-contr-B)\n</code></pre> If A is a retract of a contractible type it has a contracting homotopy<pre><code>#def is-retract-of-is-contr-hasHtpy uses (is-retract-of-A-B)\n  ( is-contr-B : is-contr B)\n  ( a : A)\n  : ( is-retract-of-is-contr-isInhabited is-contr-B) = a\n  :=\n    concat\n      ( A)\n      ( is-retract-of-is-contr-isInhabited is-contr-B)\n      ( ( comp A B A is-retract-of-retraction is-retract-of-section) a)\n      ( a)\n      ( ap B A (center-contraction B is-contr-B) (is-retract-of-section a)\n        ( is-retract-of-retraction)\n        ( homotopy-contraction B is-contr-B (is-retract-of-section a)))\n      ( is-retract-of-homotopy a)\n</code></pre> If A is a retract of a contractible type it is contractible<pre><code>#def is-contr-is-retract-of-is-contr uses (is-retract-of-A-B)\n  ( is-contr-B : is-contr B)\n  : is-contr A\n  :=\n    ( is-retract-of-is-contr-isInhabited is-contr-B\n    , is-retract-of-is-contr-hasHtpy is-contr-B)\n</code></pre> <pre><code>#end retraction-data\n</code></pre>"},{"location":"hott/06-contractible.rzk/#functions-between-contractible-types","title":"Functions between contractible types","text":"Any function between contractible types is an equivalence<pre><code>#def is-equiv-are-contr\n  ( A B : U)\n  ( is-contr-A : is-contr A)\n  ( is-contr-B : is-contr B)\n  ( f : A \u2192 B)\n  : is-equiv A B f\n  :=\n    ( ( \\ b \u2192 center-contraction A is-contr-A\n      , \\ a \u2192 homotopy-contraction A is-contr-A a)\n    , ( \\ b \u2192 center-contraction A is-contr-A\n      , \\ b \u2192 eq-is-contr B is-contr-B\n                ( f (center-contraction A is-contr-A)) b))\n</code></pre> A type equivalent to a contractible type is contractible<pre><code>#def is-contr-equiv-is-contr'\n  ( A B : U)\n  ( e : Equiv A B)\n  ( is-contr-B : is-contr B)\n  : is-contr A\n  :=\n    is-contr-is-retract-of-is-contr A B (first e , first (second e)) is-contr-B\n\n#def is-contr-equiv-is-contr\n  ( A B : U)\n  ( e : Equiv A B)\n  ( is-contr-A : is-contr A)\n  : is-contr B\n  :=\n    is-contr-is-retract-of-is-contr B A\n      ( first (second (second e)) , (first e , second (second (second e))))\n      ( is-contr-A)\n</code></pre>"},{"location":"hott/06-contractible.rzk/#based-path-spaces","title":"Based path spaces","text":"<p>For example, we prove that based path spaces are contractible.</p> Transport in the space of paths starting at a is concatenation<pre><code>#def concat-as-based-transport\n  ( A : U)\n  ( a x y : A)\n  ( p : a = x)\n  ( q : x = y)\n  : ( transport A (\\ z \u2192 (a = z)) x y q p) = (concat A a x y p q)\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' q' \u2192\n        ( transport A (\\ z \u2192 (a = z)) x y' q' p) = (concat A a x y' p q'))\n      ( refl)\n      ( y)\n      ( q)\n</code></pre> <p>The center of contraction in the based path space is <code>(a , refl)</code>.</p> The center of contraction in the based path space<pre><code>#def center-based-paths\n  ( A : U)\n  ( a : A)\n  : \u03a3 ( x : A) , (a = x)\n  := (a , refl)\n</code></pre> The contracting homotopy in the based path space<pre><code>#def contraction-based-paths\n  ( A : U)\n  ( a : A)\n  ( p : \u03a3 (x : A) , a = x)\n  : ( center-based-paths A a) = p\n  :=\n    path-of-pairs-pair-of-paths\n      A (\\ z \u2192 a = z) a (first p) (second p) (refl) (second p)\n      ( concat\n        ( a = (first p))\n        ( transport A (\\ z \u2192 (a = z)) a (first p) (second p) (refl))\n        ( concat A a a (first p) (refl) (second p))\n        ( second p)\n        ( concat-as-based-transport A a a (first p) (refl) (second p))\n        ( left-unit-concat A a (first p) (second p)))\n</code></pre> Based path spaces are contractible<pre><code>#def is-contr-based-paths\n  ( A : U)\n  ( a : A)\n  : is-contr (\u03a3 (x : A) , a = x)\n  := (center-based-paths A a , contraction-based-paths A a)\n</code></pre>"},{"location":"hott/06-contractible.rzk/#contractible-products","title":"Contractible products","text":"<pre><code>#def is-contr-product\n  ( A B : U)\n  ( is-contr-A : is-contr A)\n  ( is-contr-B : is-contr B)\n  : is-contr (product A B)\n  :=\n    ( ( first is-contr-A , first is-contr-B)\n    , \\ p \u2192 path-product A B\n              ( first is-contr-A) (first p)\n              ( first is-contr-B) (second p)\n              ( second is-contr-A (first p))\n              ( second is-contr-B (second p)))\n\n#def first-is-contr-product\n  ( A B : U)\n  ( AxB-is-contr : is-contr (product A B))\n  : is-contr A\n  :=\n    ( first (first AxB-is-contr)\n    , \\ a \u2192 first-path-product A B\n              ( first AxB-is-contr)\n              ( a , second (first AxB-is-contr))\n              ( second AxB-is-contr (a , second (first AxB-is-contr))))\n\n#def is-contr-base-is-contr-\u03a3\n  ( A : U)\n  ( B : A \u2192 U)\n  ( b : (a : A) \u2192 B a)\n  ( is-contr-AB : is-contr (\u03a3 (a : A) , B a))\n  : is-contr A\n  :=\n    ( first (first is-contr-AB)\n    , \\ a \u2192 first-path-\u03a3 A B\n              ( first is-contr-AB)\n              ( a , b a)\n              ( second is-contr-AB (a , b a)))\n</code></pre>"},{"location":"hott/06-contractible.rzk/#singleton-induction","title":"Singleton induction","text":"<p>A type is contractible if and only if it has singleton induction.</p> <pre><code>#def ev-pt\n  ( A : U)\n  ( a : A)\n  ( B : A \u2192 U)\n  : ( ( x : A) \u2192 B x) \u2192 B a\n  := \\ f \u2192 f a\n\n#def has-singleton-induction-pointed\n  ( A : U)\n  ( a : A)\n  ( B : A \u2192 U)\n  : U\n  := has-section ((x : A) \u2192 B x) (B a) (ev-pt A a B)\n\n#def has-singleton-induction-pointed-structure\n  ( A : U)\n  ( a : A)\n  : U\n  := (B : A \u2192 U) \u2192 has-section ((x : A) \u2192 B x) (B a) (ev-pt A a B)\n\n#def has-singleton-induction\n  ( A : U)\n  : U\n  := \u03a3 (a : A) , (B : A \u2192 U) \u2192 (has-singleton-induction-pointed A a B)\n\n#def ind-sing\n  ( A : U)\n  ( a : A)\n  ( B : A \u2192 U)\n  ( singleton-ind-A : has-singleton-induction-pointed A a B)\n  : ( B a) \u2192 ((x : A) \u2192 B x)\n  := (first singleton-ind-A)\n\n#def compute-ind-sing\n  ( A : U)\n  ( a : A)\n  ( B : A \u2192 U)\n  ( singleton-ind-A : has-singleton-induction-pointed A a B)\n  : ( homotopy\n      ( B a)\n      ( B a)\n      ( comp\n        ( B a)\n        ( ( x : A) \u2192 B x)\n        ( B a)\n        ( ev-pt A a B)\n        ( ind-sing A a B singleton-ind-A))\n      ( identity (B a)))\n  := (second singleton-ind-A)\n\n#def contr-implies-singleton-induction-ind\n  ( A : U)\n  ( is-contr-A : is-contr A)\n  : ( has-singleton-induction A)\n  :=\n    ( ( center-contraction A is-contr-A)\n    , \\ B \u2192\n        ( ( \\ b x \u2192\n                ( transport A B\n                  ( center-contraction A is-contr-A) x\n                  ( realign-homotopy-contraction A is-contr-A x) b))\n        , ( \\ b \u2192\n                ( ap\n                  ( ( center-contraction A is-contr-A)\n                  = ( center-contraction A is-contr-A))\n                  ( B (center-contraction A is-contr-A))\n                  ( realign-homotopy-contraction A is-contr-A\n                    ( center-contraction A is-contr-A))\n                  refl_{(center-contraction A is-contr-A)}\n                  ( \\ p \u2192\n                    ( transport-loop A B (center-contraction A is-contr-A) b p))\n                  ( path-realign-homotopy-contraction A is-contr-A)))))\n\n#def contr-implies-singleton-induction-pointed\n  ( A : U)\n  ( is-contr-A : is-contr A)\n  ( B : A \u2192 U)\n  : has-singleton-induction-pointed A (center-contraction A is-contr-A) B\n  := (second (contr-implies-singleton-induction-ind A is-contr-A)) B\n\n#def singleton-induction-ind-implies-contr\n  ( A : U)\n  ( a : A)\n  ( f : has-singleton-induction-pointed-structure A a)\n  : ( is-contr A)\n  := (a , (first (f (\\ x \u2192 a = x))) (refl_{a}))\n</code></pre>"},{"location":"hott/07-fibers.rzk/","title":"Fibers","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/07-fibers.rzk/#fibers_1","title":"Fibers","text":"<p>The homotopy fiber of a map is the following type:</p> The fiber of a map<pre><code>#def fib\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( b : B)\n  : U\n  := \u03a3 (a : A) , (f a) = b\n</code></pre> The total space of a family<pre><code>#def total-type\n  ( A : U)\n  ( P : A \u2192 U)\n  : U\n  := \u03a3 (a : A) , P a\n</code></pre> <p>We calculate the transport of (a , q) : fib b along p : a = a':</p> <pre><code>#def transport-in-fiber\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( b : B)\n  ( a a' : A)\n  ( u : (f a) = b)\n  ( p : a = a')\n  : ( transport A (\\ x \u2192 (f x) = b) a a' p u)\n  = ( concat B (f a') (f a) b (ap A B a' a f (rev A a a' p)) u)\n  :=\n    ind-path\n      ( A)\n      ( a)\n      ( \\ a'' p' \u2192\n        ( transport (A) (\\ x \u2192 (f x) = b) (a) (a'') (p') (u))\n      = ( concat (B) (f a'') (f a) (b) (ap A B a'' a f (rev A a a'' p')) (u)))\n      ( rev\n        ( ( f a) = b) (concat B (f a) (f a) b refl u) (u)\n        ( left-unit-concat B (f a) b u))\n      ( a')\n      ( p)\n</code></pre>"},{"location":"hott/07-fibers.rzk/#contractible-maps","title":"Contractible maps","text":"<p>A map is contractible just when its fibers are contractible.</p> Contractible maps<pre><code>#def is-contr-map\n  ( A B : U)\n  ( f : A \u2192 B)\n  : U\n  := (b : B) \u2192 is-contr (fib A B f b)\n</code></pre> <p>Contractible maps are equivalences:</p> <pre><code>#section is-contr-map-is-equiv\n\n#variables A B : U\n#variable f : A \u2192 B\n#variable is-contr-f : is-contr-map A B f\n</code></pre> The inverse to a contractible map<pre><code>#def is-contr-map-inverse\n  : B \u2192 A\n  := \\ b \u2192 first (center-contraction (fib A B f b) (is-contr-f b))\n\n#def has-section-is-contr-map\n  : has-section A B f\n  :=\n    ( is-contr-map-inverse\n    , \\ b \u2192 second (center-contraction (fib A B f b) (is-contr-f b)))\n\n#def is-contr-map-data-in-fiber uses (is-contr-f)\n  ( a : A)\n  : fib A B f (f a)\n  := (is-contr-map-inverse (f a) , (second has-section-is-contr-map) (f a))\n\n#def is-contr-map-path-in-fiber\n  ( a : A)\n  : ( is-contr-map-data-in-fiber a) =_{fib A B f (f a)} (a , refl)\n  :=\n    eq-is-contr\n      ( fib A B f (f a))\n      ( is-contr-f (f a))\n      ( is-contr-map-data-in-fiber a)\n      ( a , refl)\n\n#def is-contr-map-has-retraction uses (is-contr-f)\n  : has-retraction A B f\n  :=\n    ( is-contr-map-inverse\n    , \\ a \u2192 (ap (fib A B f (f a)) A\n                ( is-contr-map-data-in-fiber a)\n                ( ( a , refl))\n                ( \\ u \u2192 first u)\n                ( is-contr-map-path-in-fiber a)))\n\n#def is-equiv-is-contr-map uses (is-contr-f)\n  : is-equiv A B f\n  := (is-contr-map-has-retraction , has-section-is-contr-map)\n\n#end is-contr-map-is-equiv\n</code></pre>"},{"location":"hott/07-fibers.rzk/#half-adjoint-equivalences-are-contractible","title":"Half adjoint equivalences are contractible","text":"<p>We now show that half adjoint equivalences are contractible maps.</p> If f is a half adjoint equivalence, its fibers are inhabited<pre><code>#def is-split-surjection-is-half-adjoint-equiv\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( is-hae-f : is-half-adjoint-equiv A B f)\n  ( b : B)\n  : fib A B f b\n  :=\n    ( ( map-inverse-has-inverse A B f (first is-hae-f)) b\n    , ( second (second (first is-hae-f))) b)\n</code></pre> <p>It takes much more work to construct the contracting homotopy. The base path of this homotopy is straightforward.</p> <pre><code>#section half-adjoint-equivalence-fiber-data\n\n#variables A B : U\n#variable f : A \u2192 B\n#variable is-hae-f : is-half-adjoint-equiv A B f\n#variable b : B\n#variable z : fib A B f b\n\n#def base-path-fib-is-half-adjoint-equiv\n  : ( ( map-inverse-has-inverse A B f (first is-hae-f)) b) = (first z)\n  :=\n    concat A\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n      ( first z)\n      ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n        ( rev B (f (first z)) b (second z)))\n      ( ( first (second (first is-hae-f))) (first z))\n</code></pre> <p>Specializing the above to <code>isHAE-fib-base-path</code>:</p> <pre><code>#def transport-base-path-fib-is-half-adjoint-equiv\n  : transport A (\\ x \u2192 (f x) = b)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) b) (first z)\n      ( base-path-fib-is-half-adjoint-equiv)\n      ( ( second (second (first is-hae-f))) b)\n  = concat B (f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n      ( ap A B (first z) ((map-inverse-has-inverse A B f (first is-hae-f)) b) f\n          ( rev A ((map-inverse-has-inverse A B f (first is-hae-f)) b) (first z)\n            ( base-path-fib-is-half-adjoint-equiv)))\n      ( ( second (second (first is-hae-f))) b)\n  :=\n    transport-in-fiber A B f b\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) b) (first z)\n      ( ( second (second (first is-hae-f))) b)\n      ( base-path-fib-is-half-adjoint-equiv)\n\n#def rev-coherence-base-path-fib-is-half-adjoint-equiv\n  : rev A ((map-inverse-has-inverse A B f (first is-hae-f)) b) (first z)\n      ( base-path-fib-is-half-adjoint-equiv)\n  = concat A\n      ( first z)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n      ( rev A\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) (first z)\n        ( ( first (second (first is-hae-f))) (first z)))\n      ( rev A\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n          ( rev B (f (first z)) b (second z))))\n  :=\n    rev-concat A\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n      ( first z)\n      ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n        ( rev B (f (first z)) b (second z)))\n      ( ( first (second (first is-hae-f))) (first z))\n\n#def compute-rev-transport-base-path-fib-is-half-adjoint-equiv\n  : concat B (f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n    ( ap A B (first z) ((map-inverse-has-inverse A B f (first is-hae-f)) b) f\n      ( rev A ((map-inverse-has-inverse A B f (first is-hae-f)) b) (first z)\n        ( base-path-fib-is-half-adjoint-equiv)))\n    ( ( second (second (first is-hae-f))) b)\n  = concat B (f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n    ( ap A B (first z) ((map-inverse-has-inverse A B f (first is-hae-f)) b) f\n      ( concat A\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z)))\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n            ( rev B (f (first z)) b (second z))))))\n    ( ( second (second (first is-hae-f))) b)\n  :=\n    concat-eq-left B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( b)\n      ( ap A B (first z) ((map-inverse-has-inverse A B f (first is-hae-f)) b) f\n        ( rev A ((map-inverse-has-inverse A B f (first is-hae-f)) b) (first z)\n          ( base-path-fib-is-half-adjoint-equiv)))\n      ( ap A B (first z) ((map-inverse-has-inverse A B f (first is-hae-f)) b) f\n        ( concat A\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z)))\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n              ( rev B (f (first z)) b (second z))))))\n      ( ap-eq A B (first z) ((map-inverse-has-inverse A B f (first is-hae-f)) b) f\n        ( rev A ((map-inverse-has-inverse A B f (first is-hae-f)) b) (first z)\n          ( base-path-fib-is-half-adjoint-equiv))\n        ( concat A\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z)))\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n              ( rev B (f (first z)) b (second z)))))\n        ( rev-coherence-base-path-fib-is-half-adjoint-equiv))\n      ( ( second (second (first is-hae-f))) b)\n\n#def compute-ap-transport-base-path-fib-is-half-adjoint-equiv\n  : concat B (f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n    ( ap A B (first z) ((map-inverse-has-inverse A B f (first is-hae-f)) b) f\n      ( concat A\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) (first z)\n          ( ( first (second (first is-hae-f))) (first z)))\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n            ( rev B (f (first z)) b (second z))))))\n    ( ( second (second (first is-hae-f))) b)\n  = concat B (f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n      ( concat B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ap A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( f)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n              ( rev B (f (first z)) b (second z))))))\n      ( ( second (second (first is-hae-f))) b)\n  :=\n    concat-eq-left B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( b)\n      ( ap A B (first z) ((map-inverse-has-inverse A B f (first is-hae-f)) b) f\n        ( concat A\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z)))\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n              ( rev B (f (first z)) b (second z))))))\n      ( concat B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( f)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ap A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( f)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n              ( rev B (f (first z)) b (second z))))))\n      ( ap-concat A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n        ( f)\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z)))\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n            ( rev B (f (first z)) b (second z)))))\n      ( ( second (second (first is-hae-f))) b)\n\n#def compute-rev-ap-rev-transport-base-path-fib-is-half-adjoint-equiv\n  : concat B (f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( f)\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) (first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( ap A B\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n        ( f)\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n            ( rev B (f (first z)) b (second z))))))\n    ( ( second (second (first is-hae-f))) b)\n  = concat B (f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n      ( concat B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n        ( ap A B\n          ( first z) ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( f)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ap A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( f)\n          ( ap B A (f (first z)) b\n            ( map-inverse-has-inverse A B f (first is-hae-f))\n            ( second z))))\n      ( ( second (second (first is-hae-f))) b)\n  :=\n    concat-eq-left B\n      ( f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n      ( concat B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( f)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ap A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( f)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n              ( rev B (f (first z)) b (second z))))))\n      ( concat B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( f)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ap A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( f)\n          ( ap B A\n            ( f (first z)) b (map-inverse-has-inverse A B f (first is-hae-f))\n            ( second z))))\n      ( concat-eq-right B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( f)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ap A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b) f\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n              ( rev B (f (first z)) b (second z)))))\n        ( ap A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b) f\n          ( ap B A (f (first z)) b\n            ( map-inverse-has-inverse A B f (first is-hae-f)) (second z)))\n        ( ap-eq A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( f)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( ap B A b\n              ( f (first z))\n              ( map-inverse-has-inverse A B f (first is-hae-f))\n              ( rev B (f (first z)) b (second z))))\n          ( ap B A\n            ( f (first z))\n            ( b)\n            ( map-inverse-has-inverse A B f (first is-hae-f))\n            ( second z))\n          ( rev-ap-rev B A (f (first z)) b\n            ( map-inverse-has-inverse A B f (first is-hae-f)) (second z))))\n      ( ( second (second (first is-hae-f))) b)\n\n#def compute-ap-ap-transport-base-path-fib-is-half-adjoint-equiv\n  : concat B (f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( ap A B\n        ( first z) ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) (first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( ap A B\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n        ( f)\n        ( ap B A (f (first z)) b\n          ( map-inverse-has-inverse A B f (first is-hae-f))\n          ( second z))))\n    ( ( second (second (first is-hae-f))) b)\n  = concat B (f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( ap A B\n        ( first z) ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) (first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( ap B B (f (first z)) b\n        ( comp B A B f (map-inverse-has-inverse A B f (first is-hae-f)))\n        ( second z)))\n    ( ( second (second (first is-hae-f))) b)\n  :=\n    concat-eq-left B\n    ( f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( f)\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) (first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( ap A B\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n        ( f)\n        ( ap B A\n          ( f (first z)) b\n          ( map-inverse-has-inverse A B f (first is-hae-f)) (second z))))\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) (first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( ap B B (f (first z)) b\n        ( comp B A B f (map-inverse-has-inverse A B f (first is-hae-f)))\n        ( second z)))\n    ( concat-eq-right B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( ap A B\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n        ( f)\n        ( ap B A (f (first z)) b\n          ( map-inverse-has-inverse A B f (first is-hae-f)) (second z)))\n      ( ap B B (f (first z)) b\n        ( comp B A B f (map-inverse-has-inverse A B f (first is-hae-f)))\n        ( second z))\n      ( rev-ap-comp B A B\n        ( f (first z))\n        ( b)\n        ( map-inverse-has-inverse A B f (first is-hae-f))\n        ( f)\n        ( second z)))\n    ( ( second (second (first is-hae-f))) b)\n\n#def compute-assoc-transport-base-path-fib-is-half-adjoint-equiv\n  : concat B (f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( ap B B (f (first z)) b\n        ( comp B A B f (map-inverse-has-inverse A B f (first is-hae-f)))\n        ( second z)))\n    ( ( second (second (first is-hae-f))) b)\n  = concat B\n    ( f (first z))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n    ( b)\n    ( ap A B\n      ( first z)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n      ( f)\n      ( rev A\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( first z)\n        ( ( first (second (first is-hae-f))) (first z))))\n    ( concat B\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( b)\n      ( ap B B (f (first z)) b\n        ( comp B A B f (map-inverse-has-inverse A B f (first is-hae-f)))\n        ( second z))\n      ( ( second (second (first is-hae-f))) b))\n  :=\n    associative-concat B\n    ( f (first z))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n    ( b)\n    ( ap A B\n      ( first z)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n      ( f)\n      ( rev A\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) (first z)\n        ( ( first (second (first is-hae-f))) (first z))))\n    ( ap B B (f (first z)) b\n      ( comp B A B f (map-inverse-has-inverse A B f (first is-hae-f)))\n      ( second z))\n    ( ( second (second (first is-hae-f))) b)\n\n#def compute-nat-transport-base-path-fib-is-half-adjoint-equiv\n  : concat B\n    ( f (first z))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n    ( b)\n    ( ap A B\n      ( first z)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n      ( f)\n      ( rev A\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( first z)\n        ( ( first (second (first is-hae-f))) (first z))))\n    ( concat B\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( b)\n      ( ap B B (f (first z)) b\n        ( comp B A B f (map-inverse-has-inverse A B f (first is-hae-f)))\n        ( second z))\n      ( ( second (second (first is-hae-f))) b))\n  = concat B\n    ( f (first z))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n    ( b)\n    ( ap A B\n      ( first z)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n      ( f)\n      ( rev A\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( first z)\n        ( ( first (second (first is-hae-f))) (first z))))\n    ( concat B\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f (first z))\n      ( b)\n      ( ( second (second (first is-hae-f))) (f (first z)))\n      ( ap B B (f (first z)) b (identity B) (second z)))\n  :=\n    concat-eq-right B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( b)\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( f)\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( concat B\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n        ( b)\n        ( ap B B\n          ( f (first z))\n          ( b)\n          ( comp B A B f (map-inverse-has-inverse A B f (first is-hae-f)))\n          ( second z))\n        ( ( second (second (first is-hae-f))) b))\n      ( concat B\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f (first z))\n        ( b)\n        ( ( second (second (first is-hae-f))) (f (first z)))\n        ( ap B B (f (first z)) b (identity B) (second z)))\n      ( nat-htpy B B\n        ( comp B A B f (map-inverse-has-inverse A B f (first is-hae-f)))\n        ( identity B)\n        ( second (second (first is-hae-f)))\n        ( f (first z))\n        ( b)\n        ( second z))\n\n#def compute-ap-id-transport-base-path-fib-is-half-adjoint-equiv\n  : concat B\n    ( f (first z))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n    ( b)\n    ( ap A B\n      ( first z)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n      ( f)\n      ( rev A\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( first z)\n        ( ( first (second (first is-hae-f))) (first z))))\n    ( concat B\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f (first z))\n      ( b)\n      ( ( second (second (first is-hae-f))) (f (first z)))\n      ( ap B B (f (first z)) b (identity B) (second z)))\n  = concat B\n    ( f (first z))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n    ( b)\n    ( ap A B\n      ( first z)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n      ( f)\n      ( rev A\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( first z)\n        ( ( first (second (first is-hae-f))) (first z))))\n    ( concat B\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f (first z))\n      ( b)\n      ( ( second (second (first is-hae-f))) (f (first z)))\n      ( second z))\n  :=\n    concat-eq-right B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( b)\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( concat B\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f (first z))\n        ( b)\n        ( ( second (second (first is-hae-f))) (f (first z)))\n        ( ap B B (f (first z)) b (identity B) (second z)))\n      ( concat B\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f (first z))\n        ( b)\n        ( ( second (second (first is-hae-f))) (f (first z)))\n        ( second z))\n      ( concat-eq-right B\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f (first z))\n        ( b)\n        ( ( second (second (first is-hae-f))) (f (first z)))\n        ( ap B B (f (first z)) b (identity B) (second z))\n        ( second z)\n        ( ap-id B (f (first z)) b (second z)))\n\n#def compute-reassoc-transport-base-path-fib-is-half-adjoint-equiv\n  : concat B\n    ( f (first z))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n    ( b)\n    ( ap A B\n      ( first z)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n      ( rev A\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( first z)\n        ( ( first (second (first is-hae-f))) (first z))))\n    ( concat B\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f (first z))\n      ( b)\n      ( ( second (second (first is-hae-f))) (f (first z)))\n      ( second z))\n  = concat B (f (first z)) (f (first z)) b\n      ( concat B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f (first z))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ( second (second (first is-hae-f))) (f (first z))))\n      ( second z)\n  :=\n    rev-associative-concat B\n    ( f (first z))\n    ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n    ( f (first z))\n    ( b)\n    ( ap A B\n      ( first z)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n      ( f)\n      ( rev A\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( first z)\n        ( ( first (second (first is-hae-f))) (first z))))\n    ( ( second (second (first is-hae-f))) (f (first z)))\n    ( second z)\n\n#def compute-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv\n  : concat B (f (first z)) (f (first z)) b\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f (first z))\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( f)\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( ( second (second (first is-hae-f))) (f (first z))))\n    ( second z)\n  = concat B (f (first z)) (f (first z)) b\n      ( concat B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f (first z))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ap A B\n          ( retraction-composite-has-inverse A B f (first is-hae-f) (first z))\n          ( first z) f\n          ( ( ( first (second (first is-hae-f)))) (first z))))\n      ( second z)\n  :=\n    concat-eq-left B (f (first z)) (f (first z)) b\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f (first z))\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( ( second (second (first is-hae-f))) (f (first z))))\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f (first z))\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( ap A B\n        ( retraction-composite-has-inverse A B f (first is-hae-f) (first z))\n        ( first z)\n        ( f)\n        ( ( first (second (first is-hae-f))) (first z))))\n      ( concat-eq-right B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f (first z))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ( second (second (first is-hae-f))) (f (first z)))\n        ( ap A B\n          ( retraction-composite-has-inverse A B f (first is-hae-f) (first z))\n          ( first z) f\n          ( ( ( first (second (first is-hae-f)))) (first z)))\n        ( ( second is-hae-f) (first z)))\n      ( second z)\n\n#def reduction-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv\n  : concat B (f (first z)) (f (first z)) b\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f (first z))\n      ( ap A B\n        ( first z) ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( ap A B\n        ( retraction-composite-has-inverse A B f (first is-hae-f) (first z))\n        ( first z) f\n        ( ( ( first (second (first is-hae-f)))) (first z))))\n    ( second z)\n  = concat B (f (first z)) (f (first z)) b (refl) (second z)\n  :=\n    concat-eq-left B (f (first z)) (f (first z)) b\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( f (first z))\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( ap A B\n        ( retraction-composite-has-inverse A B f (first is-hae-f) (first z))\n        ( first z) f\n        ( ( ( first (second (first is-hae-f)))) (first z))))\n    ( refl)\n    ( concat-ap-rev-ap-id A B\n      ( retraction-composite-has-inverse A B f (first is-hae-f) (first z))\n      ( first z)\n      ( f)\n      ( ( ( first (second (first is-hae-f)))) (first z)))\n    ( second z)\n\n#def final-reduction-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv uses (A)\n  : concat B (f (first z)) (f (first z)) b (refl) (second z) = second z\n  := left-unit-concat B (f (first z)) b (second z)\n\n#def path-transport-base-path-fib-is-half-adjoint-equiv\n  : transport A (\\ x \u2192 (f x) = b)\n    ( ( map-inverse-has-inverse A B f (first is-hae-f)) b) (first z)\n    ( base-path-fib-is-half-adjoint-equiv)\n    ( ( second (second (first is-hae-f))) b) = second z\n  :=\n    alternating-12ary-concat ((f (first z)) = b)\n    ( transport A (\\ x \u2192 (f x) = b)\n      ( ( map-inverse-has-inverse A B f (first is-hae-f)) b) (first z)\n      ( base-path-fib-is-half-adjoint-equiv)\n      ( ( second (second (first is-hae-f))) b))\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( b)\n      ( ap A B (first z) ((map-inverse-has-inverse A B f (first is-hae-f)) b) f\n        ( rev A ((map-inverse-has-inverse A B f (first is-hae-f)) b) (first z)\n          ( base-path-fib-is-half-adjoint-equiv)))\n      ( ( second (second (first is-hae-f))) b))\n    ( transport-base-path-fib-is-half-adjoint-equiv)\n    ( concat B\n      ( f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n      ( ap A B (first z) ((map-inverse-has-inverse A B f (first is-hae-f)) b) f\n        ( concat A\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z)))\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n              ( rev B (f (first z)) b (second z))))))\n      ( ( second (second (first is-hae-f))) b))\n    ( compute-rev-transport-base-path-fib-is-half-adjoint-equiv)\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n      ( b)\n      ( concat B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ap A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          ( f)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( ap B A b (f (first z)) (map-inverse-has-inverse A B f (first is-hae-f))\n              ( rev B (f (first z)) b (second z))))))\n      ( ( second (second (first is-hae-f))) b))\n    ( compute-ap-transport-base-path-fib-is-half-adjoint-equiv)\n    ( concat B\n      ( f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n      ( concat B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ap A B\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n          f\n          ( ap B A (f (first z)) b\n            ( map-inverse-has-inverse A B f (first is-hae-f)) (second z))))\n      ( ( second (second (first is-hae-f))) b))\n    ( compute-rev-ap-rev-transport-base-path-fib-is-half-adjoint-equiv)\n    ( concat B (f (first z)) (f ((map-inverse-has-inverse A B f (first is-hae-f)) b)) b\n      ( concat B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ap B B (f (first z)) b\n          ( comp B A B f (map-inverse-has-inverse A B f (first is-hae-f)))\n          ( second z)))\n      ( ( second (second (first is-hae-f))) b))\n    ( compute-ap-ap-transport-base-path-fib-is-half-adjoint-equiv)\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( b)\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( f)\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( concat B\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) b))\n        ( b)\n        ( ap B B\n          ( f (first z)) (b)\n          ( comp B A B f (map-inverse-has-inverse A B f (first is-hae-f)))\n          ( second z))\n        ( ( second (second (first is-hae-f))) b)))\n    ( compute-assoc-transport-base-path-fib-is-half-adjoint-equiv)\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( b)\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n        ( f)\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) (first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( concat B\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f (first z))\n        ( b)\n        ( ( second (second (first is-hae-f))) (f (first z)))\n        ( ap B B (f (first z)) b (identity B) (second z))))\n    ( compute-nat-transport-base-path-fib-is-half-adjoint-equiv)\n    ( concat B\n      ( f (first z))\n      ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n      ( b)\n      ( ap A B\n        ( first z)\n        ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))) f\n        ( rev A\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( first z)\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( concat B\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f (first z))\n        ( b)\n        ( ( second (second (first is-hae-f))) (f (first z)))\n        ( second z)))\n    ( compute-ap-id-transport-base-path-fib-is-half-adjoint-equiv)\n    ( concat B (f (first z)) (f (first z)) b\n      ( concat B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f (first z))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( f)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ( second (second (first is-hae-f))) (f (first z))))\n        ( second z))\n    ( compute-reassoc-transport-base-path-fib-is-half-adjoint-equiv)\n    ( concat B (f (first z)) (f (first z)) b\n      ( concat B\n        ( f (first z))\n        ( f ((map-inverse-has-inverse A B f (first is-hae-f)) (f (first z))))\n        ( f (first z))\n        ( ap A B\n          ( first z)\n          ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n          ( f)\n          ( rev A\n            ( ( map-inverse-has-inverse A B f (first is-hae-f)) (f (first z)))\n            ( first z)\n            ( ( first (second (first is-hae-f))) (first z))))\n        ( ap A B\n          ( retraction-composite-has-inverse A B f (first is-hae-f) (first z))\n          ( first z) f\n          ( ( first (second (first is-hae-f))) (first z))))\n      ( second z))\n    ( compute-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv)\n    ( concat B (f (first z)) (f (first z)) b (refl) (second z))\n    ( reduction-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv)\n    ( second z)\n    ( final-reduction-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv)\n</code></pre> <p>Finally, we may define the contracting homotopy:</p> <pre><code>#def contraction-fib-is-half-adjoint-equiv\n  : ( is-split-surjection-is-half-adjoint-equiv A B f is-hae-f b) = z\n  :=\n    path-of-pairs-pair-of-paths A\n    ( \\ x \u2192 (f x) = b)\n    ( ( map-inverse-has-inverse A B f (first is-hae-f)) b)\n    ( first z)\n    ( base-path-fib-is-half-adjoint-equiv)\n    ( ( second (second (first is-hae-f))) b)\n    ( second z)\n    ( path-transport-base-path-fib-is-half-adjoint-equiv)\n\n#end half-adjoint-equivalence-fiber-data\n</code></pre> <p>Half adjoint equivalences define contractible maps:</p> <pre><code>#def is-contr-map-is-half-adjoint-equiv\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( is-hae-f : is-half-adjoint-equiv A B f)\n  : is-contr-map A B f\n  :=\n    \\ b \u2192\n    ( is-split-surjection-is-half-adjoint-equiv A B f is-hae-f b\n    , contraction-fib-is-half-adjoint-equiv A B f is-hae-f b)\n</code></pre>"},{"location":"hott/07-fibers.rzk/#equivalences-are-contractible-maps","title":"Equivalences are contractible maps","text":"<pre><code>#def is-contr-map-is-equiv\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( is-equiv-f : is-equiv A B f)\n  : is-contr-map A B f\n  :=\n    \\ b \u2192\n    ( is-split-surjection-is-half-adjoint-equiv A B f\n      ( is-half-adjoint-equiv-is-equiv A B f is-equiv-f) b\n    , \\ z \u2192 contraction-fib-is-half-adjoint-equiv A B f\n        ( is-half-adjoint-equiv-is-equiv A B f is-equiv-f) b z)\n\n#def is-contr-map-iff-is-equiv\n  ( A B : U)\n  ( f : A \u2192 B)\n  : iff (is-contr-map A B f) (is-equiv A B f)\n  := (is-equiv-is-contr-map A B f , is-contr-map-is-equiv A B f)\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/","title":"Families of maps","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#fiber-of-total-map","title":"Fiber of total map","text":"<p>We now calculate the fiber of the map on total spaces associated to a family of maps.</p> <pre><code>#def total-map\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  : ( \u03a3 ( x : A) , B x) \u2192 (\u03a3 (x : A) , C x)\n  := \\ z \u2192 (first z , f (first z) (second z))\n\n#def total-map-to-fiber\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( w : (\u03a3 (x : A) , C x))\n  : fib (B (first w)) (C (first w)) (f (first w)) (second w)\n  \u2192 ( fib (\u03a3 (x : A) , B x) (\u03a3 (x : A) , C x) (total-map A B C f) w)\n  :=\n    \\ (b , p) \u2192\n      ( ( first w , b)\n      , eq-eq-fiber-\u03a3 A C (first w) (f (first w) b) (second w) p)\n\n#def total-map-from-fiber\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( w : (\u03a3 (x : A) , C x))\n  : fib (\u03a3 (x : A) , B x) (\u03a3 (x : A) , C x) (total-map A B C f) w\n  \u2192 fib (B (first w)) (C (first w)) (f (first w)) (second w)\n  :=\n    \\ (z , p) \u2192\n    ind-path\n      ( \u03a3 ( x : A) , C x)\n      ( total-map A B C f z)\n      ( \\ w' p' \u2192 fib (B (first w')) (C (first w')) (f (first w')) (second w'))\n      ( second z , refl)\n      ( w)\n      ( p)\n\n#def total-map-to-fiber-retraction\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( w : (\u03a3 (x : A) , C x))\n  : has-retraction\n    ( fib (B (first w)) (C (first w)) (f (first w)) (second w))\n    ( fib (\u03a3 (x : A) , B x) (\u03a3 (x : A) , C x) (total-map A B C f) w)\n    ( total-map-to-fiber A B C f w)\n  :=\n    ( ( total-map-from-fiber A B C f w)\n    , ( \\ (b , p) \u2192\n        ind-path\n          ( C (first w))\n          ( f (first w) b)\n          ( \\ w1 p' \u2192\n            ( ( total-map-from-fiber A B C f ((first w , w1)))\n              ( ( total-map-to-fiber A B C f (first w , w1)) (b , p')))\n            =_{(fib (B (first w)) (C (first w)) (f (first w)) (w1))}\n            ( b , p'))\n          ( refl)\n          ( second w)\n          ( p)))\n\n#def total-map-to-fiber-section\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( w : (\u03a3 (x : A) , C x))\n  : has-section\n    ( fib (B (first w)) (C (first w)) (f (first w)) (second w))\n    ( fib (\u03a3 (x : A) , B x) (\u03a3 (x : A) , C x) (total-map A B C f) w)\n    ( total-map-to-fiber A B C f w)\n  :=\n    ( ( total-map-from-fiber A B C f w)\n    , ( \\ (z , p) \u2192\n        ind-path\n          ( \u03a3 ( x : A) , C x)\n          ( first z , f (first z) (second z))\n          ( \\ w' p' \u2192\n            ( ( total-map-to-fiber A B C f w')\n              ( ( total-map-from-fiber A B C f w') (z , p')))\n          = ( z , p'))\n          ( refl)\n          ( w)\n          ( p)))\n\n#def total-map-to-fiber-is-equiv\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( w : (\u03a3 (x : A) , C x))\n  : is-equiv\n    ( fib (B (first w)) (C (first w)) (f (first w)) (second w))\n    ( fib (\u03a3 (x : A) , B x) (\u03a3 (x : A) , C x)\n      ( total-map A B C f) w)\n    ( total-map-to-fiber A B C f w)\n  :=\n    ( total-map-to-fiber-retraction A B C f w\n    , total-map-to-fiber-section A B C f w)\n\n#def total-map-fiber-equiv\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( w : (\u03a3 (x : A) , C x))\n  : Equiv\n    ( fib (B (first w)) (C (first w)) (f (first w)) (second w))\n    ( fib (\u03a3 (x : A) , B x) (\u03a3 (x : A) , C x)\n      ( total-map A B C f) w)\n  := (total-map-to-fiber A B C f w , total-map-to-fiber-is-equiv A B C f w)\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#families-of-equivalences","title":"Families of equivalences","text":"<p>A family of equivalences induces an equivalence on total spaces and conversely. It will be easiest to work with the incoherent notion of two-sided-inverses.</p> <pre><code>#def invertible-family-total-inverse\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( invfamily : (a : A) \u2192 has-inverse (B a) (C a) (f a))\n  : ( \u03a3 ( x : A) , C x) \u2192 (\u03a3 (x : A) , B x)\n  := \\ (a , c) \u2192 (a , (map-inverse-has-inverse (B a) (C a) (f a) (invfamily a)) c)\n\n#def invertible-family-total-retraction\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( invfamily : (a : A) \u2192 has-inverse (B a) (C a) (f a))\n  : has-retraction\n    ( \u03a3 ( x : A) , B x)\n    ( \u03a3 ( x : A) , C x)\n    ( total-map A B C f)\n  :=\n    ( invertible-family-total-inverse A B C f invfamily\n    , \\ (a , b) \u2192\n        ( eq-eq-fiber-\u03a3 A B a\n          ( ( map-inverse-has-inverse (B a) (C a) (f a) (invfamily a)) (f a b)) b\n          ( ( first (second (invfamily a))) b)))\n\n#def invertible-family-total-section\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( invfamily : (a : A) \u2192 has-inverse (B a) (C a) (f a))\n  : has-section (\u03a3 (x : A) , B x) (\u03a3 (x : A) , C x) (total-map A B C f)\n  :=\n    ( invertible-family-total-inverse A B C f invfamily\n    , \\ (a , c) \u2192\n        ( eq-eq-fiber-\u03a3 A C a\n          ( f a ((map-inverse-has-inverse (B a) (C a) (f a) (invfamily a)) c)) c\n          ( ( second (second (invfamily a))) c)))\n\n#def invertible-family-total-invertible\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( invfamily : (a : A) \u2192 has-inverse (B a) (C a) (f a))\n  : has-inverse\n    ( \u03a3 ( x : A) , B x)\n    ( \u03a3 ( x : A) , C x)\n    ( total-map A B C f)\n  :=\n    ( invertible-family-total-inverse A B C f invfamily\n    , ( second (invertible-family-total-retraction A B C f invfamily)\n      , second (invertible-family-total-section A B C f invfamily)))\n\n#def family-of-equiv-total-equiv\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( familyequiv : (a : A) \u2192 is-equiv (B a) (C a) (f a))\n  : is-equiv\n    ( \u03a3 ( x : A) , B x) (\u03a3 (x : A) , C x) (total-map A B C f)\n  :=\n    is-equiv-has-inverse\n    ( \u03a3 ( x : A) , B x) (\u03a3 (x : A) , C x) (total-map A B C f)\n    ( invertible-family-total-invertible A B C f\n      ( \\ a \u2192 has-inverse-is-equiv (B a) (C a) (f a) (familyequiv a)))\n\n#def total-equiv-family-equiv\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( familyeq : (a : A) \u2192 Equiv (B a) (C a))\n  : Equiv (\u03a3 (x : A) , B x) (\u03a3 (x : A) , C x)\n  :=\n    ( total-map A B C (\\ a \u2192 first (familyeq a))\n    , family-of-equiv-total-equiv A B C\n        ( \\ a \u2192 first (familyeq a))\n        ( \\ a \u2192 second (familyeq a)))\n</code></pre> <p>The one-way result: that a family of equivalence gives an invertible map (and thus an equivalence) on total spaces.</p> <pre><code>#def total-has-inverse-family-equiv\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( familyequiv : (a : A) \u2192 is-equiv (B a) (C a) (f a))\n  : has-inverse (\u03a3 (x : A) , B x) (\u03a3 (x : A) , C x) (total-map A B C f)\n  :=\n    invertible-family-total-invertible A B C f\n    ( \\ a \u2192 has-inverse-is-equiv (B a) (C a) (f a) (familyequiv a))\n</code></pre> <p>For the converse, we make use of our calculation on fibers. The first implication could be proven similarly.</p> <pre><code>#def total-contr-map-family-of-contr-maps\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( totalcontrmap :\n    is-contr-map\n      ( \u03a3 ( x : A) , B x)\n      ( \u03a3 ( x : A) , C x)\n      ( total-map A B C f))\n  ( a : A)\n  : is-contr-map (B a) (C a) (f a)\n  :=\n    \\ c \u2192\n      is-contr-equiv-is-contr'\n        ( fib (B a) (C a) (f a) c)\n        ( fib (\u03a3 (x : A) , B x) (\u03a3 (x : A) , C x)\n          ( total-map A B C f) ((a , c)))\n        ( total-map-fiber-equiv A B C f ((a , c)))\n        ( totalcontrmap ((a , c)))\n\n#def total-equiv-family-of-equiv\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( totalequiv : is-equiv\n                ( \u03a3 ( x : A) , B x)\n                ( \u03a3 ( x : A) , C x)\n                ( total-map A B C f))\n  ( a : A)\n  : is-equiv (B a) (C a) (f a)\n  :=\n    is-equiv-is-contr-map (B a) (C a) (f a)\n    ( total-contr-map-family-of-contr-maps A B C f\n      ( is-contr-map-is-equiv\n        ( \u03a3 ( x : A) , B x) (\u03a3 (x : A) , C x)\n        ( total-map A B C f) totalequiv) a)\n\n#def family-equiv-total-equiv\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  ( totalequiv : is-equiv\n                ( \u03a3 ( x : A) , B x)\n                ( \u03a3 ( x : A) , C x)\n                ( total-map A B C f))\n  ( a : A)\n  : Equiv (B a) (C a)\n  := (f a , total-equiv-family-of-equiv A B C f totalequiv a)\n</code></pre> <p>In summary, a family of maps is an equivalence iff the map on total spaces is an equivalence.</p> <pre><code>#def total-equiv-iff-family-of-equiv\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( f : (a : A) \u2192 (B a) \u2192 (C a))\n  : iff\n      ( ( a : A) \u2192 is-equiv (B a) (C a) (f a))\n      ( is-equiv (\u03a3 (x : A) , B x) (\u03a3 (x : A) , C x)\n        ( total-map A B C f))\n  := (family-of-equiv-total-equiv A B C f , total-equiv-family-of-equiv A B C f)\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#codomain-based-path-spaces","title":"Codomain based path spaces","text":"<pre><code>#def equiv-rev\n  ( A : U)\n  ( x y : A)\n  : Equiv (x = y) (y = x)\n  := (rev A x y , ((rev A y x , rev-rev A x y) , (rev A y x , rev-rev A y x)))\n</code></pre> An equivalence between the based path spaces<pre><code>#def equiv-based-paths\n  ( A : U)\n  ( a : A)\n  : Equiv (\u03a3 (x : A) , x = a) (\u03a3 (x : A) , a = x)\n  := total-equiv-family-equiv A (\\ x \u2192 x = a) (\\ x \u2192 a = x) (\\ x \u2192 equiv-rev A x a)\n</code></pre> Codomain based path spaces are contractible<pre><code>#def is-contr-codomain-based-paths\n  ( A : U)\n  ( a : A)\n  : is-contr (\u03a3 (x : A) , x = a)\n  :=\n    is-contr-equiv-is-contr' (\u03a3 (x : A) , x = a) (\u03a3 (x : A) , a = x)\n      ( equiv-based-paths A a)\n      ( is-contr-based-paths A a)\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#pullback-of-a-type-family","title":"Pullback of a type family","text":"<p>A family of types over B pulls back along any function f : A \u2192 B to define a family of types over A.</p> <pre><code>#def pullback\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( C : B \u2192 U)\n  : A \u2192 U\n  := \\ a \u2192 C (f a)\n</code></pre> <p>The pullback of a family along homotopic maps is equivalent.</p> <pre><code>#section is-equiv-pullback-htpy\n\n#variables A B : U\n#variables f g : A \u2192 B\n#variable \u03b1 : homotopy A B f g\n#variable C : B \u2192 U\n#variable a : A\n\n#def pullback-homotopy\n  : ( pullback A B f C a) \u2192 (pullback A B g C a)\n  := transport B C (f a) (g a) (\u03b1 a)\n\n#def map-inverse-pullback-homotopy\n  : ( pullback A B g C a) \u2192 (pullback A B f C a)\n  := transport B C (g a) (f a) (rev B (f a) (g a) (\u03b1 a))\n\n#def has-retraction-pullback-homotopy\n  : has-retraction\n    ( pullback A B f C a)\n    ( pullback A B g C a)\n    ( pullback-homotopy)\n  :=\n    ( map-inverse-pullback-homotopy\n    , \\ c \u2192\n        concat\n        ( pullback A B f C a)\n        ( transport B C (g a) (f a)\n          ( rev B (f a) (g a) (\u03b1 a))\n          ( transport B C (f a) (g a) (\u03b1 a) c))\n        ( transport B C (f a) (f a)\n          ( concat B (f a) (g a) (f a) (\u03b1 a) (rev B (f a) (g a) (\u03b1 a))) c)\n        ( c)\n        ( transport-concat-rev B C (f a) (g a) (f a) (\u03b1 a)\n          ( rev B (f a) (g a) (\u03b1 a)) c)\n        ( transport2 B C (f a) (f a)\n          ( concat B (f a) (g a) (f a) (\u03b1 a) (rev B (f a) (g a) (\u03b1 a))) refl\n          ( right-inverse-concat B (f a) (g a) (\u03b1 a)) c))\n\n#def has-section-pullback-homotopy\n  : has-section (pullback A B f C a) (pullback A B g C a)\n    ( pullback-homotopy)\n  :=\n    ( map-inverse-pullback-homotopy\n    , \\ c \u2192\n      concat\n        ( pullback A B g C a)\n        ( transport B C (f a) (g a) (\u03b1 a)\n          ( transport B C (g a) (f a) (rev B (f a) (g a) (\u03b1 a)) c))\n        ( transport B C (g a) (g a)\n          ( concat B (g a) (f a) (g a) (rev B (f a) (g a) (\u03b1 a)) (\u03b1 a)) c)\n        ( c)\n        ( transport-concat-rev B C (g a) (f a) (g a)\n          ( rev B (f a) (g a) (\u03b1 a)) (\u03b1 a) (c))\n        ( transport2 B C (g a) (g a)\n          ( concat B (g a) (f a) (g a) (rev B (f a) (g a) (\u03b1 a)) (\u03b1 a))\n          ( refl)\n          ( left-inverse-concat B (f a) (g a) (\u03b1 a)) c))\n\n#def is-equiv-pullback-homotopy uses (\u03b1)\n  : is-equiv\n      ( pullback A B f C a)\n      ( pullback A B g C a)\n      ( pullback-homotopy)\n  := (has-retraction-pullback-homotopy , has-section-pullback-homotopy)\n\n#def equiv-pullback-homotopy uses (\u03b1)\n  : Equiv (pullback A B f C a) (pullback A B g C a)\n  := (pullback-homotopy , is-equiv-pullback-homotopy)\n\n#end is-equiv-pullback-htpy\n</code></pre> <p>The total space of a pulled back family of types maps to the original total space.</p> <pre><code>#def pullback-comparison-map\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( C : B \u2192 U)\n  : ( \u03a3 ( a : A) , (pullback A B f C) a) \u2192 (\u03a3 (b : B) , C b)\n  := \\ (a , c) \u2192 (f a , c)\n</code></pre> <p>Now we show that if a family is pulled back along an equivalence, the total spaces are equivalent by proving that the comparison is a contractible map. For this, we first prove that each fiber is equivalent to a fiber of the original map.</p> <pre><code>#def pullback-comparison-fiber\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( C : B \u2192 U)\n  ( z : \u03a3 (b : B) , C b)\n  : U\n  :=\n    fib\n      ( \u03a3 ( a : A) , (pullback A B f C) a)\n      ( \u03a3 ( b : B) , C b)\n      ( pullback-comparison-map A B f C) z\n\n#def pullback-comparison-fiber-to-fiber\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( C : B \u2192 U)\n  ( z : \u03a3 (b : B) , C b)\n  : ( pullback-comparison-fiber A B f C z) \u2192 (fib A B f (first z))\n  :=\n    \\ (w , p) \u2192\n    ind-path\n      ( \u03a3 ( b : B) , C b)\n      ( pullback-comparison-map A B f C w)\n      ( \\ z' p' \u2192\n        ( fib A B f (first z')))\n      ( first w , refl)\n      ( z)\n      ( p)\n\n#def from-base-fiber-to-pullback-comparison-fiber\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( C : B \u2192 U)\n  ( b : B)\n  : ( fib A B f b) \u2192 (c : C b) \u2192 (pullback-comparison-fiber A B f C (b , c))\n  :=\n    \\ (a , p) \u2192\n    ind-path\n      ( B)\n      ( f a)\n      ( \\ b' p' \u2192\n          ( c : C b') \u2192 (pullback-comparison-fiber A B f C ((b' , c))))\n      ( \\ c \u2192 ((a , c) , refl))\n      ( b)\n      ( p)\n\n#def pullback-comparison-fiber-to-fiber-inv\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( C : B \u2192 U)\n  ( z : \u03a3 (b : B) , C b)\n  : ( fib A B f (first z)) \u2192 (pullback-comparison-fiber A B f C z)\n  :=\n    \\ (a , p) \u2192\n      from-base-fiber-to-pullback-comparison-fiber A B f C\n      ( first z) (a , p) (second z)\n\n#def pullback-comparison-fiber-to-fiber-retracting-homotopy\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( C : B \u2192 U)\n  ( z : \u03a3 (b : B) , C b)\n  ( ( w , p) : pullback-comparison-fiber A B f C z)\n  : ( ( pullback-comparison-fiber-to-fiber-inv A B f C z)\n      ( ( pullback-comparison-fiber-to-fiber A B f C z) (w , p))) = (w , p)\n  :=\n    ind-path\n      ( \u03a3 ( b : B) , C b)\n      ( pullback-comparison-map A B f C w)\n      ( \\ z' p' \u2192\n        ( ( pullback-comparison-fiber-to-fiber-inv A B f C z')\n          ( ( pullback-comparison-fiber-to-fiber A B f C z') (w , p')))\n      = ( w , p'))\n      ( refl)\n      ( z)\n      ( p)\n\n#def pullback-comparison-fiber-to-fiber-section-homotopy-map\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( C : B \u2192 U)\n  ( b : B)\n  ( ( a , p) : fib A B f b)\n  : ( c : C b)\n    \u2192 ( ( pullback-comparison-fiber-to-fiber A B f C (b , c))\n        ( ( pullback-comparison-fiber-to-fiber-inv A B f C (b , c)) (a , p)))\n    = ( a , p)\n  :=\n    ind-path\n      ( B)\n      ( f a)\n      ( \\ b' p' \u2192\n        ( c : C b')\n      \u2192 ( ( pullback-comparison-fiber-to-fiber A B f C (b' , c))\n          ( ( pullback-comparison-fiber-to-fiber-inv A B f C (b' , c)) (a , p')))\n      = ( a , p'))\n      ( \\ c \u2192 refl)\n      ( b)\n      ( p)\n\n#def pullback-comparison-fiber-to-fiber-section-homotopy\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( C : B \u2192 U)\n  ( z : \u03a3 (b : B) , C b)\n  ( ( a , p) : fib A B f (first z))\n  : ( pullback-comparison-fiber-to-fiber A B f C z\n      ( pullback-comparison-fiber-to-fiber-inv A B f C z (a , p))) = (a , p)\n  :=\n    pullback-comparison-fiber-to-fiber-section-homotopy-map A B f C\n      ( first z) (a , p) (second z)\n\n#def equiv-pullback-comparison-fiber\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( C : B \u2192 U)\n  ( z : \u03a3 (b : B) , C b)\n  : Equiv (pullback-comparison-fiber A B f C z) (fib A B f (first z))\n  :=\n    ( pullback-comparison-fiber-to-fiber A B f C z\n    , ( ( pullback-comparison-fiber-to-fiber-inv A B f C z\n        , pullback-comparison-fiber-to-fiber-retracting-homotopy A B f C z)\n      , ( pullback-comparison-fiber-to-fiber-inv A B f C z\n        , pullback-comparison-fiber-to-fiber-section-homotopy A B f C z)))\n</code></pre> <p>As a corollary, we show that pullback along an equivalence induces an equivalence of total spaces.</p> <pre><code>#def total-equiv-pullback-is-equiv\n  ( A B : U)\n  ( f : A \u2192 B)\n  ( is-equiv-f : is-equiv A B f)\n  ( C : B \u2192 U)\n  : Equiv (\u03a3 (a : A) , (pullback A B f C) a) (\u03a3 (b : B) , C b)\n  :=\n    ( pullback-comparison-map A B f C\n    , is-equiv-is-contr-map\n        ( \u03a3 ( a : A) , (pullback A B f C) a)\n        ( \u03a3 ( b : B) , C b)\n        ( pullback-comparison-map A B f C)\n        ( \\ z \u2192\n          ( is-contr-equiv-is-contr'\n            ( pullback-comparison-fiber A B f C z)\n            ( fib A B f (first z))\n            ( equiv-pullback-comparison-fiber A B f C z)\n            ( is-contr-map-is-equiv A B f is-equiv-f (first z)))))\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#fundamental-theorem-of-identity-types","title":"Fundamental theorem of identity types","text":"<pre><code>#section fundamental-thm-id-types\n\n#variable A : U\n#variable a : A\n#variable B : A \u2192 U\n#variable f : (x : A) \u2192 (a = x) \u2192 B x\n\n#def fund-id-fam-of-eqs-implies-sum-over-codomain-contr\n  : ( ( x : A) \u2192 (is-equiv (a = x) (B x) (f x))) \u2192 (is-contr (\u03a3 (x : A) , B x))\n  :=\n    ( \\ familyequiv \u2192\n      ( equiv-with-contractible-domain-implies-contractible-codomain\n        ( \u03a3 ( x : A) , a = x) (\u03a3 (x : A) , B x)\n        ( ( total-map A (\\ x \u2192 (a = x)) B f)\n        , ( is-equiv-has-inverse (\u03a3 (x : A) , a = x) (\u03a3 (x : A) , B x)\n            ( total-map A (\\ x \u2192 (a = x)) B f)\n            ( total-has-inverse-family-equiv A\n              ( \\ x \u2192 (a = x)) B f familyequiv)))\n        ( is-contr-based-paths A a)))\n\n#def fund-id-sum-over-codomain-contr-implies-fam-of-eqs\n  : ( is-contr (\u03a3 (x : A) , B x))\n  \u2192 ( ( x : A) \u2192 (is-equiv (a = x) (B x) (f x)))\n  :=\n    ( \\ is-contr-\u03a3-A-B x \u2192\n      total-equiv-family-of-equiv A\n        ( \\ x' \u2192 (a = x'))\n        ( B)\n        ( f)\n        ( is-equiv-are-contr\n          ( \u03a3 ( x' : A) , (a = x'))\n          ( \u03a3 ( x' : A) , (B x'))\n          ( is-contr-based-paths A a)\n          ( is-contr-\u03a3-A-B)\n          ( total-map A (\\ x' \u2192 (a = x')) B f))\n        ( x))\n</code></pre> <p>This allows us to apply \"based path induction\" to a family satisfying the fundamental theorem:</p> <pre><code>-- Please suggest a better name.\n#def ind-based-path\n  ( familyequiv : (z : A) \u2192 (is-equiv (a = z) (B z) (f z)))\n  ( P : (z : A) \u2192 B z \u2192 U)\n  ( p0 : P a (f a refl))\n  ( u : A)\n  ( p : B u)\n  : P u p\n  :=\n    ind-sing\n      ( \u03a3 ( v : A) , B v)\n      ( a , f a refl)\n      ( \\ (u' , p') \u2192 P u' p')\n      ( contr-implies-singleton-induction-pointed\n        ( \u03a3 ( z : A) , B z)\n        ( fund-id-fam-of-eqs-implies-sum-over-codomain-contr familyequiv)\n        ( \\ (x' , p') \u2192 P x' p'))\n      ( p0)\n      ( u , p)\n\n#end fundamental-thm-id-types\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#2-of-3-for-equivalences","title":"2-of-3 for equivalences","text":"<p>The following functions refine <code>equiv-right-cancel</code> and <code>equiv-left-cancel</code> by providing control over the underlying maps of the equivalence.</p> <pre><code>#def is-equiv-right-factor\n  ( A B C : U)\n  ( f : A \u2192 B)\n  ( g : B \u2192 C)\n  ( is-equiv-g : is-equiv B C g)\n  ( is-equiv-gf : is-equiv A C (comp A B C g f))\n  : is-equiv A B f\n  :=\n    ( ( comp B C A\n        ( retraction-is-equiv A C (comp A B C g f) is-equiv-gf) g\n      , ( second (first is-equiv-gf)))\n    , ( comp B C A\n        ( section-is-equiv A C (comp A B C g f) is-equiv-gf) g\n      , \\ b \u2192\n          inv-ap-is-emb\n            B C g\n            ( is-emb-is-equiv B C g is-equiv-g)\n            ( f ((section-is-equiv A C (comp A B C g f) is-equiv-gf) (g b)))\n            b\n            ( ( second (second is-equiv-gf)) (g b))))\n\n#def is-equiv-left-factor\n  ( A B C : U)\n  ( f : A \u2192 B)\n  ( is-equiv-f : is-equiv A B f)\n  ( g : B \u2192 C)\n  ( is-equiv-gf : is-equiv A C (comp A B C g f))\n  : is-equiv B C g\n  :=\n    ( ( comp C A B\n          f (retraction-is-equiv A C (comp A B C g f) is-equiv-gf)\n      , \\ b \u2192\n          triple-concat B\n            ( f ((retraction-is-equiv A C (comp A B C g f) is-equiv-gf)\n              ( g b)))\n            ( f ((retraction-is-equiv A C (comp A B C g f) is-equiv-gf)\n              ( g (f ((section-is-equiv A B f is-equiv-f) b)))))\n            ( f ((section-is-equiv A B f is-equiv-f) b))\n            ( b)\n            ( ap B B\n              ( b)\n              ( f ((section-is-equiv A B f is-equiv-f) b))\n              ( \\ b0 \u2192\n                ( f ((retraction-is-equiv A C\n                      ( comp A B C g f) is-equiv-gf) (g b0))))\n              ( rev B (f ((section-is-equiv A B f is-equiv-f) b)) b\n                ( ( second (second is-equiv-f)) b)))\n            ( ( whisker-homotopy B A A B\n                ( \\ a \u2192\n                  ( retraction-is-equiv A C\n                    ( comp A B C g f) is-equiv-gf) (g (f a)))\n                ( \\ a \u2192 a)\n                ( second (first is-equiv-gf))\n                ( section-is-equiv A B f is-equiv-f)\n                f) b)\n            ( ( second (second is-equiv-f)) b))\n    , ( comp C A B\n        ( f)\n        ( section-is-equiv A C (comp A B C g f) is-equiv-gf)\n      , ( second (second is-equiv-gf))))\n</code></pre>"},{"location":"hott/08-families-of-maps.rzk/#maps-over-product-types","title":"Maps over product types","text":"<p>For later use, we specialize the previous results to the case of a family of types over a product type.</p> <pre><code>#section fibered-map-over-product\n\n#variables A A' B B' : U\n#variable C : A \u2192 B \u2192 U\n#variable C' : A' \u2192 B' \u2192 U\n#variable f : A \u2192 A'\n#variable g : B \u2192 B'\n#variable h : (a : A) \u2192 (b : B) \u2192 (c : C a b) \u2192 C' (f a) (g b)\n\n#def total-map-fibered-map-over-product\n  : ( \u03a3 ( a : A) , (\u03a3 (b : B) , C a b)) \u2192 (\u03a3 (a' : A') , (\u03a3 (b' : B') , C' a' b'))\n  := \\ (a , (b , c)) \u2192 (f a , (g b , h a b c))\n\n#def pullback-is-equiv-base-is-equiv-total-is-equiv\n  ( is-equiv-total :\n    is-equiv\n      ( \u03a3 ( a : A) , (\u03a3 (b : B) , C a b))\n      ( \u03a3 ( a' : A') , (\u03a3 (b' : B') , C' a' b'))\n      ( total-map-fibered-map-over-product))\n  ( is-equiv-f : is-equiv A A' f)\n  : is-equiv\n      ( \u03a3 ( a : A) , (\u03a3 (b : B) , C a b))\n      ( \u03a3 ( a : A) , (\u03a3 (b' : B') , C' (f a) b'))\n      ( \\ (a , (b , c)) \u2192 (a , (g b , h a b c)))\n  :=\n    is-equiv-right-factor\n    ( \u03a3 ( a : A) , (\u03a3 (b : B) , C a b))\n    ( \u03a3 ( a : A) , (\u03a3 (b' : B') , C' (f a) b'))\n    ( \u03a3 ( a' : A') , (\u03a3 (b' : B') , C' a' b'))\n    ( \\ (a , (b , c)) \u2192 (a , (g b , h a b c)))\n    ( \\ (a , (b' , c')) \u2192 (f a , (b' , c')))\n    ( second\n      ( total-equiv-pullback-is-equiv\n        ( A) (A')\n        ( f) (is-equiv-f)\n        ( \\ a' \u2192 (\u03a3 (b' : B') , C' a' b'))))\n    ( is-equiv-total)\n\n#def pullback-is-equiv-bases-are-equiv-total-is-equiv\n  ( is-equiv-total :\n      is-equiv\n        ( \u03a3 ( a : A) , (\u03a3 (b : B) , C a b))\n        ( \u03a3 ( a' : A') , (\u03a3 (b' : B') , C' a' b'))\n        ( total-map-fibered-map-over-product))\n  ( is-equiv-f : is-equiv A A' f)\n  ( is-equiv-g : is-equiv B B' g)\n  : is-equiv\n      ( \u03a3 ( a : A) , (\u03a3 (b : B) , C a b))\n      ( \u03a3 ( a : A) , (\u03a3 (b : B) , C' (f a) (g b)))\n      ( \\ (a , (b , c)) \u2192 (a , (b , h a b c)))\n  :=\n    is-equiv-right-factor\n    ( \u03a3 ( a : A) , (\u03a3 (b : B) , C a b))\n    ( \u03a3 ( a : A) , (\u03a3 (b : B) , C' (f a) (g b)))\n    ( \u03a3 ( a : A) , (\u03a3 (b' : B') , C' (f a) b'))\n    ( \\ (a , (b , c)) \u2192 (a , (b , h a b c)))\n    ( \\ (a , (b , c)) \u2192 (a , (g b , c)))\n    ( family-of-equiv-total-equiv A\n      ( \\ a \u2192 (\u03a3 (b : B) , C' (f a) (g b)))\n      ( \\ a \u2192 (\u03a3 (b' : B') , C' (f a) b'))\n      ( \\ a (b , c) \u2192 (g b , c))\n      ( \\ a \u2192\n        ( second\n          ( total-equiv-pullback-is-equiv\n            ( B) (B')\n            ( g) (is-equiv-g)\n            ( \\ b' \u2192 C' (f a) b')))))\n    ( pullback-is-equiv-base-is-equiv-total-is-equiv is-equiv-total is-equiv-f)\n\n#def fibered-map-is-equiv-bases-are-equiv-total-map-is-equiv\n  ( is-equiv-total :\n      is-equiv\n        ( \u03a3 ( a : A) , (\u03a3 (b : B) , C a b))\n        ( \u03a3 ( a' : A') , (\u03a3 (b' : B') , C' a' b'))\n        ( total-map-fibered-map-over-product))\n  ( is-equiv-f : is-equiv A A' f)\n  ( is-equiv-g : is-equiv B B' g)\n  ( a0 : A)\n  ( b0 : B)\n  : is-equiv (C a0 b0) (C' (f a0) (g b0)) (h a0 b0)\n  :=\n    total-equiv-family-of-equiv B\n      ( \\ b \u2192 C a0 b)\n      ( \\ b \u2192 C' (f a0) (g b))\n      ( \\ b c \u2192 h a0 b c)\n      ( total-equiv-family-of-equiv\n        ( A)\n        ( \\ a \u2192 (\u03a3 (b : B) , C a b))\n        ( \\ a \u2192 (\u03a3 (b : B) , C' (f a) (g b)))\n        ( \\ a (b , c) \u2192 (b , h a b c))\n        ( pullback-is-equiv-bases-are-equiv-total-is-equiv\n            is-equiv-total is-equiv-f is-equiv-g)\n        ( a0))\n      ( b0)\n\n#end fibered-map-over-product\n</code></pre>"},{"location":"hott/09-propositions.rzk/","title":"Propositions","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"hott/09-propositions.rzk/#propositions_1","title":"Propositions","text":"<p>A type is a proposition when its identity types are contractible.</p> <pre><code>#def is-prop\n  ( A : U)\n  : U\n  := (a : A) \u2192 (b : A) \u2192 is-contr (a = b)\n\n#def is-prop-Unit\n  : is-prop Unit\n  := \\ x y \u2192 (path-types-of-Unit-are-contractible x y)\n</code></pre>"},{"location":"hott/09-propositions.rzk/#alternative-characterizations-definitions","title":"Alternative characterizations: definitions","text":"<pre><code>#def all-elements-equal\n  ( A : U)\n  : U\n  := (a : A) \u2192 (b : A) \u2192 (a = b)\n\n#def is-contr-is-inhabited\n  ( A : U)\n  : U\n  := A \u2192 is-contr A\n\n#def is-emb-terminal-map\n  ( A : U)\n  : U\n  := is-emb A Unit (terminal-map A)\n</code></pre>"},{"location":"hott/09-propositions.rzk/#alternative-characterizations-proofs","title":"Alternative characterizations: proofs","text":"<pre><code>#def all-elements-equal-is-prop\n  ( A : U)\n  ( is-prop-A : is-prop A)\n  : all-elements-equal A\n  := \\ a b \u2192 (first (is-prop-A a b))\n\n#def is-contr-is-inhabited-all-elements-equal\n  ( A : U)\n  ( all-elements-equal-A : all-elements-equal A)\n  : is-contr-is-inhabited A\n  := \\ a \u2192 (a , all-elements-equal-A a)\n\n#def terminal-map-is-emb-is-inhabited-is-contr-is-inhabited\n  ( A : U)\n  ( c : is-contr-is-inhabited A)\n  : A \u2192 (is-emb-terminal-map A)\n  :=\n    \\ x \u2192\n      ( is-emb-is-equiv A Unit (terminal-map A)\n        ( contr-implies-terminal-map-is-equiv A (c x)))\n\n#def terminal-map-is-emb-is-contr-is-inhabited\n  ( A : U)\n  ( c : is-contr-is-inhabited A)\n  : ( is-emb-terminal-map A)\n  :=\n    ( is-emb-is-inhabited-emb A Unit (terminal-map A)\n      ( terminal-map-is-emb-is-inhabited-is-contr-is-inhabited A c))\n\n#def is-prop-is-emb-terminal-map\n  ( A : U)\n  ( f : is-emb-terminal-map A)\n  : is-prop A\n  :=\n    \\ x y \u2192\n      ( is-contr-equiv-is-contr' (x = y) (unit = unit)\n        ( ( ap A Unit x y (terminal-map A)) , (f x y))\n        ( path-types-of-Unit-are-contractible unit unit))\n\n#def is-prop-is-contr-is-inhabited\n  ( A : U)\n  ( c : is-contr-is-inhabited A)\n  : is-prop A\n  :=\n    ( is-prop-is-emb-terminal-map A\n      ( terminal-map-is-emb-is-contr-is-inhabited A c))\n</code></pre>"},{"location":"hott/10-trivial-fibrations.rzk/","title":"Trivial Fibrations","text":"<p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>In what follows we show that the projection from the total space of a Sigma type is an equivalence if and only if its fibers are contractible.</p> <pre><code>#def total-space-projection\n  ( A : U)\n  ( B : A \u2192 U)\n  : ( \u03a3 ( x : A) , B x) \u2192 A\n  := \\ z \u2192 first z\n</code></pre>"},{"location":"hott/10-trivial-fibrations.rzk/#contractible-fibers","title":"Contractible fibers","text":"<p>The following type asserts that the fibers of a type family are contractible.</p> <pre><code>#def contractible-fibers\n  ( A : U)\n  ( B : A \u2192 U)\n  : U\n  := ((x : A) \u2192 is-contr (B x))\n\n#section contractible-fibers-data\n\n#variable A : U\n#variable B : A \u2192 U\n#variable contractible-fibers-A-B : contractible-fibers A B\n</code></pre> The center of contraction in contractible fibers<pre><code>#def contractible-fibers-section\n  : ( x : A) \u2192 B x\n  := \\ x \u2192 center-contraction (B x) (contractible-fibers-A-B x)\n</code></pre> The section of the total space projection built from the contraction centers<pre><code>#def contractible-fibers-actual-section uses (contractible-fibers-A-B)\n  : ( a : A) \u2192 \u03a3 (x : A) , B x\n  := \\ a \u2192 (a , contractible-fibers-section a)\n\n#def contractible-fibers-section-htpy uses (contractible-fibers-A-B)\n  : homotopy A A\n    ( comp A (\u03a3 (x : A) , B x) A\n      ( total-space-projection A B) (contractible-fibers-actual-section))\n    ( identity A)\n  := \\ x \u2192 refl\n\n#def contractible-fibers-section-is-section uses (contractible-fibers-A-B)\n  : has-section (\u03a3 (x : A) , B x) A (total-space-projection A B)\n  := (contractible-fibers-actual-section , contractible-fibers-section-htpy)\n</code></pre> <p>This can be used to define the retraction homotopy for the total space projection, called <code>first</code> here:</p> <pre><code>#def contractible-fibers-retraction-htpy\n  : ( z : \u03a3 (x : A) , B x)\n    \u2192 ( contractible-fibers-actual-section) (first z) = z\n  :=\n    \\ z \u2192\n    eq-eq-fiber-\u03a3 A B\n      ( first z)\n      ( ( contractible-fibers-section) (first z))\n      ( second z)\n      ( homotopy-contraction (B (first z)) (contractible-fibers-A-B (first z)) (second z))\n\n#def contractible-fibers-retraction uses (contractible-fibers-A-B)\n  : has-retraction (\u03a3 (x : A) , B x) A (total-space-projection A B)\n  := (contractible-fibers-actual-section , contractible-fibers-retraction-htpy)\n</code></pre> <p>The first half of our main result:</p> <pre><code>#def is-equiv-projection-contractible-fibers uses (contractible-fibers-A-B)\n  : is-equiv (\u03a3 (x : A) , B x) A (total-space-projection A B)\n  := (contractible-fibers-retraction , contractible-fibers-section-is-section)\n\n#def equiv-projection-contractible-fibers uses (contractible-fibers-A-B)\n  : Equiv (\u03a3 (x : A) , B x) A\n  := (total-space-projection A B , is-equiv-projection-contractible-fibers)\n\n#end contractible-fibers-data\n</code></pre>"},{"location":"hott/10-trivial-fibrations.rzk/#projection-equivalences","title":"Projection equivalences","text":"<p>From a projection equivalence, it's not hard to inhabit fibers:</p> <pre><code>#def inhabited-fibers-is-equiv-projection\n  ( A : U)\n  ( B : A \u2192 U)\n  ( proj-B-to-A-is-equiv : is-equiv (\u03a3 (x : A) , B x) A (total-space-projection A B))\n  ( a : A)\n  : B a\n  :=\n    transport A B (first ((first (second proj-B-to-A-is-equiv)) a)) a\n      ( ( second (second proj-B-to-A-is-equiv)) a)\n      ( second ((first (second proj-B-to-A-is-equiv)) a))\n</code></pre> <p>This is great but we need more coherence to show that the inhabited fibers are contractible; the following proof fails:</p> <pre><code>#def is-equiv-projection-implies-contractible-fibers\n  ( A : U)\n  ( B : A \u2192 U)\n  ( proj-B-to-A-is-equiv : is-equiv (\u03a3 (x : A) , B x) A (total-space-projection A B))\n  : contractible-fibers A B\n  :=\n    ( \\ x \u2192 (second (first (first proj-B-to-A-is-equiv) x) ,\n      ( \\ u \u2192\n        second-path-\u03a3 A B (first (first proj-B-to-A-is-equiv) x) (x , u)\n          ( second (first proj-B-to-A-is-equiv) (x , u)))))\n</code></pre> <pre><code>#section projection-hae-data\n#variable A : U\n#variable B : A \u2192 U\n#variable proj-B-to-A-is-half-adjoint-equivalence :\n  is-half-adjoint-equiv (\u03a3 (x : A) , B x) A (total-space-projection A B)\n#variable w : (\u03a3 (x : A) , B x)\n</code></pre> <p>We start over from a stronger hypothesis of a half adjoint equivalence.</p> <pre><code>#def projection-hae-inverse\n  ( a : A)\n  : \u03a3 ( x : A) , B x\n  := (first (first proj-B-to-A-is-half-adjoint-equivalence)) a\n\n#def projection-hae-base-htpy uses (B)\n  ( a : A)\n  : ( first (projection-hae-inverse a)) = a\n  := (second (second (first proj-B-to-A-is-half-adjoint-equivalence))) a\n\n#def projection-hae-section uses (proj-B-to-A-is-half-adjoint-equivalence)\n  ( a : A)\n  : B a\n  :=\n    transport A B (first (projection-hae-inverse a)) a\n      ( projection-hae-base-htpy a)\n      ( second (projection-hae-inverse a))\n\n#def projection-hae-total-htpy\n  : ( projection-hae-inverse (first w)) = w\n  := (first (second (first proj-B-to-A-is-half-adjoint-equivalence))) w\n\n#def projection-hae-fibered-htpy\n  : ( transport A B (first ((projection-hae-inverse (first w)))) (first w)\n    ( first-path-\u03a3 A B\n      ( projection-hae-inverse (first w)) w\n      ( projection-hae-total-htpy))\n    ( second (projection-hae-inverse (first w))))\n  = ( second w)\n  :=\n    second-path-\u03a3 A B (projection-hae-inverse (first w)) w\n      ( projection-hae-total-htpy)\n\n#def projection-hae-base-coherence\n  : ( projection-hae-base-htpy (first w))\n  = ( first-path-\u03a3 A B (projection-hae-inverse (first w)) w\n      ( projection-hae-total-htpy))\n  := (second proj-B-to-A-is-half-adjoint-equivalence) w\n\n#def projection-hae-transport-coherence\n  : ( projection-hae-section (first w))\n  = ( transport A B (first ((projection-hae-inverse (first w)))) (first w)\n      ( first-path-\u03a3 A B\n        ( projection-hae-inverse (first w)) w\n        ( projection-hae-total-htpy))\n      ( second (projection-hae-inverse (first w))))\n  :=\n    transport2 A B (first (projection-hae-inverse (first w))) (first w)\n    ( projection-hae-base-htpy (first w))\n    ( first-path-\u03a3 A B (projection-hae-inverse (first w)) w\n      ( projection-hae-total-htpy))\n    ( projection-hae-base-coherence)\n    ( second (projection-hae-inverse (first w)))\n\n#def projection-hae-fibered-homotopy-contraction\n  : ( projection-hae-section (first w)) =_{B (first w)} (second w)\n  :=\n    concat (B (first w))\n      ( projection-hae-section (first w))\n      ( transport A B\n        ( first ((projection-hae-inverse (first w))))\n        ( first w)\n        ( first-path-\u03a3 A B (projection-hae-inverse (first w)) w\n          ( projection-hae-total-htpy))\n        ( second (projection-hae-inverse (first w))))\n      ( second w)\n      ( projection-hae-transport-coherence)\n      ( projection-hae-fibered-htpy)\n\n#end projection-hae-data\n</code></pre> <p>Finally, we have:</p> <pre><code>#def contractible-fibers-is-half-adjoint-equiv-projection\n  ( A : U)\n  ( B : A \u2192 U)\n  ( proj-B-to-A-is-half-adjoint-equivalence\n : is-half-adjoint-equiv (\u03a3 (x : A) , B x) A (total-space-projection A B))\n  : contractible-fibers A B\n  :=\n    \\ x \u2192\n      ( ( projection-hae-section A B proj-B-to-A-is-half-adjoint-equivalence x)\n      , \\ u \u2192\n          projection-hae-fibered-homotopy-contraction\n          A B proj-B-to-A-is-half-adjoint-equivalence (x , u))\n</code></pre> The converse to our first result<pre><code>#def contractible-fibers-is-equiv-projection\n  ( A : U)\n  ( B : A \u2192 U)\n  ( proj-B-to-A-is-equiv\n : is-equiv (\u03a3 (x : A) , B x) A (total-space-projection A B))\n  : contractible-fibers A B\n  :=\n    contractible-fibers-is-half-adjoint-equiv-projection A B\n      ( is-half-adjoint-equiv-is-equiv (\u03a3 (x : A) , B x) A\n        ( total-space-projection A B) proj-B-to-A-is-equiv)\n</code></pre> The main theorem<pre><code>#def projection-theorem\n  ( A : U)\n  ( B : A \u2192 U)\n  : iff\n    ( is-equiv (\u03a3 (x : A) , B x) A (total-space-projection A B))\n    ( contractible-fibers A B)\n  :=\n    ( \\ proj-B-to-A-is-equiv \u2192\n      contractible-fibers-is-equiv-projection A B proj-B-to-A-is-equiv\n    , \\ contractible-fibers-A-B \u2192\n      is-equiv-projection-contractible-fibers A B contractible-fibers-A-B)\n</code></pre>"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/","title":"Simplicial Type Theory","text":"<p>These formalisations correspond in part to Section 3 of the RS17 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#simplices-and-their-subshapes","title":"Simplices and their subshapes","text":""},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#simplices","title":"Simplices","text":"The 1-simplex<pre><code>#def \u0394\u00b9\n  : 2 \u2192 TOPE\n  := \\ t \u2192 TOP\n</code></pre> The 2-simplex<pre><code>#def \u0394\u00b2\n  : ( 2 \u00d7 2) \u2192 TOPE\n  := \\ (t , s) \u2192 s \u2264 t\n</code></pre> The 3-simplex<pre><code>#def \u0394\u00b3\n  : ( 2 \u00d7 2 \u00d7 2) \u2192 TOPE\n  := \\ ((t1 , t2) , t3) \u2192 t3 \u2264 t2 \u2227 t2 \u2264 t1\n</code></pre>"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#boundaries-of-simplices","title":"Boundaries of simplices","text":"The boundary of a 1-simplex<pre><code>#def \u2202\u0394\u00b9\n  : \u0394\u00b9 \u2192 TOPE\n  := \\ t \u2192 (t \u2261 0\u2082 \u2228 t \u2261 1\u2082)\n</code></pre> The boundary of a 2-simplex<pre><code>#def \u2202\u0394\u00b2\n  : \u0394\u00b2 \u2192 TOPE\n  :=\n    \\ (t , s) \u2192 (s \u2261 0\u2082 \u2228 t \u2261 1\u2082 \u2228 s \u2261 t)\n</code></pre>"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#the-inner-horn","title":"The inner horn","text":"<pre><code>#def \u039b\n  : ( 2 \u00d7 2) \u2192 TOPE\n  := \\ (t , s) \u2192 (s \u2261 0\u2082 \u2228 t \u2261 1\u2082)\n</code></pre>"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#products","title":"Products","text":"<p>The product of topes defines the product of shapes.</p> <pre><code>#def shape-prod\n  ( I J : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( \u03c7 : J \u2192 TOPE)\n  : ( I \u00d7 J) \u2192 TOPE\n  := \\ (t , s) \u2192 \u03c8 t \u2227 \u03c7 s\n</code></pre> The square as a product<pre><code>#def \u0394\u00b9\u00d7\u0394\u00b9\n  : ( 2 \u00d7 2) \u2192 TOPE\n  := shape-prod 2 2 \u0394\u00b9 \u0394\u00b9\n</code></pre> The total boundary of the square<pre><code>#def \u2202\u25a1\n  : ( 2 \u00d7 2) \u2192 TOPE\n  := \\ (t , s) \u2192 ((\u2202\u0394\u00b9 t) \u2227 (\u0394\u00b9 s)) \u2228 ((\u0394\u00b9 t) \u2227 (\u2202\u0394\u00b9 s))\n</code></pre> The vertical boundary of the square<pre><code>#def \u2202\u0394\u00b9\u00d7\u0394\u00b9\n  : ( 2 \u00d7 2) \u2192 TOPE\n  := shape-prod 2 2 \u2202\u0394\u00b9 \u0394\u00b9\n</code></pre> The horizontal boundary of the square<pre><code>#def \u0394\u00b9\u00d7\u2202\u0394\u00b9\n  : ( 2 \u00d7 2) \u2192 TOPE\n  := shape-prod 2 2 \u0394\u00b9 \u2202\u0394\u00b9\n</code></pre> The prism from a 2-simplex in an arrow type<pre><code>#def \u0394\u00b2\u00d7\u0394\u00b9\n  : ( 2 \u00d7 2 \u00d7 2) \u2192 TOPE\n  := shape-prod (2 \u00d7 2) 2 \u0394\u00b2 \u0394\u00b9\n</code></pre>"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#intersections","title":"Intersections","text":"<p>The intersection of shapes is defined by conjunction on topes.</p> <pre><code>#def shape-intersection\n  ( I : CUBE)\n  ( \u03c8 \u03c7 : I \u2192 TOPE)\n  : I \u2192 TOPE\n  := \\ t \u2192 \u03c8 t \u2227 \u03c7 t\n</code></pre>"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#unions","title":"Unions","text":"<p>The union of shapes is defined by disjunction on topes.</p> <pre><code>#def shapeUnion\n  ( I : CUBE)\n  ( \u03c8 \u03c7 : I \u2192 TOPE)\n  : I \u2192 TOPE\n  := \\ t \u2192 \u03c8 t \u2228 \u03c7 t\n</code></pre>"},{"location":"simplicial-hott/04-extension-types.rzk/","title":"Equivalences involving extension types","text":"<p>These formalisations correspond to Section 3 of the RS17 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/04-extension-types.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>hott/4-equivalences.rzk</code> \u2014 contains the definitions of <code>Equiv</code> and   <code>comp-equiv</code></li> <li>the file <code>hott/4-equivalences.rzk</code> relies in turn on the previous files in   <code>hott/</code></li> </ul>"},{"location":"simplicial-hott/04-extension-types.rzk/#commutation-of-arguments-and-currying","title":"Commutation of arguments and currying","text":"RS17, Theorem 4.1<pre><code>#def flip-ext-fun\n  ( I : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( \u03d5 : \u03c8 \u2192 TOPE)\n  ( X : U)\n  ( Y : \u03c8 \u2192 X \u2192 U)\n  ( f : (t : \u03d5) \u2192 (x : X) \u2192 Y t x)\n  : Equiv\n      ( ( t : \u03c8) \u2192 ((x : X) \u2192 Y t x) [\u03d5 t \u21a6 f t])\n      ( ( x : X) \u2192 (t : \u03c8) \u2192 Y t x [\u03d5 t \u21a6 f t x])\n  :=\n    ( \\ g x t \u2192 g t x\n    , ( ( \\ h t x \u2192 (h x) t\n        , \\ g \u2192 refl)\n      , ( \\ h t x \u2192 (h x) t\n        , \\ h \u2192 refl)))\n\n#def flip-ext-fun-inv\n  ( I : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( \u03d5 : \u03c8 \u2192 TOPE)\n  ( X : U)\n  ( Y : \u03c8 \u2192 X \u2192 U)\n  ( f : (t : \u03d5) \u2192 (x : X) \u2192 Y t x)\n  : Equiv\n    ( ( x : X) \u2192 (t : \u03c8) \u2192 Y t x [\u03d5 t \u21a6 f t x])\n    ( ( t : \u03c8) \u2192 ((x : X) \u2192 Y t x) [\u03d5 t \u21a6 f t])\n  :=\n    ( \\ h t x \u2192 (h x) t\n    , ( ( \\ g x t \u2192 g t x\n        , \\ h \u2192 refl)\n      , ( \\ g x t \u2192 g t x\n        , \\ g \u2192 refl)))\n</code></pre> RS17, Theorem 4.2<pre><code>#def curry-uncurry\n  ( I J : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( \u03d5 : \u03c8 \u2192 TOPE)\n  ( \u03b6 : J \u2192 TOPE)\n  ( \u03c7 : \u03b6 \u2192 TOPE)\n  ( X : \u03c8 \u2192 \u03b6 \u2192 U)\n  ( f : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 X t s)\n  : Equiv\n    ( ( t : \u03c8)\n    \u2192 ( ( s : \u03b6) \u2192 X t s [\u03c7 s \u21a6 f (t , s)]) [\u03d5 t \u21a6 \\ s \u2192 f (t , s)])\n    ( ( ( t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s)\n    \u2192 X t s [(\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 f (t , s)])\n  :=\n    ( \\ g (t , s) \u2192 (g t) s\n    , ( ( \\ h t s \u2192 h (t , s)\n        , \\ g \u2192 refl)\n      , ( \\ h t s \u2192 h (t , s)\n        , \\ h \u2192 refl)))\n\n#def uncurry-opcurry\n  ( I J : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( \u03d5 : \u03c8 \u2192 TOPE)\n  ( \u03b6 : J \u2192 TOPE)\n  ( \u03c7 : \u03b6 \u2192 TOPE)\n  ( X : \u03c8 \u2192 \u03b6 \u2192 U)\n  ( f : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 X t s)\n  : Equiv\n    ( ( ( t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s)\n    \u2192 X t s [(\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 f (t , s)])\n    ( ( s : \u03b6)\n    \u2192 ( ( t : \u03c8) \u2192 X t s [\u03d5 t \u21a6 f (t , s)]) [\u03c7 s \u21a6 \\ t \u2192 f (t , s)])\n  :=\n    ( \\ h s t \u2192 h (t , s)\n    , ( ( \\ g (t , s) \u2192 (g s) t\n        , \\ h \u2192 refl)\n      , ( \\ g (t , s) \u2192 (g s) t\n        , \\ g \u2192 refl)))\n\n#def fubini\n  ( I J : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( \u03d5 : \u03c8 \u2192 TOPE)\n  ( \u03b6 : J \u2192 TOPE)\n  ( \u03c7 : \u03b6 \u2192 TOPE)\n  ( X : \u03c8 \u2192 \u03b6 \u2192 U)\n  ( f : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 X t s)\n  : Equiv\n    ( ( t : \u03c8)\n    \u2192 ( ( s : \u03b6) \u2192 X t s [\u03c7 s \u21a6 f (t , s)]) [\u03d5 t \u21a6 \\ s \u2192 f (t , s)])\n    ( ( s : \u03b6)\n    \u2192 ( ( t : \u03c8) \u2192 X t s [\u03d5 t \u21a6 f (t , s)]) [\u03c7 s \u21a6 \\ t \u2192 f (t , s)])\n  :=\n    equiv-comp\n      ( ( t : \u03c8)\n      \u2192 ( ( s : \u03b6) \u2192 X t s [\u03c7 s \u21a6 f (t , s)]) [\u03d5 t \u21a6 \\ s \u2192 f (t , s)])\n      ( ( ( t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s)\n      \u2192 X t s [(\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 f (t , s)])\n      ( ( s : \u03b6)\n      \u2192 ( ( t : \u03c8) \u2192 X t s [\u03d5 t \u21a6 f (t , s)]) [\u03c7 s \u21a6 \\ t \u2192 f (t , s)])\n      ( curry-uncurry I J \u03c8 \u03d5 \u03b6 \u03c7 X f)\n      ( uncurry-opcurry I J \u03c8 \u03d5 \u03b6 \u03c7 X f)\n</code></pre>"},{"location":"simplicial-hott/04-extension-types.rzk/#extending-into-types-the-non-axiom-of-choice","title":"Extending into \u03a3-types (the non-axiom of choice)","text":"RS17, Theorem 4.3<pre><code>#def axiom-choice\n  ( I : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( \u03d5 : \u03c8 \u2192 TOPE)\n  ( X : \u03c8 \u2192 U)\n  ( Y : (t : \u03c8) \u2192 (x : X t) \u2192 U)\n  ( a : (t : \u03d5) \u2192 X t)\n  ( b : (t : \u03d5) \u2192 Y t (a t))\n  : Equiv\n    ( ( t : \u03c8) \u2192 (\u03a3 (x : X t) , Y t x) [\u03d5 t \u21a6 (a t , b t)])\n    ( \u03a3 ( f : ((t : \u03c8) \u2192 X t [\u03d5 t \u21a6 a t]))\n      , ( ( t : \u03c8) \u2192 Y t (f t) [\u03d5 t \u21a6 b t]))\n  :=\n      ( \\ g \u2192 (\\ t \u2192 (first (g t)) , \\ t \u2192 second (g t))\n      , ( ( \\ (f , h) t \u2192 (f t , h t)\n          , \\ _ \u2192 refl)\n        , ( \\ (f , h) t \u2192 (f t , h t)\n          , \\ _ \u2192 refl)))\n</code></pre> <pre><code>#def inv-axiom-choice\n  ( I : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( \u03d5 : \u03c8 \u2192 TOPE)\n  ( X : \u03c8 \u2192 U)\n  ( Y : (t : \u03c8) \u2192 (x : X t) \u2192 U)\n  ( a : (t : \u03d5) \u2192 X t)\n  ( b : (t : \u03d5) \u2192 Y t (a t))\n  : Equiv\n    ( \u03a3 ( f : ((t : \u03c8) \u2192 X t [\u03d5 t \u21a6 a t]))\n      , ( ( t : \u03c8) \u2192 Y t (f t) [\u03d5 t \u21a6 b t]))\n    ( ( t : \u03c8) \u2192 (\u03a3 (x : X t) , Y t x) [\u03d5 t \u21a6 (a t , b t)])\n  :=\n      ( \\ (f , h) \u2192 (\\ t \u2192 (f t , h t))\n      , ( ( \\ g \u2192 (\\ t \u2192 (first (g t)) , \\ t \u2192 second (g t))\n          , \\ _ \u2192 refl)\n        , ( \\ g \u2192 (\\ t \u2192 (first (g t)) , \\ t \u2192 second (g t))\n          , \\ _ \u2192 refl)\n        )\n      )\n</code></pre>"},{"location":"simplicial-hott/04-extension-types.rzk/#composites-and-unions-of-cofibrations","title":"Composites and unions of cofibrations","text":"<p>The original form.</p> RS17, Theorem 4.4<pre><code>#def cofibration-composition\n  ( I : CUBE)\n  ( \u03c7 : I \u2192 TOPE)\n  ( \u03c8 : \u03c7 \u2192 TOPE)\n  ( \u03d5 : \u03c8 \u2192 TOPE)\n  ( X : \u03c7 \u2192 U)\n  ( a : (t : \u03d5) \u2192 X t)\n  : Equiv\n    ( ( t : \u03c7) \u2192 X t [\u03d5 t \u21a6 a t])\n    ( \u03a3 ( f : (t : \u03c8) \u2192 X t [\u03d5 t \u21a6 a t])\n      , ( ( t : \u03c7) \u2192 X t [\u03c8 t \u21a6 f t]))\n  :=\n    ( \\ h \u2192 (\\ t \u2192 h t , \\ t \u2192 h t)\n    , ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl)\n      , ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl))))\n</code></pre> <p>A reformulated version via tope disjunction instead of inclusion (see https://github.com/rzk-lang/rzk/issues/8).</p> RS17, Theorem 4.4<pre><code>#def cofibration-composition'\n  ( I : CUBE)\n  ( \u03c7 \u03c8 \u03d5 : I \u2192 TOPE)\n  ( X : \u03c7 \u2192 U)\n  ( a : (t : I | \u03c7 t \u2227 \u03c8 t \u2227 \u03d5 t) \u2192 X t)\n  : Equiv\n      ( ( t : \u03c7) \u2192 X t [\u03c7 t \u2227 \u03c8 t \u2227 \u03d5 t \u21a6 a t])\n      ( \u03a3 ( f : (t : I | \u03c7 t \u2227 \u03c8 t) \u2192 X t [\u03c7 t \u2227 \u03c8 t \u2227 \u03d5 t \u21a6 a t])\n        , ( ( t : \u03c7) \u2192 X t [\u03c7 t \u2227 \u03c8 t \u21a6 f t]))\n  :=\n    ( \\ h \u2192 (\\ t \u2192 h t , \\ t \u2192 h t)\n    , ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl)\n      , ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl)))\n</code></pre> RS17, Theorem 4.5<pre><code>#def cofibration-union\n  ( I : CUBE)\n  ( \u03d5 \u03c8 : I \u2192 TOPE)\n  ( X : (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 U)\n  ( a : (t : \u03c8) \u2192 X t)\n  : Equiv\n      ( ( t : I | \u03d5 t \u2228 \u03c8 t) \u2192 X t [\u03c8 t \u21a6 a t])\n      ( ( t : \u03d5) \u2192 X t [\u03d5 t \u2227 \u03c8 t \u21a6 a t])\n  :=\n    ( \\ h t \u2192 h t\n    , ( ( \\ g t \u2192 recOR (\u03d5 t \u21a6 g t , \u03c8 t \u21a6 a t) , \\ _ \u2192 refl)\n      , ( \\ g t \u2192 recOR (\u03d5 t \u21a6 g t , \u03c8 t \u21a6 a t) , \\ _ \u2192 refl)))\n</code></pre>"},{"location":"simplicial-hott/04-extension-types.rzk/#relative-function-extensionality","title":"Relative function extensionality","text":"<p>There are various equivalent forms of the relative function extensionality axiom. Here we state the one that will be most useful and derive an application.</p> <pre><code>#def ext-htpy-eq\n  ( I : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( \u03d5 : \u03c8 \u2192 TOPE)\n  ( A : \u03c8 \u2192 U)\n  ( a : (t : \u03d5) \u2192 A t)\n  ( f g : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n  ( p : f = g)\n  : ( t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl]\n  :=\n    ind-path\n      ( ( t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n      ( f)\n      ( \\ g' p' \u2192 (t : \u03c8) \u2192 (f t = g' t) [\u03d5 t \u21a6 refl])\n      ( \\ t \u2192 refl)\n      ( g)\n      ( p)\n</code></pre> <p>The type that encodes the extension extensionality axiom. As suggested by footnote 8, we assert this as an \"extension extensionality\" axiom</p> RS17, Proposition 4.8(ii)<pre><code>#def ExtExt\n  : U\n  :=\n    ( I : CUBE)\n  \u2192 ( \u03c8 : I \u2192 TOPE)\n  \u2192 ( \u03d5 : \u03c8 \u2192 TOPE)\n  \u2192 ( A : \u03c8 \u2192 U)\n  \u2192 ( a : (t : \u03d5) \u2192 A t)\n  \u2192 ( f : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n  \u2192 ( g : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n  \u2192 is-equiv\n      ( f = g)\n      ( ( t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl])\n      ( ext-htpy-eq I \u03c8 \u03d5 A a f g)\n\n#assume extext : ExtExt\n</code></pre> The equivalence provided by extension extensionality<pre><code>#def equiv-ExtExt uses (extext)\n  ( I : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( \u03d5 : \u03c8 \u2192 TOPE)\n  ( A : \u03c8 \u2192 U)\n  ( a : (t : \u03d5) \u2192 A t)\n  ( f g : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n  : Equiv (f = g) ((t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl])\n  := (ext-htpy-eq I \u03c8 \u03d5 A a f g , extext I \u03c8 \u03d5 A a f g)\n</code></pre> <p>In particular, extension extensionality implies that homotopies give rise to identifications. This definition defines <code>eq-ext-htpy</code> to be the retraction to <code>ext-htpy-eq</code>.</p> <pre><code>#def eq-ext-htpy uses (extext)\n  ( I : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( \u03d5 : \u03c8 \u2192 TOPE)\n  ( A : \u03c8 \u2192 U)\n  ( a : (t : \u03d5) \u2192 A t)\n  ( f g : (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t])\n  : ( ( t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl]) \u2192 (f = g)\n  := first (first (extext I \u03c8 \u03d5 A a f g))\n</code></pre> <p>By extension extensionality, fiberwise equivalences of extension types define equivalences of extension types. For simplicity, we extend from <code>BOT</code>.</p> <pre><code>#def equiv-extension-equiv-family uses (extext)\n  ( I : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( A B : \u03c8 \u2192 U)\n  ( famequiv : (t : \u03c8) \u2192 (Equiv (A t) (B t)))\n  : Equiv ((t : \u03c8) \u2192 A t) ((t : \u03c8) \u2192 B t)\n  :=\n    ( ( \\ a t \u2192 (first (famequiv t)) (a t))\n    , ( ( ( \\ b t \u2192 (first (first (second (famequiv t)))) (b t))\n        , ( \\ a \u2192\n            eq-ext-htpy\n              ( I)\n              ( \u03c8)\n              ( \\ t \u2192 BOT)\n              ( A)\n              ( \\ u \u2192 recBOT)\n              ( \\ t \u2192\n                first (first (second (famequiv t))) (first (famequiv t) (a t)))\n              ( a)\n              ( \\ t \u2192 second (first (second (famequiv t))) (a t))))\n      , ( ( \\ b t \u2192 first (second (second (famequiv t))) (b t))\n        , ( \\ b \u2192\n            eq-ext-htpy\n              ( I)\n              ( \u03c8)\n              ( \\ t \u2192 BOT)\n              ( B)\n              ( \\ u \u2192 recBOT)\n              ( \\ t \u2192\n                first (famequiv t) (first (second (second (famequiv t))) (b t)))\n              ( b)\n              ( \\ t \u2192 second (second (second (famequiv t))) (b t))))))\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/","title":"Pre-\u221e-categories (Segal types)","text":"<p>These formalisations correspond to Section 5 of the RS17 paper.</p> <p>Segal types vs pre-\u221e-categories</p> <p>Riehl and Shulman refer to \"Segal types\" in RS17, but here we call them \"pre-\u221e-categories\".</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>hott/1-paths.md</code> - We require basic path algebra.</li> <li><code>hott/2-contractible.md</code> - We require the notion of contractible types and   their data.</li> <li><code>hott/total-space.md</code> \u2014 We rely on   <code>is-equiv-projection-contractible-fibers</code> and   <code>total-space-projection</code> in the proof of Theorem 5.5.</li> <li><code>3-simplicial-type-theory.md</code> \u2014 We rely on definitions of simplicies and their   subshapes.</li> <li><code>4-extension-types.md</code> \u2014 We use the fubini theorem and extension   extensionality.</li> </ul> <p>Some of the definitions in this file rely on function extensionality and extension extensionality:</p> <pre><code>#assume funext : FunExt\n#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#hom-types","title":"Hom types","text":"<p>Extension types are used to define the type of arrows between fixed terms:</p> <p> x y </p> RS17, Definition 5.1<pre><code>#def hom\n  ( A : U)\n  ( x y : A)\n  : U\n  :=\n    ( t : \u0394\u00b9)\n  \u2192 A [ t \u2261 0\u2082 \u21a6 x , -- the left endpoint is exactly x\n        t \u2261 1\u2082 \u21a6 y]   -- the right endpoint is exactly y\n</code></pre> <p>Extension types are also used to define the type of commutative triangles:</p> <p> x y z f g h </p> RS17, Definition 5.2<pre><code>#def hom2\n  ( A : U)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  ( h : hom A x z)\n  : U\n  :=\n    ( ( t\u2081 , t\u2082) : \u0394\u00b2)\n  \u2192 A [ t\u2082 \u2261 0\u2082 \u21a6 f t\u2081 , -- the top edge is exactly `f`,\n        t\u2081 \u2261 1\u2082 \u21a6 g t\u2082 , -- the right edge is exactly `g`, and\n        t\u2082 \u2261 t\u2081 \u21a6 h t\u2082]   -- the diagonal is exactly `h`\n</code></pre> <pre><code>#def long-edge-2-simplex\n  ( A : U)\n  ( \u03b1 : \u0394\u00b2 \u2192 A)\n  : \u0394\u00b9 \u2192 A\n  := \\ t \u2192 \u03b1 (t , t)\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#the-segal-condition","title":"The Segal condition","text":"<p>A type is a pre-\u221e-category if every composable pair of arrows has a unique composite. Note this is a considerable simplification of the usual Segal condition, which also requires homotopical uniqueness of higher-order composites.</p> RS17, Definition 5.3<pre><code>#def is-pre-\u221e-category\n  ( A : U)\n  : U\n  :=\n    ( x : A) \u2192 (y : A) \u2192 (z : A)\n  \u2192 ( f : hom A x y) \u2192 (g : hom A y z)\n  \u2192 is-contr (\u03a3 (h : hom A x z) , (hom2 A x y z f g h))\n</code></pre> <p>Pre-\u221e-categories have a composition functor and witnesses to the composition relation. Composition is written in diagrammatic order to match the order of arguments in <code>is-pre-\u221e-category</code>.</p> <pre><code>#def comp-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  : hom A x z\n  := first (first (is-pre-\u221e-category-A x y z f g))\n\n#def witness-comp-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  : hom2 A x y z f g (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g)\n  := second (first (is-pre-\u221e-category-A x y z f g))\n</code></pre> <p>Composition in a pre-\u221e-category is unique in the following sense. If there is a witness that an arrow \\(h\\) is a composite of \\(f\\) and \\(g\\), then the specified composite equals \\(h\\).</p> <p> x y z f g h \u03b1 = x y z f g comp-is-pre-\u221e-category witness-comp-is-pre-\u221e-category </p> <pre><code>#def uniqueness-comp-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  ( h : hom A x z)\n  ( alpha : hom2 A x y z f g h)\n  : ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g) = h\n  :=\n    first-path-\u03a3\n      ( hom A x z)\n      ( hom2 A x y z f g)\n      ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g\n      , witness-comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g)\n      ( h , alpha)\n      ( homotopy-contraction\n        ( \u03a3 ( k : hom A x z) , (hom2 A x y z f g k))\n        ( is-pre-\u221e-category-A x y z f g)\n        ( h , alpha))\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#characterizing-pre-categories","title":"Characterizing pre-\u221e-categories","text":"<p>Our aim is to prove that a type is a pre-\u221e-category if and only if the <code>horn-restriction</code> map, defined below, is an equivalence.</p> <p> x y z f g </p> <p>A pair of composable arrows form a horn.</p> <pre><code>#def horn\n  ( A : U)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  : \u039b \u2192 A\n  :=\n    \\ (t , s) \u2192\n    recOR\n      ( s \u2261 0\u2082 \u21a6 f t\n      , t \u2261 1\u2082 \u21a6 g s)\n</code></pre> <p>The underlying horn of a simplex:</p> <pre><code>#def horn-restriction\n  ( A : U)\n  : ( \u0394\u00b2 \u2192 A) \u2192 (\u039b \u2192 A)\n  := \\ f t \u2192 f t\n</code></pre> <p>This provides an alternate definition of pre-\u221e-categories.</p> <pre><code>#def is-local-horn-inclusion\n  ( A : U)\n  : U\n  := is-equiv (\u0394\u00b2 \u2192 A) (\u039b \u2192 A) (horn-restriction A)\n</code></pre> <p>Now we prove this definition is equivalent to the original one. Here, we prove the equivalence used in [RS17, Theorem 5.5]. However, we do this by constructing the equivalence directly, instead of using a composition of equivalences, as it is easier to write down and it computes better (we can use refl for the witnesses of the equivalence).</p> <pre><code>#def compositions-are-horn-fillings\n  ( A : U)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  : Equiv\n    ( \u03a3 ( h : hom A x z) , (hom2 A x y z f g h))\n    ( ( t : \u0394\u00b2) \u2192 A [\u039b t \u21a6 horn A x y z f g t])\n  :=\n    ( \\ hh t \u2192 (second hh) t\n    , ( ( \\ k \u2192 (\\ t \u2192 k (t , t) , \\ (t , s) \u2192 k (t , s))\n        , \\ hh \u2192 refl)\n      , ( \\ k \u2192 (\\ t \u2192 k (t , t) , \\ (t , s) \u2192 k (t , s))\n        , \\ hh \u2192 refl)))\n\n#def equiv-horn-restriction\n  ( A : U)\n  : Equiv\n    ( \u0394\u00b2 \u2192 A)\n    ( \u03a3 ( k : \u039b \u2192 A)\n      , ( \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082)))\n          , ( hom2 A\n              ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n              ( \\ t \u2192 k (t , 0\u2082)) (\\ t \u2192 k (1\u2082 , t))\n              ( h))))\n  :=\n    ( \\ k \u2192\n      ( ( \\ t \u2192 k t)\n      , ( \\ t \u2192 k (t , t) , \\ t \u2192 k t))\n    , ( ( \\ khh t \u2192 (second (second khh)) t , \\ k \u2192 refl)\n      , ( \\ khh t \u2192 (second (second khh)) t , \\ k \u2192 refl)))\n</code></pre> RS17, Theorem 5.5 (the hard direction)<pre><code>#def equiv-horn-restriction-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  : Equiv (\u0394\u00b2 \u2192 A) (\u039b \u2192 A)\n  :=\n    equiv-comp\n      ( \u0394\u00b2 \u2192 A)\n      ( \u03a3 ( k : \u039b \u2192 A)\n        , ( \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082)))\n            , ( hom2 A\n                ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n                ( \\ t \u2192 k (t , 0\u2082)) (\\ t \u2192 k (1\u2082 , t))\n                ( h))))\n      ( \u039b \u2192 A)\n      ( equiv-horn-restriction A)\n      ( total-space-projection\n        ( \u039b \u2192 A)\n        ( \\ k \u2192\n          \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082)))\n          , ( hom2 A\n              ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n              ( \\ t \u2192 k (t , 0\u2082)) (\\ t \u2192 k (1\u2082 , t))\n              ( h)))\n    , ( is-equiv-projection-contractible-fibers\n          ( \u039b \u2192 A)\n          ( \\ k \u2192\n            \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082)))\n            , ( hom2 A\n                ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n                ( \\ t \u2192 k (t , 0\u2082)) (\\ t \u2192 k (1\u2082 , t))\n                ( h)))\n          ( \\ k \u2192\n            is-pre-\u221e-category-A\n              ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n              ( \\ t \u2192 k (t , 0\u2082)) (\\ t \u2192 k (1\u2082 , t)))))\n</code></pre> <p>We verify that the mapping in <code>equiv-horn-restriction-is-pre-\u221e-category A is-pre-\u221e-category-A</code> is exactly <code>horn-restriction A</code>.</p> <pre><code>#def test-equiv-horn-restriction-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  : ( first (equiv-horn-restriction-is-pre-\u221e-category A is-pre-\u221e-category-A)) = (horn-restriction A)\n  := refl\n</code></pre> Pre-\u221e-categories are types that are local at the horn inclusion<pre><code>#def is-local-horn-inclusion-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  : is-local-horn-inclusion A\n  := second (equiv-horn-restriction-is-pre-\u221e-category A is-pre-\u221e-category-A)\n</code></pre> Types that are local at the horn inclusion are pre-\u221e-categories<pre><code>#def is-pre-\u221e-category-is-local-horn-inclusion\n  ( A : U)\n  ( is-local-horn-inclusion-A : is-local-horn-inclusion A)\n  : is-pre-\u221e-category A\n  :=\n    \\ x y z f g \u2192\n    contractible-fibers-is-equiv-projection\n      ( \u039b \u2192 A)\n      ( \\ k \u2192\n        \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082)))\n        , ( hom2 A\n            ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n            ( \\ t \u2192 k (t , 0\u2082))\n            ( \\ t \u2192 k (1\u2082 , t))\n            ( h)))\n      ( second\n        ( equiv-comp\n          ( \u03a3 ( k : \u039b \u2192 A)\n          , \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082)))\n            , ( hom2 A\n                ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n                ( \\ t \u2192 k (t , 0\u2082))\n                ( \\ t \u2192 k (1\u2082 , t))\n                ( h)))\n          ( \u0394\u00b2 \u2192 A)\n          ( \u039b \u2192 A)\n          ( inv-equiv\n            ( \u0394\u00b2 \u2192 A)\n            ( \u03a3 ( k : \u039b \u2192 A)\n            , \u03a3 ( h : hom A (k (0\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082)))\n              , ( hom2 A\n                  ( k (0\u2082 , 0\u2082)) (k (1\u2082 , 0\u2082)) (k (1\u2082 , 1\u2082))\n                  ( \\ t \u2192 k (t , 0\u2082))\n                  ( \\ t \u2192 k (1\u2082 , t))\n                  ( h)))\n            ( equiv-horn-restriction A))\n          ( horn-restriction A , is-local-horn-inclusion-A)))\n    ( horn A x y z f g)\n</code></pre> <p>We have now proven that both notions of pre-\u221e-categories are logically equivalent.</p> RS17, Theorem 5.5<pre><code>#def is-pre-\u221e-category-iff-is-local-horn-inclusion\n  ( A : U)\n  : iff (is-pre-\u221e-category A) (is-local-horn-inclusion A)\n  := (is-local-horn-inclusion-is-pre-\u221e-category A , is-pre-\u221e-category-is-local-horn-inclusion A)\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#function-and-extension-types-into-pre-categories","title":"Function and extension types into pre-\u221e-categories","text":"<p>Using the new characterization of pre-\u221e-categories, we can show that the type of functions or extensions into a family of pre-\u221e-categories is again a pre-\u221e-category. For instance if \\(X\\) is a type and \\(A : X \u2192 U\\) is such that \\(A x\\) is a pre-\u221e-category for all \\(x\\) then \\((x : X) \u2192 A x\\) is a pre-\u221e-category.</p> RS17, Corollary 5.6(i)<pre><code>#def is-pre-\u221e-category-function-type uses (funext)\n  ( X : U)\n  ( A : X \u2192 U)\n  ( fiberwise-is-pre-\u221e-category-A : (x : X) \u2192 is-local-horn-inclusion (A x))\n  : is-local-horn-inclusion ((x : X) \u2192 A x)\n  :=\n    is-equiv-triple-comp\n      ( \u0394\u00b2 \u2192 ((x : X) \u2192 A x))\n      ( ( x : X) \u2192 \u0394\u00b2 \u2192 A x)\n      ( ( x : X) \u2192 \u039b \u2192 A x)\n      ( \u039b \u2192 ((x : X) \u2192 A x))\n      ( \\ g x t \u2192 g t x) -- first equivalence\n      ( second (flip-ext-fun\n        ( 2 \u00d7 2)\n        ( \u0394\u00b2)\n        ( \\ t \u2192 BOT)\n        ( X)\n        ( \\ t \u2192 A)\n        ( \\ t \u2192 recBOT)))\n      ( \\ h x t \u2192 h x t) -- second equivalence\n      ( second (equiv-function-equiv-family\n        ( funext)\n        ( X)\n        ( \\ x \u2192 (\u0394\u00b2 \u2192 A x))\n        ( \\ x \u2192 (\u039b \u2192 A x))\n        ( \\ x \u2192 (horn-restriction (A x) , fiberwise-is-pre-\u221e-category-A x))))\n      ( \\ h t x \u2192 (h x) t) -- third equivalence\n      ( second (flip-ext-fun-inv\n        ( 2 \u00d7 2)\n        ( \u039b)\n        ( \\ t \u2192 BOT)\n        ( X)\n        ( \\ t \u2192 A)\n        ( \\ t \u2192 recBOT)))\n</code></pre> <p>If \\(X\\) is a shape and \\(A : X \u2192 U\\) is such that \\(A x\\) is a pre-\u221e-category for all \\(x\\) then \\((x : X) \u2192 A x\\) is a pre-\u221e-category.</p> RS17, Corollary 5.6(ii)<pre><code>#def is-pre-\u221e-category-extension-type' uses (extext)\n  ( I : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( A : \u03c8 \u2192 U)\n  ( fiberwise-is-pre-\u221e-category-A : (s : \u03c8) \u2192 is-local-horn-inclusion (A s))\n  : is-local-horn-inclusion ((s : \u03c8) \u2192 A s)\n  :=\n    is-equiv-triple-comp\n      ( \u0394\u00b2 \u2192 (s : \u03c8) \u2192 A s)\n      ( ( s : \u03c8) \u2192 \u0394\u00b2 \u2192 A s)\n      ( ( s : \u03c8) \u2192 \u039b \u2192 A s)\n      ( \u039b \u2192 (s : \u03c8) \u2192 A s)\n      ( \\ g s t \u2192 g t s)  -- first equivalence\n      ( second\n        ( fubini\n          ( 2 \u00d7 2)\n          ( I)\n          ( \u0394\u00b2)\n          ( \\ t \u2192 BOT)\n          ( \u03c8)\n          ( \\ s \u2192 BOT)\n          ( \\ t s \u2192 A s)\n          ( \\ u \u2192 recBOT)))\n      ( \\ h s t \u2192 h s t) -- second equivalence\n      ( second (equiv-extension-equiv-family extext I \u03c8\n        ( \\ s \u2192 \u0394\u00b2 \u2192 A s)\n        ( \\ s \u2192 \u039b \u2192 A s)\n        ( \\ s \u2192 (horn-restriction (A s) , fiberwise-is-pre-\u221e-category-A s))))\n      ( \\ h t s \u2192 (h s) t) -- third equivalence\n      ( second\n        ( fubini\n          ( I)\n          ( 2 \u00d7 2)\n          ( \u03c8)\n          ( \\ s \u2192 BOT)\n          ( \u039b)\n          ( \\ t \u2192 BOT)\n          ( \\ s t \u2192 A s)\n          ( \\ u \u2192 recBOT)))\n\n#def is-pre-\u221e-category-extension-type uses (extext)\n  ( I : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( A : \u03c8 \u2192 U)\n  ( fiberwise-is-pre-\u221e-category-A : (s : \u03c8) \u2192 is-pre-\u221e-category (A s))\n  : is-pre-\u221e-category ((s : \u03c8) \u2192 A s)\n  :=\n    is-pre-\u221e-category-is-local-horn-inclusion\n      ( ( s : \u03c8) \u2192 A s)\n      ( is-pre-\u221e-category-extension-type'\n        ( I) (\u03c8) (A)\n        ( \\ s \u2192 is-local-horn-inclusion-is-pre-\u221e-category (A s) (fiberwise-is-pre-\u221e-category-A s)))\n</code></pre> <p>In particular, the arrow type of a pre-\u221e-category is a pre-\u221e-category. First, we define the arrow type:</p> <pre><code>#def arr\n  ( A : U)\n  : U\n  := \u0394\u00b9 \u2192 A\n</code></pre> <p>For later use, an equivalent characterization of the arrow type.</p> <pre><code>#def arr-\u03a3-hom\n  ( A : U)\n  : ( arr A) \u2192 (\u03a3 (x : A) , (\u03a3 (y : A) , hom A x y))\n  := \\ f \u2192 (f 0\u2082 , (f 1\u2082 , f))\n\n#def is-equiv-arr-\u03a3-hom\n  ( A : U)\n  : is-equiv (arr A) (\u03a3 (x : A) , (\u03a3 (y : A) , hom A x y)) (arr-\u03a3-hom A)\n  :=\n    ( ( \\ (x , (y , f)) \u2192 f , \\ f \u2192 refl)\n    , ( \\ (x , (y , f)) \u2192 f , \\ xyf \u2192 refl))\n\n#def equiv-arr-\u03a3-hom\n  ( A : U)\n  : Equiv (arr A) (\u03a3 (x : A) , (\u03a3 (y : A) , hom A x y))\n  := (arr-\u03a3-hom A , is-equiv-arr-\u03a3-hom A)\n</code></pre> RS17, Corollary 5.6(ii), special case for locality at the horn inclusion<pre><code>#def is-local-horn-inclusion-arr uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-local-horn-inclusion A)\n  : is-local-horn-inclusion (arr A)\n  :=\n    is-pre-\u221e-category-extension-type'\n      ( 2)\n      ( \u0394\u00b9)\n      ( \\ _ \u2192 A)\n      ( \\ _ \u2192 is-pre-\u221e-category-A)\n</code></pre> RS17, Corollary 5.6(ii), special case for the Segal condition<pre><code>#def is-pre-\u221e-category-arr uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  : is-pre-\u221e-category (arr A)\n  :=\n    is-pre-\u221e-category-extension-type\n      ( 2)\n      ( \u0394\u00b9)\n      ( \\ _ \u2192 A)\n      ( \\ _ \u2192 is-pre-\u221e-category-A)\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#identity","title":"Identity","text":"<p>All types have identity arrows and witnesses to the identity composition law.</p> <p> x x x </p> RS17, Definition 5.7<pre><code>#def id-hom\n  ( A : U)\n  ( x : A)\n  : hom A x x\n  := \\ t \u2192 x\n</code></pre> <p>Witness for the right identity law:</p> <p> x y y f y f f </p> RS17, Proposition 5.8a<pre><code>#def comp-id-witness\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  : hom2 A x y y f (id-hom A y) f\n  := \\ (t , s) \u2192 f t\n</code></pre> <p>Witness for the left identity law:</p> <p> x x y x f f f </p> RS17, Proposition 5.8b<pre><code>#def id-comp-witness\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  : hom2 A x x y (id-hom A x) f f\n  := \\ (t , s) \u2192 f s\n</code></pre> <p>In a pre-\u221e-category, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. Thus, an identity axiom was not needed in the definition of pre-\u221e-categorys.</p> If A is a pre-\u221e-category then the right unit law holds<pre><code>#def comp-id-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y y f (id-hom A y)) = f\n  :=\n    uniqueness-comp-is-pre-\u221e-category\n      ( A)\n      ( is-pre-\u221e-category-A)\n      ( x) (y) (y)\n      ( f)\n      ( id-hom A y)\n      ( f)\n      ( comp-id-witness A x y f)\n</code></pre> If A is a pre-\u221e-category then the left unit law holds<pre><code>#def id-comp-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x x y (id-hom A x) f) =_{hom A x y} f\n  :=\n    uniqueness-comp-is-pre-\u221e-category\n      ( A)\n      ( is-pre-\u221e-category-A)\n      ( x) (x) (y)\n      ( id-hom A x)\n      ( f)\n      ( f)\n      ( id-comp-witness A x y f)\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#associativity","title":"Associativity","text":"<p>We now prove that composition in a pre-\u221e-category is associative, by using the fact that the type of arrows in a pre-\u221e-category is itself a pre-\u221e-category.</p> <p> \u2022 \u2022 \u2022 \u2022 </p> <pre><code>#def unfolding-square\n  ( A : U)\n  ( triangle : \u0394\u00b2 \u2192 A)\n  : \u0394\u00b9\u00d7\u0394\u00b9 \u2192 A\n  :=\n    \\ (t , s) \u2192\n    recOR\n      ( t \u2264 s \u21a6 triangle (s , t)\n      , s \u2264 t \u21a6 triangle (t , s))\n</code></pre> <p>For use in the proof of associativity:</p> <p> x y z y f g comp-is-pre-\u221e-category g f </p> <pre><code>#def witness-square-comp-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  : \u0394\u00b9\u00d7\u0394\u00b9 \u2192 A\n  := unfolding-square A (witness-comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g)\n</code></pre> <p>The <code>witness-square-comp-is-pre-\u221e-category</code> as an arrow in the arrow type:</p> <p> x y z y f g </p> <pre><code>#def arr-in-arr-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  : hom (arr A) f g\n  := \\ t s \u2192 witness-square-comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g (t , s)\n</code></pre> <p> w x x y y z f g h </p> <pre><code>#def witness-asociative-is-pre-\u221e-category uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( w x y z : A)\n  ( f : hom A w x)\n  ( g : hom A x y)\n  ( h : hom A y z)\n  : hom2 (arr A) f g h\n      ( arr-in-arr-is-pre-\u221e-category A is-pre-\u221e-category-A w x y f g)\n      ( arr-in-arr-is-pre-\u221e-category A is-pre-\u221e-category-A x y z g h)\n      ( comp-is-pre-\u221e-category (arr A) (is-pre-\u221e-category-arr A is-pre-\u221e-category-A)\n      f g h\n      ( arr-in-arr-is-pre-\u221e-category A is-pre-\u221e-category-A w x y f g)\n      ( arr-in-arr-is-pre-\u221e-category A is-pre-\u221e-category-A x y z g h))\n  :=\n    witness-comp-is-pre-\u221e-category\n      ( arr A)\n      ( is-pre-\u221e-category-arr A is-pre-\u221e-category-A)\n      f g h\n      ( arr-in-arr-is-pre-\u221e-category A is-pre-\u221e-category-A w x y f g)\n      ( arr-in-arr-is-pre-\u221e-category A is-pre-\u221e-category-A x y z g h)\n</code></pre> <p> w x y z g f h </p> <p>The <code>witness-associative-is-pre-\u221e-category</code> curries to define a diagram \\(\u0394\u00b2\u00d7\u0394\u00b9 \u2192 A\\). The <code>tetrahedron-associative-is-pre-\u221e-category</code> is extracted via the middle-simplex map \\(((t , s) , r) \u21a6 ((t , r) , s)\\) from \\(\u0394\u00b3\\) to \\(\u0394\u00b2\u00d7\u0394\u00b9\\).</p> <pre><code>#def tetrahedron-associative-is-pre-\u221e-category uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( w x y z : A)\n  ( f : hom A w x)\n  ( g : hom A x y)\n  ( h : hom A y z)\n  : \u0394\u00b3 \u2192 A\n  :=\n    \\ ((t , s) , r) \u2192\n    ( witness-asociative-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h) (t , r) s\n</code></pre> <p> w x y z g f h </p> <p>The diagonal composite of three arrows extracted from the <code>tetrahedron-associative-is-pre-\u221e-category</code>.</p> <pre><code>#def triple-comp-is-pre-\u221e-category uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( w x y z : A)\n  ( f : hom A w x)\n  ( g : hom A x y)\n  ( h : hom A y z)\n  : hom A w z\n  :=\n    \\ t \u2192\n    tetrahedron-associative-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h\n      ( ( t , t) , t)\n</code></pre> <p> w x y z g f h </p> <pre><code>#def left-witness-asociative-is-pre-\u221e-category uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( w x y z : A)\n  ( f : hom A w x)\n  ( g : hom A x y)\n  ( h : hom A y z)\n  : hom2 A w y z\n    ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y f g)\n    h\n    ( triple-comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h)\n  :=\n    \\ (t , s) \u2192\n    tetrahedron-associative-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h\n      ( ( t , t) , s)\n</code></pre> <p>The front face:</p> <p> w x y z g f h </p> <pre><code>#def right-witness-asociative-is-pre-\u221e-category uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( w x y z : A)\n  ( f : hom A w x)\n  ( g : hom A x y)\n  ( h : hom A y z)\n  : hom2 A w x z\n    ( f)\n    ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z g h)\n    ( triple-comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h)\n  :=\n    \\ (t , s) \u2192\n    tetrahedron-associative-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h\n      ( ( t , s) , s)\n</code></pre> <pre><code>#def left-associative-is-pre-\u221e-category uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( w x y z : A)\n  ( f : hom A w x)\n  ( g : hom A x y)\n  ( h : hom A y z)\n  : ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A w y z (comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y f g) h)\n  = ( triple-comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h)\n  :=\n    uniqueness-comp-is-pre-\u221e-category\n      A is-pre-\u221e-category-A w y z (comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y f g) h\n      ( triple-comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h)\n      ( left-witness-asociative-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h)\n\n#def right-associative-is-pre-\u221e-category uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( w x y z : A)\n  ( f : hom A w x)\n  ( g : hom A x y)\n  ( h : hom A y z)\n  : ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x z f (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z g h))\n  = ( triple-comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h)\n  :=\n    uniqueness-comp-is-pre-\u221e-category\n      ( A) (is-pre-\u221e-category-A) (w) (x) (z) (f) (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z g h)\n      ( triple-comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h)\n      ( right-witness-asociative-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h)\n</code></pre> <p>We conclude that composition in pre-\u221e-categories is associative.</p> RS17, Proposition 5.9<pre><code>#def associative-is-pre-\u221e-category uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( w x y z : A)\n  ( f : hom A w x)\n  ( g : hom A x y)\n  ( h : hom A y z)\n  : ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A w y z (comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y f g) h)\n  = ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x z f (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z g h))\n  :=\n    zig-zag-concat\n    ( hom A w z)\n    ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A w y z (comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y f g) h)\n    ( triple-comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h)\n    ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x z f (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z g h))\n    ( left-associative-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h)\n    ( right-associative-is-pre-\u221e-category A is-pre-\u221e-category-A w x y z f g h)\n\n\n#def postcomp-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : ( z : A) \u2192 (hom A z x) \u2192 (hom A z y)\n  := \\ z g \u2192 comp-is-pre-\u221e-category A is-pre-\u221e-category-A z x y g f\n\n#def precomp-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : ( z : A) \u2192 (hom A y z) \u2192 (hom A x z)\n  := \\ z \u2192 comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f\n</code></pre>"},{"location":"simplicial-hott/05-segal-types.rzk/#homotopies","title":"Homotopies","text":"<p>We may define a \"homotopy\" to be a path between parallel arrows. In a pre-\u221e-category, homotopies are equivalent to terms in <code>hom2</code> types involving an identity arrow.</p> <pre><code>#def map-hom2-homotopy\n  ( A : U)\n  ( x y : A)\n  ( f g : hom A x y)\n  : ( f = g) \u2192 (hom2 A x x y (id-hom A x) f g)\n  :=\n    ind-path\n      ( hom A x y)\n      ( f)\n      ( \\ g' p' \u2192 (hom2 A x x y (id-hom A x) f g'))\n      ( id-comp-witness A x y f)\n      ( g)\n\n#def map-total-hom2-homotopy\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  : ( \u03a3 ( g : hom A x y) , (f = g))\n  \u2192 ( \u03a3 ( g : hom A x y) , (hom2 A x x y (id-hom A x) f g))\n  := \\ (g , p) \u2192 (g , map-hom2-homotopy A x y f g p)\n\n#def is-equiv-map-total-hom2-homotopy-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : is-equiv\n      ( \u03a3 ( g : hom A x y) , f = g)\n      ( \u03a3 ( g : hom A x y) , (hom2 A x x y (id-hom A x) f g))\n      ( map-total-hom2-homotopy A x y f)\n  :=\n    is-equiv-are-contr\n      ( \u03a3 ( g : hom A x y) , (f = g))\n      ( \u03a3 ( g : hom A x y) , (hom2 A x x y (id-hom A x) f g))\n      ( is-contr-based-paths (hom A x y) f)\n      ( is-pre-\u221e-category-A x x y (id-hom A x) f)\n      ( map-total-hom2-homotopy A x y f)\n</code></pre> RS17, Proposition 5.10<pre><code>#def equiv-homotopy-hom2-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f h : hom A x y)\n  : Equiv (f = h) (hom2 A x x y (id-hom A x) f h)\n  :=\n    ( ( map-hom2-homotopy A x y f h)\n    , ( total-equiv-family-of-equiv\n        ( hom A x y)\n        ( \\ k \u2192 (f = k))\n        ( \\ k \u2192 (hom2 A x x y (id-hom A x) f k))\n        ( map-hom2-homotopy A x y f)\n        ( is-equiv-map-total-hom2-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A x y f)\n        ( h)))\n</code></pre> <p>A dual notion of homotopy can be defined similarly.</p> <pre><code>#def map-hom2-homotopy'\n  ( A : U)\n  ( x y : A)\n  ( f g : hom A x y)\n  ( p : f = g)\n  : ( hom2 A x y y f (id-hom A y) g)\n  :=\n    ind-path\n      ( hom A x y)\n      ( f)\n      ( \\ g' p' \u2192 (hom2 A x y y f (id-hom A y) g'))\n      ( comp-id-witness A x y f)\n      ( g)\n      ( p)\n\n#def map-total-hom2-homotopy'\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  : ( \u03a3 ( g : hom A x y) , (f = g))\n  \u2192 ( \u03a3 ( g : hom A x y) , (hom2 A x y y f (id-hom A y) g))\n  := \\ (g , p) \u2192 (g , map-hom2-homotopy' A x y f g p)\n\n#def is-equiv-map-total-hom2-homotopy'-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : is-equiv\n      ( \u03a3 ( g : hom A x y) , f = g)\n      ( \u03a3 ( g : hom A x y) , (hom2 A x y y f (id-hom A y) g))\n      ( map-total-hom2-homotopy' A x y f)\n  :=\n    is-equiv-are-contr\n      ( \u03a3 ( g : hom A x y) , (f = g))\n      ( \u03a3 ( g : hom A x y) , (hom2 A x y y f (id-hom A y) g))\n      ( is-contr-based-paths (hom A x y) f)\n      ( is-pre-\u221e-category-A x y y f (id-hom A y))\n      ( map-total-hom2-homotopy' A x y f)\n</code></pre> RS17, Proposition 5.10<pre><code>#def equiv-homotopy-hom2'-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f h : hom A x y)\n  : Equiv (f = h) (hom2 A x y y f (id-hom A y) h)\n  :=\n    ( ( map-hom2-homotopy' A x y f h)\n    , ( total-equiv-family-of-equiv\n        ( hom A x y)\n        ( \\ k \u2192 (f = k))\n        ( \\ k \u2192 (hom2 A x y y f (id-hom A y) k))\n        ( map-hom2-homotopy' A x y f)\n        ( is-equiv-map-total-hom2-homotopy'-is-pre-\u221e-category A is-pre-\u221e-category-A x y f)\n        ( h)))\n</code></pre> <p>More generally, a homotopy between a composite and another map is equivalent to the data provided by a commutative triangle with that boundary.</p> <pre><code>#def map-hom2-eq-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  ( h : hom A x z)\n  ( p : (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g) = h)\n  : ( hom2 A x y z f g h)\n  :=\n    ind-path\n      ( hom A x z)\n      ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g)\n      ( \\ h' p' \u2192 hom2 A x y z f g h')\n      ( witness-comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g)\n      ( h)\n      ( p)\n\n#def map-total-hom2-eq-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  : ( \u03a3 ( h : hom A x z) , (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g) = h)\n  \u2192 ( \u03a3 ( h : hom A x z) , (hom2 A x y z f g h))\n  := \\ (h , p) \u2192 (h , map-hom2-eq-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g h p)\n\n#def is-equiv-map-total-hom2-eq-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  : is-equiv\n      ( \u03a3 ( h : hom A x z) , (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g) = h)\n      ( \u03a3 ( h : hom A x z) , (hom2 A x y z f g h))\n      ( map-total-hom2-eq-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g)\n  :=\n    is-equiv-are-contr\n      ( \u03a3 ( h : hom A x z) , (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g) = h)\n      ( \u03a3 ( h : hom A x z) , (hom2 A x y z f g h))\n      ( is-contr-based-paths (hom A x z) (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g))\n      ( is-pre-\u221e-category-A x y z f g)\n      ( map-total-hom2-eq-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g)\n</code></pre> RS17, Proposition 5.12<pre><code>#def equiv-hom2-eq-comp-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  ( k : hom A x z)\n  : Equiv ((comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g) = k) (hom2 A x y z f g k)\n  :=\n    ( ( map-hom2-eq-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g k)\n    , ( total-equiv-family-of-equiv\n        ( hom A x z)\n        ( \\ m \u2192 (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g) = m)\n        ( hom2 A x y z f g)\n        ( map-hom2-eq-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g)\n        ( is-equiv-map-total-hom2-eq-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g)\n        ( k)))\n</code></pre> <p>Homotopies form a congruence, meaning that homotopies are respected by composition:</p> RS17, Proposition 5.13<pre><code>#def congruence-homotopy-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y z : A)\n  ( f g : hom A x y)\n  ( h k : hom A y z)\n  ( p : f = g)\n  ( q : h = k)\n  : ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f h)\n  = ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z g k)\n  :=\n    ind-path\n      ( hom A y z)\n      ( h)\n      ( \\ k' q' \u2192\n        ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f h)\n      = ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z g k'))\n      ( ind-path\n        ( hom A x y)\n        ( f)\n        ( \\ g' p' \u2192\n          ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f h)\n        = ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z g' h))\n        ( refl)\n        ( g)\n        ( p))\n      ( k)\n      ( q)\n</code></pre> <p>As a special case of the above:</p> <pre><code>#def postwhisker-homotopy-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y z : A)\n  ( f g : hom A x y)\n  ( h : hom A y z)\n  ( p : f = g)\n  : ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f h) = (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z g h)\n  := congruence-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g h h p refl\n</code></pre> <p>As a special case of the above:</p> <pre><code>#def prewhisker-homotopy-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( w x y : A)\n  ( k : hom A w x)\n  ( f g : hom A x y)\n  ( p : f = g)\n  : ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y k f)\n  = ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y k g)\n  := congruence-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A w x y k k f g refl p\n</code></pre> RS17, Proposition 5.14(a)<pre><code>#def compute-postwhisker-homotopy-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y z : A)\n  ( f g : hom A x y)\n  ( h : hom A y z)\n  ( p : f = g)\n  : ( postwhisker-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g h p)\n  = ( ap (hom A x y) (hom A x z) f g (\\ k \u2192 comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z k h) p)\n  :=\n    ind-path\n      ( hom A x y)\n      ( f)\n      ( \\ g' p' \u2192\n        ( postwhisker-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g' h p')\n      = ( ap\n          ( hom A x y) (hom A x z)\n          ( f) (g') (\\ k \u2192 comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z k h) (p')))\n      ( refl)\n      ( g)\n      ( p)\n</code></pre> RS17, Proposition 5.14(b)<pre><code>#def prewhisker-homotopy-is-ap-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( w x y : A)\n  ( k : hom A w x)\n  ( f g : hom A x y)\n  ( p : f = g)\n  : ( prewhisker-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A w x y k f g p)\n  = ( ap (hom A x y) (hom A w y) f g (comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y k) p)\n  :=\n    ind-path\n      ( hom A x y)\n      ( f)\n      ( \\ g' p' \u2192\n        ( prewhisker-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A w x y k f g' p')\n      = ( ap (hom A x y) (hom A w y) f g' (comp-is-pre-\u221e-category A is-pre-\u221e-category-A w x y k) p'))\n      ( refl)\n      ( g)\n      ( p)\n\n#section is-pre-\u221e-category-Unit\n\n#def is-contr-Unit\n  : is-contr Unit\n  := (unit , \\ _ \u2192 refl)\n\n#def is-contr-\u0394\u00b2\u2192Unit uses (extext)\n  : is-contr (\u0394\u00b2 \u2192 Unit)\n  :=\n    ( \\ _ \u2192 unit\n    , \\ k \u2192\n      eq-ext-htpy extext\n        ( 2 \u00d7 2) \u0394\u00b2 (\\ _ \u2192 BOT)\n        ( \\ _ \u2192 Unit) (\\ _ \u2192 recBOT)\n        ( \\ _ \u2192 unit) k\n        ( \\ _ \u2192 refl))\n\n#def is-pre-\u221e-category-Unit uses (extext)\n  : is-pre-\u221e-category Unit\n  :=\n    \\ x y z f g \u2192\n    is-contr-is-retract-of-is-contr\n      ( \u03a3 ( h : hom Unit x z) , (hom2 Unit x y z f g h))\n      ( \u0394\u00b2 \u2192 Unit)\n      ( ( \\ (_ , k) \u2192 k)\n      , ( \\ k \u2192 ((\\ t \u2192 k (t , t)) , k) , \\ _ \u2192 refl))\n      ( is-contr-\u0394\u00b2\u2192Unit)\n\n#end is-pre-\u221e-category-Unit\n</code></pre> <p> <p></p>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/","title":"The 2-category of pre-\u221e-categories","text":"<p>These formalisations correspond to Section 6 of the RS17 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>3-simplicial-type-theory.md</code> \u2014 We rely on definitions of simplicies and their   subshapes.</li> <li><code>4-extension-types.md</code> \u2014 We use extension extensionality.</li> <li><code>5-segal-types.md</code> - We use the notion of hom types.</li> </ul> <p>Some of the definitions in this file rely on extension extensionality:</p> <pre><code>#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#functors","title":"Functors","text":"<p>Functions between types induce an action on hom types, preserving sources and targets. The action is called <code>ap-hom</code> to avoid conflicting with <code>ap</code>.</p> RS17, Section 6.1<pre><code>#def ap-hom\n  ( A B : U)\n  ( F : A \u2192 B)\n  ( x y : A)\n  ( f : hom A x y)\n  : hom B (F x) (F y)\n  := \\ t \u2192 F (f t)\n\n#def ap-hom2\n  ( A B : U)\n  ( F : A \u2192 B)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  ( h : hom A x z)\n  ( \u03b1 : hom2 A x y z f g h)\n  : hom2 B (F x) (F y) (F z)\n    ( ap-hom A B F x y f) (ap-hom A B F y z g) (ap-hom A B F x z h)\n  := \\ t \u2192 F (\u03b1 t)\n</code></pre> <p>Functions between types automatically preserve identity arrows. Preservation of identities follows from extension extensionality because these arrows are pointwise equal.</p> RS17, Proposition 6.1.a<pre><code>#def functors-pres-id uses (extext)\n  ( A B : U)\n  ( F : A \u2192 B)\n  ( x : A)\n  : ( ap-hom A B F x x (id-hom A x)) = (id-hom B (F x))\n  :=\n    eq-ext-htpy\n      ( extext)\n      ( 2)\n      ( \u0394\u00b9)\n      ( \u2202\u0394\u00b9)\n      ( \\ t \u2192 B)\n      ( \\ t \u2192 recOR (t \u2261 0\u2082 \u21a6 F x , t \u2261 1\u2082 \u21a6 F x))\n      ( ap-hom A B F x x (id-hom A x))\n      ( id-hom B (F x))\n      ( \\ t \u2192 refl)\n</code></pre> <p>Preservation of composition requires the Segal hypothesis.</p> RS17, Proposition 6.1.b<pre><code>#def functors-pres-comp\n  ( A B : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( is-pre-\u221e-category-B : is-pre-\u221e-category B)\n  ( F : A \u2192 B)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  :\n    ( comp-is-pre-\u221e-category B is-pre-\u221e-category-B\n      ( F x) (F y) (F z)\n      ( ap-hom A B F x y f)\n      ( ap-hom A B F y z g))\n\n  = ( ap-hom A B F x z (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g))\n  :=\n    uniqueness-comp-is-pre-\u221e-category B is-pre-\u221e-category-B\n      ( F x) (F y) (F z)\n      ( ap-hom A B F x y f)\n      ( ap-hom A B F y z g)\n      ( ap-hom A B F x z (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g))\n      ( ap-hom2 A B F x y z f g\n        ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g)\n        ( witness-comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f g))\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#natural-transformations","title":"Natural transformations","text":"<p>Given two simplicial maps <code>f g : (x : A) \u2192 B x</code> , a natural transformation from <code>f</code> to <code>g</code> is an arrow <code>\u03b7 : hom ((x : A) \u2192 B x) f g</code> between them.</p> RS17, Definition 6.2<pre><code>#def nat-trans\n  ( A : U)\n  ( B : A \u2192 U)\n  ( f g : (x : A) \u2192 (B x))\n  : U\n  := hom ((x : A) \u2192 (B x)) f g\n</code></pre> <p>Equivalently , natural transformations can be determined by their components , i.e. as a family of arrows <code>(x : A) \u2192 hom (B x) (f x) (g x)</code>.</p> <pre><code>#def nat-trans-components\n  ( A : U)\n  ( B : A \u2192 U)\n  ( f g : (x : A) \u2192 (B x))\n  : U\n  := (x : A) \u2192 hom (B x) (f x) (g x)\n</code></pre> <pre><code>#def ev-components-nat-trans\n  ( A : U)\n  ( B : A \u2192 U)\n  ( f g : (x : A) \u2192 (B x))\n  ( \u03b7 : nat-trans A B f g)\n  : nat-trans-components A B f g\n  := \\ x t \u2192 \u03b7 t x\n\n#def nat-trans-nat-trans-components\n  ( A : U)\n  ( B : A \u2192 U)\n  ( f g : (x : A) \u2192 (B x))\n  ( \u03b7 : nat-trans-components A B f g)\n  : nat-trans A B f g\n  := \\ t x \u2192 \u03b7 x t\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#natural-transformation-extensionality","title":"Natural transformation extensionality","text":"RS17, Proposition 6.3<pre><code>#def is-equiv-ev-components-nat-trans\n  ( A : U)\n  ( B : A \u2192 U)\n  ( f g : (x : A) \u2192 (B x))\n  : is-equiv\n      ( nat-trans A B f g)\n      ( nat-trans-components A B f g)\n      ( ev-components-nat-trans A B f g)\n  :=\n    ( ( \\ \u03b7 t x \u2192 \u03b7 x t , \\ _ \u2192 refl)\n    , ( \\ \u03b7 t x \u2192 \u03b7 x t , \\ _ \u2192 refl))\n\n#def equiv-components-nat-trans\n  ( A : U)\n  ( B : A \u2192 U)\n  ( f g : (x : A) \u2192 (B x))\n  : Equiv (nat-trans A B f g) (nat-trans-components A B f g)\n  :=\n    ( ev-components-nat-trans A B f g\n    , is-equiv-ev-components-nat-trans A B f g)\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#horizontal-composition","title":"Horizontal composition","text":"<p>Horizontal composition of natural transformations makes sense over any type. In particular , contrary to what is written in [RS17] we do not need <code>C</code> to be a pre-\u221e-category.</p> <pre><code>#def horizontal-comp-nat-trans\n  ( A B C : U)\n  ( f g : A \u2192 B)\n  ( f' g' : B \u2192 C)\n  ( \u03b7 : nat-trans A (\\ _ \u2192 B) f g)\n  ( \u03b7' : nat-trans B (\\ _ \u2192 C) f' g')\n  : nat-trans A (\\ _ \u2192 C) (\\ x \u2192 f' (f x)) (\\ x \u2192 g' (g x))\n  := \\ t x \u2192 \u03b7' t (\u03b7 t x)\n\n#def horizontal-comp-nat-trans-components\n  ( A B C : U)\n  ( f g : A \u2192 B)\n  ( f' g' : B \u2192 C)\n  ( \u03b7 : nat-trans-components A (\\ _ \u2192 B) f g)\n  ( \u03b7' : nat-trans-components B (\\ _ \u2192 C) f' g')\n  : nat-trans-components A (\\ _ \u2192 C) (\\ x \u2192 f' (f x)) (\\ x \u2192 g' (g x))\n  := \\ x t \u2192 \u03b7' (\u03b7 x t) t\n</code></pre>"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#vertical-composition","title":"Vertical composition","text":"<p>We can define vertical composition for natural transformations in families of pre-\u221e-categories.</p> <pre><code>#def vertical-comp-nat-trans-components\n  ( A : U)\n  ( B : A \u2192 U)\n  ( is-pre-\u221e-category-B : (x : A) \u2192 is-pre-\u221e-category (B x))\n  ( f g h : (x : A) \u2192 (B x))\n  ( \u03b7 : nat-trans-components A B f g)\n  ( \u03b7' : nat-trans-components A B g h)\n  : nat-trans-components A B f h\n  := \\ x \u2192 comp-is-pre-\u221e-category (B x) (is-pre-\u221e-category-B x) (f x) (g x) (h x) (\u03b7 x) (\u03b7' x)\n\n#def vertical-comp-nat-trans\n  ( A : U)\n  ( B : A \u2192 U)\n  ( is-pre-\u221e-category-B : (x : A) \u2192 is-pre-\u221e-category (B x))\n  ( f g h : (x : A) \u2192 (B x))\n  ( \u03b7 : nat-trans A B f g)\n  ( \u03b7' : nat-trans A B g h)\n  : nat-trans A B f h\n  :=\n    \\ t x \u2192\n    vertical-comp-nat-trans-components A B is-pre-\u221e-category-B f g h\n      ( \\ x' t' \u2192 \u03b7 t' x')\n      ( \\ x' t' \u2192 \u03b7' t' x')\n      ( x)\n      ( t)\n</code></pre> <p>The identity natural transformation is identity arrows on components</p> RS17, Proposition 6.5(ii)<pre><code>#def id-arr-components-id-nat-trans\n  ( A : U)\n  ( B : A \u2192 U)\n  ( f : (x : A) \u2192 (B x))\n  ( a : A)\n  : ( \\ t \u2192 id-hom ((x : A) \u2192 B x) f t a) =_{\u0394\u00b9 \u2192 B a} id-hom (B a) (f a)\n  := refl\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/","title":"\u221e-groupoids (Discrete types)","text":"<p>These formalisations correspond to Section 7 of the RS17 paper.</p> <p>Discrete types vs \u221e-groupoids</p> <p>Riehl and Shulman refer to \"Discrete types\" in RS17, but here we call them \"\u221e-groupoids\".</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>hott/1-paths.md</code> - We require basic path algebra.</li> <li><code>hott/4-equivalences.md</code> - We require the notion of equivalence between types.</li> <li><code>3-simplicial-type-theory.md</code> \u2014 We rely on definitions of simplicies and their   subshapes.</li> <li><code>4-extension-types.md</code> \u2014 We use extension extensionality.</li> <li><code>5-segal-types.md</code> - We use the notion of hom types.</li> </ul> <p>Some of the definitions in this file rely on function extensionality and extension extensionality:</p> <pre><code>#assume funext : FunExt\n#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#the-definition","title":"The definition","text":"<p>\u221e-groupoids are types in which the hom-types are canonically equivalent to identity types.</p> RS17, Definition 7.1<pre><code>#def hom-eq\n  ( A : U)\n  ( x y : A)\n  ( p : x = y)\n  : hom A x y\n  := ind-path (A) (x) (\\ y' p' \u2192 hom A x y') ((id-hom A x)) (y) (p)\n\n#def is-\u221e-groupoid\n  ( A : U)\n  : U\n  := (x : A) \u2192 (y : A) \u2192 is-equiv (x = y) (hom A x y) (hom-eq A x y)\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#families-of-groupoids","title":"Families of \u221e-groupoids","text":"<p>By function extensionality, the dependent function type associated to a family of \u221e-groupoids is itself \u221e-groupoid.</p> <pre><code>#def equiv-hom-eq-function-type-is-\u221e-groupoid uses (funext)\n  ( X : U)\n  ( A : X \u2192 U)\n  ( is-\u221e-groupoid-A : (x : X) \u2192 is-\u221e-groupoid (A x))\n  ( f g : (x : X) \u2192 A x)\n  : Equiv (f = g) (hom ((x : X) \u2192 A x) f g)\n  :=\n    equiv-triple-comp\n      ( f = g)\n      ( ( x : X) \u2192 f x = g x)\n      ( ( x : X) \u2192 hom (A x) (f x) (g x))\n      ( hom ((x : X) \u2192 A x) f g)\n      ( equiv-FunExt funext X A f g)\n      ( equiv-function-equiv-family funext X\n        ( \\ x \u2192 (f x = g x))\n        ( \\ x \u2192 hom (A x) (f x) (g x))\n        ( \\ x \u2192 (hom-eq (A x) (f x) (g x) , (is-\u221e-groupoid-A x (f x) (g x)))))\n      ( flip-ext-fun-inv\n        ( 2)\n        ( \u0394\u00b9)\n        ( \u2202\u0394\u00b9)\n        ( X)\n        ( \\ t x \u2192 A x)\n        ( \\ t x \u2192 recOR (t \u2261 0\u2082 \u21a6 f x , t \u2261 1\u2082 \u21a6 g x)))\n\n#def compute-hom-eq-function-type-is-\u221e-groupoid uses (funext)\n  ( X : U)\n  ( A : X \u2192 U)\n  ( is-\u221e-groupoid-A : (x : X) \u2192 is-\u221e-groupoid (A x))\n  ( f g : (x : X) \u2192 A x)\n  ( h : f = g)\n  : ( hom-eq ((x : X) \u2192 A x) f g h)\n  = ( first (equiv-hom-eq-function-type-is-\u221e-groupoid X A is-\u221e-groupoid-A f g)) h\n  :=\n    ind-path\n      ( ( x : X) \u2192 A x)\n      ( f)\n      ( \\ g' h' \u2192\n        hom-eq ((x : X) \u2192 A x) f g' h'\n      = ( first (equiv-hom-eq-function-type-is-\u221e-groupoid X A is-\u221e-groupoid-A f g')) h')\n      ( refl)\n      ( g)\n      ( h)\n</code></pre> RS17, Proposition 7.2<pre><code>#def is-\u221e-groupoid-function-type uses (funext)\n  ( X : U)\n  ( A : X \u2192 U)\n  ( is-\u221e-groupoid-A : (x : X) \u2192 is-\u221e-groupoid (A x))\n  : is-\u221e-groupoid ((x : X) \u2192 A x)\n  :=\n    \\ f g \u2192\n    is-equiv-homotopy\n      ( f = g)\n      ( hom ((x : X) \u2192 A x) f g)\n      ( hom-eq ((x : X) \u2192 A x) f g)\n      ( first (equiv-hom-eq-function-type-is-\u221e-groupoid X A is-\u221e-groupoid-A f g))\n      ( compute-hom-eq-function-type-is-\u221e-groupoid X A is-\u221e-groupoid-A f g)\n      ( second (equiv-hom-eq-function-type-is-\u221e-groupoid X A is-\u221e-groupoid-A f g))\n</code></pre> <p>By extension extensionality, an extension type into a family of \u221e-groupoids is itself \u221e-groupoid. Since <code>equiv-extension-equiv-family</code> considers total extension types only, extending from <code>BOT</code>, that's all we prove here for now.</p> <pre><code>#def equiv-hom-eq-extension-type-is-\u221e-groupoid uses (extext)\n  ( I : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( A : \u03c8 \u2192 U)\n  ( is-\u221e-groupoid-A : (t : \u03c8) \u2192 is-\u221e-groupoid (A t))\n  ( f g : (t : \u03c8) \u2192 A t)\n  : Equiv (f = g) (hom ((t : \u03c8) \u2192 A t) f g)\n  :=\n    equiv-triple-comp\n      ( f = g)\n      ( ( t : \u03c8) \u2192 f t = g t)\n      ( ( t : \u03c8) \u2192 hom (A t) (f t) (g t))\n      ( hom ((t : \u03c8) \u2192 A t) f g)\n      ( equiv-ExtExt extext I \u03c8 (\\ _ \u2192 BOT) A (\\ _ \u2192 recBOT) f g)\n      ( equiv-extension-equiv-family\n        ( extext)\n        ( I)\n        ( \u03c8)\n        ( \\ t \u2192 f t = g t)\n        ( \\ t \u2192 hom (A t) (f t) (g t))\n        ( \\ t \u2192 (hom-eq (A t) (f t) (g t) , (is-\u221e-groupoid-A t (f t) (g t)))))\n      ( fubini\n        ( I)\n        ( 2)\n        ( \u03c8)\n        ( \\ t \u2192 BOT)\n        ( \u0394\u00b9)\n        ( \u2202\u0394\u00b9)\n        ( \\ t s \u2192 A t)\n        ( \\ (t , s) \u2192 recOR (s \u2261 0\u2082 \u21a6 f t , s \u2261 1\u2082 \u21a6 g t)))\n\n#def compute-hom-eq-extension-type-is-\u221e-groupoid uses (extext)\n  ( I : CUBE)\n  ( \u03c8 : (t : I) \u2192 TOPE)\n  ( A : \u03c8 \u2192 U)\n  ( is-\u221e-groupoid-A : (t : \u03c8) \u2192 is-\u221e-groupoid (A t))\n  ( f g : (t : \u03c8) \u2192 A t)\n  ( h : f = g)\n  : ( hom-eq ((t : \u03c8) \u2192 A t) f g h)\n  = ( first (equiv-hom-eq-extension-type-is-\u221e-groupoid I \u03c8 A is-\u221e-groupoid-A f g)) h\n  :=\n    ind-path\n      ( ( t : \u03c8) \u2192 A t)\n      ( f)\n      ( \\ g' h' \u2192\n        ( hom-eq ((t : \u03c8) \u2192 A t) f g' h')\n      = ( first (equiv-hom-eq-extension-type-is-\u221e-groupoid I \u03c8 A is-\u221e-groupoid-A f g') h'))\n      ( refl)\n      ( g)\n      ( h)\n</code></pre> RS17, Proposition 7.2, for extension types<pre><code>#def is-\u221e-groupoid-extension-type uses (extext)\n  ( I : CUBE)\n  ( \u03c8 : (t : I) \u2192 TOPE)\n  ( A : \u03c8 \u2192 U)\n  ( is-\u221e-groupoid-A : (t : \u03c8) \u2192 is-\u221e-groupoid (A t))\n  : is-\u221e-groupoid ((t : \u03c8) \u2192 A t)\n  :=\n    \\ f g \u2192\n    is-equiv-homotopy\n      ( f = g)\n      ( hom ((t : \u03c8) \u2192 A t) f g)\n      ( hom-eq ((t : \u03c8) \u2192 A t) f g)\n      ( first (equiv-hom-eq-extension-type-is-\u221e-groupoid I \u03c8 A is-\u221e-groupoid-A f g))\n      ( compute-hom-eq-extension-type-is-\u221e-groupoid I \u03c8 A is-\u221e-groupoid-A f g)\n      ( second (equiv-hom-eq-extension-type-is-\u221e-groupoid I \u03c8 A is-\u221e-groupoid-A f g))\n</code></pre> <p>For instance, the arrow type of a \u221e-groupoid is itself \u221e-groupoid.</p> <pre><code>#def is-\u221e-groupoid-arr uses (extext)\n  ( A : U)\n  ( is-\u221e-groupoid-A : is-\u221e-groupoid A)\n  : is-\u221e-groupoid (arr A)\n  := is-\u221e-groupoid-extension-type 2 \u0394\u00b9 (\\ _ \u2192 A) (\\ _ \u2192 is-\u221e-groupoid-A)\n</code></pre>"},{"location":"simplicial-hott/07-discrete.rzk/#-groupoids-are-pre-categories","title":"\u221e-groupoids are pre-\u221e-categories","text":"<p>\u221e-groupoids are automatically pre-\u221e-categories.</p> <pre><code>#section \u221e-groupoid-arr-equivalences\n\n#variable A : U\n#variable is-\u221e-groupoid-A : is-\u221e-groupoid A\n#variables x y z w : A\n#variable f : hom A x y\n#variable g : hom A z w\n\n#def is-equiv-hom-eq-\u221e-groupoid uses (extext x y z w)\n  : is-equiv (f =_{arr A} g) (hom (arr A) f g) (hom-eq (arr A) f g)\n  := (is-\u221e-groupoid-arr A is-\u221e-groupoid-A) f g\n\n#def equiv-hom-eq-\u221e-groupoid uses (extext x y z w)\n  : Equiv (f =_{arr A} g) (hom (arr A) f g)\n  := (hom-eq (arr A) f g , (is-\u221e-groupoid-arr A is-\u221e-groupoid-A) f g)\n\n#def equiv-square-hom-arr\n  : Equiv\n      ( hom (arr A) f g)\n      ( \u03a3 ( h : hom A x z)\n        , ( \u03a3 ( k : hom A y w)\n            , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n              \u2192 A [ t \u2261 0\u2082 \u2227 \u0394\u00b9 s \u21a6 f s\n                  , t \u2261 1\u2082 \u2227 \u0394\u00b9 s \u21a6 g s\n                  , \u0394\u00b9 t \u2227 s \u2261 0\u2082 \u21a6 h t\n                  , \u0394\u00b9 t \u2227 s \u2261 1\u2082 \u21a6 k t])))\n  :=\n    ( \\ \u03b1 \u2192\n      ( ( \\ t \u2192 \u03b1 t 0\u2082)\n      , ( ( \\ t \u2192 \u03b1 t 1\u2082) , (\\ (t , s) \u2192 \u03b1 t s)))\n    , ( ( ( \\ \u03c3 t s \u2192 (second (second \u03c3)) (t , s)) , (\\ \u03b1 \u2192 refl))\n      , ( ( \\ \u03c3 t s \u2192 (second (second \u03c3)) (t , s)) , (\\ \u03c3 \u2192 refl))))\n</code></pre> <p>The equivalence underlying <code>equiv-arr-\u03a3-hom</code>:</p> <pre><code>#def fibered-arr-free-arr\n  : ( arr A) \u2192 (\u03a3 (u : A) , (\u03a3 (v : A) , hom A u v))\n  := \\ k \u2192 (k 0\u2082 , (k 1\u2082 , k))\n\n#def is-equiv-fibered-arr-free-arr\n  : is-equiv (arr A) (\u03a3 (u : A) , (\u03a3 (v : A) , hom A u v)) (fibered-arr-free-arr)\n  := is-equiv-arr-\u03a3-hom A\n\n#def is-equiv-ap-fibered-arr-free-arr uses (w x y z)\n  : is-equiv\n      ( f =_{\u0394\u00b9 \u2192 A} g)\n      ( fibered-arr-free-arr f = fibered-arr-free-arr g)\n      ( ap\n        ( arr A)\n        ( \u03a3 ( u : A) , (\u03a3 (v : A) , (hom A u v)))\n        ( f)\n        ( g)\n        ( fibered-arr-free-arr))\n  :=\n    is-emb-is-equiv\n      ( arr A)\n      ( \u03a3 ( u : A) , (\u03a3 (v : A) , (hom A u v)))\n      ( fibered-arr-free-arr)\n      ( is-equiv-fibered-arr-free-arr)\n      ( f)\n      ( g)\n\n#def equiv-eq-fibered-arr-eq-free-arr uses (w x y z)\n  : Equiv (f =_{\u0394\u00b9 \u2192 A} g) (fibered-arr-free-arr f = fibered-arr-free-arr g)\n  :=\n    equiv-ap-is-equiv\n      ( arr A)\n      ( \u03a3 ( u : A) , (\u03a3 (v : A) , (hom A u v)))\n      ( fibered-arr-free-arr)\n      ( is-equiv-fibered-arr-free-arr)\n      ( f)\n      ( g)\n\n#def equiv-sigma-over-product-hom-eq\n  : Equiv\n      ( fibered-arr-free-arr f = fibered-arr-free-arr g)\n      ( \u03a3 ( p : x = z)\n        , ( \u03a3 ( q : y = w)\n            , ( product-transport A A (hom A) x z y w p q f = g)))\n  :=\n    extensionality-\u03a3-over-product\n      ( A) (A)\n      ( hom A)\n      ( fibered-arr-free-arr f)\n      ( fibered-arr-free-arr g)\n\n#def equiv-square-sigma-over-product uses (extext is-\u221e-groupoid-A)\n  : Equiv\n    ( \u03a3 ( p : x = z)\n      , ( \u03a3 ( q : y = w)\n          , ( product-transport A A (hom A) x z y w p q f = g)))\n    ( \u03a3 ( h : hom A x z)\n      , ( \u03a3 ( k : hom A y w)\n          , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n            \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n                , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n                , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h t\n                , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k t])))\n  :=\n    equiv-left-cancel\n      ( f =_{\u0394\u00b9 \u2192 A} g)\n      ( \u03a3 ( p : x = z)\n        , ( \u03a3 ( q : y = w)\n            , ( product-transport A A (hom A) x z y w p q f = g)))\n      ( \u03a3 ( h : hom A x z)\n        , ( \u03a3 ( k : hom A y w)\n            , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n              \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n                  , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n                  , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h t\n                  , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k t])))\n      ( equiv-comp\n        ( f =_{\u0394\u00b9 \u2192 A} g)\n        ( fibered-arr-free-arr f = fibered-arr-free-arr g)\n        ( \u03a3 ( p : x = z)\n          , ( \u03a3 ( q : y = w)\n              , ( product-transport A A (hom A) x z y w p q f = g)))\n        equiv-eq-fibered-arr-eq-free-arr\n        equiv-sigma-over-product-hom-eq)\n      ( equiv-comp\n        ( f =_{\u0394\u00b9 \u2192 A} g)\n        ( hom (arr A) f g)\n        ( \u03a3 ( h : hom A x z)\n          , ( \u03a3 ( k : hom A y w)\n              , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n                \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n                    , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n                    , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h t\n                    , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k t])))\n        ( equiv-hom-eq-\u221e-groupoid)\n        ( equiv-square-hom-arr))\n</code></pre> <p>We close the section so we can use path induction.</p> <pre><code>#end \u221e-groupoid-arr-equivalences\n</code></pre> <pre><code>#def fibered-map-square-sigma-over-product\n  ( A : U)\n  ( x y z w : A)\n  ( f : hom A x y)\n  ( p : x = z)\n  ( q : y = w)\n  : ( g : hom A z w)\n  \u2192 ( product-transport A A (hom A) x z y w p q f = g)\n  \u2192 ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n        , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 (hom-eq A x z p) t\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 (hom-eq A y w q) t])\n  :=\n    ind-path\n      ( A)\n      ( x)\n      ( \\ z' p' \u2192\n        ( g : hom A z' w)\n      \u2192 ( product-transport A A (hom A) x z' y w p' q f = g)\n      \u2192 ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 (hom-eq A x z' p') t\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 (hom-eq A y w q) t]))\n      ( ind-path\n        ( A)\n        ( y)\n        ( \\ w' q' \u2192\n          ( g : hom A x w')\n        \u2192 ( product-transport A A (hom A) x x y w' refl q' f = g)\n        \u2192 ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n          \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n              , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 (hom-eq A y w' q') t]))\n        ( ind-path\n          ( hom A x y)\n          ( f)\n          ( \\ g' \u03c4' \u2192\n            ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n            \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n                , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g' s\n                , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n                , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n          ( \\ (t , s) \u2192 f s))\n        ( w)\n        ( q))\n      ( z)\n      ( p)\n\n#def square-sigma-over-product\n  ( A : U)\n  ( x y z w : A)\n  ( f : hom A x y)\n  ( g : hom A z w)\n  ( ( p , (q , \u03c4)) :\n    ( \u03a3 ( p : x = z)\n      , ( \u03a3 ( q : y = w)\n          , ( product-transport A A (hom A) x z y w p q f = g))))\n  : \u03a3 ( h : hom A x z)\n    , ( \u03a3 ( k : hom A y w)\n        , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n          \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n              , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h t\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k t]))\n  :=\n    ( ( hom-eq A x z p)\n    , ( ( hom-eq A y w q)\n      , ( fibered-map-square-sigma-over-product\n          ( A)\n          ( x) (y) (z) (w)\n          ( f) (p) (q) (g)\n          ( \u03c4))))\n\n#def refl-refl-map-equiv-square-sigma-over-product uses (extext)\n  ( A : U)\n  ( is-\u221e-groupoid-A : is-\u221e-groupoid A)\n  ( x y : A)\n  ( f g : hom A x y)\n  ( \u03c4 : product-transport A A (hom A) x x y y refl refl f = g)\n  : ( first\n      ( equiv-square-sigma-over-product A is-\u221e-groupoid-A x y x y f g)\n      ( refl , (refl , \u03c4)))\n  = ( square-sigma-over-product\n      ( A)\n      ( x) (y) (x) (y)\n      ( f) (g)\n      ( refl , (refl , \u03c4)))\n  :=\n    ind-path\n      ( hom A x y)\n      ( f)\n      ( \\ g' \u03c4' \u2192\n        ( first\n          ( equiv-square-sigma-over-product A is-\u221e-groupoid-A x y x y f g')\n          ( refl , (refl , \u03c4')))\n      = ( square-sigma-over-product\n          ( A)\n          ( x) (y) (x) (y)\n          ( f) (g')\n          ( refl , (refl , \u03c4'))))\n      ( refl)\n      ( g)\n      ( \u03c4)\n\n#def map-equiv-square-sigma-over-product uses (extext)\n  ( A : U)\n  ( is-\u221e-groupoid-A : is-\u221e-groupoid A)\n  ( x y z w : A)\n  ( f : hom A x y)\n  ( p : x = z)\n  ( q : y = w)\n  : ( g : hom A z w)\n  \u2192 ( \u03c4 : product-transport A A (hom A) x z y w p q f = g)\n  \u2192 ( first\n      ( equiv-square-sigma-over-product A is-\u221e-groupoid-A x y z w f g)\n      ( p , (q , \u03c4)))\n  = ( square-sigma-over-product\n        A x y z w f g (p , (q , \u03c4)))\n  :=\n    ind-path\n      ( A)\n      ( y)\n      ( \\ w' q' \u2192\n        ( g : hom A z w')\n      \u2192 ( \u03c4 : product-transport A A (hom A) x z y w' p q' f = g)\n      \u2192 ( first\n          ( equiv-square-sigma-over-product\n              A is-\u221e-groupoid-A x y z w' f g))\n          ( p , (q' , \u03c4))\n      = ( square-sigma-over-product A x y z w' f g)\n          ( p , (q' , \u03c4)))\n      ( ind-path\n        ( A)\n        ( x)\n        ( \\ z' p' \u2192\n          ( g : hom A z' y)\n        \u2192 ( \u03c4 : product-transport A A (hom A) x z' y y p' refl f = g)\n        \u2192 ( first\n            ( equiv-square-sigma-over-product A is-\u221e-groupoid-A x y z' y f g)\n            ( p' , (refl , \u03c4)))\n        = ( square-sigma-over-product A x y z' y f g (p' , (refl , \u03c4))))\n        ( refl-refl-map-equiv-square-sigma-over-product\n            ( A) (is-\u221e-groupoid-A) (x) (y) (f))\n        ( z)\n        ( p))\n      ( w)\n      ( q)\n\n#def is-equiv-square-sigma-over-product uses (extext)\n  ( A : U)\n  ( is-\u221e-groupoid-A : is-\u221e-groupoid A)\n  ( x y z w : A)\n  ( f : hom A x y)\n  ( g : hom A z w)\n  : is-equiv\n    ( \u03a3 ( p : x = z)\n      , ( \u03a3 ( q : y = w)\n          , ( product-transport A A (hom A) x z y w p q f = g)))\n    ( \u03a3 ( h : hom A x z)\n      , ( \u03a3 ( k : hom A y w)\n          , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n            \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n                , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n                , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h t\n                , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k t])))\n    ( square-sigma-over-product A x y z w f g)\n  :=\n    is-equiv-rev-homotopy\n    ( \u03a3 ( p : x = z)\n      , ( \u03a3 ( q : y = w)\n          , ( product-transport A A (hom A) x z y w p q f = g)))\n    ( \u03a3 ( h : hom A x z)\n      , ( \u03a3 ( k : hom A y w)\n          , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n            \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n                , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n                , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h t\n                , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k t])))\n    ( first (equiv-square-sigma-over-product A is-\u221e-groupoid-A x y z w f g))\n    ( square-sigma-over-product A x y z w f g)\n    ( \\ (p , (q , \u03c4)) \u2192\n      map-equiv-square-sigma-over-product A is-\u221e-groupoid-A x y z w f p q g \u03c4)\n    ( second (equiv-square-sigma-over-product A is-\u221e-groupoid-A x y z w f g))\n\n#def is-equiv-fibered-map-square-sigma-over-product uses (extext)\n  ( A : U)\n  ( is-\u221e-groupoid-A : is-\u221e-groupoid A)\n  ( x y z w : A)\n  ( f : hom A x y)\n  ( g : hom A z w)\n  ( p : x = z)\n  ( q : y = w)\n  : is-equiv\n    ( product-transport A A (hom A) x z y w p q f = g)\n    ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n        , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 (hom-eq A x z p) t\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 (hom-eq A y w q) t])\n    ( fibered-map-square-sigma-over-product A x y z w f p q g)\n  :=\n    fibered-map-is-equiv-bases-are-equiv-total-map-is-equiv\n      ( x = z)\n      ( hom A x z)\n      ( y = w)\n      ( hom A y w)\n      ( \\ p' q' \u2192 (product-transport A A (hom A) x z y w p' q' f) = g)\n      ( \\ h' k' \u2192\n        ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 h' t\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 k' t]))\n      ( hom-eq A x z)\n      ( hom-eq A y w)\n      ( \\ p' q' \u2192\n        fibered-map-square-sigma-over-product\n          ( A)\n          ( x) (y) (z) (w)\n          ( f)\n          ( p')\n          ( q')\n          ( g))\n      ( is-equiv-square-sigma-over-product A is-\u221e-groupoid-A x y z w f g)\n      ( is-\u221e-groupoid-A x z)\n      ( is-\u221e-groupoid-A y w)\n      ( p)\n      ( q)\n\n#def is-equiv-fibered-map-square-sigma-over-product-refl-refl uses (extext)\n  ( A : U)\n  ( is-\u221e-groupoid-A : is-\u221e-groupoid A)\n  ( x y : A)\n  ( f : hom A x y)\n  ( g : hom A x y)\n  : is-equiv\n    ( f = g)\n    ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n        , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y])\n    ( fibered-map-square-sigma-over-product\n      A x y x y f refl refl g)\n  :=\n    is-equiv-fibered-map-square-sigma-over-product\n      A is-\u221e-groupoid-A x y x y f g refl refl\n</code></pre> <p>The previous calculations allow us to establish a family of equivalences:</p> <pre><code>#def is-equiv-sum-fibered-map-square-sigma-over-product-refl-refl uses (extext)\n  ( A : U)\n  ( is-\u221e-groupoid-A : is-\u221e-groupoid A)\n  ( x y : A)\n  ( f : hom A x y)\n  : is-equiv\n    ( \u03a3 ( g : hom A x y) , f = g)\n    ( \u03a3 ( g : hom A x y)\n      , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n    ( total-map\n      ( hom A x y)\n      ( \\ g \u2192 f = g)\n      ( \\ g \u2192\n        ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n      \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n          , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y])\n      ( fibered-map-square-sigma-over-product\n          A x y x y f refl refl))\n  :=\n    family-of-equiv-total-equiv\n      ( hom A x y)\n      ( \\ g \u2192 f = g)\n      ( \\ g \u2192\n        ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n      \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n          , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y])\n      ( fibered-map-square-sigma-over-product\n          A x y x y f refl refl)\n      ( \\ g \u2192\n        is-equiv-fibered-map-square-sigma-over-product-refl-refl\n          ( A) (is-\u221e-groupoid-A)\n          ( x) (y)\n          ( f) (g))\n\n#def equiv-sum-fibered-map-square-sigma-over-product-refl-refl uses (extext)\n  ( A : U)\n  ( is-\u221e-groupoid-A : is-\u221e-groupoid A)\n  ( x y : A)\n  ( f : hom A x y)\n  : Equiv\n      ( \u03a3 ( g : hom A x y) , f = g)\n      ( \u03a3 ( g : hom A x y)\n        , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n          \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n              , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n  :=\n    ( ( total-map\n        ( hom A x y)\n        ( \\ g \u2192 f = g)\n        ( \\ g \u2192\n          ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y])\n        ( fibered-map-square-sigma-over-product\n            A x y x y f refl refl))\n  , is-equiv-sum-fibered-map-square-sigma-over-product-refl-refl\n      A is-\u221e-groupoid-A x y f)\n</code></pre> <p>Now using the equivalence on total spaces and the contractibility of based path spaces, we conclude that the codomain extension type is contractible.</p> <pre><code>#def is-contr-horn-refl-refl-extension-type uses (extext)\n  ( A : U)\n  ( is-\u221e-groupoid-A : is-\u221e-groupoid A)\n  ( x y : A)\n  ( f : hom A x y)\n  : is-contr\n    ( \u03a3 ( g : hom A x y)\n      , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n  :=\n    is-contr-equiv-is-contr\n      ( \u03a3 ( g : hom A x y) , f = g)\n      ( \u03a3 ( g : hom A x y)\n        , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n          \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n              , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n      ( equiv-sum-fibered-map-square-sigma-over-product-refl-refl\n          A is-\u221e-groupoid-A x y f)\n      ( is-contr-based-paths (hom A x y) f)\n</code></pre> <p>The extension types that appear in the Segal condition are retracts of this type --- at least when the second arrow in the composable pair is an identity.</p> <pre><code>#def triangle-to-square-section\n  ( A : U)\n  ( x y : A)\n  ( f g : hom A x y)\n  ( \u03b1 : hom2 A x y y f (id-hom A y) g)\n  : ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n  \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n      , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n      , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n      , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]\n  := \\ (t , s) \u2192 recOR (t \u2264 s \u21a6 \u03b1 (s , t) , s \u2264 t \u21a6 g s)\n\n#def sigma-triangle-to-sigma-square-section\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( ( d , \u03b1) : \u03a3 (d : hom A x y) , hom2 A x y y f (id-hom A y) d)\n  : \u03a3 ( g : hom A x y)\n    , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n      \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n          , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y])\n  := (d , triangle-to-square-section A x y f d \u03b1)\n\n#def sigma-square-to-sigma-triangle-retraction\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( ( g , \u03c3) :\n    \u03a3 ( g : hom A x y)\n    , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n      \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n          , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n  : \u03a3 ( d : hom A x y) , (hom2 A x y y f (id-hom A y) d)\n  := ((\\ t \u2192 \u03c3 (t , t)) , (\\ (t , s) \u2192 \u03c3 (s , t)))\n\n#def sigma-triangle-to-sigma-square-retract\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  : is-retract-of\n      ( \u03a3 ( d : hom A x y) , (hom2 A x y y f (id-hom A y) d))\n      ( \u03a3 ( g : hom A x y)\n        , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n          \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n              , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n  :=\n    ( ( sigma-triangle-to-sigma-square-section A x y f)\n    , ( ( sigma-square-to-sigma-triangle-retraction A x y f)\n      , ( \\ d\u03b1 \u2192 refl)))\n</code></pre> <p>We can now verify the Segal condition in the case of composable pairs in which the second arrow is an identity.</p> <pre><code>#def is-contr-hom2-with-id-is-\u221e-groupoid uses (extext)\n  ( A : U)\n  ( is-\u221e-groupoid-A : is-\u221e-groupoid A)\n  ( x y : A)\n  ( f : hom A x y)\n  : is-contr (\u03a3 (d : hom A x y) , (hom2 A x y y f (id-hom A y) d))\n  :=\n    is-contr-is-retract-of-is-contr\n      ( \u03a3 ( d : hom A x y) , (hom2 A x y y f (id-hom A y) d))\n      ( \u03a3 ( g : hom A x y)\n        , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n          \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 f s\n              , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 g s\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 x\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 y]))\n      ( sigma-triangle-to-sigma-square-retract A x y f)\n      ( is-contr-horn-refl-refl-extension-type A is-\u221e-groupoid-A x y f)\n</code></pre> <p>But since <code>A</code> is an \u221e-groupoid, its hom type family is equivalent to its identity type family, and we can use \"path induction\" over arrows to reduce the general case to the one just proven:</p> <pre><code>#def is-contr-hom2-is-\u221e-groupoid uses (extext)\n  ( A : U)\n  ( is-\u221e-groupoid-A : is-\u221e-groupoid A)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  : is-contr (\u03a3 (h : hom A x z) , hom2 A x y z f g h)\n  :=\n    ind-based-path\n      ( A)\n      ( y)\n      ( \\ w \u2192 hom A y w)\n      ( \\ w \u2192 hom-eq A y w)\n      ( is-\u221e-groupoid-A y)\n      ( \\ w d \u2192 is-contr (\u03a3 (h : hom A x w) , hom2 A x y w f d h))\n      ( is-contr-hom2-with-id-is-\u221e-groupoid A is-\u221e-groupoid-A x y f)\n      ( z)\n      ( g)\n</code></pre> <p>Finally, we conclude:</p> RS17, Proposition 7.3<pre><code>#def is-pre-\u221e-category-is-\u221e-groupoid uses (extext)\n  ( A : U)\n  ( is-\u221e-groupoid-A : is-\u221e-groupoid A)\n  : is-pre-\u221e-category A\n  := is-contr-hom2-is-\u221e-groupoid A is-\u221e-groupoid-A\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/","title":"Covariantly functorial type families","text":"<p>These formalisations correspond to Section 8 of the RS17 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>hott/*</code> - We require various prerequisites from homotopy type theory, for   instance the notion of contractible types.</li> <li><code>3-simplicial-type-theory.md</code> \u2014 We rely on definitions of simplicies and their   subshapes.</li> <li><code>5-segal-types.md</code> - We make use of the notion of pre-\u221e-categories and their   structures.</li> </ul> <p>Some of the definitions in this file rely on extension extensionality:</p> <pre><code>#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#dependent-hom-types","title":"Dependent hom types","text":"<p>In a type family over a base type, there is a dependent hom type of arrows that live over a specified arrow in the base type.</p> RS17, Section 8 Prelim<pre><code>#def dhom\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C : A \u2192 U)\n  ( u : C x)\n  ( v : C y)\n  : U\n  := (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u , t \u2261 1\u2082 \u21a6 v]\n</code></pre> <p>It will be convenient to collect together dependent hom types with fixed domain but varying codomain.</p> <pre><code>#def dhom-from\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C : A \u2192 U)\n  ( u : C x)\n  : U\n  := (\u03a3 (v : C y) , dhom A x y f C u v)\n</code></pre> <p>There is also a type of dependent commutative triangles over a base commutative triangle.</p> <pre><code>#def dhom2\n  ( A : U)\n  ( x y z : A)\n  ( f : hom A x y)\n  ( g : hom A y z)\n  ( h : hom A x z)\n  ( \u03b1 : hom2 A x y z f g h)\n  ( C : A \u2192 U)\n  ( u : C x)\n  ( v : C y)\n  ( w : C z)\n  ( ff : dhom A x y f C u v)\n  ( gg : dhom A y z g C v w)\n  ( hh : dhom A x z h C u w)\n  : U\n  :=\n    ( ( t1 , t2) : \u0394\u00b2) \u2192 C (\u03b1 (t1 , t2)) [\n        t2 \u2261 0\u2082 \u21a6 ff t1\n      , t1 \u2261 1\u2082 \u21a6 gg t2\n      , t2 \u2261 t1 \u21a6 hh t2\n      ]\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-families","title":"Covariant families","text":"<p>A family of types over a base type is covariant if every arrow in the base has a unique lift with specified domain.</p> RS17, Definition 8.2<pre><code>#def is-covariant\n  ( A : U)\n  ( C : A \u2192 U)\n  : U\n  :=\n    ( x : A) \u2192 (y : A) \u2192 (f : hom A x y) \u2192 (u : C x)\n  \u2192 is-contr (dhom-from A x y f C u)\n</code></pre> The type of covariant families over a fixed type<pre><code>#def covariant-family (A : U)\n  : U\n  := (\u03a3 (C : (A \u2192 U)) , is-covariant A C)\n</code></pre> <p>The notion of having a unique lift with a fixed domain may also be expressed by contractibility of the type of extensions along the domain inclusion into the 1-simplex.</p> <pre><code>#def has-unique-fixed-domain-lifts\n  ( A : U)\n  ( C : A \u2192 U)\n  : U\n  :=\n    ( x : A) \u2192 (y : A) \u2192 (f : hom A x y) \u2192 (u : C x)\n  \u2192 is-contr ((t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u])\n</code></pre> <p>These two notions of covariance are equivalent because the two types of lifts of a base arrow with fixed domain are equivalent. Note that this is not quite an instance of Theorem 4.4 but its proof, with a very small modification, works here.</p> <pre><code>#def equiv-lifts-with-fixed-domain\n  ( A : U)\n  ( C : A \u2192 U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( u : C x)\n  : Equiv\n      ( ( t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u])\n      ( dhom-from A x y f C u)\n  :=\n    ( \\ h \u2192 (h 1\u2082 , \\ t \u2192 h t)\n    , ( ( \\ fg t \u2192 (second fg) t , \\ h \u2192 refl)\n      , ( ( \\ fg t \u2192 (second fg) t , \\ h \u2192 refl))))\n</code></pre> <p>By the equivalence-invariance of contractibility, this proves the desired logical equivalence</p> RS17, Proposition 8.4<pre><code>#def has-unique-fixed-domain-lifts-iff-is-covariant\n  ( A : U)\n  ( C : A \u2192 U)\n  : iff\n      ( has-unique-fixed-domain-lifts A C)\n      ( is-covariant A C)\n  :=\n    ( ( \\ C-has-unique-lifts x y f u \u2192\n        is-contr-equiv-is-contr\n          ( ( t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u])\n          ( dhom-from A x y f C u)\n          ( equiv-lifts-with-fixed-domain A C x y f u)\n          ( C-has-unique-lifts x y f u))\n    , ( \\ C-is-covariant x y f u \u2192\n        is-contr-equiv-is-contr'\n          ( ( t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u])\n          ( dhom-from A x y f C u)\n          ( equiv-lifts-with-fixed-domain A C x y f u)\n          ( C-is-covariant x y f u)))\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#representable-covariant-families","title":"Representable covariant families","text":"<p>If A is a pre-\u221e-category and a : A is any term, then hom A a defines a covariant family over A, and conversely if this family is covariant for every a : A, then A must be a pre-\u221e-category. The proof involves a rather lengthy composition of equivalences.</p> <pre><code>#def dhom-representable\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  ( v : hom A a y)\n  : U\n  := dhom A x y f (\\ z \u2192 hom A a z) u v\n</code></pre> <p>By uncurrying (RS 4.2) we have an equivalence:</p> <pre><code>#def uncurried-dhom-representable\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  ( v : hom A a y)\n  : Equiv\n    ( dhom-representable A a x y f u v)\n    ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n  :=\n    curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 (\\ t s \u2192 A)\n    ( \\ (t , s) \u2192\n      recOR\n        ( ( t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t))\n\n#def dhom-from-representable\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : U\n  := dhom-from A x y f (\\ z \u2192 hom A a z) u\n</code></pre> <p>By uncurrying (RS 4.2) we have an equivalence:</p> <pre><code>#def uncurried-dhom-from-representable\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n    ( dhom-from-representable A a x y f u)\n    ( \u03a3 ( v : hom A a y)\n      , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n  :=\n    total-equiv-family-equiv\n      ( hom A a y)\n      ( \\ v \u2192 dhom-representable A a x y f u v)\n      ( \\ v \u2192\n        ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n      ( \\ v \u2192 uncurried-dhom-representable A a x y f u v)\n\n#def square-to-hom2-pushout\n  ( A : U)\n  ( w x y z : A)\n  ( u : hom A w x)\n  ( f : hom A x z)\n  ( g : hom A w y)\n  ( v : hom A y z)\n  : ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 g t\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n  \u2192 ( \u03a3 ( d : hom A w z) , product (hom2 A w x z u f d) (hom2 A w y z g v d))\n  :=\n    \\ sq \u2192\n    ( ( \\ t \u2192 sq (t , t)) , (\\ (t , s) \u2192 sq (s , t) , \\ (t , s) \u2192 sq (t , s)))\n\n#def hom2-pushout-to-square\n  ( A : U)\n  ( w x y z : A)\n  ( u : hom A w x)\n  ( f : hom A x z)\n  ( g : hom A w y)\n  ( v : hom A y z)\n  : ( \u03a3 ( d : hom A w z)\n      , ( product (hom2 A w x z u f d) (hom2 A w y z g v d)))\n    \u2192 ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n      \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n          , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 g t\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n  :=\n    \\ (d , (\u03b11 , \u03b12)) (t , s) \u2192\n    recOR\n      ( t \u2264 s \u21a6 \u03b11 (s , t)\n      , s \u2264 t \u21a6 \u03b12 (t , s))\n\n#def equiv-square-hom2-pushout\n  ( A : U)\n  ( w x y z : A)\n  ( u : hom A w x)\n  ( f : hom A x z)\n  ( g : hom A w y)\n  ( v : hom A y z)\n  : Equiv\n    ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 g t\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n    ( \u03a3 ( d : hom A w z) , (product (hom2 A w x z u f d) (hom2 A w y z g v d)))\n  :=\n    ( ( square-to-hom2-pushout A w x y z u f g v)\n    , ( ( hom2-pushout-to-square A w x y z u f g v , \\ sq \u2192 refl)\n      , ( hom2-pushout-to-square A w x y z u f g v , \\ \u03b1s \u2192 refl)))\n\n#def representable-dhom-from-uncurry-hom2\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n    ( \u03a3 ( v : hom A a y)\n    , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n      \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n          , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n    ( \u03a3 ( v : hom A a y)\n      , ( \u03a3 ( d : hom A a y)\n          , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n  :=\n    total-equiv-family-equiv\n    ( hom A a y)\n    ( \\ v \u2192\n      ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n      \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n          , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n    ( \\ v \u2192\n      ( \u03a3 ( d : hom A a y)\n        , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n    ( \\ v \u2192 equiv-square-hom2-pushout A a x a y u f (id-hom A a) v)\n\n#def representable-dhom-from-hom2\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n    ( dhom-from-representable A a x y f u)\n    ( \u03a3 ( d : hom A a y)\n      , ( \u03a3 ( v : hom A a y)\n          , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n  :=\n    equiv-triple-comp\n    ( dhom-from-representable A a x y f u)\n    ( \u03a3 ( v : hom A a y)\n      , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n    ( \u03a3 ( v : hom A a y)\n      , ( \u03a3 ( d : hom A a y)\n          , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n    ( \u03a3 ( d : hom A a y)\n      , ( \u03a3 ( v : hom A a y)\n          , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n    ( uncurried-dhom-from-representable A a x y f u)\n    ( representable-dhom-from-uncurry-hom2 A a x y f u)\n    ( fubini-\u03a3 (hom A a y) (hom A a y)\n      ( \\ v d \u2192 product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))\n\n#def representable-dhom-from-hom2-dist\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n    ( dhom-from-representable A a x y f u)\n    ( \u03a3 ( d : hom A a y)\n      , ( product\n          ( hom2 A a x y u f d)\n          ( \u03a3 ( v : hom A a y) , (hom2 A a a y (id-hom A a) v d))))\n  :=\n    equiv-right-cancel\n    ( dhom-from-representable A a x y f u)\n    ( \u03a3 ( d : hom A a y)\n      , ( product\n          ( hom2 A a x y u f d)\n          ( \u03a3 ( v : hom A a y) , hom2 A a a y (id-hom A a) v d)))\n    ( \u03a3 ( d : hom A a y)\n      , ( \u03a3 ( v : hom A a y)\n          , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n    ( representable-dhom-from-hom2 A a x y f u)\n    ( total-equiv-family-equiv\n      ( hom A a y)\n      ( \\ d \u2192\n        ( product\n          ( hom2 A a x y u f d)\n          ( \u03a3 ( v : hom A a y) , (hom2 A a a y (id-hom A a) v d))))\n      ( \\ d \u2192\n        ( \u03a3 ( v : hom A a y)\n          , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))))\n      ( \\ d \u2192\n        ( distributive-product-\u03a3\n          ( hom2 A a x y u f d)\n          ( hom A a y)\n          ( \\ v \u2192 hom2 A a a y (id-hom A a) v d))))\n</code></pre> <p>Now we introduce the hypothesis that A is pre-\u221e-category.</p> <pre><code>#def representable-dhom-from-path-space-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n    ( dhom-from-representable A a x y f u)\n    ( \u03a3 ( d : hom A a y)\n      , ( product (hom2 A a x y u f d) (\u03a3 (v : hom A a y) , (v = d))))\n  :=\n    equiv-right-cancel\n    ( dhom-from-representable A a x y f u)\n    ( \u03a3 ( d : hom A a y)\n      , ( product (hom2 A a x y u f d) (\u03a3 (v : hom A a y) , (v = d))))\n    ( \u03a3 ( d : hom A a y)\n      , ( product\n          ( hom2 A a x y u f d)\n          ( \u03a3 ( v : hom A a y) , hom2 A a a y (id-hom A a) v d)))\n    ( representable-dhom-from-hom2-dist A a x y f u)\n    ( total-equiv-family-equiv\n      ( hom A a y)\n      ( \\ d \u2192 product (hom2 A a x y u f d) (\u03a3 (v : hom A a y) , (v = d)))\n      ( \\ d \u2192\n        ( product\n          ( hom2 A a x y u f d)\n          ( \u03a3 ( v : hom A a y) , hom2 A a a y (id-hom A a) v d)))\n      ( \\ d \u2192\n        ( total-equiv-family-equiv\n          ( hom2 A a x y u f d)\n          ( \\ \u03b1 \u2192 (\u03a3 (v : hom A a y) , (v = d)))\n          ( \\ \u03b1 \u2192 (\u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d))\n          ( \\ \u03b1 \u2192\n            ( total-equiv-family-equiv\n              ( hom A a y)\n              ( \\ v \u2192 (v = d))\n              ( \\ v \u2192 hom2 A a a y (id-hom A a) v d)\n              ( \\ v \u2192 (equiv-homotopy-hom2-is-pre-\u221e-category A is-pre-\u221e-category-A a y v d)))))))\n\n\n#def codomain-based-paths-contraction\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  ( d : hom A a y)\n  : Equiv\n    ( product (hom2 A a x y u f d) (\u03a3 (v : hom A a y) , (v = d)))\n    ( hom2 A a x y u f d)\n  :=\n    equiv-projection-contractible-fibers\n      ( hom2 A a x y u f d)\n      ( \\ \u03b1 \u2192 (\u03a3 (v : hom A a y) , (v = d)))\n      ( \\ \u03b1 \u2192 is-contr-codomain-based-paths (hom A a y) d)\n\n#def is-pre-\u221e-category-representable-dhom-from-hom2\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n    ( dhom-from-representable A a x y f u)\n    ( \u03a3 ( d : hom A a y) , (hom2 A a x y u f d))\n  :=\n    equiv-comp\n    ( dhom-from-representable A a x y f u)\n    ( \u03a3 ( d : hom A a y)\n    , ( product (hom2 A a x y u f d) (\u03a3 (v : hom A a y) , (v = d))))\n    ( \u03a3 ( d : hom A a y) , (hom2 A a x y u f d))\n    ( representable-dhom-from-path-space-is-pre-\u221e-category A is-pre-\u221e-category-A a x y f u)\n    ( total-equiv-family-equiv\n      ( hom A a y)\n      ( \\ d \u2192 product (hom2 A a x y u f d) (\u03a3 (v : hom A a y) , (v = d)))\n      ( \\ d \u2192 hom2 A a x y u f d)\n      ( \\ d \u2192 codomain-based-paths-contraction A a x y f u d))\n\n#def is-pre-\u221e-category-representable-dhom-from-contractible\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : is-contr (dhom-from-representable A a x y f u)\n  :=\n    is-contr-equiv-is-contr'\n      ( dhom-from-representable A a x y f u)\n      ( \u03a3 ( d : hom A a y) , (hom2 A a x y u f d))\n      ( is-pre-\u221e-category-representable-dhom-from-hom2 A is-pre-\u221e-category-A a x y f u)\n      ( is-pre-\u221e-category-A a x y u f)\n</code></pre> <p>Finally, we see that covariant hom families in a pre-\u221e-category are covariant.</p> RS17, Proposition 8.13(&lt;-)<pre><code>#def is-covariant-representable-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  : is-covariant A (\\ x \u2192 hom A a x)\n  := is-pre-\u221e-category-representable-dhom-from-contractible A is-pre-\u221e-category-A a\n</code></pre> <p>The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for pre-\u221e-categories - so instead we argue as follows:</p> RS17, Proposition 8.13(\u2192)<pre><code>#def is-pre-\u221e-category-is-covariant-representable\n  ( A : U)\n  ( corepresentable-family-is-covariant : (a : A)\n  \u2192 is-covariant A (\\ x \u2192 hom A a x))\n  : is-pre-\u221e-category A\n  :=\n    \\ x y z f g \u2192\n    is-contr-base-is-contr-\u03a3\n    ( \u03a3 ( h : hom A x z) , hom2 A x y z f g h)\n    ( \\ hk \u2192 \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v (first hk))\n    ( \\ hk \u2192 (first hk , \\ (t , s) \u2192 first hk s))\n    ( is-contr-equiv-is-contr'\n      ( \u03a3 ( hk : \u03a3 (h : hom A x z) , hom2 A x y z f g h)\n        , ( \u03a3 ( v : hom A x z) , hom2 A x x z (id-hom A x) v (first hk)))\n      ( dhom-from-representable A x y z g f)\n      ( inv-equiv\n        ( dhom-from-representable A x y z g f)\n        ( \u03a3 ( hk : \u03a3 (h : hom A x z) , hom2 A x y z f g h)\n          , ( \u03a3 ( v : hom A x z) , hom2 A x x z (id-hom A x) v (first hk)))\n        ( equiv-comp\n          ( dhom-from-representable A x y z g f)\n          ( \u03a3 ( h : hom A x z)\n            , ( product\n                ( hom2 A x y z f g h)\n                ( \u03a3 ( v : hom A x z) , hom2 A x x z (id-hom A x) v h)))\n          ( \u03a3 ( hk : \u03a3 (h : hom A x z) , hom2 A x y z f g h)\n            , ( \u03a3 ( v : hom A x z) , hom2 A x x z (id-hom A x) v (first hk)))\n          ( representable-dhom-from-hom2-dist A x y z g f)\n          ( associative-\u03a3\n            ( hom A x z)\n            ( \\ h \u2192 hom2 A x y z f g h)\n            ( \\ h _ \u2192 \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v h))))\n      ( corepresentable-family-is-covariant x y z g f))\n</code></pre> <p>While not needed to prove Proposition 8.13, it is interesting to observe that the dependent hom types in a representable family can be understood as extension types as follows.</p> <pre><code>#def cofibration-union-test\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n    ( ( ( t , s) : \u2202\u25a1)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n    ( ( ( t , s) : 2 \u00d7 2 | (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s))\n    \u2192 A [ (t \u2261 1\u2082) \u2227 (s \u2261 0\u2082) \u21a6 a\n        , ( t \u2261 1\u2082) \u2227 (s \u2261 1\u2082) \u21a6 y])\n  :=\n    cofibration-union\n    ( 2 \u00d7 2)\n    ( \\ (t , s) \u2192 (t \u2261 1\u2082) \u2227 \u0394\u00b9 s)\n    ( \\ (t , s) \u2192\n      ( ( t \u2261 0\u2082) \u2227 (\u0394\u00b9 s)) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 0\u2082)) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 1\u2082)))\n    ( \\ (t , s) \u2192 A)\n    ( \\ (t , s) \u2192\n      recOR\n        ( ( t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t))\n\n#def base-hom-rewriting\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n    ( ( ( t , s) : 2 \u00d7 2 | (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s))\n    \u2192 A [ (t \u2261 1\u2082) \u2227 (s \u2261 0\u2082) \u21a6 a\n        , ( t \u2261 1\u2082) \u2227 (s \u2261 1\u2082) \u21a6 y])\n    ( hom A a y)\n  :=\n    ( ( \\ v \u2192 (\\ r \u2192 v ((1\u2082 , r))))\n    , ( ( \\ v (t , s) \u2192 v s , \\ _ \u2192 refl)\n      , ( \\ v (_ , s) \u2192 v s , \\ _ \u2192 refl)))\n\n#def base-hom-expansion\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n    ( ( ( t , s) : \u2202\u25a1)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n    ( hom A a y)\n  :=\n    equiv-comp\n    ( ( ( t , s) : \u2202\u25a1)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n    ( ( ( t , s) : 2 \u00d7 2 | (t \u2261 1\u2082) \u2227 (\u0394\u00b9 s))\n    \u2192 A [ (t \u2261 1\u2082) \u2227 (s \u2261 0\u2082) \u21a6 a\n        , ( t \u2261 1\u2082) \u2227 (s \u2261 1\u2082) \u21a6 y])\n    ( hom A a y)\n    ( cofibration-union-test A a x y f u)\n    ( base-hom-rewriting A a x y f u)\n\n#def representable-dhom-from-expansion\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n    ( \u03a3 ( sq :\n          ( ( t , s) : \u2202\u25a1)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n      , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 (sq (1\u2082 , s))\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n    ( \u03a3 ( v : hom A a y)\n      , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n  :=\n    total-equiv-pullback-is-equiv\n    ( ( ( t , s) : \u2202\u25a1)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n    ( hom A a y)\n    ( first (base-hom-expansion A a x y f u))\n    ( second (base-hom-expansion A a x y f u))\n    ( \\ v \u2192\n      ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n      \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n          , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n\n#def representable-dhom-from-composite-expansion\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n    ( dhom-from-representable A a x y f u)\n    ( \u03a3 ( sq :\n          ( ( t , s) : \u2202\u25a1)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n      , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 (sq (1\u2082 , s))\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n  :=\n    equiv-right-cancel\n      ( dhom-from-representable A a x y f u)\n      ( \u03a3 ( sq :\n            ( ( t , s) : \u2202\u25a1)\n          \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n        , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n          \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n              , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 (sq (1\u2082 , s))\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n      ( \u03a3 ( v : hom A a y)\n        , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n          \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n              , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n              , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n      ( uncurried-dhom-from-representable A a x y f u)\n      ( representable-dhom-from-expansion A a x y f u)\n\n#def representable-dhom-from-cofibration-composition\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n    ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n    ( \u03a3 ( sq :\n          ( ( t , s) : \u2202\u25a1)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n      , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 (sq (1\u2082 , s))\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n  :=\n    cofibration-composition (2 \u00d7 2) \u0394\u00b9\u00d7\u0394\u00b9 \u2202\u25a1\n      ( \\ (t , s) \u2192\n        ( ( t \u2261 0\u2082) \u2227 (\u0394\u00b9 s)) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 0\u2082)) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 1\u2082)))\n      ( \\ ts \u2192 A)\n      ( \\ (t , s) \u2192\n        recOR\n          ( ( t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t))\n\n#def representable-dhom-from-as-extension-type\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A a x)\n  : Equiv\n      ( dhom-from-representable A a x y f u)\n      ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n      \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n  :=\n    equiv-right-cancel\n    ( dhom-from-representable A a x y f u)\n    ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n    ( \u03a3 ( sq :\n          ( ( t , s) : \u2202\u25a1)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t])\n      , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 (sq (1\u2082 , s))\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 a\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 f t]))\n    ( representable-dhom-from-composite-expansion A a x y f u)\n    ( representable-dhom-from-cofibration-composition A a x y f u)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-lifts-transport-and-uniqueness","title":"Covariant lifts, transport, and uniqueness","text":"<p>In a covariant family C over a base type A , a term u : C x may be transported along an arrow f : hom A x y to give a term in C y.</p> RS17, covariant transport from beginning of Section 8.2<pre><code>#def covariant-transport\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( u : C x)\n  : C y\n  :=\n    first (center-contraction (dhom-from A x y f C u) (is-covariant-C x y f u))\n</code></pre> RS17, covariant lift from beginning of Section 8.2<pre><code>#def covariant-lift\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( u : C x)\n  : ( dhom A x y f C u (covariant-transport A x y f C is-covariant-C u))\n  :=\n    second (center-contraction (dhom-from A x y f C u) (is-covariant-C x y f u))\n\n#def covariant-uniqueness\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( u : C x)\n  ( lift : dhom-from A x y f C u)\n  : ( covariant-transport A x y f C is-covariant-C u) = (first lift)\n  :=\n    first-path-\u03a3\n    ( C y)\n    ( \\ v \u2192 dhom A x y f C u v)\n    ( center-contraction (dhom-from A x y f C u) (is-covariant-C x y f u))\n    ( lift)\n    ( homotopy-contraction (dhom-from A x y f C u) (is-covariant-C x y f u) lift)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-functoriality","title":"Covariant functoriality","text":"<p>The covariant transport operation defines a covariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law.</p> <pre><code>#def id-dhom\n  ( A : U)\n  ( x : A)\n  ( C : A \u2192 U)\n  ( u : C x)\n  : dhom A x x (id-hom A x) C u u\n  := \\ t \u2192 u\n</code></pre> RS17, Proposition 8.16, Part 2, Covariant families preserve identities<pre><code>#def id-arr-covariant-transport\n  ( A : U)\n  ( x : A)\n  ( C : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( u : C x)\n  : ( covariant-transport A x x (id-hom A x) C is-covariant-C u) = u\n  :=\n    covariant-uniqueness\n      A x x (id-hom A x) C is-covariant-C u (u , id-dhom A x C u)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#natural-transformations","title":"Natural transformations","text":"<p>A fiberwise map between covariant families is automatically \"natural\" commuting with the covariant lifts.</p> RS17, Proposition 8.17, Covariant naturality<pre><code>#def covariant-fiberwise-transformation-application\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C D : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( \u03d5 : (z : A) \u2192 C z \u2192 D z)\n  ( u : C x)\n  : dhom-from A x y f D (\u03d5 x u)\n  :=\n    ( ( \u03d5 y (covariant-transport A x y f C is-covariant-C u))\n    , ( \\ t \u2192 \u03d5 (f t) (covariant-lift A x y f C is-covariant-C u t)))\n\n#def naturality-covariant-fiberwise-transformation\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C D : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( is-covariant-D : is-covariant A D)\n  ( \u03d5 : (z : A) \u2192 C z \u2192 D z)\n  ( u : C x)\n  : ( covariant-transport A x y f D is-covariant-D (\u03d5 x u))\n  = ( \u03d5 y (covariant-transport A x y f C is-covariant-C u))\n  :=\n    covariant-uniqueness A x y f D is-covariant-D (\u03d5 x u)\n      ( covariant-fiberwise-transformation-application\n          A x y f C D is-covariant-C \u03d5 u)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-equivalence","title":"Covariant equivalence","text":"<p>A family of types that is equivalent to a covariant family is itself covariant.</p> <p>To prove this we first show that the corresponding types of lifts with fixed domain are equivalent:</p> <pre><code>#def equiv-covariant-total-dhom\n  ( A : U)\n  ( C : A \u2192 U)\n  ( x y : A)\n  ( f : hom A x y)\n  : Equiv\n    ( ( t : \u0394\u00b9) \u2192 C (f t))\n    ( \u03a3 ( u : C x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u]))\n  :=\n    ( ( \\ h \u2192 (h 0\u2082 , \\ t \u2192 h t))\n    , ( ( \\ k t \u2192 (second k) t , \\ h \u2192 refl)\n      , ( ( \\ k t \u2192 (second k) t , \\ h \u2192 refl))))\n</code></pre> <pre><code>#section dhom-from-equivalence\n\n#variable A : U\n#variables B C : A \u2192 U\n#variable equiv-BC : (a : A) \u2192 Equiv (B a) (C a)\n#variables x y : A\n#variable f : hom A x y\n\n#def equiv-total-dhom-equiv uses (A x y)\n  : Equiv ((t : \u0394\u00b9) \u2192 B (f t)) ((t : \u0394\u00b9) \u2192 C (f t))\n  :=\n    equiv-extension-equiv-family\n      ( extext)\n      ( 2)\n      ( \u0394\u00b9)\n      ( \\ t \u2192 B (f t))\n      ( \\ t \u2192 C (f t))\n      ( \\ t \u2192 equiv-BC (f t))\n\n#def equiv-total-covariant-dhom-equiv uses (extext equiv-BC)\n  : Equiv\n    ( \u03a3 ( i : B x) , ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]))\n    ( \u03a3 ( u : C x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u]))\n  :=\n    equiv-triple-comp\n    ( \u03a3 ( i : B x) , ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]))\n    ( ( t : \u0394\u00b9) \u2192 B (f t))\n    ( ( t : \u0394\u00b9) \u2192 C (f t))\n    ( \u03a3 ( u : C x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u]))\n    ( inv-equiv\n      ( ( t : \u0394\u00b9) \u2192 B (f t))\n      ( \u03a3 ( i : B x) , ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]))\n      ( equiv-covariant-total-dhom A B x y f))\n    ( equiv-total-dhom-equiv)\n    ( equiv-covariant-total-dhom A C x y f)\n\n#def equiv-pullback-total-covariant-dhom-equiv uses (A y)\n  : Equiv\n    ( \u03a3 ( i : B x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) i]))\n    ( \u03a3 ( u : C x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u]))\n  :=\n    total-equiv-pullback-is-equiv\n      ( B x)\n      ( C x)\n      ( first (equiv-BC x))\n      ( second (equiv-BC x))\n      ( \\ u \u2192 ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u]))\n\n#def is-equiv-to-pullback-total-covariant-dhom-equiv uses (extext A y)\n  : is-equiv\n    ( \u03a3 ( i : B x) , ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]))\n    ( \u03a3 ( i : B x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) i]))\n    ( \\ (i , h) \u2192 (i , \\ t \u2192 (first (equiv-BC (f t))) (h t)))\n  :=\n    is-equiv-right-factor\n    ( \u03a3 ( i : B x) , ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]))\n    ( \u03a3 ( i : B x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) i]))\n    ( \u03a3 ( u : C x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u]))\n    ( \\ (i , h) \u2192 (i , \\ t \u2192 (first (equiv-BC (f t))) (h t)))\n    ( first (equiv-pullback-total-covariant-dhom-equiv))\n    ( second (equiv-pullback-total-covariant-dhom-equiv))\n    ( second (equiv-total-covariant-dhom-equiv))\n\n#def equiv-to-pullback-total-covariant-dhom-equiv uses (extext A y)\n  : Equiv\n    ( \u03a3 ( i : B x) , ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]))\n    ( \u03a3 ( i : B x) , ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) i]))\n  :=\n    ( \\ (i , h) \u2192 (i , \\ t \u2192 (first (equiv-BC (f t))) (h t))\n    , is-equiv-to-pullback-total-covariant-dhom-equiv)\n\n#def family-equiv-dhom-family-equiv uses (extext A y)\n  ( i : B x)\n  : Equiv\n    ( ( t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])\n    ( ( t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) i])\n  :=\n    family-equiv-total-equiv\n    ( B x)\n    ( \\ ii \u2192 ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 ii]))\n    ( \\ ii \u2192 ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) ii]))\n    ( \\ ii h t \u2192 (first (equiv-BC (f t))) (h t))\n    ( is-equiv-to-pullback-total-covariant-dhom-equiv)\n    ( i)\n\n#end dhom-from-equivalence\n</code></pre> <p>Now we introduce the hypothesis that \\(C\\) is covariant in the form of <code>has-unique-fixed-domain-lifts</code>.</p> <pre><code>#def equiv-has-unique-fixed-domain-lifts uses (extext)\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( equiv-BC : (a : A) \u2192 Equiv (B a) (C a))\n  ( has-unique-fixed-domain-lifts-C :\n    has-unique-fixed-domain-lifts A C)\n  : has-unique-fixed-domain-lifts A B\n  :=\n    \\ x y f i \u2192\n    is-contr-equiv-is-contr'\n    ( ( t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])\n    ( ( t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 (first (equiv-BC x)) i])\n    ( family-equiv-dhom-family-equiv A B C equiv-BC x y f i)\n    ( has-unique-fixed-domain-lifts-C x y f ((first (equiv-BC x)) i))\n\n#def equiv-is-covariant uses (extext)\n  ( A : U)\n  ( B C : A \u2192 U)\n  ( equiv-BC : (a : A) \u2192 Equiv (B a) (C a))\n  ( is-covariant-C : is-covariant A C)\n  : is-covariant A B\n  :=\n    ( first (has-unique-fixed-domain-lifts-iff-is-covariant A B))\n      ( equiv-has-unique-fixed-domain-lifts\n        A B C equiv-BC\n        ( ( second (has-unique-fixed-domain-lifts-iff-is-covariant A C))\n          is-covariant-C))\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-families","title":"Contravariant families","text":"<p>A family of types over a base type is contravariant if every arrow in the base has a unique lift with specified codomain.</p> <pre><code>#def dhom-to\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C : A \u2192 U)\n  ( v : C y)\n  : U\n  := (\u03a3 (u : C x) , dhom A x y f C u v)\n</code></pre> RS17, Definition 8.2, dual form<pre><code>#def is-contravariant\n  ( A : U)\n  ( C : A \u2192 U)\n  : U\n  :=\n    ( x : A) \u2192 (y : A) \u2192 (f : hom A x y) \u2192 (v : C y)\n  \u2192 is-contr (dhom-to A x y f C v)\n</code></pre> The type of contravariant families over a fixed type<pre><code>#def contravariant-family (A : U)\n  : U\n  := (\u03a3 (C : A \u2192 U) , is-contravariant A C)\n</code></pre> <p>The notion of having a unique lift with a fixed codomain may also be expressed by contractibility of the type of extensions along the codomain inclusion into the 1-simplex.</p> <pre><code>#def has-unique-fixed-codomain-lifts\n  ( A : U)\n  ( C : A \u2192 U)\n  : U\n  :=\n    ( x : A) \u2192 (y : A) \u2192 (f : hom A x y) \u2192 (v : C y)\n  \u2192 is-contr ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v])\n</code></pre> <p>These two notions of covariance are equivalent because the two types of lifts of a base arrow with fixed codomain are equivalent. Note that this is not quite an instance of Theorem 4.4 but its proof, with a very small modification, works here.</p> <pre><code>#def equiv-lifts-with-fixed-codomain\n  ( A : U)\n  ( C : A \u2192 U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( v : C y)\n  : Equiv\n      ( ( t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v])\n      ( dhom-to A x y f C v)\n  :=\n    ( ( \\ h \u2192 (h 0\u2082 , \\ t \u2192 h t))\n    , ( ( \\ fg t \u2192 (second fg) t , \\ h \u2192 refl)\n      , ( ( \\ fg t \u2192 (second fg) t , \\ h \u2192 refl))))\n</code></pre> <p>By the equivalence-invariance of contractibility, this proves the desired logical equivalence</p> RS17, Proposition 8.4<pre><code>#def has-unique-fixed-codomain-lifts-iff-is-contravariant\n  ( A : U)\n  ( C : A \u2192 U)\n  : iff\n      ( has-unique-fixed-codomain-lifts A C)\n      ( is-contravariant A C)\n  :=\n    ( ( \\ C-has-unique-lifts x y f v \u2192\n        is-contr-equiv-is-contr\n          ( ( t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v])\n          ( dhom-to A x y f C v)\n          ( equiv-lifts-with-fixed-codomain A C x y f v)\n          ( C-has-unique-lifts x y f v))\n    , ( \\ is-contravariant-C x y f v \u2192\n        is-contr-equiv-is-contr'\n          ( ( t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v])\n          ( dhom-to A x y f C v)\n          ( equiv-lifts-with-fixed-codomain A C x y f v)\n          ( is-contravariant-C x y f v)))\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#representable-contravariant-families","title":"Representable contravariant families","text":"<p>If A is a pre-\u221e-category and a : A is any term, then the family \\ x \u2192 hom A x a defines a contravariant family over A , and conversely if this family is contravariant for every a : A , then A must be a pre-\u221e-category. The proof involves a rather lengthy composition of equivalences.</p> <pre><code>#def dhom-contra-representable\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A x a)\n  ( v : hom A y a)\n  : U\n  := dhom A x y f (\\ z \u2192 hom A z a) u v\n</code></pre> <p>By uncurrying (RS 4.2) we have an equivalence:</p> <pre><code>#def uncurried-dhom-contra-representable\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( u : hom A x a)\n  ( v : hom A y a)\n  : Equiv\n    ( dhom-contra-representable A a x y f u v)\n    ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n    \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a])\n  :=\n    curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 (\\ t s \u2192 A)\n      ( \\ (t , s) \u2192\n        recOR\n        ( ( t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n        , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t\n        , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a))\n\n#def dhom-to-representable\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( v : hom A y a)\n  : U\n  := dhom-to A x y f (\\ z \u2192 hom A z a) v\n</code></pre> <p>By uncurrying (RS 4.2) we have an equivalence:</p> <pre><code>#def uncurried-dhom-to-representable\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( v : hom A y a)\n  : Equiv\n    ( dhom-to-representable A a x y f v)\n    ( \u03a3 ( u : hom A x a)\n      , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a]))\n  :=\n    total-equiv-family-equiv\n    ( hom A x a)\n    ( \\ u \u2192 dhom-contra-representable A a x y f u v)\n    ( \\ u \u2192\n      ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n      \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n          , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a]))\n    ( \\ u \u2192 uncurried-dhom-contra-representable A a x y f u v)\n\n#def representable-dhom-to-uncurry-hom2\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( v : hom A y a)\n  : Equiv\n    ( \u03a3 ( u : hom A x a)\n      , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n          , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a]))\n    ( \u03a3 ( u : hom A x a)\n    , ( \u03a3 ( d : hom A x a)\n      , product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))\n  :=\n    total-equiv-family-equiv (hom A x a)\n    ( \\ u \u2192\n      ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n      \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n          , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t\n          , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a]))\n    ( \\ u \u2192\n      \u03a3 ( d : hom A x a)\n      , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))\n    ( \\ u \u2192 equiv-square-hom2-pushout A x a y a u (id-hom A a) f v)\n\n#def representable-dhom-to-hom2\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( v : hom A y a)\n  : Equiv\n    ( dhom-to-representable A a x y f v)\n    ( \u03a3 ( d : hom A x a)\n    , ( \u03a3 ( u : hom A x a)\n      , product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))\n  :=\n    equiv-triple-comp\n    ( dhom-to-representable A a x y f v)\n    ( \u03a3 ( u : hom A x a)\n      , ( ( ( t , s) : \u0394\u00b9\u00d7\u0394\u00b9)\n        \u2192 A [ (t \u2261 0\u2082) \u2227 (\u0394\u00b9 s) \u21a6 u s\n            , ( t \u2261 1\u2082) \u2227 (\u0394\u00b9 s) \u21a6 v s\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 0\u2082) \u21a6 f t\n            , ( \u0394\u00b9 t) \u2227 (s \u2261 1\u2082) \u21a6 a]))\n    ( \u03a3 ( u : hom A x a)\n      , ( \u03a3 ( d : hom A x a)\n          , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))))\n    ( \u03a3 ( d : hom A x a)\n      , ( \u03a3 ( u : hom A x a)\n          , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))))\n    ( uncurried-dhom-to-representable A a x y f v)\n    ( representable-dhom-to-uncurry-hom2 A a x y f v)\n    ( fubini-\u03a3 (hom A x a) (hom A x a)\n      ( \\ u d \u2192 product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))\n\n#def representable-dhom-to-hom2-swap\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( v : hom A y a)\n  : Equiv\n    ( dhom-to-representable A a x y f v)\n    ( \u03a3 ( d : hom A x a)\n      , ( \u03a3 ( u : hom A x a)\n          , ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d))))\n  :=\n    equiv-comp\n      ( dhom-to-representable A a x y f v)\n      ( \u03a3 ( d : hom A x a)\n        , ( \u03a3 ( u : hom A x a)\n            , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))))\n      ( \u03a3 ( d : hom A x a)\n        , ( \u03a3 ( u : hom A x a)\n            , ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d))))\n      ( representable-dhom-to-hom2 A a x y f v)\n      ( total-equiv-family-equiv (hom A x a)\n        ( \\ d \u2192\n          \u03a3 ( u : hom A x a)\n          , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))\n        ( \\ d \u2192\n          \u03a3 ( u : hom A x a)\n          , ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d)))\n        ( \\ d \u2192 total-equiv-family-equiv (hom A x a)\n          ( \\ u \u2192 product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))\n          ( \\ u \u2192 product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d))\n          ( \\ u \u2192\n            sym-product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))))\n\n#def representable-dhom-to-hom2-dist\n  ( A : U)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( v : hom A y a)\n  : Equiv\n      ( dhom-to-representable A a x y f v)\n      ( \u03a3 ( d : hom A x a)\n        , ( product\n            ( hom2 A x y a f v d)\n            ( \u03a3 ( u : hom A x a) , hom2 A x a a u (id-hom A a) d)))\n  :=\n    equiv-right-cancel\n    ( dhom-to-representable A a x y f v)\n    ( \u03a3 ( d : hom A x a)\n      , ( product\n          ( hom2 A x y a f v d)\n          ( \u03a3 ( u : hom A x a) , hom2 A x a a u (id-hom A a) d)))\n    ( \u03a3 ( d : hom A x a)\n      , ( \u03a3 ( u : hom A x a)\n        , product\n          ( hom2 A x y a f v d)\n          ( hom2 A x a a u (id-hom A a) d)))\n    ( representable-dhom-to-hom2-swap A a x y f v)\n    ( total-equiv-family-equiv (hom A x a)\n      ( \\ d \u2192\n        ( product\n          ( hom2 A x y a f v d)\n          ( \u03a3 ( u : hom A x a) , hom2 A x a a u (id-hom A a) d)))\n      ( \\ d \u2192\n        ( \u03a3 ( u : hom A x a)\n          , ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d))))\n      ( \\ d \u2192\n        ( distributive-product-\u03a3\n          ( hom2 A x y a f v d)\n          ( hom A x a)\n          ( \\ u \u2192 hom2 A x a a u (id-hom A a) d))))\n</code></pre> <p>Now we introduce the hypothesis that A is pre-\u221e-category.</p> <pre><code>#def representable-dhom-to-path-space-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( v : hom A y a)\n  : Equiv\n    ( dhom-to-representable A a x y f v)\n    ( \u03a3 ( d : hom A x a)\n      , ( product (hom2 A x y a f v d) (\u03a3 (u : hom A x a) , (u = d))))\n  :=\n    equiv-right-cancel\n    ( dhom-to-representable A a x y f v)\n    ( \u03a3 ( d : hom A x a)\n      , ( product (hom2 A x y a f v d) (\u03a3 (u : hom A x a) , (u = d))))\n    ( \u03a3 ( d : hom A x a)\n      , ( product\n          ( hom2 A x y a f v d)\n          ( \u03a3 ( u : hom A x a) , (hom2 A x a a u (id-hom A a) d))))\n    ( representable-dhom-to-hom2-dist A a x y f v)\n    ( total-equiv-family-equiv (hom A x a)\n      ( \\ d \u2192 product (hom2 A x y a f v d) (\u03a3 (u : hom A x a) , (u = d)))\n      ( \\ d \u2192\n        product\n          ( hom2 A x y a f v d)\n          ( \u03a3 ( u : hom A x a) , hom2 A x a a u (id-hom A a) d))\n      ( \\ d \u2192\n        total-equiv-family-equiv\n          ( hom2 A x y a f v d)\n          ( \\ \u03b1 \u2192 (\u03a3 (u : hom A x a) , (u = d)))\n          ( \\ \u03b1 \u2192 (\u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d))\n          ( \\ \u03b1 \u2192\n          ( total-equiv-family-equiv\n            ( hom A x a)\n            ( \\ u \u2192 (u = d))\n            ( \\ u \u2192 hom2 A x a a u (id-hom A a) d)\n            ( \\ u \u2192 equiv-homotopy-hom2'-is-pre-\u221e-category A is-pre-\u221e-category-A x a u d)))))\n\n#def is-pre-\u221e-category-representable-dhom-to-hom2\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( v : hom A y a)\n  : Equiv\n    ( dhom-to-representable A a x y f v)\n    ( \u03a3 ( d : hom A x a) , (hom2 A x y a f v d))\n  :=\n    equiv-comp\n    ( dhom-to-representable A a x y f v)\n    ( \u03a3 ( d : hom A x a)\n      , ( product (hom2 A x y a f v d) (\u03a3 (u : hom A x a) , (u = d))))\n    ( \u03a3 ( d : hom A x a) , (hom2 A x y a f v d))\n    ( representable-dhom-to-path-space-is-pre-\u221e-category A is-pre-\u221e-category-A a x y f v)\n    ( total-equiv-family-equiv\n      ( hom A x a)\n      ( \\ d \u2192 product (hom2 A x y a f v d) (\u03a3 (u : hom A x a) , (u = d)))\n      ( \\ d \u2192 hom2 A x y a f v d)\n      ( \\ d \u2192 codomain-based-paths-contraction A x y a v f d))\n\n#def is-pre-\u221e-category-representable-dhom-to-contractible\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a x y : A)\n  ( f : hom A x y)\n  ( v : hom A y a)\n  : is-contr (dhom-to-representable A a x y f v)\n  :=\n    is-contr-equiv-is-contr'\n      ( dhom-to-representable A a x y f v)\n      ( \u03a3 ( d : hom A x a) , (hom2 A x y a f v d))\n      ( is-pre-\u221e-category-representable-dhom-to-hom2 A is-pre-\u221e-category-A a x y f v)\n      ( is-pre-\u221e-category-A x y a f v)\n</code></pre> <p>Finally, we see that contravariant hom families in a pre-\u221e-category are contravariant.</p> RS17, Proposition 8.13(&lt;-), dual<pre><code>#def is-contravariant-representable-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  : is-contravariant A (\\ x \u2192 hom A x a)\n  := is-pre-\u221e-category-representable-dhom-to-contractible A is-pre-\u221e-category-A a\n</code></pre> <p>The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for pre-\u221e-categories - so instead we argue as follows:</p> RS17, Proposition 8.13(\u2192), dual<pre><code>#def is-pre-\u221e-category-is-contravariant-representable\n  ( A : U)\n  ( representable-family-is-contravariant : (a : A)\n  \u2192 is-contravariant A (\\ x \u2192 hom A x a))\n  : is-pre-\u221e-category A\n  :=\n    \\ x y z f g \u2192\n      is-contr-base-is-contr-\u03a3\n      ( \u03a3 ( h : hom A x z) , (hom2 A x y z f g h))\n      ( \\ hk \u2192 \u03a3 (u : hom A x z) , (hom2 A x z z u (id-hom A z) (first hk)))\n      ( \\ hk \u2192 (first hk , \\ (t , s) \u2192 first hk t))\n      ( is-contr-equiv-is-contr'\n        ( \u03a3 ( hk : \u03a3 (h : hom A x z) , (hom2 A x y z f g h))\n          , ( \u03a3 ( u : hom A x z) , hom2 A x z z u (id-hom A z) (first hk)))\n        ( dhom-to-representable A z x y f g)\n        ( inv-equiv\n          ( dhom-to-representable A z x y f g)\n          ( \u03a3 ( hk : \u03a3 (h : hom A x z) , (hom2 A x y z f g h))\n            , ( \u03a3 ( u : hom A x z) , hom2 A x z z u (id-hom A z) (first hk)))\n          ( equiv-comp\n            ( dhom-to-representable A z x y f g)\n            ( \u03a3 ( h : hom A x z)\n              , ( product\n                  ( hom2 A x y z f g h)\n                  ( \u03a3 ( u : hom A x z) , hom2 A x z z u (id-hom A z) h)))\n            ( \u03a3 ( hk : \u03a3 (h : hom A x z) , (hom2 A x y z f g h))\n              , ( \u03a3 ( u : hom A x z) , hom2 A x z z u (id-hom A z) (first hk)))\n            ( representable-dhom-to-hom2-dist A z x y f g)\n            ( associative-\u03a3\n              ( hom A x z)\n              ( \\ h \u2192 hom2 A x y z f g h)\n              ( \\ h _ \u2192 \u03a3 (u : hom A x z) , (hom2 A x z z u (id-hom A z) h)))))\n              ( representable-family-is-contravariant z x y f g))\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-lifts-transport-and-uniqueness","title":"Contravariant lifts, transport, and uniqueness","text":"<p>In a contravariant family C over a base type A, a term v : C y may be transported along an arrow f : hom A x y to give a term in C x.</p> RS17, contravariant transport from beginning of Section 8.2<pre><code>#def contravariant-transport\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  ( v : C y)\n  : C x\n  :=\n    first\n      ( center-contraction (dhom-to A x y f C v) (is-contravariant-C x y f v))\n</code></pre> RS17, contravariant lift from beginning of Section 8.2<pre><code>#def contravariant-lift\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  ( v : C y)\n  : ( dhom A x y f C (contravariant-transport A x y f C is-contravariant-C v) v)\n  :=\n    second\n      ( center-contraction (dhom-to A x y f C v) (is-contravariant-C x y f v))\n\n#def contravariant-uniqueness\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  ( v : C y)\n  ( lift : dhom-to A x y f C v)\n  : ( contravariant-transport A x y f C is-contravariant-C v) = (first lift)\n  :=\n    first-path-\u03a3\n    ( C x)\n    ( \\ u \u2192 dhom A x y f C u v)\n    ( center-contraction\n      ( dhom-to A x y f C v)\n      ( is-contravariant-C x y f v))\n    ( lift)\n    ( homotopy-contraction\n      ( dhom-to A x y f C v)\n      ( is-contravariant-C x y f v)\n      ( lift))\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-functoriality","title":"Contravariant functoriality","text":"<p>The contravariant transport operation defines a comtravariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law.</p> RS17, Proposition 8.16, Part 2, dual, Contravariant families preserve identities<pre><code>#def id-arr-contravariant-transport\n  ( A : U)\n  ( x : A)\n  ( C : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  ( u : C x)\n  : ( contravariant-transport A x x (id-hom A x) C is-contravariant-C u) = u\n  :=\n    contravariant-uniqueness A x x (id-hom A x) C is-contravariant-C u\n      ( u , id-dhom A x C u)\n</code></pre>"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-natural-transformations","title":"Contravariant natural transformations","text":"<p>A fiberwise map between contrvariant families is automatically \"natural\" commuting with the contravariant lifts.</p> RS17, Proposition 8.17, dual, Contravariant naturality<pre><code>#def contravariant-fiberwise-transformation-application\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C D : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  ( \u03d5 : (z : A) \u2192 C z \u2192 D z)\n  ( v : C y)\n  : dhom-to A x y f D (\u03d5 y v)\n  :=\n    ( \u03d5 x (contravariant-transport A x y f C is-contravariant-C v)\n    , \\ t \u2192 \u03d5 (f t) (contravariant-lift A x y f C is-contravariant-C v t))\n\n#def naturality-contravariant-fiberwise-transformation\n  ( A : U)\n  ( x y : A)\n  ( f : hom A x y)\n  ( C D : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  ( is-contravariant-D : is-contravariant A D)\n  ( \u03d5 : (z : A) \u2192 C z \u2192 D z)\n  ( v : C y)\n  : ( contravariant-transport A x y f D is-contravariant-D (\u03d5 y v))\n  = ( \u03d5 x (contravariant-transport A x y f C is-contravariant-C v))\n  :=\n    contravariant-uniqueness A x y f D is-contravariant-D (\u03d5 y v)\n    ( contravariant-fiberwise-transformation-application\n        A x y f C D is-contravariant-C \u03d5 v)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/","title":"The Yoneda lemma","text":"<p>These formalisations correspond to Section 9 of the RS17 paper.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>hott/*</code> - We require various prerequisites from homotopy type theory, for   instance the axiom of function extensionality.</li> <li><code>3-simplicial-type-theory.md</code> \u2014 We rely on definitions of simplicies and their   subshapes.</li> <li><code>4-extension-types.md</code> \u2014 We use the fubini theorem and extension   extensionality.</li> <li><code>5-segal-types.md</code> - We make heavy use of the notion of pre-\u221e-categories</li> <li><code>8-covariant.md</code> - We use covariant type families.</li> </ul> <p>Some of the definitions in this file rely on function extensionality and extension extensionality:</p> <pre><code>#assume funext : FunExt\n#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#natural-transformations-involving-a-representable-functor","title":"Natural transformations involving a representable functor","text":"<p>Fix a pre-\u221e-category \\(A\\) and a term \\(a : A\\). The Yoneda lemma characterizes natural transformations from the representable type family <code>hom A a : A \u2192 U</code> to a covariant type family <code>C : A \u2192 U</code>.</p> <p>Ordinarily, such a natural transformation would involve a family of maps</p> <p><code>\u03d5 : (z : A) \u2192 hom A a z \u2192 C z</code></p> <p>together with a proof of naturality of these components, but by naturality-covariant-fiberwise-transformation naturality is automatic.</p> <pre><code>#def naturality-covariant-fiberwise-representable-transformation\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a x y : A)\n  ( f : hom A a x)\n  ( g : hom A x y)\n  ( C : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( \u03d5 : (z : A) \u2192 hom A a z \u2192 C z)\n  : ( covariant-transport A x y g C is-covariant-C (\u03d5 x f))\n  = ( \u03d5 y (comp-is-pre-\u221e-category A is-pre-\u221e-category-A a x y f g))\n  :=\n    naturality-covariant-fiberwise-transformation A x y g\n      ( \\ z \u2192 hom A a z)\n      ( C)\n      ( is-covariant-representable-is-pre-\u221e-category A is-pre-\u221e-category-A a)\n      ( is-covariant-C)\n      ( \u03d5)\n      ( f)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-maps","title":"The Yoneda maps","text":"<p>For any pre-\u221e-category \\(A\\) and term \\(a : A\\), the Yoneda lemma provides an equivalence between the type <code>(z : A) \u2192 hom A a z \u2192 C z</code> of natural transformations out of the functor <code>hom A a</code> and values in an arbitrary covariant family \\(C\\) and the type \\(C a\\).</p> <p>One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the covariant transport operation.</p> <p>The following map, <code>evid</code>, evaluates a natural transformation out of a representable functor at the identity arrow.</p> <pre><code>#def evid\n  ( A : U)\n  ( a : A)\n  ( C : A \u2192 U)\n  : ( ( z : A) \u2192 hom A a z \u2192 C z) \u2192 C a\n  := \\ \u03d5 \u2192 \u03d5 a (id-hom A a)\n</code></pre> <p>The inverse map only exists for pre-\u221e-categories.</p> <pre><code>#def yon\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  : C a \u2192 ((z : A) \u2192 hom A a z \u2192 C z)\n  := \\ u x f \u2192 covariant-transport A a x f C is-covariant-C u\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-composites","title":"The Yoneda composites","text":"<p>It remains to show that the Yoneda maps are inverses. One retraction is straightforward:</p> <pre><code>#def evid-yon\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( u : C a)\n  : ( evid A a C) ((yon A is-pre-\u221e-category-A a C is-covariant-C) u) = u\n  := id-arr-covariant-transport A a C is-covariant-C u\n</code></pre> <p>The other composite carries \\(\u03d5\\) to an a priori distinct natural transformation. We first show that these are pointwise equal at all <code>x : A</code> and <code>f : hom A a x</code> in two steps.</p> <pre><code>#section yon-evid\n\n#variable A : U\n#variable is-pre-\u221e-category-A : is-pre-\u221e-category A\n#variable a : A\n#variable C : A \u2192 U\n#variable is-covariant-C : is-covariant A C\n</code></pre> <p>The composite <code>yon-evid</code> of <code>\u03d5</code> equals <code>\u03d5</code> at all <code>x : A</code> and <code>f : hom A a x</code>.</p> <pre><code>#def yon-evid-twice-pointwise\n  ( \u03d5 : (z : A) \u2192 hom A a z \u2192 C z)\n  ( x : A)\n  ( f : hom A a x)\n  : ( ( yon A is-pre-\u221e-category-A a C is-covariant-C) ((evid A a C) \u03d5)) x f = \u03d5 x f\n  :=\n    concat\n      ( C x)\n      ( ( ( yon A is-pre-\u221e-category-A a C is-covariant-C) ((evid A a C) \u03d5)) x f)\n      ( \u03d5 x (comp-is-pre-\u221e-category A is-pre-\u221e-category-A a a x (id-hom A a) f))\n      ( \u03d5 x f)\n      ( naturality-covariant-fiberwise-representable-transformation\n        A is-pre-\u221e-category-A a a x (id-hom A a) f C is-covariant-C \u03d5)\n      ( ap\n        ( hom A a x)\n        ( C x)\n        ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A a a x (id-hom A a) f)\n        ( f)\n        ( \u03d5 x)\n        ( id-comp-is-pre-\u221e-category A is-pre-\u221e-category-A a x f))\n</code></pre> <p>By <code>funext</code>, these are equals as functions of <code>f</code> pointwise in <code>x</code>.</p> <pre><code>#def yon-evid-once-pointwise uses (funext)\n  ( \u03d5 : (z : A) \u2192 hom A a z \u2192 C z)\n  ( x : A)\n  : ( ( yon A is-pre-\u221e-category-A a C is-covariant-C) ((evid A a C) \u03d5)) x = \u03d5 x\n  :=\n    eq-htpy funext\n      ( hom A a x)\n      ( \\ f \u2192 C x)\n      ( \\ f \u2192 ((yon A is-pre-\u221e-category-A a C is-covariant-C) ((evid A a C) \u03d5)) x f)\n      ( \\ f \u2192 (\u03d5 x f))\n      ( \\ f \u2192 yon-evid-twice-pointwise \u03d5 x f)\n</code></pre> <p>By <code>funext</code> again, these are equal as functions of <code>x</code> and <code>f</code>.</p> <pre><code>#def yon-evid uses (funext)\n  ( \u03d5 : (z : A) \u2192 hom A a z \u2192 C z)\n  : ( ( yon A is-pre-\u221e-category-A a C is-covariant-C) ((evid A a C) \u03d5)) = \u03d5\n  :=\n    eq-htpy funext\n      ( A)\n      ( \\ x \u2192 (hom A a x \u2192 C x))\n      ( \\ x \u2192 ((yon A is-pre-\u221e-category-A a C is-covariant-C) ((evid A a C) \u03d5)) x)\n      ( \\ x \u2192 (\u03d5 x))\n      ( \\ x \u2192 yon-evid-once-pointwise \u03d5 x)\n\n#end yon-evid\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-lemma_1","title":"The Yoneda lemma","text":"<p>The Yoneda lemma says that evaluation at the identity defines an equivalence. This is proven combining the previous steps.</p> RS17, Theorem 9.1<pre><code>#def yoneda-lemma uses (funext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  : is-equiv ((z : A) \u2192 hom A a z \u2192 C z) (C a) (evid A a C)\n  :=\n    ( ( ( yon A is-pre-\u221e-category-A a C is-covariant-C)\n      , ( yon-evid A is-pre-\u221e-category-A a C is-covariant-C))\n    , ( ( yon A is-pre-\u221e-category-A a C is-covariant-C)\n      , ( evid-yon A is-pre-\u221e-category-A a C is-covariant-C)))\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#naturality","title":"Naturality","text":"<p>The equivalence of the Yoneda lemma is natural in both \\(a : A\\) and \\(C : A \u2192 U\\).</p> <p>Naturality in \\(a\\) follows from the fact that the maps <code>evid</code> and <code>yon</code> are fiberwise equivalences between covariant families over \\(A\\), though it requires some work to prove that the domain is covariant.</p> <pre><code>#def is-covariant-yoneda-domain uses (funext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( C : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  : is-covariant A (\\ a \u2192 (z : A) \u2192 hom A a z \u2192 C z)\n  :=\n    equiv-is-covariant\n    ( extext)\n    ( A)\n    ( \\ a \u2192 (z : A) \u2192 hom A a z \u2192 C z)\n    ( C)\n    ( \\ a \u2192 (evid A a C , yoneda-lemma A is-pre-\u221e-category-A a C is-covariant-C))\n    ( is-covariant-C)\n\n#def is-natural-in-object-evid uses (funext extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a b : A)\n  ( f : hom A a b)\n  ( C : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( \u03d5 : (z : A) \u2192 hom A a z \u2192 C z)\n  : ( covariant-transport A a b f C is-covariant-C (evid A a C \u03d5))\n  = ( evid A b C\n\n      ( covariant-transport A a b f\n        ( \\ x \u2192 (z : A) \u2192 hom A x z \u2192 C z)\n\n        ( is-covariant-yoneda-domain A is-pre-\u221e-category-A C is-covariant-C) \u03d5))\n  :=\n    naturality-covariant-fiberwise-transformation\n    ( A)\n    ( a)\n    ( b)\n    ( f)\n    ( \\ x \u2192 (z : A) \u2192 hom A x z \u2192 C z)\n    ( C)\n    ( is-covariant-yoneda-domain A is-pre-\u221e-category-A C is-covariant-C)\n    ( is-covariant-C)\n    ( \\ x \u2192 evid A x C)\n    ( \u03d5)\n\n#def is-natural-in-object-yon uses (funext extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a b : A)\n  ( f : hom A a b)\n  ( C : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( u : C a)\n  : ( covariant-transport\n      A a b f\n      ( \\ x \u2192 (z : A) \u2192 hom A x z \u2192 C z)\n      ( is-covariant-yoneda-domain A is-pre-\u221e-category-A C is-covariant-C)\n      ( yon A is-pre-\u221e-category-A a C is-covariant-C u))\n  = ( yon A is-pre-\u221e-category-A b C is-covariant-C\n      ( covariant-transport A a b f C is-covariant-C u))\n  :=\n    naturality-covariant-fiberwise-transformation\n    ( A)\n    ( a)\n    ( b)\n    ( f)\n    ( C)\n    ( \\ x \u2192 (z : A) \u2192 hom A x z \u2192 C z)\n    ( is-covariant-C)\n    ( is-covariant-yoneda-domain A is-pre-\u221e-category-A C is-covariant-C)\n    ( \\ x \u2192 yon A is-pre-\u221e-category-A x C is-covariant-C)\n    ( u)\n</code></pre> <p>Naturality in \\(C\\) is not automatic but can be proven easily:</p> RS17, Lemma 9.2(i)<pre><code>#def is-natural-in-family-evid\n  ( A : U)\n  ( a : A)\n  ( C D : A \u2192 U)\n  ( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n  ( \u03c6 : (z : A) \u2192 hom A a z \u2192 C z)\n  : ( comp ((z : A) \u2192 hom A a z \u2192 C z) (C a) (D a) (\u03c8 a) (evid A a C)) \u03c6\n  = ( comp ((z : A) \u2192 hom A a z \u2192 C z) ((z : A) \u2192 hom A a z \u2192 D z) (D a)\n    ( evid A a D) (\\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))) \u03c6\n  := refl\n</code></pre> RS17, Lemma 9.2(ii)<pre><code>#def is-natural-in-family-yon-twice-pointwise\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C D : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( is-covariant-D : is-covariant A D)\n  ( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n  ( u : C a)\n  ( x : A)\n  ( f : hom A a x)\n  : ( comp (C a) (D a) ((z : A) \u2192 hom A a z \u2192 D z)\n      ( yon A is-pre-\u221e-category-A a D is-covariant-D) (\u03c8 a)) u x f\n  = ( comp (C a) ((z : A) \u2192 hom A a z \u2192 C z) ((z : A) \u2192 hom A a z \u2192 D z)\n      ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-pre-\u221e-category-A a C is-covariant-C)) u x f\n  :=\n    naturality-covariant-fiberwise-transformation\n      A a x f C D is-covariant-C is-covariant-D \u03c8 u\n\n#def is-natural-in-family-yon-once-pointwise uses (funext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C D : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( is-covariant-D : is-covariant A D)\n  ( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n  ( u : C a)\n  ( x : A)\n  : ( comp (C a) (D a) ((z : A) \u2192 hom A a z \u2192 D z)\n      ( yon A is-pre-\u221e-category-A a D is-covariant-D) (\u03c8 a)) u x\n  = ( comp (C a) ((z : A) \u2192 hom A a z \u2192 C z) ((z : A) \u2192 hom A a z \u2192 D z)\n      ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-pre-\u221e-category-A a C is-covariant-C)) u x\n  :=\n    eq-htpy funext\n      ( hom A a x)\n      ( \\ f \u2192 D x)\n      ( \\ f \u2192\n        ( comp (C a) (D a) ((z : A) \u2192 hom A a z \u2192 D z)\n          ( yon A is-pre-\u221e-category-A a D is-covariant-D) (\u03c8 a)) u x f)\n      ( \\ f \u2192\n        ( comp (C a) ((z : A) \u2192 hom A a z \u2192 C z) ((z : A) \u2192 hom A a z \u2192 D z)\n        ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-pre-\u221e-category-A a C is-covariant-C)) u x f)\n      ( \\ f \u2192\n        is-natural-in-family-yon-twice-pointwise\n          A is-pre-\u221e-category-A a C D is-covariant-C is-covariant-D \u03c8 u x f)\n\n#def is-natural-in-family-yon uses (funext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C D : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  ( is-covariant-D : is-covariant A D)\n  ( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n  ( u : C a)\n  : ( comp (C a) (D a) ((z : A) \u2192 hom A a z \u2192 D z)\n      ( yon A is-pre-\u221e-category-A a D is-covariant-D) (\u03c8 a)) u\n  = ( comp (C a) ((z : A) \u2192 hom A a z \u2192 C z) ((z : A) \u2192 hom A a z \u2192 D z)\n      ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-pre-\u221e-category-A a C is-covariant-C)) u\n  :=\n    eq-htpy funext\n      ( A)\n      ( \\ x \u2192 hom A a x \u2192 D x)\n      ( \\ x \u2192\n        ( comp (C a) (D a) ((z : A) \u2192 hom A a z \u2192 D z)\n          ( yon A is-pre-\u221e-category-A a D is-covariant-D) (\u03c8 a)) u x)\n      ( \\ x \u2192\n        ( comp (C a) ((z : A) \u2192 hom A a z \u2192 C z) ((z : A) \u2192 hom A a z \u2192 D z)\n        ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-pre-\u221e-category-A a C is-covariant-C)) u x)\n      ( \\ x \u2192\n        is-natural-in-family-yon-once-pointwise\n          A is-pre-\u221e-category-A a C D is-covariant-C is-covariant-D \u03c8 u x)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#yoneda-for-contravariant-families","title":"Yoneda for contravariant families","text":"<p>Dually, the Yoneda lemma for contravariant type families characterizes natural transformations from the contravariant family represented by a term \\(a : A\\) in a pre-\u221e-category to a contravariant type family \\(C : A \u2192 U\\).</p> <p>By <code>naturality-contravariant-fiberwise-transformation</code> naturality is again automatic.</p> <pre><code>#def naturality-contravariant-fiberwise-representable-transformation\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a x y : A)\n  ( f : hom A y a)\n  ( g : hom A x y)\n  ( C : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  ( \u03d5 : (z : A) \u2192 hom A z a \u2192 C z)\n  : ( contravariant-transport A x y g C is-contravariant-C (\u03d5 y f))\n  = ( \u03d5 x (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y a g f))\n  :=\n    naturality-contravariant-fiberwise-transformation A x y g\n      ( \\ z \u2192 hom A z a) C\n      ( is-contravariant-representable-is-pre-\u221e-category A is-pre-\u221e-category-A a)\n      ( is-contravariant-C)\n      ( \u03d5)\n      ( f)\n</code></pre> <p>For any pre-\u221e-category \\(A\\) and term \\(a : A\\), the contravariant Yoneda lemma provides an equivalence between the type <code>(z : A) \u2192 hom A z a \u2192 C z</code> of natural transformations out of the functor <code>\\ z \u2192 hom A z a</code> and valued in an arbitrary contravariant family \\(C\\) and the type \\(C a\\).</p> <p>One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the contravariant transport operation.</p> <p>The following map, <code>contra-evid</code> evaluates a natural transformation out of a representable functor at the identity arrow.</p> <pre><code>#def contra-evid\n  ( A : U)\n  ( a : A)\n  ( C : A \u2192 U)\n  : ( ( z : A) \u2192 hom A z a \u2192 C z) \u2192 C a\n  := \\ \u03d5 \u2192 \u03d5 a (id-hom A a)\n</code></pre> <p>The inverse map only exists for pre-\u221e-categories and contravariant families.</p> <pre><code>#def contra-yon\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  : C a \u2192 ((z : A) \u2192 hom A z a \u2192 C z)\n  := \\ v z f \u2192 contravariant-transport A z a f C is-contravariant-C v\n</code></pre> <p>It remains to show that the Yoneda maps are inverses. One retraction is straightforward:</p> <pre><code>#def contra-evid-yon\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  ( v : C a)\n  : contra-evid A a C ((contra-yon A is-pre-\u221e-category-A a C is-contravariant-C) v) = v\n  := id-arr-contravariant-transport A a C is-contravariant-C v\n</code></pre> <p>The other composite carries \\(\u03d5\\) to an a priori distinct natural transformation. We first show that these are pointwise equal at all <code>x : A</code> and <code>f : hom A x a</code> in two steps.</p> <pre><code>#section contra-yon-evid\n\n#variable A : U\n#variable is-pre-\u221e-category-A : is-pre-\u221e-category A\n#variable a : A\n#variable C : A \u2192 U\n#variable is-contravariant-C : is-contravariant A C\n</code></pre> <p>The composite <code>contra-yon-evid</code> of <code>\u03d5</code> equals <code>\u03d5</code> at all <code>x : A</code> and <code>f : hom A x a</code>.</p> <pre><code>#def contra-yon-evid-twice-pointwise\n  ( \u03d5 : (z : A) \u2192 hom A z a \u2192 C z)\n  ( x : A)\n  ( f : hom A x a)\n  : ( ( contra-yon A is-pre-\u221e-category-A a C is-contravariant-C)\n        ( ( contra-evid A a C) \u03d5)) x f = \u03d5 x f\n  :=\n    concat\n      ( C x)\n      ( ( ( contra-yon A is-pre-\u221e-category-A a C is-contravariant-C)\n            ( ( contra-evid A a C) \u03d5)) x f)\n      ( \u03d5 x (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x a a f (id-hom A a)))\n      ( \u03d5 x f)\n      ( naturality-contravariant-fiberwise-representable-transformation\n          A is-pre-\u221e-category-A a x a (id-hom A a) f C is-contravariant-C \u03d5)\n      ( ap\n        ( hom A x a)\n        ( C x)\n        ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x a a f (id-hom A a))\n        ( f)\n        ( \u03d5 x)\n        ( comp-id-is-pre-\u221e-category A is-pre-\u221e-category-A x a f))\n</code></pre> <p>By <code>funext</code>, these are equals as functions of <code>f</code> pointwise in <code>x</code>.</p> <pre><code>#def contra-yon-evid-once-pointwise uses (funext)\n  ( \u03d5 : (z : A) \u2192 hom A z a \u2192 C z)\n  ( x : A)\n  : ( ( contra-yon A is-pre-\u221e-category-A a C is-contravariant-C)\n        ( ( contra-evid A a C) \u03d5)) x = \u03d5 x\n  :=\n    eq-htpy funext\n      ( hom A x a)\n      ( \\ f \u2192 C x)\n      ( \\ f \u2192\n        ( ( contra-yon A is-pre-\u221e-category-A a C is-contravariant-C)\n          ( ( contra-evid A a C) \u03d5)) x f)\n      ( \\ f \u2192 (\u03d5 x f))\n      ( \\ f \u2192 contra-yon-evid-twice-pointwise \u03d5 x f)\n</code></pre> <p>By <code>funext</code> again, these are equal as functions of <code>x</code> and <code>f</code>.</p> <pre><code>#def contra-yon-evid uses (funext)\n  ( \u03d5 : (z : A) \u2192 hom A z a \u2192 C z)\n  : contra-yon A is-pre-\u221e-category-A a C is-contravariant-C (contra-evid A a C \u03d5) = \u03d5\n  :=\n    eq-htpy funext\n      ( A)\n      ( \\ x \u2192 (hom A x a \u2192 C x))\n      ( contra-yon A is-pre-\u221e-category-A a C is-contravariant-C (contra-evid A a C \u03d5))\n      ( \u03d5)\n      ( contra-yon-evid-once-pointwise \u03d5)\n\n#end contra-yon-evid\n</code></pre> <p>The contravariant Yoneda lemma says that evaluation at the identity defines an equivalence.</p> <pre><code>#def contra-yoneda-lemma uses (funext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  : is-equiv ((z : A) \u2192 hom A z a \u2192 C z) (C a) (contra-evid A a C)\n  :=\n    ( ( ( contra-yon A is-pre-\u221e-category-A a C is-contravariant-C)\n      , ( contra-yon-evid A is-pre-\u221e-category-A a C is-contravariant-C))\n    , ( ( contra-yon A is-pre-\u221e-category-A a C is-contravariant-C)\n      , ( contra-evid-yon A is-pre-\u221e-category-A a C is-contravariant-C)))\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#contravariant-naturality","title":"Contravariant Naturality","text":"<p>The equivalence of the Yoneda lemma is natural in both \\(a : A\\) and \\(C : A \u2192 U\\).</p> <p>Naturality in \\(a\\) follows from the fact that the maps <code>evid</code> and <code>yon</code> are fiberwise equivalences between contravariant families over \\(A\\), though it requires some work, which has not yet been formalized, to prove that the domain is contravariant.</p> <p>Naturality in \\(C\\) is not automatic but can be proven easily:</p> RS17, Lemma 9.2(i), dual<pre><code>#def is-natural-in-family-contra-evid\n  ( A : U)\n  ( a : A)\n  ( C D : A \u2192 U)\n  ( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n  ( \u03c6 : (z : A) \u2192 hom A z a \u2192 C z)\n  : ( comp ((z : A) \u2192 hom A z a \u2192 C z) (C a) (D a)\n      ( \u03c8 a) (contra-evid A a C)) \u03c6\n  = ( comp ((z : A) \u2192 hom A z a \u2192 C z) ((z : A) \u2192 hom A z a \u2192 D z) (D a)\n      ( contra-evid A a D) (\\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))) \u03c6\n  := refl\n</code></pre> RS17, Lemma 9.2(ii), dual<pre><code>#def is-natural-in-family-contra-yon-twice-pointwise\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C D : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  ( is-contravariant-D : is-contravariant A D)\n  ( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n  ( u : C a)\n  ( x : A)\n  ( f : hom A x a)\n  : ( comp (C a) (D a) ((z : A) \u2192 hom A z a \u2192 D z)\n      ( contra-yon A is-pre-\u221e-category-A a D is-contravariant-D) (\u03c8 a)) u x f\n  = ( comp (C a) ((z : A) \u2192 hom A z a \u2192 C z) ((z : A) \u2192 hom A z a \u2192 D z)\n      ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))\n      ( contra-yon A is-pre-\u221e-category-A a C is-contravariant-C)) u x f\n  :=\n    naturality-contravariant-fiberwise-transformation\n      A x a f C D is-contravariant-C is-contravariant-D \u03c8 u\n\n#def is-natural-in-family-contra-yon-once-pointwise uses (funext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C D : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  ( is-contravariant-D : is-contravariant A D)\n  ( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n  ( u : C a)\n  ( x : A)\n  : ( comp (C a) (D a) ((z : A) \u2192 hom A z a \u2192 D z)\n      ( contra-yon A is-pre-\u221e-category-A a D is-contravariant-D) (\u03c8 a)) u x\n  = ( comp (C a) ((z : A) \u2192 hom A z a \u2192 C z) ((z : A) \u2192 hom A z a \u2192 D z)\n      ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))\n      ( contra-yon A is-pre-\u221e-category-A a C is-contravariant-C)) u x\n  :=\n    eq-htpy funext\n      ( hom A x a)\n      ( \\ f \u2192 D x)\n      ( \\ f \u2192\n        ( comp (C a) (D a) ((z : A) \u2192 hom A z a \u2192 D z)\n          ( contra-yon A is-pre-\u221e-category-A a D is-contravariant-D) (\u03c8 a)) u x f)\n      ( \\ f \u2192\n        ( comp (C a) ((z : A) \u2192 hom A z a \u2192 C z) ((z : A) \u2192 hom A z a \u2192 D z)\n        ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))\n        ( contra-yon A is-pre-\u221e-category-A a C is-contravariant-C)) u x f)\n      ( \\ f \u2192\n        is-natural-in-family-contra-yon-twice-pointwise\n          A is-pre-\u221e-category-A a C D is-contravariant-C is-contravariant-D \u03c8 u x f)\n\n#def is-natural-in-family-contra-yon uses (funext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C D : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  ( is-contravariant-D : is-contravariant A D)\n  ( \u03c8 : (z : A) \u2192 C z \u2192 D z)\n  ( u : C a)\n  : ( comp (C a) (D a) ((z : A) \u2192 hom A z a \u2192 D z)\n      ( contra-yon A is-pre-\u221e-category-A a D is-contravariant-D) (\u03c8 a)) u\n  = ( comp (C a) ((z : A) \u2192 hom A z a \u2192 C z) ((z : A) \u2192 hom A z a \u2192 D z)\n      ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))\n      ( contra-yon A is-pre-\u221e-category-A a C is-contravariant-C)) u\n  :=\n    eq-htpy funext\n      ( A)\n      ( \\ x \u2192 hom A x a \u2192 D x)\n      ( \\ x \u2192\n        ( comp (C a) (D a) ((z : A) \u2192 hom A z a \u2192 D z)\n          ( contra-yon A is-pre-\u221e-category-A a D is-contravariant-D) (\u03c8 a)) u x)\n      ( \\ x \u2192\n        ( comp (C a) ((z : A) \u2192 hom A z a \u2192 C z) ((z : A) \u2192 hom A z a \u2192 D z)\n        ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))\n        ( contra-yon A is-pre-\u221e-category-A a C is-contravariant-C)) u x)\n      ( \\ x \u2192\n        is-natural-in-family-contra-yon-once-pointwise\n          A is-pre-\u221e-category-A a C D is-contravariant-C is-contravariant-D \u03c8 u x)\n</code></pre> <p>From a type-theoretic perspective, the Yoneda lemma is a \u201cdirected\u201d version of the \u201ctransport\u201d operation for identity types. This suggests a \u201cdependently typed\u201d generalization of the Yoneda lemma, analogous to the full induction principle for identity types. We prove this as a special case of a result about covariant families over a type with an initial object.</p>"},{"location":"simplicial-hott/09-yoneda.rzk/#initial-objects","title":"Initial objects","text":"<p>A term \\(a\\) in a type \\(A\\) is initial if all of its mapping-out hom types are contractible.</p> RS17, Definition 9.6<pre><code>#def is-initial\n  ( A : U)\n  ( a : A)\n  : U\n  := (x : A) \u2192 is-contr (hom A a x)\n</code></pre> <p>Initial objects satisfy an induction principle relative to covariant families.</p> <pre><code>#section initial-evaluation-equivalence\n\n#variable A : U\n#variable a : A\n#variable is-initial-a : is-initial A a\n#variable C : A \u2192 U\n#variable is-covariant-C : is-covariant A C\n\n#def arrows-from-initial\n  ( x : A)\n  : hom A a x\n  := center-contraction (hom A a x) (is-initial-a x)\n\n#def identity-component-arrows-from-initial\n  : arrows-from-initial a = id-hom A a\n  := homotopy-contraction (hom A a a) (is-initial-a a) (id-hom A a)\n\n#def ind-initial uses (is-initial-a)\n  ( u : C a)\n  : ( x : A) \u2192 C x\n  :=\n    \\ x \u2192 covariant-transport A a x (arrows-from-initial x) C is-covariant-C u\n\n#def has-cov-section-ev-pt uses (is-initial-a)\n  : has-section ((x : A) \u2192 C x) (C a) (ev-pt A a C)\n  :=\n    ( ( ind-initial)\n    , ( \\ u \u2192\n        concat\n          ( C a)\n          ( covariant-transport A a a\n            ( arrows-from-initial a) C is-covariant-C u)\n          ( covariant-transport A a a\n            ( id-hom A a) C is-covariant-C u)\n          ( u)\n          ( ap\n            ( hom A a a)\n            ( C a)\n            ( arrows-from-initial a)\n            ( id-hom A a)\n            ( \\ f \u2192\n              covariant-transport A a a f C is-covariant-C u)\n            ( identity-component-arrows-from-initial))\n          ( id-arr-covariant-transport A a C is-covariant-C u)))\n\n#def ind-initial-ev-pt-pointwise uses (is-initial-a)\n  ( s : (x : A) \u2192 C x)\n  ( b : A)\n  : ind-initial (ev-pt A a C s) b = s b\n  :=\n    covariant-uniqueness\n      ( A)\n      ( a)\n      ( b)\n      ( arrows-from-initial b)\n      ( C)\n      ( is-covariant-C)\n      ( ev-pt A a C s)\n      ( ( s b , \\ t \u2192 s (arrows-from-initial b t)))\n\n#end initial-evaluation-equivalence\n</code></pre> <p>We now prove that induction from an initial element in the base of a covariant family defines an inverse equivalence to evaluation at the element.</p> RS17, Theorem 9.7<pre><code>#def is-equiv-covariant-ev-initial uses (funext)\n  ( A : U)\n  ( a : A)\n  ( is-initial-a : is-initial A a)\n  ( C : A \u2192 U)\n  ( is-covariant-C : is-covariant A C)\n  : is-equiv ((x : A) \u2192 C x) (C a) (ev-pt A a C)\n  :=\n    ( ( ( ind-initial A a is-initial-a C is-covariant-C)\n      , ( \\ s \u2192 eq-htpy\n                  funext\n                    ( A)\n                    ( C)\n                    ( ind-initial\n                        A a is-initial-a C is-covariant-C (ev-pt A a C s))\n                    ( s)\n                    ( ind-initial-ev-pt-pointwise\n                        A a is-initial-a C is-covariant-C s)))\n    , ( has-cov-section-ev-pt A a is-initial-a C is-covariant-C))\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#initial-objects-in-slice-categories","title":"Initial objects in slice categories","text":"<p>The type <code>coslice A a</code> is the type of arrows in \\(A\\) with domain \\(a\\).</p> <pre><code>#def coslice\n  ( A : U)\n  ( a : A)\n  : U\n  := \u03a3 (z : A) , (hom A a z)\n</code></pre> <p>We now show that the coslice under \\(a\\) in a pre-\u221e-category \\(A\\) has an initial object given by the identity arrow at \\(a\\). This makes use of the following equivalence.</p> <pre><code>#def equiv-hom-in-coslice\n  ( A : U)\n  ( a x : A)\n  ( f : hom A a x)\n  : Equiv\n    ( hom (coslice A a) (a , id-hom A a) (x , f))\n    ( ( t : \u0394\u00b9) \u2192 hom A a (f t) [t \u2261 0\u2082 \u21a6 id-hom A a])\n  :=\n    ( \\ h t s \u2192 (second (h s)) t\n    , ( ( \\ k s \u2192 (k 1\u2082 s , \\ t \u2192 k t s)\n      , \\ h \u2192 refl)\n    , ( \\ k s \u2192 (k 1\u2082 s , \\ t \u2192 k t s)\n      , \\ k \u2192 refl)))\n</code></pre> <p>Since \\(hom A a\\) is covariant when \\(A\\) is pre-\u221e-category, this latter type is contractible.</p> <pre><code>#def is-contr-is-pre-\u221e-category-hom-in-coslice\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a x : A)\n  ( f : hom A a x)\n  : is-contr ((t : \u0394\u00b9) \u2192 hom A a (f t) [t \u2261 0\u2082 \u21a6 id-hom A a])\n  :=\n    ( second (has-unique-fixed-domain-lifts-iff-is-covariant\n                A (\\ z \u2192 hom A a z)))\n      ( is-covariant-representable-is-pre-\u221e-category A is-pre-\u221e-category-A a)\n      ( a)\n      ( x)\n      ( f)\n      ( id-hom A a)\n</code></pre> <p>This proves the initiality of identity arrows in the coslice of a pre-\u221e-category.</p> RS17, Lemma 9.8<pre><code>#def is-initial-id-hom-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  : is-initial (coslice A a) (a , id-hom A a)\n  :=\n    \\ (x , f) \u2192\n    is-contr-equiv-is-contr'\n      ( hom (coslice A a) (a , id-hom A a) (x , f))\n      ( ( t : \u0394\u00b9) \u2192 hom A a (f t) [t \u2261 0\u2082 \u21a6 id-hom A a])\n      ( equiv-hom-in-coslice A a x f)\n      ( is-contr-is-pre-\u221e-category-hom-in-coslice A is-pre-\u221e-category-A a x f)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#dependent-yoneda-lemma","title":"Dependent Yoneda lemma","text":"<p>The dependent Yoneda lemma now follows by specializing these results.</p> <pre><code>#def dependent-evid\n  ( A : U)\n  ( a : A)\n  ( C : (coslice A a) \u2192 U)\n  : ( ( p : coslice A a) \u2192 C p) \u2192 C (a , id-hom A a)\n  := \\ s \u2192 s (a , id-hom A a)\n\n#def dependent-yoneda-lemma' uses (funext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C : (coslice A a) \u2192 U)\n  ( is-covariant-C : is-covariant (coslice A a) C)\n  : is-equiv\n      ( ( p : coslice A a) \u2192 C p)\n      ( C (a , id-hom A a))\n      ( dependent-evid A a C)\n  :=\n    is-equiv-covariant-ev-initial\n      ( coslice A a)\n      ( ( a , id-hom A a))\n      ( is-initial-id-hom-is-pre-\u221e-category A is-pre-\u221e-category-A a)\n      ( C)\n      ( is-covariant-C)\n</code></pre> <p>The actual dependent Yoneda is equivalent to the result just proven, just with an equivalent type in the domain of the evaluation map.</p> RS17, Theorem 9.5<pre><code>#def dependent-yoneda-lemma uses (funext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C : (coslice A a) \u2192 U)\n  ( is-covariant-C : is-covariant (coslice A a) C)\n  : is-equiv\n      ( ( x : A) \u2192 (f : hom A a x) \u2192 C (x , f))\n      ( C (a , id-hom A a))\n      ( \\ s \u2192 s a (id-hom A a))\n  :=\n    is-equiv-left-factor\n      ( ( p : coslice A a) \u2192 C p)\n      ( ( x : A) \u2192 (f : hom A a x) \u2192 C (x , f))\n      ( C (a , id-hom A a))\n      ( first (equiv-dependent-curry A (\\ z \u2192 hom A a z) (\\ x f \u2192 C (x , f))))\n      ( second (equiv-dependent-curry A (\\ z \u2192 hom A a z) (\\ x f \u2192 C (x , f))))\n      ( \\ s \u2192 s a (id-hom A a))\n      ( dependent-yoneda-lemma' A is-pre-\u221e-category-A a C is-covariant-C)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#final-objects","title":"Final objects","text":"<p>A term \\(a\\) in a type \\(A\\) is initial if all of its mapping-out hom types are contractible.</p> <pre><code>#def is-final\n  ( A : U)\n  ( a : A)\n  : U\n  := (x : A) \u2192 is-contr (hom A x a)\n</code></pre> <p>Final objects satisfy an induction principle relative to contravariant families.</p> <pre><code>#section final-evaluation-equivalence\n\n#variable A : U\n#variable a : A\n#variable is-final-a : is-final A a\n#variable C : A \u2192 U\n#variable is-contravariant-C : is-contravariant A C\n\n#def arrows-to-final\n  ( x : A)\n  : hom A x a\n  := center-contraction (hom A x a) (is-final-a x)\n\n#def identity-component-arrows-to-final\n  : arrows-to-final a = id-hom A a\n  := homotopy-contraction (hom A a a) (is-final-a a) (id-hom A a)\n\n#def ind-final uses (is-final-a)\n  ( u : C a)\n  : ( x : A) \u2192 C x\n  :=\n    \\ x \u2192\n    contravariant-transport A x a (arrows-to-final x) C is-contravariant-C u\n\n#def has-contra-section-ev-pt uses (is-final-a)\n  : has-section ((x : A) \u2192 C x) (C a) (ev-pt A a C)\n  :=\n    ( ( ind-final)\n    , ( \\ u \u2192\n        concat\n          ( C a)\n          ( contravariant-transport A a a\n            ( arrows-to-final a) C is-contravariant-C u)\n          ( contravariant-transport A a a\n            ( id-hom A a) C is-contravariant-C u)\n          ( u)\n          ( ap\n            ( hom A a a)\n            ( C a)\n            ( arrows-to-final a)\n            ( id-hom A a)\n            ( \\ f \u2192\n              contravariant-transport A a a f C is-contravariant-C u)\n            ( identity-component-arrows-to-final))\n          ( id-arr-contravariant-transport A a C is-contravariant-C u)))\n\n#def ind-final-ev-pt-pointwise uses (is-final-a)\n  ( s : (x : A) \u2192 C x)\n  ( b : A)\n  : ind-final (ev-pt A a C s) b = s b\n  :=\n    contravariant-uniqueness\n      ( A)\n      ( b)\n      ( a)\n      ( arrows-to-final b)\n      ( C)\n      ( is-contravariant-C)\n      ( ev-pt A a C s)\n      ( ( s b , \\ t \u2192 s (arrows-to-final b t)))\n\n#end final-evaluation-equivalence\n</code></pre> <p>We now prove that induction from a final element in the base of a contravariant family defines an inverse equivalence to evaluation at the element.</p> RS17, Theorem 9.7, dual<pre><code>#def is-equiv-contravariant-ev-final uses (funext)\n  ( A : U)\n  ( a : A)\n  ( is-final-a : is-final A a)\n  ( C : A \u2192 U)\n  ( is-contravariant-C : is-contravariant A C)\n  : is-equiv ((x : A) \u2192 C x) (C a) (ev-pt A a C)\n  :=\n    ( ( ( ind-final A a is-final-a C is-contravariant-C)\n      , ( \\ s \u2192 eq-htpy\n                  funext\n                    ( A)\n                    ( C)\n                    ( ind-final\n                        A a is-final-a C is-contravariant-C (ev-pt A a C s))\n                    ( s)\n                    ( ind-final-ev-pt-pointwise\n                        A a is-final-a C is-contravariant-C s)))\n    , ( has-contra-section-ev-pt A a is-final-a C is-contravariant-C))\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#final-objects-in-slice-categories","title":"Final objects in slice categories","text":"<p>The type <code>slice A a</code> is the type of arrows in \\(A\\) with codomain \\(a\\).</p> <pre><code>#def slice\n  ( A : U)\n  ( a : A)\n  : U\n  := \u03a3 (z : A) , (hom A z a)\n</code></pre> <p>We now show that the slice over \\(a\\) in a pre-\u221e-category \\(A\\) has a final object given by the identity arrow at \\(a\\). This makes use of the following equivalence.</p> <pre><code>#def equiv-hom-in-slice\n  ( A : U)\n  ( a x : A)\n  ( f : hom A x a)\n  : Equiv\n    ( hom (slice A a) (x , f) (a , id-hom A a))\n    ( ( t : \u0394\u00b9) \u2192 hom A (f t) a [t \u2261 1\u2082 \u21a6 id-hom A a])\n  :=\n    ( \\ h t s \u2192 (second (h s)) t\n    , ( ( \\ k s \u2192 (k 0\u2082 s , \\ t \u2192 k t s)\n      , \\ h \u2192 refl)\n    , ( \\ k s \u2192 (k 0\u2082 s , \\ t \u2192 k t s)\n      , \\ k \u2192 refl)))\n</code></pre> <p>Since \\(\\ z \u2192 hom A z a\\) is contravariant when \\(A\\) is pre-\u221e-category, this latter type is contractible.</p> <pre><code>#def is-contr-is-pre-\u221e-category-hom-in-slice\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a x : A)\n  ( f : hom A x a)\n  : is-contr ((t : \u0394\u00b9) \u2192 hom A (f t) a [t \u2261 1\u2082 \u21a6 id-hom A a])\n  :=\n    ( second (has-unique-fixed-codomain-lifts-iff-is-contravariant\n                A (\\ z \u2192 hom A z a)))\n      ( is-contravariant-representable-is-pre-\u221e-category A is-pre-\u221e-category-A a)\n      ( x)\n      ( a)\n      ( f)\n      ( id-hom A a)\n</code></pre> <p>This proves the finality of identity arrows in the slice of a pre-\u221e-category.</p> RS17, Lemma 9.8, dual<pre><code>#def is-final-id-hom-is-pre-\u221e-category\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  : is-final (slice A a) (a , id-hom A a)\n  :=\n    \\ (x , f) \u2192\n    is-contr-equiv-is-contr'\n      ( hom (slice A a) (x , f) (a , id-hom A a))\n      ( ( t : \u0394\u00b9) \u2192 hom A (f t) a [t \u2261 1\u2082 \u21a6 id-hom A a])\n      ( equiv-hom-in-slice A a x f)\n      ( is-contr-is-pre-\u221e-category-hom-in-slice A is-pre-\u221e-category-A a x f)\n</code></pre>"},{"location":"simplicial-hott/09-yoneda.rzk/#contravariant-dependent-yoneda-lemma","title":"Contravariant Dependent Yoneda lemma","text":"<p>The contravariant version of the dependent Yoneda lemma now follows by specializing these results.</p> <pre><code>#def contra-dependent-evid\n  ( A : U)\n  ( a : A)\n  ( C : (slice A a) \u2192 U)\n  : ( ( p : slice A a) \u2192 C p) \u2192 C (a , id-hom A a)\n  := \\ s \u2192 s (a , id-hom A a)\n\n#def contra-dependent-yoneda-lemma' uses (funext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C : (slice A a) \u2192 U)\n  ( is-contravariant-C : is-contravariant (slice A a) C)\n  : is-equiv\n      ( ( p : slice A a) \u2192 C p)\n      ( C (a , id-hom A a))\n      ( contra-dependent-evid A a C)\n  :=\n    is-equiv-contravariant-ev-final\n      ( slice A a)\n      ( ( a , id-hom A a))\n      ( is-final-id-hom-is-pre-\u221e-category A is-pre-\u221e-category-A a)\n      ( C)\n      ( is-contravariant-C)\n</code></pre> <p>The actual contravariant dependent Yoneda is equivalent to the result just proven, just with an equivalent type in the domain of the evaluation map.</p> RS17, Theorem 9.5, dual<pre><code>#def contra-dependent-yoneda-lemma uses (funext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a : A)\n  ( C : (slice A a) \u2192 U)\n  ( is-contravariant-C : is-contravariant (slice A a) C)\n  : is-equiv\n      ( ( x : A) \u2192 (f : hom A x a) \u2192 C (x , f))\n      ( C (a , id-hom A a))\n      ( \\ s \u2192 s a (id-hom A a))\n  :=\n    is-equiv-left-factor\n      ( ( p : slice A a) \u2192 C p)\n      ( ( x : A) \u2192 (f : hom A x a) \u2192 C (x , f))\n      ( C (a , id-hom A a))\n      ( first (equiv-dependent-curry A (\\ z \u2192 hom A z a) (\\ x f \u2192 C (x , f))))\n      ( second (equiv-dependent-curry A (\\ z \u2192 hom A z a) (\\ x f \u2192 C (x , f))))\n      ( \\ s \u2192 s a (id-hom A a))\n      ( contra-dependent-yoneda-lemma'\n          A is-pre-\u221e-category-A a C is-contravariant-C)\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/","title":"\u221e-categories (Rezk types)","text":"<p>Rezk types vs \u221e-categories</p> <p>Riehl and Shulman refer to \"Rezk types\" in RS17, but here we call them \"\u221e-categories\".</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>Some of the definitions in this file rely on extension extensionality:</p> <pre><code>#assume extext : ExtExt\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/#isomorphisms","title":"Isomorphisms","text":"<pre><code>#def has-retraction-arrow\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  ( g : hom A y x)\n  : U\n  := (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y x f g) =_{hom A x x} (id-hom A x)\n\n#def Retraction-arrow\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : U\n  := \u03a3 (g : hom A y x) , (has-retraction-arrow A is-pre-\u221e-category-A x y f g)\n\n#def has-section-arrow\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  ( h : hom A y x)\n  : U\n  := (comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x y h f) =_{hom A y y} (id-hom A y)\n\n#def Section-arrow\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : U\n  := \u03a3 (h : hom A y x) , (has-section-arrow A is-pre-\u221e-category-A x y f h)\n\n#def is-iso-arrow\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : U\n  :=\n    product\n    ( Retraction-arrow A is-pre-\u221e-category-A x y f)\n    ( Section-arrow A is-pre-\u221e-category-A x y f)\n\n#def Iso\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  : U\n  := \u03a3 (f : hom A x y) , is-iso-arrow A is-pre-\u221e-category-A x y f\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/#invertible-arrows","title":"Invertible arrows","text":"<p>We now show that <code>f : hom A a x</code> is an isomorphism if and only if it is invertible, meaning <code>f</code> has a two-sided composition inverse <code>g : hom A x a</code>.</p> <pre><code>#def has-inverse-arrow\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : U\n  :=\n    \u03a3 ( g : hom A y x)\n    , product\n      ( has-retraction-arrow A is-pre-\u221e-category-A x y f g)\n      ( has-section-arrow A is-pre-\u221e-category-A x y f g)\n\n#def is-iso-arrow-has-inverse-arrow\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : ( has-inverse-arrow A is-pre-\u221e-category-A x y f) \u2192 (is-iso-arrow A is-pre-\u221e-category-A x y f)\n  :=\n    ( \\ (g , (p , q)) \u2192 ((g , p) , (g , q)))\n\n#def has-inverse-arrow-is-iso-arrow uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : ( is-iso-arrow A is-pre-\u221e-category-A x y f) \u2192 (has-inverse-arrow A is-pre-\u221e-category-A x y f)\n  :=\n    ( \\ ((g , p) , (h , q)) \u2192\n      ( g\n      , ( p\n        , ( concat\n            ( hom A y y)\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x y g f)\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x y h f)\n            ( id-hom A y)\n            ( postwhisker-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A y x y g h f\n              ( alternating-quintuple-concat\n                ( hom A y x)\n                ( g)\n                ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y y x (id-hom A y) g)\n                ( rev\n                  ( hom A y x)\n                  ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y y x (id-hom A y) g)\n                  ( g)\n                  ( id-comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x g))\n                ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y y x\n                  ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x y h f) (g))\n                ( postwhisker-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A y y x\n                  ( id-hom A y)\n                  ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x y h f)\n                  ( g)\n                  ( rev\n                    ( hom A y y)\n                    ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x y h f)\n                    ( id-hom A y)\n                    ( q)))\n                ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x x\n                  ( h)\n                  ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y x f g))\n                ( associative-is-pre-\u221e-category extext A is-pre-\u221e-category-A y x y x h f g)\n                ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x x h (id-hom A x))\n                ( prewhisker-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A y x x h\n                  ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y x f g)\n                  ( id-hom A x) p)\n                ( h)\n                ( comp-id-is-pre-\u221e-category A is-pre-\u221e-category-A y x h)))\n            ( q)))))\n</code></pre> RS17, Proposition 10.1<pre><code>#def inverse-iff-iso-arrow uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : iff (has-inverse-arrow A is-pre-\u221e-category-A x y f) (is-iso-arrow A is-pre-\u221e-category-A x y f)\n  :=\n    ( is-iso-arrow-has-inverse-arrow A is-pre-\u221e-category-A x y f\n    , has-inverse-arrow-is-iso-arrow A is-pre-\u221e-category-A x y f)\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/#being-an-isomorphism-is-a-proposition","title":"Being an isomorphism is a proposition","text":"<p>The predicate <code>is-iso-arrow</code> is a proposition.</p> <pre><code>#def has-retraction-postcomp-has-retraction uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  ( g : hom A y x)\n  ( gg : has-retraction-arrow A is-pre-\u221e-category-A x y f g)\n  : ( z : A)\n  \u2192 has-retraction (hom A z x) (hom A z y)\n      ( postcomp-is-pre-\u221e-category A is-pre-\u221e-category-A x y f z)\n  :=\n    \\ z \u2192\n    ( ( postcomp-is-pre-\u221e-category A is-pre-\u221e-category-A y x g z)\n      , \\ k \u2192\n      ( triple-concat\n        ( hom A z x)\n        ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A z y x\n          ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A z x y k f) g)\n        ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A z x x\n          k (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y x f g))\n        ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A z x x k (id-hom A x))\n        ( k)\n        ( associative-is-pre-\u221e-category extext A is-pre-\u221e-category-A z x y x k f g)\n        ( prewhisker-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A z x x k\n          ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y x f g) (id-hom A x) gg)\n        ( comp-id-is-pre-\u221e-category A is-pre-\u221e-category-A z x k)))\n\n#def has-section-postcomp-has-section uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  ( h : hom A y x)\n  ( hh : has-section-arrow A is-pre-\u221e-category-A x y f h)\n  : ( z : A)\n  \u2192 has-section (hom A z x) (hom A z y) (postcomp-is-pre-\u221e-category A is-pre-\u221e-category-A x y f z)\n  :=\n    \\ z \u2192\n    ( ( postcomp-is-pre-\u221e-category A is-pre-\u221e-category-A y x h z)\n      , \\ k \u2192\n        ( triple-concat\n          ( hom A z y)\n          ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A z x y\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A z y x k h) f)\n          ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A z y y\n            k (comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x y h f))\n          ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A z y y k (id-hom A y))\n          ( k)\n          ( associative-is-pre-\u221e-category extext A is-pre-\u221e-category-A z y x y k h f)\n          ( prewhisker-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A z y y k\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x y h f) (id-hom A y) hh)\n          ( comp-id-is-pre-\u221e-category A is-pre-\u221e-category-A z y k)))\n\n#def is-equiv-postcomp-is-iso uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  ( g : hom A y x)\n  ( gg : has-retraction-arrow A is-pre-\u221e-category-A x y f g)\n  ( h : hom A y x)\n  ( hh : has-section-arrow A is-pre-\u221e-category-A x y f h)\n  : ( z : A)\n  \u2192 is-equiv (hom A z x) (hom A z y) (postcomp-is-pre-\u221e-category A is-pre-\u221e-category-A x y f z)\n  :=\n    \\ z \u2192\n    ( ( has-retraction-postcomp-has-retraction A is-pre-\u221e-category-A x y f g gg z)\n    , ( has-section-postcomp-has-section A is-pre-\u221e-category-A x y f h hh z))\n\n#def has-retraction-precomp-has-section uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  ( h : hom A y x)\n  ( hh : has-section-arrow A is-pre-\u221e-category-A x y f h)\n  : ( z : A)\n  \u2192 has-retraction (hom A y z) (hom A x z)\n      ( precomp-is-pre-\u221e-category A is-pre-\u221e-category-A x y f z)\n  :=\n    \\ z \u2192\n    ( ( precomp-is-pre-\u221e-category A is-pre-\u221e-category-A y x h z)\n      , \\ k \u2192\n        ( triple-concat\n          ( hom A y z)\n          ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x z\n            h (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f k))\n          ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y y z\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x y h f) k)\n          ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y y z (id-hom A y) k)\n          ( k)\n          ( rev\n            ( hom A y z)\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y y z\n              ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x y h f) k)\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x z\n              h (comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z f k))\n            ( associative-is-pre-\u221e-category extext A is-pre-\u221e-category-A y x y z h f k))\n          ( postwhisker-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A y y z\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x y h f)\n            ( id-hom A y) k hh)\n          ( id-comp-is-pre-\u221e-category A is-pre-\u221e-category-A y z k)\n        )\n    )\n\n#def has-section-precomp-has-retraction uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  ( g : hom A y x)\n  ( gg : has-retraction-arrow A is-pre-\u221e-category-A x y f g)\n  : ( z : A)\n  \u2192 has-section (hom A y z) (hom A x z) (precomp-is-pre-\u221e-category A is-pre-\u221e-category-A x y f z)\n  :=\n    \\ z \u2192\n    ( ( precomp-is-pre-\u221e-category A is-pre-\u221e-category-A y x g z)\n      , \\ k \u2192\n        ( triple-concat\n          ( hom A x z)\n          ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z\n            f (comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x z g k))\n          ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x x z\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y x f g) k)\n          ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x x z\n            ( id-hom A x) k)\n          ( k)\n          ( rev\n            ( hom A x z)\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x x z\n              ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y x f g) k)\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y z\n              f (comp-is-pre-\u221e-category A is-pre-\u221e-category-A y x z g k))\n            ( associative-is-pre-\u221e-category extext A is-pre-\u221e-category-A x y x z f g k))\n          ( postwhisker-homotopy-is-pre-\u221e-category A is-pre-\u221e-category-A x x z\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A x y x f g)\n            ( id-hom A x)\n            ( k)\n            ( gg))\n          ( id-comp-is-pre-\u221e-category A is-pre-\u221e-category-A x z k)))\n\n#def is-equiv-precomp-is-iso uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  ( g : hom A y x)\n  ( gg : has-retraction-arrow A is-pre-\u221e-category-A x y f g)\n  ( h : hom A y x)\n  ( hh : has-section-arrow A is-pre-\u221e-category-A x y f h)\n  : ( z : A)\n  \u2192 is-equiv (hom A y z) (hom A x z) (precomp-is-pre-\u221e-category A is-pre-\u221e-category-A x y f z)\n  :=\n    \\ z \u2192\n      ( ( has-retraction-precomp-has-section A is-pre-\u221e-category-A x y f h hh z)\n      , ( has-section-precomp-has-retraction A is-pre-\u221e-category-A x y f g gg z))\n\n#def is-contr-Retraction-arrow-is-iso uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  ( g : hom A y x)\n  ( gg : has-retraction-arrow A is-pre-\u221e-category-A x y f g)\n  ( h : hom A y x)\n  ( hh : has-section-arrow A is-pre-\u221e-category-A x y f h)\n  : is-contr (Retraction-arrow A is-pre-\u221e-category-A x y f)\n  :=\n    ( is-contr-map-is-equiv\n      ( hom A y x)\n      ( hom A x x)\n      ( precomp-is-pre-\u221e-category A is-pre-\u221e-category-A x y f x)\n      ( is-equiv-precomp-is-iso A is-pre-\u221e-category-A x y f g gg h hh x))\n    ( id-hom A x)\n\n#def is-contr-Section-arrow-is-iso uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  ( g : hom A y x)\n  ( gg : has-retraction-arrow A is-pre-\u221e-category-A x y f g)\n  ( h : hom A y x)\n  ( hh : has-section-arrow A is-pre-\u221e-category-A x y f h)\n  : is-contr (Section-arrow A is-pre-\u221e-category-A x y f)\n  :=\n    ( is-contr-map-is-equiv\n      ( hom A y x)\n      ( hom A y y)\n      ( postcomp-is-pre-\u221e-category A is-pre-\u221e-category-A x y f y)\n      ( is-equiv-postcomp-is-iso A is-pre-\u221e-category-A x y f g gg h hh y))\n    ( id-hom A y)\n\n#def is-contr-is-iso-arrow-is-iso uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  ( g : hom A y x)\n  ( gg : has-retraction-arrow A is-pre-\u221e-category-A x y f g)\n  ( h : hom A y x)\n  ( hh : has-section-arrow A is-pre-\u221e-category-A x y f h)\n  : is-contr (is-iso-arrow A is-pre-\u221e-category-A x y f)\n  :=\n    ( is-contr-product\n      ( Retraction-arrow A is-pre-\u221e-category-A x y f)\n      ( Section-arrow A is-pre-\u221e-category-A x y f)\n      ( is-contr-Retraction-arrow-is-iso A is-pre-\u221e-category-A x y f g gg h hh)\n      ( is-contr-Section-arrow-is-iso A is-pre-\u221e-category-A x y f g gg h hh))\n</code></pre> RS17, Proposition 10.2<pre><code>#def is-prop-is-iso-arrow uses (extext)\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  ( f : hom A x y)\n  : ( is-prop (is-iso-arrow A is-pre-\u221e-category-A x y f))\n  :=\n    ( is-prop-is-contr-is-inhabited\n      ( is-iso-arrow A is-pre-\u221e-category-A x y f)\n      ( \\ is-isof \u2192\n        ( is-contr-is-iso-arrow-is-iso A is-pre-\u221e-category-A x y f\n          ( first (first is-isof))\n          ( second (first is-isof))\n          ( first (second is-isof))\n          ( second (second is-isof)))))\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/#-categories","title":"\u221e-categories","text":"<p>A pre-\u221e-category \\(A\\) is an \u221e-category just when, for all <code>x y : A</code>, the natural map from <code>x = y</code> to <code>Iso A is-pre-\u221e-category-A x y</code> is an equivalence.</p> <pre><code>#def iso-id-arrow\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  : ( x : A) \u2192 Iso A is-pre-\u221e-category-A x x\n  :=\n    \\ x \u2192\n    (\n    ( id-hom A x)\n  , (\n    (\n      ( id-hom A x)\n    , ( id-comp-is-pre-\u221e-category A is-pre-\u221e-category-A x x (id-hom A x))\n    )\n  , (\n      ( id-hom A x)\n    , ( id-comp-is-pre-\u221e-category A is-pre-\u221e-category-A x x (id-hom A x))\n    )\n      )\n  )\n\n#def iso-eq\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( x y : A)\n  : ( x = y) \u2192 Iso A is-pre-\u221e-category-A x y\n  :=\n    \\ p \u2192\n    ind-path\n      ( A)\n      ( x)\n      ( \\ y' p' \u2192 Iso A is-pre-\u221e-category-A x y')\n      ( iso-id-arrow A is-pre-\u221e-category-A x)\n      ( y)\n      ( p)\n</code></pre> RS17, Definition 10.6<pre><code>#def is-\u221e-category\n  ( A : U)\n  : U\n  :=\n    \u03a3 ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n    , ( x : A) \u2192 (y : A)\n      \u2192 is-equiv (x = y) (Iso A is-pre-\u221e-category-A x y) (iso-eq A is-pre-\u221e-category-A x y)\n\n#def is-pre-\u221e-category-is-\u221e-category\n  ( A : U)\n  ( is-\u221e-category-A : is-\u221e-category A)\n  : is-pre-\u221e-category A\n  := (first (is-\u221e-category-A))\n</code></pre>"},{"location":"simplicial-hott/10-rezk-types.rzk/#uniqueness-of-initial-and-final-objects","title":"Uniqueness of initial and final objects","text":"<p>In a pre-\u221e-category, initial objects are isomorphic.</p> <pre><code>#def iso-initial\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a b : A)\n  ( is-initial-a : is-initial A a)\n  ( is-initial-b : is-initial A b)\n  : Iso A is-pre-\u221e-category-A a b\n  :=\n    ( first (is-initial-a b)\n    , ( ( first (is-initial-b a)\n        , eq-is-contr\n            ( hom A a a)\n            ( is-initial-a a)\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A a b a\n              ( first (is-initial-a b))\n              ( first (is-initial-b a)))\n            ( id-hom A a))\n      , ( first (is-initial-b a)\n        , eq-is-contr\n            ( hom A b b)\n            ( is-initial-b b)\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A b a b\n              ( first (is-initial-b a))\n              ( first (is-initial-a b)))\n            ( id-hom A b))))\n</code></pre> <p>In a pre-\u221e-category, final objects are isomorphic.</p> <pre><code>#def iso-final\n  ( A : U)\n  ( is-pre-\u221e-category-A : is-pre-\u221e-category A)\n  ( a b : A)\n  ( is-final-a : is-final A a)\n  ( is-final-b : is-final A b)\n  ( iso : Iso A is-pre-\u221e-category-A a b)\n  : Iso A is-pre-\u221e-category-A a b\n  :=\n    ( first (is-final-b a)\n    , ( ( first (is-final-a b)\n        , eq-is-contr\n            ( hom A a a)\n            ( is-final-a a)\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A a b a\n              ( first (is-final-b a))\n              ( first (is-final-a b)))\n            ( id-hom A a))\n      , ( first (is-final-a b)\n        , eq-is-contr\n            ( hom A b b)\n            ( is-final-b b)\n            ( comp-is-pre-\u221e-category A is-pre-\u221e-category-A b a b\n              ( first (is-final-a b))\n              ( first (is-final-b a)))\n            ( id-hom A b))))\n</code></pre>"},{"location":"simplicial-hott/12-cocartesian.rzk/","title":"Cocartesian families","text":"<p>These formalizations capture cocartesian families as treated in BW23.</p> <p>The goal, for now, is not to give a general structural account as in the paper but rather to provide the definitions and results that are necessary to prove the cocartesian Yoneda Lemma.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"simplicial-hott/12-cocartesian.rzk/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>hott/*</code> - We require various prerequisites from homotopy type theory, for   instance the axiom of function extensionality.</li> <li><code>3-simplicial-type-theory.md</code> \u2014 We rely on definitions of simplicies and their   subshapes.</li> <li><code>4-extension-types.md</code> \u2014 We use the fubini theorem and extension   extensionality.</li> <li><code>5-segal-types.md</code> - We make heavy use of the notion of Segal types</li> <li><code>10-rezk-types.md</code>- We use Rezk types.</li> </ul>"},{"location":"simplicial-hott/12-cocartesian.rzk/#iso-inner-families","title":"(Iso-)Inner families","text":"<p>This is a (tentative and redundant) definition of (iso-)inner families. In the future, hopefully, these can be replaced by instances of orthogonal and LARI families.</p> <pre><code>#def is-inner-family\n  ( B : U)\n  ( P : B \u2192 U)\n  : U\n  :=\n    product\n    ( product (is-pre-\u221e-category B) (is-pre-\u221e-category (\u03a3 (b : B) , P b)))\n    ( ( b : B) \u2192 (is-pre-\u221e-category (P b)))\n\n#def is-isoinner-family\n  ( B : U)\n  ( P : B \u2192 U)\n  : U\n  :=\n    product\n    ( product (is-\u221e-category B) (is-\u221e-category (\u03a3 (b : B) , P b)))\n    ( ( b : B) \u2192 (is-\u221e-category (P b)))\n\n#def is-pre-\u221e-category-base-is-isoinner\n ( B : U)\n ( P : B \u2192 U)\n ( is-isoinner-P : is-isoinner-family B P)\n  : is-pre-\u221e-category B\n  := (is-pre-\u221e-category-is-\u221e-category B (first (first is-isoinner-P)))\n\n#def is-inner-is-isoinner\n ( B : U)\n ( P : B \u2192 U)\n ( is-isoinner-P : is-isoinner-family B P)\n  : is-inner-family B P\n  := (\n      ( is-pre-\u221e-category-is-\u221e-category B (first (first is-isoinner-P))\n      , ( is-pre-\u221e-category-is-\u221e-category (total-type B P) (second (first is-isoinner-P)))\n        )\n    , ( \\ b \u2192 (is-pre-\u221e-category-is-\u221e-category (P b) ((second is-isoinner-P) b)))\n    )\n</code></pre>"},{"location":"simplicial-hott/12-cocartesian.rzk/#dependent-composition","title":"Dependent composition","text":"<p>In an inner family, we can dependently compose arrows. To make this precise, some coherence seems to be needed going through the axiom of choice for extension types.</p> <pre><code>#def axiom-choice-dhom\n  ( B : U)\n  ( a b : B)\n  ( P : B \u2192 U)\n  ( x : P a)\n  ( y : P b)\n  : Equiv\n    ( hom (total-type B P) (a , x) (b , y))\n    ( \u03a3 ( u' : hom B a b)\n      , ( dhom B a b u' P x y)\n    )\n  :=\n  ( axiom-choice\n    2\n    \u0394\u00b9\n    \u2202\u0394\u00b9\n    ( \\ t \u2192 B)\n    ( \\ t \u2192 \\ c \u2192 (P c))\n    ( \\ t \u2192 recOR(t \u2261 0\u2082 \u21a6 a , t \u2261 1\u2082 \u21a6 b))\n    ( \\ t \u2192 recOR(t \u2261 0\u2082 \u21a6 x , t \u2261 1\u2082 \u21a6 y))\n  )\n\n#def inv-axiom-choice-dhom\n  ( B : U)\n  ( a b : B)\n  ( P : B \u2192 U)\n  ( x : P a)\n  ( y : P b)\n  : Equiv\n    ( \u03a3 ( u' : hom B a b)\n      , ( dhom B a b u' P x y)\n    )\n    ( hom (total-type B P) (a , x) (b , y))\n  :=\n    ( inv-equiv\n      ( hom (total-type B P) (a , x) (b , y))\n      ( \u03a3 ( u' : hom B a b)\n        , ( dhom B a b u' P x y)\n      )\n      ( axiom-choice-dhom B a b P x y)\n    )\n\n#def axiom-choice-hom2\n  ( B : U)\n  ( a b c : B)\n  ( u : hom B a b)\n  ( v : hom B b c)\n  ( w : hom B a c)\n  ( P : B \u2192 U)\n  ( x : P a)\n  ( y : P b)\n  ( z : P c)\n  ( f : dhom B a b u P x y)\n  ( g : dhom B b c v P y z)\n  ( h : dhom B a c w P x z)\n  : Equiv\n    ( hom2 (total-type B P) (a , x) (b , y) (c , z) (\\ t \u2192 (u t , f t)) (\\ t \u2192 (v t , g t)) (\\ t \u2192 (w t , h t)))\n    ( \u03a3 ( \u03b1 : hom2 B a b c u v w)\n      , ( dhom2 B a b c u v w \u03b1 P x y z f g h)\n    )\n  :=\n  ( axiom-choice\n    ( 2 \u00d7 2)\n    \u0394\u00b2\n    \u2202\u0394\u00b2\n    ( \\ (t , s) \u2192 B)\n    ( \\ (t , s) \u2192 \\ k \u2192 (P k))\n    ( \\ (t , s) \u2192 recOR(s \u2261 0\u2082 \u21a6 u t , t \u2261 1\u2082 \u21a6 v s , s \u2261 t \u21a6 w s))\n    ( \\ (t , s) \u2192 recOR(s \u2261 0\u2082 \u21a6 f t , t \u2261 1\u2082 \u21a6 g s , s \u2261 t \u21a6 h s))\n  )\n\n#def dep-comp-is-inner-sigma\n  ( B : U)\n  ( a b c : B)\n  ( u : hom B a b)\n  ( v : hom B b c)\n  ( P : B \u2192 U)\n  ( is-inner-family-P : is-inner-family B P)\n  ( x : P a)\n  ( y : P b)\n  ( z : P c)\n  ( f : dhom B a b u P x y)\n  ( g : dhom B b c v P y z)\n  : ( \u03a3 ( w : hom B a c) , (dhom B a c w P x z))\n  :=\n        (\n        ( first (axiom-choice-dhom B a c P x z))\n\n        ( comp-is-pre-\u221e-category (total-type B P) (second (first is-inner-family-P))\n        ( a , x) (b , y) (c , z)\n        ( ( \\ t \u2192 (u t , f t)))\n        ( ( \\ t \u2192 (v t , g t)))\n        )\n        )\n\n#def proj1-dep-comp-is-inner\n  ( B : U)\n  ( a b c : B)\n  ( u : hom B a b)\n  ( v : hom B b c)\n  ( P : B \u2192 U)\n  ( is-inner-family-P : is-inner-family B P)\n  ( x : P a)\n  ( y : P b)\n  ( z : P c)\n  ( f : dhom B a b u P x y)\n  ( g : dhom B b c v P y z)\n  : hom B a c\n  := (first (dep-comp-is-inner-sigma B a b c u v P is-inner-family-P x y z f g))\n\n#def proj1-dep-comp-is-inner-alt\n  ( B : U)\n  ( a b c : B)\n  ( u : hom B a b)\n  ( v : hom B b c)\n  ( P : B \u2192 U)\n  ( is-pre-\u221e-category-B : is-pre-\u221e-category B)\n  ( is-pre-\u221e-category-total-P : is-pre-\u221e-category (total-type B P))\n  ( x : P a)\n  ( y : P b)\n  ( z : P c)\n  ( f : dhom B a b u P x y)\n  ( g : dhom B b c v P y z)\n  : ( hom B a c)\n  := (first\n      ( ( first (axiom-choice-dhom B a c P x z))\n        ( comp-is-pre-\u221e-category (total-type B P) is-pre-\u221e-category-total-P\n        ( a , x) (b , y) (c , z)\n        ( \\ t \u2192 (u t , f t))\n        ( \\ t \u2192 (v t , g t))\n        )\n      )\n  )\n\n\n#def proj\n  ( B : U)\n  ( a b : B)\n  ( u : hom B a b)\n  ( P : B \u2192 U)\n  ( x : P a)\n  ( y : P b)\n  ( f : dhom B a b u P x y)\n  : ( hom B a b)\n  := (first\n      ( ( first (axiom-choice-dhom B a b P x y))\n        ( ( \\ t \u2192 (u t , f t)))\n      )\n  )\n\n#def proj-path\n  ( B : U)\n  ( a b : B)\n  ( u : hom B a b)\n  ( P : B \u2192 U)\n  ( x : P a)\n  ( y : P b)\n  ( f : dhom B a b u P x y)\n  : u = (proj B a b u P x y f)\n  := refl\n\n#def comp-total-type-is-inner\n  ( B : U)\n  ( a b c : B)\n  ( u : hom B a b)\n  ( v : hom B b c)\n  ( P : B \u2192 U)\n  ( is-pre-\u221e-category-B : is-pre-\u221e-category B)\n  ( is-pre-\u221e-category-total-P : is-pre-\u221e-category (total-type B P))\n  ( x : P a)\n  ( y : P b)\n  ( z : P c)\n  ( f : dhom B a b u P x y)\n  ( g : dhom B b c v P y z)\n  : hom (total-type B P) (a , x) (c , z)\n  := (\n    ( first (inv-axiom-choice-dhom B a c P x z))\n    (\n     ( first (axiom-choice-dhom B a c P x z))\n      ( comp-is-pre-\u221e-category (total-type B P) is-pre-\u221e-category-total-P (a , x) (b , y) (c , z)\n     ( ( first (inv-axiom-choice-dhom B a b P x y))((\\ t \u2192 u t , \\ t \u2192 f t)))\n     ( ( first (inv-axiom-choice-dhom B b c P y z))((\\ t \u2192 v t , \\ t \u2192 g t)))\n    )\n    )\n  )\n\n#def comp2-total-type-is-inner\n  ( B : U)\n  ( a b c : B)\n  ( u : hom B a b)\n  ( v : hom B b c)\n  ( P : B \u2192 U)\n  ( is-pre-\u221e-category-B : is-pre-\u221e-category B)\n  ( is-pre-\u221e-category-total-P : is-pre-\u221e-category (total-type B P))\n  ( x : P a)\n  ( y : P b)\n  ( z : P c)\n  ( f : dhom B a b u P x y)\n  ( g : dhom B b c v P y z)\n  : hom2 (total-type B P) (a , x) (b , y) (c , z)\n    ( ( first (inv-axiom-choice-dhom B a b P x y))((\\ t \u2192 u t , \\ t \u2192 f t)))\n    ( ( first (inv-axiom-choice-dhom B b c P y z))((\\ t \u2192 v t , \\ t \u2192 g t)))\n    ( comp-total-type-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P x y z f g)\n  := (witness-comp-is-pre-\u221e-category (total-type B P) is-pre-\u221e-category-total-P  (a , x) (b , y) (c , z)\n    ( ( first (inv-axiom-choice-dhom B a b P x y))((\\ t \u2192 u t , \\ t \u2192 f t)))\n    ( ( first (inv-axiom-choice-dhom B b c P y z))((\\ t \u2192 v t , \\ t \u2192 g t)))\n   )\n\n#def proj2-comp-total-type-is-inner\n  ( B : U)\n  ( a b c : B)\n  ( u : hom B a b)\n  ( v : hom B b c)\n  ( P : B \u2192 U)\n  ( is-pre-\u221e-category-B : is-pre-\u221e-category B)\n  ( is-pre-\u221e-category-total-P : is-pre-\u221e-category (total-type B P))\n  ( x : P a)\n  ( y : P b)\n  ( z : P c)\n  ( f : dhom B a b u P x y)\n  ( g : dhom B b c v P y z)\n  : dhom B a c (first ((first (axiom-choice-dhom B a c P x z))\n    ( comp-total-type-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P x y z f g)))\n  P x z\n  :=\n  ( second ((first (axiom-choice-dhom B a c P x z))\n    ( comp-total-type-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P x y z f g)\n  )\n  )\n\n#def hom2-base-hom2-total-is-inner\n  ( B : U)\n  ( a b c : B)\n  ( u : hom B a b)\n  ( v : hom B b c)\n  ( P : B \u2192 U)\n  ( is-pre-\u221e-category-B : is-pre-\u221e-category B)\n  ( is-pre-\u221e-category-total-P : is-pre-\u221e-category (total-type B P))\n  ( x : P a)\n  ( y : P b)\n  ( z : P c)\n  ( f : dhom B a b u P x y)\n  ( g : dhom B b c v P y z)\n  : hom2 B a b c u v\n  (\n  ( first ((first (axiom-choice-dhom B a c P x z))\n    ( comp-total-type-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P x y z f g)\n  )\n  )\n  )\n  :=\n    ( ap-hom2\n    ( total-type B P)\n    B\n    ( proj-base B P)\n    ( a , x) (b , y) (c , z)\n    ( ( first (inv-axiom-choice-dhom B a b P x y))((\\ t \u2192 u t , \\ t \u2192 f t)))\n    ( ( first (inv-axiom-choice-dhom B b c P y z))((\\ t \u2192 v t , \\ t \u2192 g t)))\n    ( comp-total-type-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P x y z f g)\n    ( comp2-total-type-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P x y z f g)\n    )\n\n#def coherence-comp-is-inner\n  ( B : U)\n  ( a b c : B)\n  ( u : hom B a b)\n  ( v : hom B b c)\n  ( P : B \u2192 U)\n  ( is-pre-\u221e-category-B : is-pre-\u221e-category B)\n  ( is-pre-\u221e-category-total-P : is-pre-\u221e-category (total-type B P))\n  ( x : P a)\n  ( y : P b)\n  ( z : P c)\n  ( f : dhom B a b u P x y)\n  ( g : dhom B b c v P y z)\n  : ( comp-is-pre-\u221e-category B is-pre-\u221e-category-B a b c u v)\n    = ( first ((first (axiom-choice-dhom B a c P x z))\n    ( comp-total-type-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P x y z f g)\n  )\n  )\n  :=\n    ( uniqueness-comp-is-pre-\u221e-category B is-pre-\u221e-category-B a b c u v\n     ( first ((first (axiom-choice-dhom B a c P x z))\n      ( comp-total-type-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P x y z f g)\n      )\n    )\n    ( hom2-base-hom2-total-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P x y z f g)\n    )\n\n#def dep-comp-is-inner\n  ( B : U)\n  ( a b c : B)\n  ( u : hom B a b)\n  ( v : hom B b c)\n  ( P : B \u2192 U)\n  ( is-pre-\u221e-category-B : is-pre-\u221e-category B)\n  ( is-pre-\u221e-category-total-P : is-pre-\u221e-category (total-type B P))\n  ( x : P a)\n  ( y : P b)\n  ( z : P c)\n  ( f : dhom B a b u P x y)\n  ( g : dhom B b c v P y z)\n  : dhom B a c (comp-is-pre-\u221e-category B is-pre-\u221e-category-B a b c u v) P x z\n  :=\n  ( transport\n\n    ( hom B a c)\n\n    ( \\ w \u2192 dhom B a c w P x z)\n\n    ( first ((first (axiom-choice-dhom B a c P x z))\n    ( comp-total-type-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P x y z f g)))\n\n    ( comp-is-pre-\u221e-category B is-pre-\u221e-category-B a b c u v)\n\n    ( rev (hom B a c)\n       ( comp-is-pre-\u221e-category B is-pre-\u221e-category-B a b c u v)\n       ( first ((first (axiom-choice-dhom B a c P x z))\n    ( comp-total-type-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P x y z f g)))\n     ( coherence-comp-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P x y z f g)\n    )\n\n    ( proj2-comp-total-type-is-inner B a b c u v P is-pre-\u221e-category-B is-pre-\u221e-category-total-P\n     x y z f g)\n\n  )\n\n#def dep-comp-is-isoinner\n  ( B : U)\n  ( a b c : B)\n  ( u : hom B a b)\n  ( v : hom B b c)\n  ( P : B \u2192 U)\n  ( is-isoinner-P : is-isoinner-family B P)\n  ( x : P a)\n  ( y : P b)\n  ( z : P c)\n  ( f : dhom B a b u P x y)\n  ( g : dhom B b c v P y z)\n  : dhom B a c (comp-is-pre-\u221e-category B (first (first (is-inner-is-isoinner B P is-isoinner-P))) a b c u v) P x z\n  :=\n  ( dep-comp-is-inner B a b c u v P (first (first (is-inner-is-isoinner B P is-isoinner-P)))\n   ( second (first (is-inner-is-isoinner B P is-isoinner-P)))\n   x y z f g)\n</code></pre>"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-arrows","title":"Cocartesian arrows","text":"<p>Here we define the proposition that a dependent arrow in a family is cocartesian. This is an alternative version using unpacked extension types, as this is preferred for usage.</p> <pre><code>#def filling-data-cocartesian\n  ( B : U)\n  ( b b' b'' : B)\n  ( u : hom B b b')\n  ( v : hom B b' b'')\n  ( w : hom B b b'')\n  ( sigma : hom2 B b b' b'' u v w)\n  ( P : B \u2192 U)\n  ( e : P b)\n  ( e' : P b')\n  ( e'' : P b'')\n  ( f : dhom B b b' u P e e')\n  ( h : dhom B b b'' w P e e'')\n  : U\n  := \u03a3 (g : dhom B b' b'' v P e' e'')\n        , ( dhom2 B b b' b'' u v w sigma P e e' e'' f g h)\n</code></pre> BW23, Definition 5.1.1<pre><code>#def is-cocartesian-arrow\n  ( B : U)\n  ( b b' : B)\n  ( u : hom B b b')\n  ( P : B \u2192 U)\n  ( e : P b)\n  ( e' : P b')\n  ( f : dhom B b b' u P e e')\n  : U\n  :=\n    ( b'' : B) \u2192 (v : hom B b' b'') \u2192 (w : hom B b b'')\n    \u2192 ( sigma : hom2 B b b' b'' u v w) \u2192 (e'' : P b'')\n    \u2192 ( h : dhom B b b'' w P e e'')\n    \u2192 is-contr (filling-data-cocartesian B b b' b'' u v w sigma\n        P e e' e'' f h)\n</code></pre> <pre><code>#def cocartesian-arrow\n  ( B : U)\n  ( b b' : B)\n  ( u : hom B b b')\n  ( P : B \u2192 U)\n  ( e : P b)\n  ( e' : P b')\n  : U\n  := \u03a3 (f : dhom B b b' u P e e') , (is-cocartesian-arrow B b b' u P e e' f)\n</code></pre> <pre><code>#def filling-data-is-cocartesian\n  ( B : U)\n  ( b b' b'' : B)\n  ( u : hom B b b')\n  ( v : hom B b' b'')\n  ( w : hom B b b'')\n  ( sigma : hom2 B b b' b'' u v w)\n  ( P : B \u2192 U)\n  ( e : P b)\n  ( e' : P b')\n  ( e'' : P b'')\n  ( f : dhom B b b' u P e e')\n  ( is-cocartesian-arrow-f : is-cocartesian-arrow B b b' u P e e' f)\n  ( h : dhom B b b'' w P e e'')\n  : ( filling-data-cocartesian B b b' b'' u v w sigma\n        P e e' e'' f h)\n  := ((center-contraction\n       ( filling-data-cocartesian B b b' b'' u v w sigma\n        P e e' e'' f h)\n        ( is-cocartesian-arrow-f b'' v w sigma e'' h)\n        )\n        )\n\n#def filling-arrow-is-cocartesian\n  ( B : U)\n  ( b b' b'' : B)\n  ( u : hom B b b')\n  ( v : hom B b' b'')\n  ( w : hom B b b'')\n  ( sigma : hom2 B b b' b'' u v w)\n  ( P : B \u2192 U)\n  ( e : P b)\n  ( e' : P b')\n  ( e'' : P b'')\n  ( f : dhom B b b' u P e e')\n  ( is-cocartesian-arrow-f : is-cocartesian-arrow B b b' u P e e' f)\n  ( h : dhom B b b'' w P e e'')\n  : dhom B b' b'' v P e' e''\n  := (first (filling-data-is-cocartesian B b b' b'' u v w sigma\n       P e e' e'' f is-cocartesian-arrow-f h\n        )\n     )\n\n#def filling-simplex-is-cocartesian\n  ( B : U)\n  ( b b' b'' : B)\n  ( u : hom B b b')\n  ( v : hom B b' b'')\n  ( w : hom B b b'')\n  ( sigma : hom2 B b b' b'' u v w)\n  ( P : B \u2192 U)\n  ( e : P b)\n  ( e' : P b')\n  ( e'' : P b'')\n  ( f : dhom B b b' u P e e')\n  ( is-cocartesian-arrow-f : is-cocartesian-arrow B b b' u P e e' f)\n  ( h : dhom B b b'' w P e e'')\n  : ( dhom2 B b b' b'' u v w sigma P e e' e'' f\n      ( filling-arrow-is-cocartesian B b b' b'' u v w sigma P e e' e'' f is-cocartesian-arrow-f h)\n   h)\n  := (second (filling-data-is-cocartesian B b b' b'' u v w sigma\n       P e e' e'' f is-cocartesian-arrow-f h\n        )\n     )\n</code></pre>"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-lifts","title":"Cocartesian lifts","text":"<p>The following is the type of cocartesian lifts of a fixed arrow in the base with a given starting point in the fiber.</p> BW23, Definition 5.1.2<pre><code>#def cocartesian-lift\n  ( B : U)\n  ( b b' : B)\n  ( u : hom B b b')\n  ( P : B \u2192 U)\n  ( e : P b)\n  : U\n  :=\n    \u03a3 ( e' : P b')\n    , \u03a3 ( f : dhom B b b' u P e e') , is-cocartesian-arrow B b b' u P e e' f\n</code></pre>"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-family","title":"Cocartesian family","text":"<p>A family over cocartesian if it is isoinner and any arrow in the has a cocartesian lift, given a point in the fiber over the domain.</p> BW23, Definition 5.2.1<pre><code>#def has-cocartesian-lifts\n  ( B : U)\n  ( P : B \u2192 U)\n  : U\n  :=\n    ( b : B) \u2192 (b' : B) \u2192 (u : hom B b b')\n    \u2192 ( e : P b) \u2192 (\u03a3 (e' : P b')\n      , ( \u03a3 ( f : dhom B b b' u P e e') , is-cocartesian-arrow B b b' u P e e' f))\n</code></pre> BW23, Definition 5.2.2<pre><code>#def is-cocartesian-family\n  ( B : U)\n  ( P : B \u2192 U)\n  : U\n  := product (is-isoinner-family B P) (has-cocartesian-lifts B P)\n</code></pre>"}]}