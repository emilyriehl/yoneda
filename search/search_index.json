{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yoneda for \u221e-categories This is a formalization library for simplicial Homotopy Type Theory (sHoTT) with the aim of proving the Yoneda lemma for \u221e-categories following the paper \" A type theory for synthetic \u221e-categories \" [1]. This formalization project could be regarded as a companion to the article \" Could \u221e-category theory be taught to undergraduates? \" [2]. The formalizations are implemented using rzk , an experimental proof assistant for a variant of type theory with shapes developed by Nikolai Kudasov . Formalizations were contributed by Nikolai Kudasov, Emily Riehl , and Jonathan Weinberger . Another aim of this project is to compare the proof of the Yoneda lemma for \u221e-categories in simplicial HoTT with proofs of the Yoneda lemma for 1-categories in other proof assistants. To that end Sina Hazratpour has contributed a formalization in Lean3 extracted from materials he prepared to teach Introduction to Proofs at Johns Hopkins, which can be found here . References Emily Riehl & Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 Emily Riehl. Could \u221e-category theory be taught to undergraduates? Notices of the AMS. May 2023. https://www.ams.org/journals/notices/202305/noti2692/noti2692.html","title":"About"},{"location":"#yoneda-for-categories","text":"This is a formalization library for simplicial Homotopy Type Theory (sHoTT) with the aim of proving the Yoneda lemma for \u221e-categories following the paper \" A type theory for synthetic \u221e-categories \" [1]. This formalization project could be regarded as a companion to the article \" Could \u221e-category theory be taught to undergraduates? \" [2]. The formalizations are implemented using rzk , an experimental proof assistant for a variant of type theory with shapes developed by Nikolai Kudasov . Formalizations were contributed by Nikolai Kudasov, Emily Riehl , and Jonathan Weinberger . Another aim of this project is to compare the proof of the Yoneda lemma for \u221e-categories in simplicial HoTT with proofs of the Yoneda lemma for 1-categories in other proof assistants. To that end Sina Hazratpour has contributed a formalization in Lean3 extracted from materials he prepared to teach Introduction to Proofs at Johns Hopkins, which can be found here .","title":"Yoneda for \u221e-categories"},{"location":"#references","text":"Emily Riehl & Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 Emily Riehl. Could \u221e-category theory be taught to undergraduates? Notices of the AMS. May 2023. https://www.ams.org/journals/notices/202305/noti2692/noti2692.html","title":"References"},{"location":"hott/0-common/","text":"0. Common This is a literate rzk file: #lang rzk-1 Products of types #def prod (A B : U) : U := \u2211 (x : A), B -- defined to illustrate the syntax for terms in sigma types #def diagonal (A : U) (a : A) : prod A A := (a , a) The type of logical equivalences between types #def iff (A B : U) : U := prod (A -> B) (B -> A) Basic function definitions #def composition (A B C : U) -- Three types. (g : B -> C) -- The second function. (f : A -> B) -- The first function. : A -> C -- The composite function. := \\z -> g (f z) #def triple-composition (A B C D : U) (h : C -> D) (g : B -> C) (f : A -> B) : A -> D := \\z -> h (g (f z)) #def identity (A : U) (a : A) : A := a #def constant (X A : U) -- The source and target types. (a : A) -- The constant output value. : X -> A := \\x -> a Substitution -- Reindexing a type family along a function into the base type. #def reindex (A B : U) (f : B -> A) (C : A -> U) : (B -> U) := \\b -> C (f b)","title":"Common"},{"location":"hott/0-common/#0-common","text":"This is a literate rzk file: #lang rzk-1","title":"0. Common"},{"location":"hott/0-common/#products-of-types","text":"#def prod (A B : U) : U := \u2211 (x : A), B -- defined to illustrate the syntax for terms in sigma types #def diagonal (A : U) (a : A) : prod A A := (a , a)","title":"Products of types"},{"location":"hott/0-common/#the-type-of-logical-equivalences-between-types","text":"#def iff (A B : U) : U := prod (A -> B) (B -> A)","title":"The type of logical equivalences between types"},{"location":"hott/0-common/#basic-function-definitions","text":"#def composition (A B C : U) -- Three types. (g : B -> C) -- The second function. (f : A -> B) -- The first function. : A -> C -- The composite function. := \\z -> g (f z) #def triple-composition (A B C D : U) (h : C -> D) (g : B -> C) (f : A -> B) : A -> D := \\z -> h (g (f z)) #def identity (A : U) (a : A) : A := a #def constant (X A : U) -- The source and target types. (a : A) -- The constant output value. : X -> A := \\x -> a","title":"Basic function definitions"},{"location":"hott/0-common/#substitution","text":"-- Reindexing a type family along a function into the base type. #def reindex (A B : U) (f : B -> A) (C : A -> U) : (B -> U) := \\b -> C (f b)","title":"Substitution"},{"location":"hott/1-paths/","text":"1. Paths This is a literate rzk file: #lang rzk-1 Some basic path algebra -- path reversal #def rev (A : U) -- A type. (x y : A) -- Two points. (p : x = y) -- A path from x to y in A. : y = x -- The reversal will be defined by path induction on p. := idJ(A, x, \\y' p' -> y' = x, refl, y, p) -- path composition by induction on the second path #def concat (A : U) -- A type. (x y z : A) -- Three points. (p : x = y) -- A path from x to y in A. (q : y = z) -- A path from y to z in A. : (x = z) := idJ(A, y, \\z' q' -> (x = z'), p, z, q) -- an alternative construction of path composition by induction on the first path -- this is useful in situations where it's easier to induction on the first path #def altconcat (A : U) -- A type. (x y z : A) -- Three points. (p : x = y) -- A path from x to y in A. : (y = z) -> (x = z) := idJ(A, x, \\y' p' -> (y' = z) -> (x = z), \\q' -> q', y, p) -- the coherence we don't have definitionally #def refl-concat (A : U) (x y : A) (p : x = y) : (concat A x x y refl p) = p := idJ(A, x, \\y' p' -> (concat A x x y' refl p') = p', refl, y, p) -- a higher path comparing the two compositions #def concat-altconcat (A : U) -- A type. (x y z : A) -- Three points. (p : x = y) -- A path from x to y in A. : (q : y = z) -> (concat A x y z p q) = (altconcat A x y z p q) := idJ(A, x, \\y' -> \\p' -> (q' : y' =_{A} z) -> (concat A x y' z p' q') =_{x =_{A} z} altconcat A x y' z p' q', \\q' -> refl-concat A x z q', y, p) -- a higher path comparing the two compositions in the other order #def altconcat-concat (A : U) -- A type. (x y z : A) -- Three points. (p : x = y) -- A path from x to y in A. (q : y = z) -- A path from y to z in A. : (altconcat A x y z p q) = concat A x y z p q := rev (x = z) (concat A x y z p q) (altconcat A x y z p q) (concat-altconcat A x y z p q) -- concatenation of two paths with common codomain; defined using concat and rev #def zig-zag-concat (A : U) -- A type. (x y z : A) -- Three points. (p : x = y) -- A path from x to y in A. (q : z = y) -- A path from z to y in A. : (x = z) := concat A x y z p (rev A z y q) -- concatenation of two paths with common domain; defined using concat and rev #def zag-zig-concat (A : U) -- A type. (x y z : A) -- Three points. (p : y = x) -- A path from y to x in A. (q : y = z) -- A path from y to z in A. : (x = z) := concat A x y z (rev A y x p) q #def concat-right-cancel (A : U) -- A type. (x y z : A) -- Three points. (p q : x = y) -- Two paths from x to y in A. (r : y = z) -- A path from y to z in A. : ((concat A x y z p r) = (concat A x y z q r)) -> (p = q) := idJ(A, y, \\z' r' -> (H : (concat A x y z' p r') = (concat A x y z' q r')) -> (p = q), \\H -> H, z, r) -- postwhiskering paths of paths #def homotopy-concat (A : U) -- A type. (x y z : A) -- Three points. (p q : x = y) -- Two paths from x to y in A. (H : p = q) (r : y = z) : (concat A x y z p r) = (concat A x y z q r) := idJ(A, y, \\z' r' -> (concat A x y z' p r') = (concat A x y z' q r'), H, z, r) -- prewhiskering paths of paths is much harder #def concat-homotopy (A : U) (x y : A) (p : x = y) : (z : A) -> (q : y = z) -> (r : y = z) -> (H : q = r) -> (concat A x y z p q) = (concat A x y z p r) := idJ(A, x, \\y' p' -> (z : A) -> (q : y' = z) -> (r : y' = z) -> (H : q = r) -> (concat A x y' z p' q) = (concat A x y' z p' r), \\z q r H -> concat (x = z) (concat A x x z refl q) r (concat A x x z refl r) (concat (x = z) (concat A x x z refl q) q r (refl-concat A x z q) H) (rev (x = z) (concat A x x z refl r) r (refl-concat A x z r)), y, p) -- this is easier to prove for altconcat then for concat #def alt-triangle-rotation (A : U) (x y z : A) (p : x = z) (q : x = y) : (r : y = z) -> (H : p = altconcat A x y z q r) -> (altconcat A y x z (rev A x y q) p) = r := idJ(A, x, \\y' q' -> (r' : y' =_{A} z) -> (H' : p = altconcat A x y' z q' r') -> (altconcat A y' x z (rev A x y' q') p) = r', \\r' H' -> H', y, q) #def triangle-rotation (A : U) (x y z : A) (p : x = z) (q : x = y) (r : y = z) (H : p = concat A x y z q r) : (concat A y x z (rev A x y q) p) = r := concat (y = z) (concat A y x z (rev A x y q) p) (altconcat A y x z (rev A x y q) p) r (concat-altconcat A y x z (rev A x y q) p) (alt-triangle-rotation A x y z p q r (concat (x = z) p (concat A x y z q r) (altconcat A x y z q r) H (concat-altconcat A x y z q r))) -- Application of functions to paths #def ap (A B : U) (x y : A) (f : A -> B) (p : x = y) : (f x = f y) := idJ(A, x, \\y' -> \\p' -> (f x = f y'), refl, y, p) #def ap-id (A : U) (x y : A) (p : x = y) : (ap A A x y (identity A) p) = p := idJ(A, x, \\y' -> \\p' -> (ap A A x y' (\\z -> z) p') = p', refl, y, p) -- application of a function to homotopic paths yields homotopic paths #def ap-htpy (A B : U) (x y : A) (f : A -> B) (p q : x = y) (H : p = q) : (ap A B x y f p) = (ap A B x y f q) := idJ(x = y, p, \\q' H' -> (ap A B x y f p) = (ap A B x y f q'), refl, q, H) #def ap-comp (A B C : U) (x y : A) (f : A -> B) (g : B -> C) (p : x = y) : (ap A C x y (composition A B C g f) p) = (ap B C (f x) (f y) g (ap A B x y f p)) := idJ(A, x, \\y' p' -> (ap A C x y' (\\z -> g (f z)) p') = (ap B C (f x) (f y') g (ap A B x y' f p')), refl, y, p) #def rev-ap-comp (A B C : U) (x y : A) (f : A -> B) (g : B -> C) (p : x = y) : (ap B C (f x) (f y) g (ap A B x y f p)) = (ap A C x y (composition A B C g f) p) := rev (g (f x) = g (f y)) (ap A C x y (\\z -> g (f z)) p) (ap B C (f x) (f y) g (ap A B x y f p)) (ap-comp A B C x y f g p) -- transport in a type family along a path in the base #def transport (A : U) (B : A -> U) (x y : A) (p : x = y) (u : B x) : B y := idJ(A, x, \\y' p' -> B y', u, y, p) -- The lift of a base path to a path from a term in the total space to its transport. #def transport-lift (A : U) (B : A -> U) (x y : A) (p : x = y) (u : B x) : (x, u) =_{\u2211 (z : A), B z} (y, transport A B x y p u) := idJ(A, x, \\y' p' -> (x, u) =_{\u2211 (z : A), B z} (y', transport A B x y' p' u), refl, y, p) -- for later use, some higher transport #def transport2 (A : U) (B : A -> U) (x y : A) (p q : x = y) (H : p = q) (u : B x) : (transport A B x y p u) = (transport A B x y q u) := idJ(x = y, p, \\q' H' -> (transport A B x y p u) = (transport A B x y q' u), refl, q, H) -- Application of dependent functions on paths #def apd (A : U) (B : (a : A) -> U) (x y : A) (f : (z : A) -> B z) (p : x = y) : ((transport A B x y p (f x)) = f y) := idJ(A, x, \\y' -> \\p' -> ((transport A B x y' p' (f x)) = f y'), refl, y, p)","title":"Paths"},{"location":"hott/1-paths/#1-paths","text":"This is a literate rzk file: #lang rzk-1","title":"1. Paths"},{"location":"hott/1-paths/#some-basic-path-algebra","text":"-- path reversal #def rev (A : U) -- A type. (x y : A) -- Two points. (p : x = y) -- A path from x to y in A. : y = x -- The reversal will be defined by path induction on p. := idJ(A, x, \\y' p' -> y' = x, refl, y, p) -- path composition by induction on the second path #def concat (A : U) -- A type. (x y z : A) -- Three points. (p : x = y) -- A path from x to y in A. (q : y = z) -- A path from y to z in A. : (x = z) := idJ(A, y, \\z' q' -> (x = z'), p, z, q) -- an alternative construction of path composition by induction on the first path -- this is useful in situations where it's easier to induction on the first path #def altconcat (A : U) -- A type. (x y z : A) -- Three points. (p : x = y) -- A path from x to y in A. : (y = z) -> (x = z) := idJ(A, x, \\y' p' -> (y' = z) -> (x = z), \\q' -> q', y, p) -- the coherence we don't have definitionally #def refl-concat (A : U) (x y : A) (p : x = y) : (concat A x x y refl p) = p := idJ(A, x, \\y' p' -> (concat A x x y' refl p') = p', refl, y, p) -- a higher path comparing the two compositions #def concat-altconcat (A : U) -- A type. (x y z : A) -- Three points. (p : x = y) -- A path from x to y in A. : (q : y = z) -> (concat A x y z p q) = (altconcat A x y z p q) := idJ(A, x, \\y' -> \\p' -> (q' : y' =_{A} z) -> (concat A x y' z p' q') =_{x =_{A} z} altconcat A x y' z p' q', \\q' -> refl-concat A x z q', y, p) -- a higher path comparing the two compositions in the other order #def altconcat-concat (A : U) -- A type. (x y z : A) -- Three points. (p : x = y) -- A path from x to y in A. (q : y = z) -- A path from y to z in A. : (altconcat A x y z p q) = concat A x y z p q := rev (x = z) (concat A x y z p q) (altconcat A x y z p q) (concat-altconcat A x y z p q) -- concatenation of two paths with common codomain; defined using concat and rev #def zig-zag-concat (A : U) -- A type. (x y z : A) -- Three points. (p : x = y) -- A path from x to y in A. (q : z = y) -- A path from z to y in A. : (x = z) := concat A x y z p (rev A z y q) -- concatenation of two paths with common domain; defined using concat and rev #def zag-zig-concat (A : U) -- A type. (x y z : A) -- Three points. (p : y = x) -- A path from y to x in A. (q : y = z) -- A path from y to z in A. : (x = z) := concat A x y z (rev A y x p) q #def concat-right-cancel (A : U) -- A type. (x y z : A) -- Three points. (p q : x = y) -- Two paths from x to y in A. (r : y = z) -- A path from y to z in A. : ((concat A x y z p r) = (concat A x y z q r)) -> (p = q) := idJ(A, y, \\z' r' -> (H : (concat A x y z' p r') = (concat A x y z' q r')) -> (p = q), \\H -> H, z, r) -- postwhiskering paths of paths #def homotopy-concat (A : U) -- A type. (x y z : A) -- Three points. (p q : x = y) -- Two paths from x to y in A. (H : p = q) (r : y = z) : (concat A x y z p r) = (concat A x y z q r) := idJ(A, y, \\z' r' -> (concat A x y z' p r') = (concat A x y z' q r'), H, z, r) -- prewhiskering paths of paths is much harder #def concat-homotopy (A : U) (x y : A) (p : x = y) : (z : A) -> (q : y = z) -> (r : y = z) -> (H : q = r) -> (concat A x y z p q) = (concat A x y z p r) := idJ(A, x, \\y' p' -> (z : A) -> (q : y' = z) -> (r : y' = z) -> (H : q = r) -> (concat A x y' z p' q) = (concat A x y' z p' r), \\z q r H -> concat (x = z) (concat A x x z refl q) r (concat A x x z refl r) (concat (x = z) (concat A x x z refl q) q r (refl-concat A x z q) H) (rev (x = z) (concat A x x z refl r) r (refl-concat A x z r)), y, p) -- this is easier to prove for altconcat then for concat #def alt-triangle-rotation (A : U) (x y z : A) (p : x = z) (q : x = y) : (r : y = z) -> (H : p = altconcat A x y z q r) -> (altconcat A y x z (rev A x y q) p) = r := idJ(A, x, \\y' q' -> (r' : y' =_{A} z) -> (H' : p = altconcat A x y' z q' r') -> (altconcat A y' x z (rev A x y' q') p) = r', \\r' H' -> H', y, q) #def triangle-rotation (A : U) (x y z : A) (p : x = z) (q : x = y) (r : y = z) (H : p = concat A x y z q r) : (concat A y x z (rev A x y q) p) = r := concat (y = z) (concat A y x z (rev A x y q) p) (altconcat A y x z (rev A x y q) p) r (concat-altconcat A y x z (rev A x y q) p) (alt-triangle-rotation A x y z p q r (concat (x = z) p (concat A x y z q r) (altconcat A x y z q r) H (concat-altconcat A x y z q r))) -- Application of functions to paths #def ap (A B : U) (x y : A) (f : A -> B) (p : x = y) : (f x = f y) := idJ(A, x, \\y' -> \\p' -> (f x = f y'), refl, y, p) #def ap-id (A : U) (x y : A) (p : x = y) : (ap A A x y (identity A) p) = p := idJ(A, x, \\y' -> \\p' -> (ap A A x y' (\\z -> z) p') = p', refl, y, p) -- application of a function to homotopic paths yields homotopic paths #def ap-htpy (A B : U) (x y : A) (f : A -> B) (p q : x = y) (H : p = q) : (ap A B x y f p) = (ap A B x y f q) := idJ(x = y, p, \\q' H' -> (ap A B x y f p) = (ap A B x y f q'), refl, q, H) #def ap-comp (A B C : U) (x y : A) (f : A -> B) (g : B -> C) (p : x = y) : (ap A C x y (composition A B C g f) p) = (ap B C (f x) (f y) g (ap A B x y f p)) := idJ(A, x, \\y' p' -> (ap A C x y' (\\z -> g (f z)) p') = (ap B C (f x) (f y') g (ap A B x y' f p')), refl, y, p) #def rev-ap-comp (A B C : U) (x y : A) (f : A -> B) (g : B -> C) (p : x = y) : (ap B C (f x) (f y) g (ap A B x y f p)) = (ap A C x y (composition A B C g f) p) := rev (g (f x) = g (f y)) (ap A C x y (\\z -> g (f z)) p) (ap B C (f x) (f y) g (ap A B x y f p)) (ap-comp A B C x y f g p) -- transport in a type family along a path in the base #def transport (A : U) (B : A -> U) (x y : A) (p : x = y) (u : B x) : B y := idJ(A, x, \\y' p' -> B y', u, y, p) -- The lift of a base path to a path from a term in the total space to its transport. #def transport-lift (A : U) (B : A -> U) (x y : A) (p : x = y) (u : B x) : (x, u) =_{\u2211 (z : A), B z} (y, transport A B x y p u) := idJ(A, x, \\y' p' -> (x, u) =_{\u2211 (z : A), B z} (y', transport A B x y' p' u), refl, y, p) -- for later use, some higher transport #def transport2 (A : U) (B : A -> U) (x y : A) (p q : x = y) (H : p = q) (u : B x) : (transport A B x y p u) = (transport A B x y q u) := idJ(x = y, p, \\q' H' -> (transport A B x y p u) = (transport A B x y q' u), refl, q, H) -- Application of dependent functions on paths #def apd (A : U) (B : (a : A) -> U) (x y : A) (f : (z : A) -> B z) (p : x = y) : ((transport A B x y p (f x)) = f y) := idJ(A, x, \\y' -> \\p' -> ((transport A B x y' p' (f x)) = f y'), refl, y, p)","title":"Some basic path algebra"},{"location":"hott/2-contractible/","text":"2. Contractible This is a literate rzk file: #lang rzk-1 Contractible types -- contractible types #def isContr (A : U) : U := \u2211 (x : A), (y : A) -> x = y Contractible type data #def contraction-center (A : U) (Aiscontr : isContr A) : A := (first Aiscontr) -- The path from the contraction center to any point. #def contracting-htpy (A : U) (Aiscontr : isContr A) : (z : A) -> (contraction-center A Aiscontr) = z := second Aiscontr -- A path between an arbitrary pair of types in a contractible type. #def contractible-connecting-htpy (A : U) (Aiscontr : isContr A) (x y : A) : x = y := zag-zig-concat A x (contraction-center A Aiscontr) y (contracting-htpy A Aiscontr x) (contracting-htpy A Aiscontr y)","title":"Contractible"},{"location":"hott/2-contractible/#2-contractible","text":"This is a literate rzk file: #lang rzk-1","title":"2. Contractible"},{"location":"hott/2-contractible/#contractible-types","text":"-- contractible types #def isContr (A : U) : U := \u2211 (x : A), (y : A) -> x = y","title":"Contractible types"},{"location":"hott/2-contractible/#contractible-type-data","text":"#def contraction-center (A : U) (Aiscontr : isContr A) : A := (first Aiscontr) -- The path from the contraction center to any point. #def contracting-htpy (A : U) (Aiscontr : isContr A) : (z : A) -> (contraction-center A Aiscontr) = z := second Aiscontr -- A path between an arbitrary pair of types in a contractible type. #def contractible-connecting-htpy (A : U) (Aiscontr : isContr A) (x y : A) : x = y := zag-zig-concat A x (contraction-center A Aiscontr) y (contracting-htpy A Aiscontr x) (contracting-htpy A Aiscontr y)","title":"Contractible type data"},{"location":"hott/3-homotopies/","text":"3. Homotopies This is a literate rzk file: #lang rzk-1 Homotopies and their algebra -- The type of homotopies between parallel functions. #def homotopy (A B : U) -- Two types. (f g : A -> B) -- Two parallel functions. : U := (a : A) -> (f a = g a) #def homotopy-rev (A B : U) -- Two types. (f g : A -> B) -- Two parallel functions. (H : homotopy A B f g) -- A homotopy from f to g. : homotopy A B g f := \\a -> rev B (f a) (g a) (H a) -- Homotopy composition is defined in diagrammatic order like concat but unlike composition. #def homotopy-composition (A B : U) -- Two types. (f g h : A -> B) -- Three parallel functions. (H : homotopy A B f g) (K : homotopy A B g h) : homotopy A B f h := \\a -> concat B (f a) (g a) (h a) (H a) (K a) #def homotopy-postwhisker (A B C : U) -- Three types. (f g : A -> B) -- Two parallel functions. (H : homotopy A B f g) -- A homotopy from f to g. (h : B -> C) : homotopy A C (composition A B C h f) (composition A B C h g) := \\a -> ap B C (f a) (g a) h (H a) #def homotopy-prewhisker (A B C : U) -- Three types. (f g : B -> C) -- Two parallel functions (H : homotopy B C f g) (h : A -> B) : homotopy A C (composition A B C f h) (composition A B C g h) := \\a -> H (h a) Naturality -- The naturality square associated to a homotopy and a path. #def nat-htpy (A B : U) -- Two types. (f g : A -> B) -- Two parallel functions. (H : homotopy A B f g) -- A homotopy from f to g. (x y : A) (p : x = y) : (concat B (f x) (f y) (g y) (ap A B x y f p) (H y)) = (concat B (f x) (g x) (g y) (H x) (ap A B x y g p)) := idJ(A, x, \\y' p' -> (concat B (f x) (f y') (g y') (ap A B x y' f p') (H y')) = (concat B (f x) (g x) (g y') (H x) (ap A B x y' g p')), refl-concat B (f x) (g x) (H x), y, p) -- In the case of a homotopy H from f to the identity the previous square applies to the path H a to produce the following naturality square. #def a-cylinder-homotopy-coherence (A : U) (f : A -> A) (H : homotopy A A f (identity A)) (a : A) : (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = (concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a))) := nat-htpy A A f (identity A) H (f a) a (H a) -- After composing with ap-id, this naturality square transforms to the following: #def another-cylinder-homotopy-coherence (A : U) (f : A -> A) (H : homotopy A A f (identity A)) (a : A) : (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = (concat A (f (f a)) (f a) (a) (H (f a)) (H a)) := concat ((f (f a)) = a) (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) (concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a))) (concat A (f (f a)) (f a) (a) (H (f a)) (H a)) (a-cylinder-homotopy-coherence A f H a) (concat-homotopy A (f (f a)) (f a) (H (f a)) a (ap A A (f a) a (identity A) (H a)) (H a) (ap-id A (f a) a (H a))) -- Cancelling the path (H a) on the right and reversing yields a path we need: #def cylinder-homotopy-coherence (A : U) (f : A -> A) (H : homotopy A A f (identity A)) (a : A) : (H (f a)) =(ap A A (f a) a f (H a)) := rev (f (f a) = f a) (ap A A (f a) a f (H a)) (H (f a)) (concat-right-cancel A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H (f a)) (H a) (another-cylinder-homotopy-coherence A f H a))","title":"Homotopies"},{"location":"hott/3-homotopies/#3-homotopies","text":"This is a literate rzk file: #lang rzk-1","title":"3. Homotopies"},{"location":"hott/3-homotopies/#homotopies-and-their-algebra","text":"-- The type of homotopies between parallel functions. #def homotopy (A B : U) -- Two types. (f g : A -> B) -- Two parallel functions. : U := (a : A) -> (f a = g a) #def homotopy-rev (A B : U) -- Two types. (f g : A -> B) -- Two parallel functions. (H : homotopy A B f g) -- A homotopy from f to g. : homotopy A B g f := \\a -> rev B (f a) (g a) (H a) -- Homotopy composition is defined in diagrammatic order like concat but unlike composition. #def homotopy-composition (A B : U) -- Two types. (f g h : A -> B) -- Three parallel functions. (H : homotopy A B f g) (K : homotopy A B g h) : homotopy A B f h := \\a -> concat B (f a) (g a) (h a) (H a) (K a) #def homotopy-postwhisker (A B C : U) -- Three types. (f g : A -> B) -- Two parallel functions. (H : homotopy A B f g) -- A homotopy from f to g. (h : B -> C) : homotopy A C (composition A B C h f) (composition A B C h g) := \\a -> ap B C (f a) (g a) h (H a) #def homotopy-prewhisker (A B C : U) -- Three types. (f g : B -> C) -- Two parallel functions (H : homotopy B C f g) (h : A -> B) : homotopy A C (composition A B C f h) (composition A B C g h) := \\a -> H (h a)","title":"Homotopies and their algebra"},{"location":"hott/3-homotopies/#naturality","text":"-- The naturality square associated to a homotopy and a path. #def nat-htpy (A B : U) -- Two types. (f g : A -> B) -- Two parallel functions. (H : homotopy A B f g) -- A homotopy from f to g. (x y : A) (p : x = y) : (concat B (f x) (f y) (g y) (ap A B x y f p) (H y)) = (concat B (f x) (g x) (g y) (H x) (ap A B x y g p)) := idJ(A, x, \\y' p' -> (concat B (f x) (f y') (g y') (ap A B x y' f p') (H y')) = (concat B (f x) (g x) (g y') (H x) (ap A B x y' g p')), refl-concat B (f x) (g x) (H x), y, p) -- In the case of a homotopy H from f to the identity the previous square applies to the path H a to produce the following naturality square. #def a-cylinder-homotopy-coherence (A : U) (f : A -> A) (H : homotopy A A f (identity A)) (a : A) : (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = (concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a))) := nat-htpy A A f (identity A) H (f a) a (H a) -- After composing with ap-id, this naturality square transforms to the following: #def another-cylinder-homotopy-coherence (A : U) (f : A -> A) (H : homotopy A A f (identity A)) (a : A) : (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = (concat A (f (f a)) (f a) (a) (H (f a)) (H a)) := concat ((f (f a)) = a) (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) (concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a))) (concat A (f (f a)) (f a) (a) (H (f a)) (H a)) (a-cylinder-homotopy-coherence A f H a) (concat-homotopy A (f (f a)) (f a) (H (f a)) a (ap A A (f a) a (identity A) (H a)) (H a) (ap-id A (f a) a (H a))) -- Cancelling the path (H a) on the right and reversing yields a path we need: #def cylinder-homotopy-coherence (A : U) (f : A -> A) (H : homotopy A A f (identity A)) (a : A) : (H (f a)) =(ap A A (f a) a f (H a)) := rev (f (f a) = f a) (ap A A (f a) a f (H a)) (H (f a)) (concat-right-cancel A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H (f a)) (H a) (another-cylinder-homotopy-coherence A f H a))","title":"Naturality"},{"location":"hott/4-equivalences/","text":"4. Equivalences This is a literate rzk file: #lang rzk-1 Sections and retractions #def hasSection (A B : U) (f : A -> B) : U := \u2211 (s : B -> A), homotopy B B (composition B A B f s)(identity B) #def hasRetraction (A B : U) (f : A -> B) : U := \u2211 (r : B -> A), homotopy A A (composition A B A r f)(identity A) Equivalences -- equivalences are bi-invertible maps #def isEquiv (A B : U) (f : A -> B) : U := prod (hasRetraction A B f) (hasSection A B f) #def isEquiv-section (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : B -> A := (first (second fisequiv)) #def isEquiv-retraction (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : B -> A := (first (first fisequiv)) -- the homotopy between the section and retraction of an equivalence #def isEquiv-htpic-inverses (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : homotopy B A (isEquiv-section A B f fisequiv) (isEquiv-retraction A B f fisequiv) := homotopy-composition B A (isEquiv-section A B f fisequiv) (triple-composition B A B A (isEquiv-retraction A B f fisequiv) f ((isEquiv-section A B f fisequiv))) (isEquiv-retraction A B f fisequiv) (homotopy-rev B A (triple-composition B A B A (isEquiv-retraction A B f fisequiv) f ((isEquiv-section A B f fisequiv))) (isEquiv-section A B f fisequiv) (homotopy-prewhisker B A A (composition A B A (isEquiv-retraction A B f fisequiv) f) (identity A) (second (first fisequiv)) (isEquiv-section A B f fisequiv))) (homotopy-postwhisker B B A (composition B A B f (isEquiv-section A B f fisequiv)) (identity B) (second (second fisequiv)) (isEquiv-retraction A B f fisequiv)) Invertible maps -- the following type of more coherent equivalences is not a proposition #def hasInverse (A B : U) (f : A -> B) : U := \u2211 (g : B -> A), -- A two-sided inverse (prod (homotopy A A (composition A B A g f)(identity A)) -- The retracting homotopy (homotopy B B (composition B A B f g)(identity B))) -- The section homotopy #def hasInverse-inverse (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : B -> A := first (fhasinverse) Equivalences are invertible maps -- invertible maps are equivalences #def hasInverse-isEquiv (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : isEquiv A B f := ((first fhasinverse, first (second fhasinverse)), (first fhasinverse, second (second fhasinverse))) -- equivalences are invertible #def isEquiv-hasInverse (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : hasInverse A B f := (isEquiv-section A B f fisequiv, (homotopy-composition A A (composition A B A (isEquiv-section A B f fisequiv) f) (composition A B A (isEquiv-retraction A B f fisequiv) f) (identity A) (homotopy-prewhisker A B A (isEquiv-section A B f fisequiv) (isEquiv-retraction A B f fisequiv) (isEquiv-htpic-inverses A B f fisequiv) f) (second (first fisequiv)) , second (second fisequiv))) Half adjoint equivalences -- Some iterated composites associated to a pair of invertible maps. #def hasInverse-retraction-composite (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : A -> A := composition A B A (hasInverse-inverse A B f fhasinverse) f #def hasInverse-section-composite (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : B -> B := composition B A B f (hasInverse-inverse A B f fhasinverse) -- This composite is parallel to f; we won't need the dual notion. #def hasInverse-triple-composite (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : A -> B := triple-composition A B A B f (hasInverse-inverse A B f fhasinverse) f -- This composite is also parallel to f; again we won't need the dual notion. #def hasInverse-quintuple-composite (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : A -> B := \\a -> f ((hasInverse-inverse A B f fhasinverse) (f ((hasInverse-inverse A B f fhasinverse) (f a)))) -- We'll require a more coherent notion of equivalence #def isHalfAdjointEquiv (A B : U) (f : A -> B) : U := \u2211 (fhasinverse : (hasInverse A B f)), (a : A) -> (((second (second fhasinverse))) (f a)) = (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (((first (second fhasinverse))) a)) -- By function extensionality, the previous definition coincides with the following one: #def ALTisHalfAdjointEquiv (A B : U) (f : A -> B) : U := \u2211 (fhasinverse : (hasInverse A B f)), ((homotopy-prewhisker A B B (hasInverse-section-composite A B f fhasinverse) (identity B) (second (second fhasinverse)) f) = ((homotopy-postwhisker A A B (hasInverse-retraction-composite A B f fhasinverse) (identity A) (first (second fhasinverse)) f))) -- To promote an invertible map to a half adjoint equivalence we keep one homotopy and discard the other #def hasInverse-kept-htpy (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : homotopy A A (hasInverse-retraction-composite A B f fhasinverse) (identity A) := (first (second fhasinverse)) #def hasInverse-discarded-htpy (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : homotopy B B (hasInverse-section-composite A B f fhasinverse) (identity B) := (second (second fhasinverse)) -- the required coherence will be built by transforming an instance of this naturality square #def hasInverse-discarded-naturality-square (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) (a : A) : concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse)(hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-discarded-htpy A B f fhasinverse (f a)) = concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) := nat-htpy A B (hasInverse-triple-composite A B f fhasinverse) f (\\x -> hasInverse-discarded-htpy A B f fhasinverse (f x)) (hasInverse-retraction-composite A B f fhasinverse a) (a) (hasInverse-kept-htpy A B f fhasinverse a) -- building a path that will be whiskered into the naturality square above #def hasInverse-cylinder-homotopy-coherence (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) (a : A) : (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) = ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a) := cylinder-homotopy-coherence A (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse) a #def hasInverse-ap-cylinder-homotopy-coherence (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) (a : A) : ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) = ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) := ap-htpy A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-cylinder-homotopy-coherence A B f fhasinverse a) #def hasInverse-cylinder-coherence (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) (a : A) : ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) = (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) := concat ((hasInverse-quintuple-composite A B f fhasinverse a) = (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a))) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-ap-cylinder-homotopy-coherence A B f fhasinverse a) (rev-ap-comp A A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) f (hasInverse-kept-htpy A B f fhasinverse a)) -- this morally gives the half adjoint inverse coherence; it just requires rotation #def hasInverse-replaced-naturality-square (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) (a : A) : concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (hasInverse-discarded-htpy A B f fhasinverse (f a)) = concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) := concat ((hasInverse-quintuple-composite A B f fhasinverse a) =_{B} (f a)) (concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (hasInverse-discarded-htpy A B f fhasinverse (f a))) (concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-discarded-htpy A B f fhasinverse (f a))) (concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a))) (homotopy-concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-cylinder-coherence A B f fhasinverse a) (hasInverse-discarded-htpy A B f fhasinverse (f a))) (hasInverse-discarded-naturality-square A B f fhasinverse a) -- This will replace the discarded homotopy #def hasInverse-corrected-htpy (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : homotopy B B (hasInverse-section-composite A B f fhasinverse) (\\b -> b) := \\b -> concat B ((hasInverse-section-composite A B f fhasinverse) b) ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) b)) b (rev B ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) b)) ((hasInverse-section-composite A B f fhasinverse) b) (hasInverse-discarded-htpy A B f fhasinverse ((hasInverse-section-composite A B f fhasinverse) b))) (concat B ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) b)) ((hasInverse-section-composite A B f fhasinverse) b) b (ap A B ((hasInverse-retraction-composite A B f fhasinverse) (hasInverse-inverse A B f fhasinverse b)) (hasInverse-inverse A B f fhasinverse b) f ((first (second fhasinverse)) (hasInverse-inverse A B f fhasinverse b))) ((hasInverse-discarded-htpy A B f fhasinverse b))) -- this is the half adjoint coherence #def hasInverse-coherence (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) (a : A) : (hasInverse-corrected-htpy A B f fhasinverse (f a)) = (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) := triangle-rotation B (hasInverse-quintuple-composite A B f fhasinverse a)(hasInverse-triple-composite A B f fhasinverse a) (f a) (concat B ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) (f a))) ((hasInverse-section-composite A B f fhasinverse) (f a)) (f a) (ap A B ((hasInverse-retraction-composite A B f fhasinverse) (hasInverse-inverse A B f fhasinverse (f a))) (hasInverse-inverse A B f fhasinverse (f a)) f ((first (second fhasinverse)) (hasInverse-inverse A B f fhasinverse (f a)))) ((hasInverse-discarded-htpy A B f fhasinverse (f a)))) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-replaced-naturality-square A B f fhasinverse a) -- to promote an invertible map to a half adjoint equivalence we change the data of the invertible map by replacing the discarded homotopy with the corrected one. #def hasInverse-correctedhasInverse (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : hasInverse A B f := (hasInverse-inverse A B f fhasinverse, (hasInverse-kept-htpy A B f fhasinverse, hasInverse-corrected-htpy A B f fhasinverse)) -- Invertible maps are half adjoint equivalences! #def hasInverse-isHalfAdjointEquiv (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : isHalfAdjointEquiv A B f := (hasInverse-correctedhasInverse A B f fhasinverse, hasInverse-coherence A B f fhasinverse) -- Equivalences are half adjoint equivalences! #def isEquiv-isHalfAdjointEquiv (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : isHalfAdjointEquiv A B f := hasInverse-isHalfAdjointEquiv A B f (isEquiv-hasInverse A B f fisequiv) Composing equivalences -- The type of equivalences between types uses the propositional notion isEquiv rather than the incoherent hasInverse. #def Eq (A B : U) : U := \u2211 (f : A -> B), ((isEquiv A) B) f -- The data of an equivalence is not symmetric so we promote an equivalence to an invertible map to prove symmetry #def sym_Eq (A B : U) (e : Eq A B) : Eq B A := (first (isEquiv-hasInverse A B (first e) (second e)) , (( first e , second (second (isEquiv-hasInverse A B (first e) (second e))) ) , ( first e , first (second (isEquiv-hasInverse A B (first e) (second e))) ) )) -- Composition of equivalences in diagrammatic order. #def compose_Eq (A B C : U) (A=B : Eq A B) (B=C : Eq B C) : Eq A C := (\\a -> (first B=C) ((first A=B) a), -- the composite equivalence ((\\c -> (first (first (second A=B))) ((first (first (second (B=C)))) c), (\\a -> concat A ((first (first (second A=B))) ((first (first (second B=C))) ((first B=C) ((first A=B) a)))) ((first (first (second A=B))) ((first A=B) a)) a (ap B A ((first (first (second B=C))) ((first B=C) ((first A=B) a))) -- should be inferred ((first A=B) a) -- should be inferred (first (first (second A=B))) ((second (first (second B=C))) ((first A=B) a))) ((second (first (second A=B))) a))), (\\c -> (first (second (second A=B))) ((first (second (second (B=C)))) c), (\\c -> concat C ((first B=C) ((first A=B) ((first (second (second A=B))) ((first (second (second B=C))) c)))) ((first B=C) ((first (second (second B=C))) c)) c (ap B C ((first A=B) ((first (second (second A=B))) ((first (second (second B=C))) c))) -- should be inferred ((first (second (second B=C))) c) -- should be inferred (first B=C) ((second (second (second A=B))) ((first (second (second B=C))) c))) ((second (second (second B=C))) c))))) -- now we compose the functions that are equivalences #def compose_isEquiv (A B C : U) (f : A -> B) (fisequiv : isEquiv A B f) (g : B -> C) (gisequiv : isEquiv B C g) : isEquiv A C (composition A B C g f) := ((composition C B A (isEquiv-retraction A B f fisequiv) (isEquiv-retraction B C g gisequiv), \\a -> concat A ((isEquiv-retraction A B f fisequiv) ((isEquiv-retraction B C g gisequiv) (g (f a)))) ((isEquiv-retraction A B f fisequiv) (f a)) a (ap B A ((isEquiv-retraction B C g gisequiv) (g (f a))) -- should be inferred (f a) -- should be inferred (isEquiv-retraction A B f fisequiv) ((second (first gisequiv)) (f a))) ((second (first fisequiv)) a)), (composition C B A (isEquiv-section A B f fisequiv) (isEquiv-section B C g gisequiv), \\c -> concat C (g (f ((first (second fisequiv)) ((first (second gisequiv)) c)))) (g ((first (second gisequiv)) c)) c (ap B C (f ((first (second fisequiv)) ((first (second gisequiv)) c))) -- should be inferred ((first (second gisequiv)) c) -- should be inferred g ((second (second fisequiv)) ((first (second gisequiv)) c))) ((second (second gisequiv)) c))) -- a composition of three equivalences #def triple_compose_Eq (A B C D : U) (A=B : Eq A B) (B=C : Eq B C) (C=D : Eq C D) : Eq A D := compose_Eq A B D (A=B) (compose_Eq B C D B=C C=D) #def triple_compose_isEquiv (A B C D : U) (f : A -> B) (fisequiv : isEquiv A B f) (g : B -> C) (gisequiv : isEquiv B C g) (h : C -> D) (hisequiv : isEquiv C D h) : isEquiv A D (triple-composition A B C D h g f) := compose_isEquiv A B D f fisequiv (composition B C D h g) (compose_isEquiv B C D g gisequiv h hisequiv) Function extensionality -- The type that encodes the function extensionality axiom. #def FunExt : U := (X : U) -> (A : X -> U) -> (f : (x : X) -> A x) -> (g : (x : X) -> A x) -> (px : (x : X) -> f x = g x) -> f = g -- Using function extensionality, a fiberwise equivalence defines an equivalence of dependent function types #def fibered-equiv-function-equiv (funext : FunExt) (X : U) (A B : X -> U) (fibequiv : (x : X) -> Eq (A x) (B x)) : Eq ((x : X) -> A x) ((x : X) -> B x) := ((\\a -> \\x -> (first (fibequiv x)) (a x)), (((\\b -> \\x -> (first (first (second (fibequiv x)))) (b x)), \\a -> funext X A (\\x -> (first (first (second (fibequiv x)))) ((first (fibequiv x)) (a x))) a (\\x -> (second (first (second (fibequiv x)))) (a x))), ((\\b -> \\x -> (first (second (second (fibequiv x)))) (b x)), (\\b -> funext X B (\\x -> (first (fibequiv x)) ((first (second (second (fibequiv x)))) (b x))) b (\\x -> (second (second (second (fibequiv x)))) (b x))))))","title":"Equivalences"},{"location":"hott/4-equivalences/#4-equivalences","text":"This is a literate rzk file: #lang rzk-1","title":"4. Equivalences"},{"location":"hott/4-equivalences/#sections-and-retractions","text":"#def hasSection (A B : U) (f : A -> B) : U := \u2211 (s : B -> A), homotopy B B (composition B A B f s)(identity B) #def hasRetraction (A B : U) (f : A -> B) : U := \u2211 (r : B -> A), homotopy A A (composition A B A r f)(identity A)","title":"Sections and retractions"},{"location":"hott/4-equivalences/#equivalences","text":"-- equivalences are bi-invertible maps #def isEquiv (A B : U) (f : A -> B) : U := prod (hasRetraction A B f) (hasSection A B f) #def isEquiv-section (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : B -> A := (first (second fisequiv)) #def isEquiv-retraction (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : B -> A := (first (first fisequiv)) -- the homotopy between the section and retraction of an equivalence #def isEquiv-htpic-inverses (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : homotopy B A (isEquiv-section A B f fisequiv) (isEquiv-retraction A B f fisequiv) := homotopy-composition B A (isEquiv-section A B f fisequiv) (triple-composition B A B A (isEquiv-retraction A B f fisequiv) f ((isEquiv-section A B f fisequiv))) (isEquiv-retraction A B f fisequiv) (homotopy-rev B A (triple-composition B A B A (isEquiv-retraction A B f fisequiv) f ((isEquiv-section A B f fisequiv))) (isEquiv-section A B f fisequiv) (homotopy-prewhisker B A A (composition A B A (isEquiv-retraction A B f fisequiv) f) (identity A) (second (first fisequiv)) (isEquiv-section A B f fisequiv))) (homotopy-postwhisker B B A (composition B A B f (isEquiv-section A B f fisequiv)) (identity B) (second (second fisequiv)) (isEquiv-retraction A B f fisequiv))","title":"Equivalences"},{"location":"hott/4-equivalences/#invertible-maps","text":"-- the following type of more coherent equivalences is not a proposition #def hasInverse (A B : U) (f : A -> B) : U := \u2211 (g : B -> A), -- A two-sided inverse (prod (homotopy A A (composition A B A g f)(identity A)) -- The retracting homotopy (homotopy B B (composition B A B f g)(identity B))) -- The section homotopy #def hasInverse-inverse (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : B -> A := first (fhasinverse)","title":"Invertible maps"},{"location":"hott/4-equivalences/#equivalences-are-invertible-maps","text":"-- invertible maps are equivalences #def hasInverse-isEquiv (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : isEquiv A B f := ((first fhasinverse, first (second fhasinverse)), (first fhasinverse, second (second fhasinverse))) -- equivalences are invertible #def isEquiv-hasInverse (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : hasInverse A B f := (isEquiv-section A B f fisequiv, (homotopy-composition A A (composition A B A (isEquiv-section A B f fisequiv) f) (composition A B A (isEquiv-retraction A B f fisequiv) f) (identity A) (homotopy-prewhisker A B A (isEquiv-section A B f fisequiv) (isEquiv-retraction A B f fisequiv) (isEquiv-htpic-inverses A B f fisequiv) f) (second (first fisequiv)) , second (second fisequiv)))","title":"Equivalences are invertible maps"},{"location":"hott/4-equivalences/#half-adjoint-equivalences","text":"-- Some iterated composites associated to a pair of invertible maps. #def hasInverse-retraction-composite (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : A -> A := composition A B A (hasInverse-inverse A B f fhasinverse) f #def hasInverse-section-composite (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : B -> B := composition B A B f (hasInverse-inverse A B f fhasinverse) -- This composite is parallel to f; we won't need the dual notion. #def hasInverse-triple-composite (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : A -> B := triple-composition A B A B f (hasInverse-inverse A B f fhasinverse) f -- This composite is also parallel to f; again we won't need the dual notion. #def hasInverse-quintuple-composite (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : A -> B := \\a -> f ((hasInverse-inverse A B f fhasinverse) (f ((hasInverse-inverse A B f fhasinverse) (f a)))) -- We'll require a more coherent notion of equivalence #def isHalfAdjointEquiv (A B : U) (f : A -> B) : U := \u2211 (fhasinverse : (hasInverse A B f)), (a : A) -> (((second (second fhasinverse))) (f a)) = (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (((first (second fhasinverse))) a)) -- By function extensionality, the previous definition coincides with the following one: #def ALTisHalfAdjointEquiv (A B : U) (f : A -> B) : U := \u2211 (fhasinverse : (hasInverse A B f)), ((homotopy-prewhisker A B B (hasInverse-section-composite A B f fhasinverse) (identity B) (second (second fhasinverse)) f) = ((homotopy-postwhisker A A B (hasInverse-retraction-composite A B f fhasinverse) (identity A) (first (second fhasinverse)) f))) -- To promote an invertible map to a half adjoint equivalence we keep one homotopy and discard the other #def hasInverse-kept-htpy (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : homotopy A A (hasInverse-retraction-composite A B f fhasinverse) (identity A) := (first (second fhasinverse)) #def hasInverse-discarded-htpy (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : homotopy B B (hasInverse-section-composite A B f fhasinverse) (identity B) := (second (second fhasinverse)) -- the required coherence will be built by transforming an instance of this naturality square #def hasInverse-discarded-naturality-square (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) (a : A) : concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse)(hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-discarded-htpy A B f fhasinverse (f a)) = concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) := nat-htpy A B (hasInverse-triple-composite A B f fhasinverse) f (\\x -> hasInverse-discarded-htpy A B f fhasinverse (f x)) (hasInverse-retraction-composite A B f fhasinverse a) (a) (hasInverse-kept-htpy A B f fhasinverse a) -- building a path that will be whiskered into the naturality square above #def hasInverse-cylinder-homotopy-coherence (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) (a : A) : (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) = ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a) := cylinder-homotopy-coherence A (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse) a #def hasInverse-ap-cylinder-homotopy-coherence (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) (a : A) : ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) = ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) := ap-htpy A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-cylinder-homotopy-coherence A B f fhasinverse a) #def hasInverse-cylinder-coherence (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) (a : A) : ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) = (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) := concat ((hasInverse-quintuple-composite A B f fhasinverse a) = (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a))) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-ap-cylinder-homotopy-coherence A B f fhasinverse a) (rev-ap-comp A A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) f (hasInverse-kept-htpy A B f fhasinverse a)) -- this morally gives the half adjoint inverse coherence; it just requires rotation #def hasInverse-replaced-naturality-square (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) (a : A) : concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (hasInverse-discarded-htpy A B f fhasinverse (f a)) = concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) := concat ((hasInverse-quintuple-composite A B f fhasinverse a) =_{B} (f a)) (concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (hasInverse-discarded-htpy A B f fhasinverse (f a))) (concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-discarded-htpy A B f fhasinverse (f a))) (concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a))) (homotopy-concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-cylinder-coherence A B f fhasinverse a) (hasInverse-discarded-htpy A B f fhasinverse (f a))) (hasInverse-discarded-naturality-square A B f fhasinverse a) -- This will replace the discarded homotopy #def hasInverse-corrected-htpy (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : homotopy B B (hasInverse-section-composite A B f fhasinverse) (\\b -> b) := \\b -> concat B ((hasInverse-section-composite A B f fhasinverse) b) ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) b)) b (rev B ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) b)) ((hasInverse-section-composite A B f fhasinverse) b) (hasInverse-discarded-htpy A B f fhasinverse ((hasInverse-section-composite A B f fhasinverse) b))) (concat B ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) b)) ((hasInverse-section-composite A B f fhasinverse) b) b (ap A B ((hasInverse-retraction-composite A B f fhasinverse) (hasInverse-inverse A B f fhasinverse b)) (hasInverse-inverse A B f fhasinverse b) f ((first (second fhasinverse)) (hasInverse-inverse A B f fhasinverse b))) ((hasInverse-discarded-htpy A B f fhasinverse b))) -- this is the half adjoint coherence #def hasInverse-coherence (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) (a : A) : (hasInverse-corrected-htpy A B f fhasinverse (f a)) = (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) := triangle-rotation B (hasInverse-quintuple-composite A B f fhasinverse a)(hasInverse-triple-composite A B f fhasinverse a) (f a) (concat B ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) (f a))) ((hasInverse-section-composite A B f fhasinverse) (f a)) (f a) (ap A B ((hasInverse-retraction-composite A B f fhasinverse) (hasInverse-inverse A B f fhasinverse (f a))) (hasInverse-inverse A B f fhasinverse (f a)) f ((first (second fhasinverse)) (hasInverse-inverse A B f fhasinverse (f a)))) ((hasInverse-discarded-htpy A B f fhasinverse (f a)))) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-replaced-naturality-square A B f fhasinverse a) -- to promote an invertible map to a half adjoint equivalence we change the data of the invertible map by replacing the discarded homotopy with the corrected one. #def hasInverse-correctedhasInverse (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : hasInverse A B f := (hasInverse-inverse A B f fhasinverse, (hasInverse-kept-htpy A B f fhasinverse, hasInverse-corrected-htpy A B f fhasinverse)) -- Invertible maps are half adjoint equivalences! #def hasInverse-isHalfAdjointEquiv (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : isHalfAdjointEquiv A B f := (hasInverse-correctedhasInverse A B f fhasinverse, hasInverse-coherence A B f fhasinverse) -- Equivalences are half adjoint equivalences! #def isEquiv-isHalfAdjointEquiv (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : isHalfAdjointEquiv A B f := hasInverse-isHalfAdjointEquiv A B f (isEquiv-hasInverse A B f fisequiv)","title":"Half adjoint equivalences"},{"location":"hott/4-equivalences/#composing-equivalences","text":"-- The type of equivalences between types uses the propositional notion isEquiv rather than the incoherent hasInverse. #def Eq (A B : U) : U := \u2211 (f : A -> B), ((isEquiv A) B) f -- The data of an equivalence is not symmetric so we promote an equivalence to an invertible map to prove symmetry #def sym_Eq (A B : U) (e : Eq A B) : Eq B A := (first (isEquiv-hasInverse A B (first e) (second e)) , (( first e , second (second (isEquiv-hasInverse A B (first e) (second e))) ) , ( first e , first (second (isEquiv-hasInverse A B (first e) (second e))) ) )) -- Composition of equivalences in diagrammatic order. #def compose_Eq (A B C : U) (A=B : Eq A B) (B=C : Eq B C) : Eq A C := (\\a -> (first B=C) ((first A=B) a), -- the composite equivalence ((\\c -> (first (first (second A=B))) ((first (first (second (B=C)))) c), (\\a -> concat A ((first (first (second A=B))) ((first (first (second B=C))) ((first B=C) ((first A=B) a)))) ((first (first (second A=B))) ((first A=B) a)) a (ap B A ((first (first (second B=C))) ((first B=C) ((first A=B) a))) -- should be inferred ((first A=B) a) -- should be inferred (first (first (second A=B))) ((second (first (second B=C))) ((first A=B) a))) ((second (first (second A=B))) a))), (\\c -> (first (second (second A=B))) ((first (second (second (B=C)))) c), (\\c -> concat C ((first B=C) ((first A=B) ((first (second (second A=B))) ((first (second (second B=C))) c)))) ((first B=C) ((first (second (second B=C))) c)) c (ap B C ((first A=B) ((first (second (second A=B))) ((first (second (second B=C))) c))) -- should be inferred ((first (second (second B=C))) c) -- should be inferred (first B=C) ((second (second (second A=B))) ((first (second (second B=C))) c))) ((second (second (second B=C))) c))))) -- now we compose the functions that are equivalences #def compose_isEquiv (A B C : U) (f : A -> B) (fisequiv : isEquiv A B f) (g : B -> C) (gisequiv : isEquiv B C g) : isEquiv A C (composition A B C g f) := ((composition C B A (isEquiv-retraction A B f fisequiv) (isEquiv-retraction B C g gisequiv), \\a -> concat A ((isEquiv-retraction A B f fisequiv) ((isEquiv-retraction B C g gisequiv) (g (f a)))) ((isEquiv-retraction A B f fisequiv) (f a)) a (ap B A ((isEquiv-retraction B C g gisequiv) (g (f a))) -- should be inferred (f a) -- should be inferred (isEquiv-retraction A B f fisequiv) ((second (first gisequiv)) (f a))) ((second (first fisequiv)) a)), (composition C B A (isEquiv-section A B f fisequiv) (isEquiv-section B C g gisequiv), \\c -> concat C (g (f ((first (second fisequiv)) ((first (second gisequiv)) c)))) (g ((first (second gisequiv)) c)) c (ap B C (f ((first (second fisequiv)) ((first (second gisequiv)) c))) -- should be inferred ((first (second gisequiv)) c) -- should be inferred g ((second (second fisequiv)) ((first (second gisequiv)) c))) ((second (second gisequiv)) c))) -- a composition of three equivalences #def triple_compose_Eq (A B C D : U) (A=B : Eq A B) (B=C : Eq B C) (C=D : Eq C D) : Eq A D := compose_Eq A B D (A=B) (compose_Eq B C D B=C C=D) #def triple_compose_isEquiv (A B C D : U) (f : A -> B) (fisequiv : isEquiv A B f) (g : B -> C) (gisequiv : isEquiv B C g) (h : C -> D) (hisequiv : isEquiv C D h) : isEquiv A D (triple-composition A B C D h g f) := compose_isEquiv A B D f fisequiv (composition B C D h g) (compose_isEquiv B C D g gisequiv h hisequiv)","title":"Composing equivalences"},{"location":"hott/4-equivalences/#function-extensionality","text":"-- The type that encodes the function extensionality axiom. #def FunExt : U := (X : U) -> (A : X -> U) -> (f : (x : X) -> A x) -> (g : (x : X) -> A x) -> (px : (x : X) -> f x = g x) -> f = g -- Using function extensionality, a fiberwise equivalence defines an equivalence of dependent function types #def fibered-equiv-function-equiv (funext : FunExt) (X : U) (A B : X -> U) (fibequiv : (x : X) -> Eq (A x) (B x)) : Eq ((x : X) -> A x) ((x : X) -> B x) := ((\\a -> \\x -> (first (fibequiv x)) (a x)), (((\\b -> \\x -> (first (first (second (fibequiv x)))) (b x)), \\a -> funext X A (\\x -> (first (first (second (fibequiv x)))) ((first (fibequiv x)) (a x))) a (\\x -> (second (first (second (fibequiv x)))) (a x))), ((\\b -> \\x -> (first (second (second (fibequiv x)))) (b x)), (\\b -> funext X B (\\x -> (first (fibequiv x)) ((first (second (second (fibequiv x)))) (b x))) b (\\x -> (second (second (second (fibequiv x)))) (b x))))))","title":"Function extensionality"},{"location":"hott/5-sigma/","text":"5. Sigma types This is a literate rzk file: #lang rzk-1 Identity types of sigma types -- Sigma-induction #def ind-Sigma (A : U) (B : A -> U) (C : (\u2211(a : A), B a) -> U) (s : \u2211(a : A), B a) (f : (a : A) -> (b : B a) -> C (a, b)) : C s := (f (first s)) (second s) -- [Rijke 22, Definition 9.3.1] #def Eq-Sigma (A : U) (B : A -> U) (s t : \u2211(a : A), B a) : U := \u2211(p : (first s) = (first t)), (transport A B (first s) (first t) p (second s)) = (second t) -- [Rijke 22, used in Lemma 9.3.2] #def refl-in-Sigma (A : U) (B : A -> U) (x : A) (y : B x) : \u2211(p : (x = x)), ((transport A B x x refl_{x} y) = y) := (refl_{x}, refl_{y}) -- [Rijke 22, Lemma 9.3.2] -- Eq-sigma is reflexive #def reflexive-Eq-Sigma (A : U) (B : A -> U) (s : \u2211(a : A), B a) : (Eq-Sigma A B s s) := (ind-Sigma A B (\\k -> (Eq-Sigma A B k k)) s (\\u v -> (refl_{u}, refl_{v})) ) -- [Rijke 22, Definition 9.3.3] #def pair-eq (A : U) (B : A -> U) (s t : \u2211(a : A), B a) (p : s = t) : (Eq-Sigma A B s t) := idJ(\u2211(a : A), B a, s, \\t' p' -> (Eq-Sigma A B s t'), (reflexive-Eq-Sigma A B s), t, p) -- A path through the total space projects to a path in the base -- Morally but not definitionally the first component of pair-eq. #def total-path-to-base-path (A : U) (B : A -> U) (z w : \u2211 (a : A), B a) (p : z = w) : ((first z) = first w) := ap (\u2211 (a : A), B a) A z w (\\u -> first u) p -- A path through the total space gives a path in a fiber using transport along the path in the base. -- Morally, but not definitionally, the second component of pair-eq. #def total-path-to-fibered-path (A : U) (B : A -> U) (z w : \u2211 (a : A), B a) (p : z = w) : (transport A B (first z) (first w) (total-path-to-base-path A B z w p) (second z)) = (second w) := idJ((\u2211 (a : A), B a), z, \\w' p' -> (transport A B (first z) (first w') (total-path-to-base-path A B z w' p') (second z)) = (second w'), refl, w, p) -- A path in a fiber defines a path in the total space #def fibered-path-to-sigma-path (A : U) (B : A -> U) (x : A) (u v : B x) (p : u = v) : (x , u) =_{\u2211 (a : A), B a} (x , v) := idJ(B x, u, \\v' p' -> (x , u) = (x , v'), refl, v, p) -- Essentially the inverse to pair-eq but with explicit arguments. #def pair-of-paths-to-path-of-pairs (A : U) (B : A -> U) (x y : A) (p : x = y) : (u : B x) -> (v : B y) -> ((transport A B x y p u) = v) -> (x, u) =_{\u2211 (z : A), B z} (y, v) := idJ(A, x, \\y' p' -> (u' : B x) -> (v' : B y') -> ((transport A B x y' p' u') = v') -> (x, u') =_{\u2211 (z : A), B z} (y', v'), \\(u' : B x) -> \\(v' : B x) -> \\(q' : (transport A B x x refl u') = v') -> (fibered-path-to-sigma-path A B x u' v' q'), y, p) -- The inverse to pair-eq. #def eq-pair (A : U) (B : A -> U) (s t : \u2211(a : A), B a) (e : Eq-Sigma A B s t) : (s = t) := pair-of-paths-to-path-of-pairs A B (first s) (first t) (first e) (second s) (second t) (second e) Based path spaces As an application, we prove the based path spaces are contractible. -- Transport in the space of paths starting at a is concatenation. #def based-transport-is-concat (A : U) -- The ambient type. (a x y : A) -- The basepoint and two other points. (p : a = x) -- An element of the based path space. (q : x = y) -- A path in the base. : (transport A (\\z -> (a = z)) x y q p) = (concat A a x y p q) := idJ(A, x, \\y' q' -> (transport A (\\z -> (a = z)) x y' q' p) = (concat A a x y' p q'), refl, y, q) -- The center of contraction in the based path space is (a, refl) #def based-paths-center (A : U) -- The ambient type. (a : A) -- The basepoint. : \u2211 (x : A), a = x := (a, refl) -- The contracting homotopy. #def based-paths-contracting-homotopy (A : U) -- The ambient type. (a : A) -- The basepoint. (p : \u2211 (x : A), a = x) -- Another based path. : (based-paths-center A a) =_{\u2211 (x : A), a = x} p := pair-of-paths-to-path-of-pairs A (\\z -> a = z) a (first p) (second p) (refl) (second p) (concat (a = (first p)) (transport A (\\z -> (a = z)) a (first p) (second p) (refl)) (concat A a a (first p) (refl) (second p)) (second p) (based-transport-is-concat A a a (first p) (refl) (second p)) (refl-concat A a (first p) (second p))) -- Based path spaces are contractible #def based-paths-contractible (A : U) -- The ambient type. (a : A) -- The basepoint. : isContr (\u2211 (x : A), a = x) := (based-paths-center A a, based-paths-contracting-homotopy A a)","title":"Sigma types"},{"location":"hott/5-sigma/#5-sigma-types","text":"This is a literate rzk file: #lang rzk-1","title":"5. Sigma types"},{"location":"hott/5-sigma/#identity-types-of-sigma-types","text":"-- Sigma-induction #def ind-Sigma (A : U) (B : A -> U) (C : (\u2211(a : A), B a) -> U) (s : \u2211(a : A), B a) (f : (a : A) -> (b : B a) -> C (a, b)) : C s := (f (first s)) (second s) -- [Rijke 22, Definition 9.3.1] #def Eq-Sigma (A : U) (B : A -> U) (s t : \u2211(a : A), B a) : U := \u2211(p : (first s) = (first t)), (transport A B (first s) (first t) p (second s)) = (second t) -- [Rijke 22, used in Lemma 9.3.2] #def refl-in-Sigma (A : U) (B : A -> U) (x : A) (y : B x) : \u2211(p : (x = x)), ((transport A B x x refl_{x} y) = y) := (refl_{x}, refl_{y}) -- [Rijke 22, Lemma 9.3.2] -- Eq-sigma is reflexive #def reflexive-Eq-Sigma (A : U) (B : A -> U) (s : \u2211(a : A), B a) : (Eq-Sigma A B s s) := (ind-Sigma A B (\\k -> (Eq-Sigma A B k k)) s (\\u v -> (refl_{u}, refl_{v})) ) -- [Rijke 22, Definition 9.3.3] #def pair-eq (A : U) (B : A -> U) (s t : \u2211(a : A), B a) (p : s = t) : (Eq-Sigma A B s t) := idJ(\u2211(a : A), B a, s, \\t' p' -> (Eq-Sigma A B s t'), (reflexive-Eq-Sigma A B s), t, p) -- A path through the total space projects to a path in the base -- Morally but not definitionally the first component of pair-eq. #def total-path-to-base-path (A : U) (B : A -> U) (z w : \u2211 (a : A), B a) (p : z = w) : ((first z) = first w) := ap (\u2211 (a : A), B a) A z w (\\u -> first u) p -- A path through the total space gives a path in a fiber using transport along the path in the base. -- Morally, but not definitionally, the second component of pair-eq. #def total-path-to-fibered-path (A : U) (B : A -> U) (z w : \u2211 (a : A), B a) (p : z = w) : (transport A B (first z) (first w) (total-path-to-base-path A B z w p) (second z)) = (second w) := idJ((\u2211 (a : A), B a), z, \\w' p' -> (transport A B (first z) (first w') (total-path-to-base-path A B z w' p') (second z)) = (second w'), refl, w, p) -- A path in a fiber defines a path in the total space #def fibered-path-to-sigma-path (A : U) (B : A -> U) (x : A) (u v : B x) (p : u = v) : (x , u) =_{\u2211 (a : A), B a} (x , v) := idJ(B x, u, \\v' p' -> (x , u) = (x , v'), refl, v, p) -- Essentially the inverse to pair-eq but with explicit arguments. #def pair-of-paths-to-path-of-pairs (A : U) (B : A -> U) (x y : A) (p : x = y) : (u : B x) -> (v : B y) -> ((transport A B x y p u) = v) -> (x, u) =_{\u2211 (z : A), B z} (y, v) := idJ(A, x, \\y' p' -> (u' : B x) -> (v' : B y') -> ((transport A B x y' p' u') = v') -> (x, u') =_{\u2211 (z : A), B z} (y', v'), \\(u' : B x) -> \\(v' : B x) -> \\(q' : (transport A B x x refl u') = v') -> (fibered-path-to-sigma-path A B x u' v' q'), y, p) -- The inverse to pair-eq. #def eq-pair (A : U) (B : A -> U) (s t : \u2211(a : A), B a) (e : Eq-Sigma A B s t) : (s = t) := pair-of-paths-to-path-of-pairs A B (first s) (first t) (first e) (second s) (second t) (second e)","title":"Identity types of sigma types"},{"location":"hott/5-sigma/#based-path-spaces","text":"As an application, we prove the based path spaces are contractible. -- Transport in the space of paths starting at a is concatenation. #def based-transport-is-concat (A : U) -- The ambient type. (a x y : A) -- The basepoint and two other points. (p : a = x) -- An element of the based path space. (q : x = y) -- A path in the base. : (transport A (\\z -> (a = z)) x y q p) = (concat A a x y p q) := idJ(A, x, \\y' q' -> (transport A (\\z -> (a = z)) x y' q' p) = (concat A a x y' p q'), refl, y, q) -- The center of contraction in the based path space is (a, refl) #def based-paths-center (A : U) -- The ambient type. (a : A) -- The basepoint. : \u2211 (x : A), a = x := (a, refl) -- The contracting homotopy. #def based-paths-contracting-homotopy (A : U) -- The ambient type. (a : A) -- The basepoint. (p : \u2211 (x : A), a = x) -- Another based path. : (based-paths-center A a) =_{\u2211 (x : A), a = x} p := pair-of-paths-to-path-of-pairs A (\\z -> a = z) a (first p) (second p) (refl) (second p) (concat (a = (first p)) (transport A (\\z -> (a = z)) a (first p) (second p) (refl)) (concat A a a (first p) (refl) (second p)) (second p) (based-transport-is-concat A a a (first p) (refl) (second p)) (refl-concat A a (first p) (second p))) -- Based path spaces are contractible #def based-paths-contractible (A : U) -- The ambient type. (a : A) -- The basepoint. : isContr (\u2211 (x : A), a = x) := (based-paths-center A a, based-paths-contracting-homotopy A a)","title":"Based path spaces"},{"location":"hott/6-trivial-fibrations/","text":"6. Trivial Fibrations This is a literate rzk file: #lang rzk-1 Contractible fibers -- In what follows we apply show that the projection from the total space of a sigma type is an equivalence if and only if its fibers are contractible #def total-space-projection (A : U) (B : A -> U) : (\u2211 (x : A), B x) -> A := \\z -> first z -- The type that asserts that the fibers of a type family are contractible #def contractible-fibers (A : U) (B : A -> U) : U := ((x : A) -> isContr (B x)) -- The center of contraction in a contractible fibers #def contractible-fibers-section (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : (x : A) -> B x := \\x -> contraction-center (B x) (ABcontrfib x) -- The section of the total space projection built from the contraction centers #def contractible-fibers-actual-section (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : (x : A) -> \u2211 (x : A), B x := \\x -> (x , contractible-fibers-section A B ABcontrfib x) #def contractible-fibers-section-htpy (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : homotopy A A (composition A (\u2211 (x : A), B x) A (total-space-projection A B) (contractible-fibers-actual-section A B ABcontrfib)) (identity A) := \\x -> refl #def contractible-fibers-section-is-section (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : hasSection (\u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-actual-section A B ABcontrfib , contractible-fibers-section-htpy A B ABcontrfib) -- This can be used to define the retraction homotopy for the total space projection, called \"first\" here #def contractible-fibers-retraction-htpy (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : (z : \u2211 (x : A), B x) -> ((contractible-fibers-actual-section A B ABcontrfib) (first z)) = z := \\z -> fibered-path-to-sigma-path A B (first z) ((contractible-fibers-section A B ABcontrfib) (first z)) (second z) (contracting-htpy (B (first z)) (ABcontrfib (first z)) (second z)) #def contractible-fibers-retraction (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : hasRetraction (\u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-actual-section A B ABcontrfib , contractible-fibers-retraction-htpy A B ABcontrfib) -- The first half of our main result: #def contractible-fibers-projection-equiv (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-retraction A B ABcontrfib , contractible-fibers-section-is-section A B ABcontrfib) Projection equivalences -- From a projection equivalence, it's not hard to inhabit fibers #def projection-equiv-implies-inhabited-fibers (A : U) (B : A -> U) (ABprojequiv : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (x : A) : B x := transport A B (first ((first (second ABprojequiv)) x)) x ((second (second ABprojequiv)) x) (second ((first (second ABprojequiv)) x)) -- This is great but I'll need more coherence to show that the inhabited fibers are contractible; the following proof fails -- #def projection-equiv-implies-contractible-fibers -- (A : U) -- (B : A -> U) -- (ABprojequiv : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) -- : contractible-fibers A B -- := \\x -> (second ((first (first ABprojequiv)) x) , -- \\u -> total-path-to-fibered-path A B ((first (first ABprojequiv)) x) (x, u) ((second (first ABprojequiv)) (x, u)) ) -- We start over from a stronger hypothesis of a half adjoint equivalence #def projection-coherent-equiv-inverse (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (a : A) : \u2211 (x : A), B x := (first (first ABprojHAE)) a #def projection-coherent-equiv-base-htpy (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (a : A) : (first (projection-coherent-equiv-inverse A B ABprojHAE a)) = a := (second (second (first ABprojHAE))) a #def projection-coherent-equiv-section (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (a : A) : B a := transport A B (first (projection-coherent-equiv-inverse A B ABprojHAE a)) a (projection-coherent-equiv-base-htpy A B ABprojHAE a) (second (projection-coherent-equiv-inverse A B ABprojHAE a)) #def projection-coherent-equiv-total-htpy (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (w : (\u2211 (x : A), B x)) : (projection-coherent-equiv-inverse A B ABprojHAE (first w)) = w := (first (second (first ABprojHAE))) w #def projection-coherent-equiv-fibered-htpy (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (w : (\u2211 (x : A), B x)) : (transport A B (first ((projection-coherent-equiv-inverse A B ABprojHAE (first w)))) (first w) (total-path-to-base-path A B (projection-coherent-equiv-inverse A B ABprojHAE (first w)) w (projection-coherent-equiv-total-htpy A B ABprojHAE w)) (second (projection-coherent-equiv-inverse A B ABprojHAE (first w)))) = (second w) := total-path-to-fibered-path A B (projection-coherent-equiv-inverse A B ABprojHAE (first w)) w (projection-coherent-equiv-total-htpy A B ABprojHAE w) #def projection-coherent-equiv-base-coherence (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (w : (\u2211 (x : A), B x)) : (projection-coherent-equiv-base-htpy A B ABprojHAE (first w)) = (total-path-to-base-path A B (projection-coherent-equiv-inverse A B ABprojHAE (first w)) w (projection-coherent-equiv-total-htpy A B ABprojHAE w)) := (second ABprojHAE) w #def projection-coherent-equiv-transport-coherence (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (w : (\u2211 (x : A), B x)) : (projection-coherent-equiv-section A B ABprojHAE (first w)) = (transport A B (first ((projection-coherent-equiv-inverse A B ABprojHAE (first w)))) (first w) (total-path-to-base-path A B (projection-coherent-equiv-inverse A B ABprojHAE (first w)) w (projection-coherent-equiv-total-htpy A B ABprojHAE w)) (second (projection-coherent-equiv-inverse A B ABprojHAE (first w)))) := transport2 A B (first (projection-coherent-equiv-inverse A B ABprojHAE (first w))) (first w) (projection-coherent-equiv-base-htpy A B ABprojHAE (first w)) (total-path-to-base-path A B (projection-coherent-equiv-inverse A B ABprojHAE (first w)) w (projection-coherent-equiv-total-htpy A B ABprojHAE w)) (projection-coherent-equiv-base-coherence A B ABprojHAE w) (second (projection-coherent-equiv-inverse A B ABprojHAE (first w))) #def projection-coherent-equiv-fibered-contracting-htpy (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (w : (\u2211 (x : A), B x)) : (projection-coherent-equiv-section A B ABprojHAE (first w)) =_{B (first w)} (second w) := concat (B (first w)) (projection-coherent-equiv-section A B ABprojHAE (first w)) (transport A B (first ((projection-coherent-equiv-inverse A B ABprojHAE (first w)))) (first w) (total-path-to-base-path A B (projection-coherent-equiv-inverse A B ABprojHAE (first w)) w (projection-coherent-equiv-total-htpy A B ABprojHAE w)) (second (projection-coherent-equiv-inverse A B ABprojHAE (first w)))) (second w) (projection-coherent-equiv-transport-coherence A B ABprojHAE w) (projection-coherent-equiv-fibered-htpy A B ABprojHAE w) -- Finally we have #def projection-coherent-equiv-contractible-fibers (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) : contractible-fibers A B := \\x -> ((projection-coherent-equiv-section A B ABprojHAE x), \\u -> (projection-coherent-equiv-fibered-contracting-htpy A B ABprojHAE (x, u))) -- The converse to our first result #def projection-equiv-contractible-fibers (A : U) (B : A -> U) (ABprojequiv : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) : contractible-fibers A B := projection-coherent-equiv-contractible-fibers A B (isEquiv-isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B) ABprojequiv) -- The main theorem #def projection-theorem (A : U) (B : (a : A) -> U) : iff (isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (contractible-fibers A B) := (\\ABprojequiv -> projection-equiv-contractible-fibers A B ABprojequiv, \\ABcontrfib -> contractible-fibers-projection-equiv A B ABcontrfib)","title":"Trivial fibrations"},{"location":"hott/6-trivial-fibrations/#6-trivial-fibrations","text":"This is a literate rzk file: #lang rzk-1","title":"6. Trivial Fibrations"},{"location":"hott/6-trivial-fibrations/#contractible-fibers","text":"-- In what follows we apply show that the projection from the total space of a sigma type is an equivalence if and only if its fibers are contractible #def total-space-projection (A : U) (B : A -> U) : (\u2211 (x : A), B x) -> A := \\z -> first z -- The type that asserts that the fibers of a type family are contractible #def contractible-fibers (A : U) (B : A -> U) : U := ((x : A) -> isContr (B x)) -- The center of contraction in a contractible fibers #def contractible-fibers-section (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : (x : A) -> B x := \\x -> contraction-center (B x) (ABcontrfib x) -- The section of the total space projection built from the contraction centers #def contractible-fibers-actual-section (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : (x : A) -> \u2211 (x : A), B x := \\x -> (x , contractible-fibers-section A B ABcontrfib x) #def contractible-fibers-section-htpy (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : homotopy A A (composition A (\u2211 (x : A), B x) A (total-space-projection A B) (contractible-fibers-actual-section A B ABcontrfib)) (identity A) := \\x -> refl #def contractible-fibers-section-is-section (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : hasSection (\u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-actual-section A B ABcontrfib , contractible-fibers-section-htpy A B ABcontrfib) -- This can be used to define the retraction homotopy for the total space projection, called \"first\" here #def contractible-fibers-retraction-htpy (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : (z : \u2211 (x : A), B x) -> ((contractible-fibers-actual-section A B ABcontrfib) (first z)) = z := \\z -> fibered-path-to-sigma-path A B (first z) ((contractible-fibers-section A B ABcontrfib) (first z)) (second z) (contracting-htpy (B (first z)) (ABcontrfib (first z)) (second z)) #def contractible-fibers-retraction (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : hasRetraction (\u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-actual-section A B ABcontrfib , contractible-fibers-retraction-htpy A B ABcontrfib) -- The first half of our main result: #def contractible-fibers-projection-equiv (A : U) (B : A -> U) (ABcontrfib : contractible-fibers A B) : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-retraction A B ABcontrfib , contractible-fibers-section-is-section A B ABcontrfib)","title":"Contractible fibers"},{"location":"hott/6-trivial-fibrations/#projection-equivalences","text":"-- From a projection equivalence, it's not hard to inhabit fibers #def projection-equiv-implies-inhabited-fibers (A : U) (B : A -> U) (ABprojequiv : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (x : A) : B x := transport A B (first ((first (second ABprojequiv)) x)) x ((second (second ABprojequiv)) x) (second ((first (second ABprojequiv)) x)) -- This is great but I'll need more coherence to show that the inhabited fibers are contractible; the following proof fails -- #def projection-equiv-implies-contractible-fibers -- (A : U) -- (B : A -> U) -- (ABprojequiv : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) -- : contractible-fibers A B -- := \\x -> (second ((first (first ABprojequiv)) x) , -- \\u -> total-path-to-fibered-path A B ((first (first ABprojequiv)) x) (x, u) ((second (first ABprojequiv)) (x, u)) ) -- We start over from a stronger hypothesis of a half adjoint equivalence #def projection-coherent-equiv-inverse (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (a : A) : \u2211 (x : A), B x := (first (first ABprojHAE)) a #def projection-coherent-equiv-base-htpy (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (a : A) : (first (projection-coherent-equiv-inverse A B ABprojHAE a)) = a := (second (second (first ABprojHAE))) a #def projection-coherent-equiv-section (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (a : A) : B a := transport A B (first (projection-coherent-equiv-inverse A B ABprojHAE a)) a (projection-coherent-equiv-base-htpy A B ABprojHAE a) (second (projection-coherent-equiv-inverse A B ABprojHAE a)) #def projection-coherent-equiv-total-htpy (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (w : (\u2211 (x : A), B x)) : (projection-coherent-equiv-inverse A B ABprojHAE (first w)) = w := (first (second (first ABprojHAE))) w #def projection-coherent-equiv-fibered-htpy (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (w : (\u2211 (x : A), B x)) : (transport A B (first ((projection-coherent-equiv-inverse A B ABprojHAE (first w)))) (first w) (total-path-to-base-path A B (projection-coherent-equiv-inverse A B ABprojHAE (first w)) w (projection-coherent-equiv-total-htpy A B ABprojHAE w)) (second (projection-coherent-equiv-inverse A B ABprojHAE (first w)))) = (second w) := total-path-to-fibered-path A B (projection-coherent-equiv-inverse A B ABprojHAE (first w)) w (projection-coherent-equiv-total-htpy A B ABprojHAE w) #def projection-coherent-equiv-base-coherence (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (w : (\u2211 (x : A), B x)) : (projection-coherent-equiv-base-htpy A B ABprojHAE (first w)) = (total-path-to-base-path A B (projection-coherent-equiv-inverse A B ABprojHAE (first w)) w (projection-coherent-equiv-total-htpy A B ABprojHAE w)) := (second ABprojHAE) w #def projection-coherent-equiv-transport-coherence (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (w : (\u2211 (x : A), B x)) : (projection-coherent-equiv-section A B ABprojHAE (first w)) = (transport A B (first ((projection-coherent-equiv-inverse A B ABprojHAE (first w)))) (first w) (total-path-to-base-path A B (projection-coherent-equiv-inverse A B ABprojHAE (first w)) w (projection-coherent-equiv-total-htpy A B ABprojHAE w)) (second (projection-coherent-equiv-inverse A B ABprojHAE (first w)))) := transport2 A B (first (projection-coherent-equiv-inverse A B ABprojHAE (first w))) (first w) (projection-coherent-equiv-base-htpy A B ABprojHAE (first w)) (total-path-to-base-path A B (projection-coherent-equiv-inverse A B ABprojHAE (first w)) w (projection-coherent-equiv-total-htpy A B ABprojHAE w)) (projection-coherent-equiv-base-coherence A B ABprojHAE w) (second (projection-coherent-equiv-inverse A B ABprojHAE (first w))) #def projection-coherent-equiv-fibered-contracting-htpy (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (w : (\u2211 (x : A), B x)) : (projection-coherent-equiv-section A B ABprojHAE (first w)) =_{B (first w)} (second w) := concat (B (first w)) (projection-coherent-equiv-section A B ABprojHAE (first w)) (transport A B (first ((projection-coherent-equiv-inverse A B ABprojHAE (first w)))) (first w) (total-path-to-base-path A B (projection-coherent-equiv-inverse A B ABprojHAE (first w)) w (projection-coherent-equiv-total-htpy A B ABprojHAE w)) (second (projection-coherent-equiv-inverse A B ABprojHAE (first w)))) (second w) (projection-coherent-equiv-transport-coherence A B ABprojHAE w) (projection-coherent-equiv-fibered-htpy A B ABprojHAE w) -- Finally we have #def projection-coherent-equiv-contractible-fibers (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) : contractible-fibers A B := \\x -> ((projection-coherent-equiv-section A B ABprojHAE x), \\u -> (projection-coherent-equiv-fibered-contracting-htpy A B ABprojHAE (x, u))) -- The converse to our first result #def projection-equiv-contractible-fibers (A : U) (B : A -> U) (ABprojequiv : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) : contractible-fibers A B := projection-coherent-equiv-contractible-fibers A B (isEquiv-isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B) ABprojequiv) -- The main theorem #def projection-theorem (A : U) (B : (a : A) -> U) : iff (isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (contractible-fibers A B) := (\\ABprojequiv -> projection-equiv-contractible-fibers A B ABprojequiv, \\ABcontrfib -> contractible-fibers-projection-equiv A B ABcontrfib)","title":"Projection equivalences"},{"location":"simplicial-hott/3-simplicial-type-theory/","text":"3. Simplicial Type Theory These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1 Simplicies and their subshapes Simplicies: -- 1-simplex #def \u0394\u00b9 : 2 -> TOPE := \\t -> TOP -- 2-simplex #def \u0394\u00b2 : (2 * 2) -> TOPE := \\(t, s) -> s <= t -- 3-simplex #def \u0394\u00b3 : (2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 Boundaries of simplices: -- boundary of a 1-simplex #def \u2202\u0394\u00b9 : \u0394\u00b9 -> TOPE := \\t -> (t === 0_2 \\/ t === 1_2) -- boundary of a 2-simplex #def \u2202\u0394\u00b2 : \u0394\u00b2 -> TOPE := \\ts -> ((second ts) === 0_2 \\/ (first ts) === 1_2 \\/ (second ts) === (first ts)) Horns: -- the (2,1)-horn #def \u039b : (2 * 2) -> TOPE := \\(t, s) -> (s === 0_2 \\/ t === 1_2) Products: -- the product of topes defines the product of shapes #def shapeProd (I J : CUBE) (psi : I -> TOPE) (chi : J -> TOPE) : (I * J) -> TOPE := \\(t, s) -> psi t /\\ chi s -- the square as a product #def \u0394\u00b9\u00d7\u0394\u00b9 : (2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 -- the vertical boundary of the square #def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : (2 * 2) -> TOPE := shapeProd 2 2 \u2202\u0394\u00b9 \u0394\u00b9 -- the prism from a 2-simplex in an arrow type #def \u0394\u00b2\u00d7\u0394\u00b9 : (2 * 2 * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9","title":"Simplicial Type Theory"},{"location":"simplicial-hott/3-simplicial-type-theory/#3-simplicial-type-theory","text":"These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"3. Simplicial Type Theory"},{"location":"simplicial-hott/3-simplicial-type-theory/#simplicies-and-their-subshapes","text":"Simplicies: -- 1-simplex #def \u0394\u00b9 : 2 -> TOPE := \\t -> TOP -- 2-simplex #def \u0394\u00b2 : (2 * 2) -> TOPE := \\(t, s) -> s <= t -- 3-simplex #def \u0394\u00b3 : (2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 Boundaries of simplices: -- boundary of a 1-simplex #def \u2202\u0394\u00b9 : \u0394\u00b9 -> TOPE := \\t -> (t === 0_2 \\/ t === 1_2) -- boundary of a 2-simplex #def \u2202\u0394\u00b2 : \u0394\u00b2 -> TOPE := \\ts -> ((second ts) === 0_2 \\/ (first ts) === 1_2 \\/ (second ts) === (first ts)) Horns: -- the (2,1)-horn #def \u039b : (2 * 2) -> TOPE := \\(t, s) -> (s === 0_2 \\/ t === 1_2) Products: -- the product of topes defines the product of shapes #def shapeProd (I J : CUBE) (psi : I -> TOPE) (chi : J -> TOPE) : (I * J) -> TOPE := \\(t, s) -> psi t /\\ chi s -- the square as a product #def \u0394\u00b9\u00d7\u0394\u00b9 : (2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 -- the vertical boundary of the square #def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : (2 * 2) -> TOPE := shapeProd 2 2 \u2202\u0394\u00b9 \u0394\u00b9 -- the prism from a 2-simplex in an arrow type #def \u0394\u00b2\u00d7\u0394\u00b9 : (2 * 2 * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9","title":"Simplicies and their subshapes"},{"location":"simplicial-hott/4-extension-types/","text":"4. Equivalences involving extension types These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/4-equivalences.rzk \u2014 contains the definitions of Eq and compose_Eq the file hott/4-equivalences.rzk relies in turn on the previous files in hott/ Commutation of arguments and currying -- [RS17, Theorem 4.1] #def flip-ext-fun (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : U) (Y : psi -> X -> U) (f : (t : phi) -> (x : X) -> Y t x) : Eq (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) := (\\g x t -> g t x, -- the one-way map ((\\h t x -> (h x) t, -- the retraction \\g -> refl), -- the retracting homotopy (\\h t x -> (h x) t, -- the section \\h -> refl))) -- the section homotopy #def flip-ext-fun-inv (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : U) (Y : psi -> X -> U) (f : (t : phi) -> (x : X) -> Y t x) : Eq ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) := (\\h t x -> (h x) t, -- the one-way map ((\\g x t -> g t x, -- the retraction \\h -> refl), -- the retracting homotopy (\\g x t -> g t x, -- the section \\g -> refl))) -- [RS17, Theorem 4.2] #def curry-uncurry (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) := (\\g (t, s) -> (g t) s, -- the one way map ((\\h t s -> h (t , s) -- its retraction ,\\g -> refl), -- the retracting homotopy (\\h t s -> h (t , s) -- its section ,\\h -> refl))) -- the section homotopy #def uncurry-opcurry (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := (\\h s t -> h (t , s) , -- the one way map ((\\g (t, s) -> (g s) t -- its retraction ,\\h -> refl), -- the retracting homotopy (\\g (t, s) -> (g s) t -- its section ,\\g -> refl))) -- the section homotopy #def fubini (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := compose_Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) (curry-uncurry I J psi phi zeta chi X f) (uncurry-opcurry I J psi phi zeta chi X f) Extending into \u2211-types (the non-axiom of choice) -- [RS17, Theorem 4.3] #def axiom-choice (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : psi -> U) (Y : (t : psi) -> (x : X t) -> U) (a : (t : phi) -> X t) (b : (t : phi) -> Y t (a t)) : Eq (<{t : I | psi t} -> (\u2211 (x : X t), Y t x) [ phi t |-> (a t , b t) ]>) (\u2211 (f : (<{t : I | psi t} -> X t [phi t |-> a t ]>)), (<{t : I | psi t} -> Y t (f t) [ phi t |-> b t ]>)) := (\\g -> (\\t -> (first (g t)), \\t -> second (g t)) , -- the one way map ((\\h t -> ((first h) t, (second h) t) -- its retraction , \\g -> refl), -- the retracting homotopy (\\h t -> ((first h) t, (second h) t) -- its section , \\h -> refl))) -- the section homotopy Composites and unions of cofibrations -- [RS17, Theorem 4.4] -- Reformulated via tope disjunction instead of inclusion. -- See https://github.com/fizruk/rzk/issues/8 #def cofibration_composition' (I : CUBE) (chi psi phi : I -> TOPE) (X : chi -> U) (a : <{t : I | chi t /\\ psi t /\\ phi t} -> X t >) : Eq <{t : I | chi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]> (\u2211 (f : <{t : I | chi t /\\ psi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]>), <{t : I | chi t} -> X t [ chi t /\\ psi t |-> f t ]>) := (\\h -> (\\t -> h t, \\t -> h t), ((\\fg t -> (second fg) t, \\h -> refl), ((\\fg t -> (second fg) t, \\h -> refl)))) -- [RS17, Theorem 4.5] #def cofibration_union (I : CUBE) (phi psi : I -> TOPE) (X : <{t : I | phi t \\/ psi t} -> U >) (a : (t : psi) -> X t) : Eq <{t : I | phi t \\/ psi t} -> X t [ psi t |-> a t ]> <{t : I | phi t} -> X t [ phi t /\\ psi t |-> a t ]> := (\\h -> \\t -> h t, ((\\g -> \\t -> recOR(phi t |-> g t, psi t |-> a t), \\h -> refl), (\\g -> \\t -> recOR(phi t |-> g t, psi t |-> a t), \\h -> refl))) Relative function extensionality There are various equivalent forms of the relative function extensionality axiom. Here we state the one that will be most useful and derive an application. -- [RS17, Proposition 4.8(ii)] -- as suggested by footnote 8, we assert this as an \"extension extensionality\" axiom #def ExtExt : U := (I : CUBE) -> (psi : I -> TOPE) -> (phi : psi -> TOPE) -> (A : psi -> U) -> (a : (t : phi) -> A t) -> (f : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (g : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (_ : <{t : I | psi t} -> (f t = g t) [ phi t |-> refl ]>) -> (f = g) -- A fiberwise equivalence defines an equivalence of extension types, for simplicity extending from BOT #def fibered-equiv-extension-equiv (extext : ExtExt) (I : CUBE) (psi : I -> TOPE) (A B : psi -> U) (fibequiv : (t : psi) -> (Eq (A t) (B t)) ) : Eq (<{t : I | psi t } -> A t >) (<{t : I | psi t } -> B t >) := ((\\a t -> (first (fibequiv t)) (a t)), (((\\b t -> (first (first (second (fibequiv t)))) (b t)), \\a -> extext I psi (\\t -> BOT) A (\\u -> recBOT) (\\t -> (first (first (second (fibequiv t)))) ((first (fibequiv t)) (a t))) a (\\t -> (second (first (second (fibequiv t)))) (a t))), ((\\b t -> (first (second (second (fibequiv t)))) (b t)), (\\b -> extext I psi (\\t -> BOT) B (\\u -> recBOT) (\\t -> (first (fibequiv t)) ((first (second (second (fibequiv t)))) (b t))) b (\\t -> (second (second (second (fibequiv t)))) (b t))))))","title":"Extension Types"},{"location":"simplicial-hott/4-extension-types/#4-equivalences-involving-extension-types","text":"These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"4. Equivalences involving extension types"},{"location":"simplicial-hott/4-extension-types/#prerequisites","text":"hott/4-equivalences.rzk \u2014 contains the definitions of Eq and compose_Eq the file hott/4-equivalences.rzk relies in turn on the previous files in hott/","title":"Prerequisites"},{"location":"simplicial-hott/4-extension-types/#commutation-of-arguments-and-currying","text":"-- [RS17, Theorem 4.1] #def flip-ext-fun (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : U) (Y : psi -> X -> U) (f : (t : phi) -> (x : X) -> Y t x) : Eq (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) := (\\g x t -> g t x, -- the one-way map ((\\h t x -> (h x) t, -- the retraction \\g -> refl), -- the retracting homotopy (\\h t x -> (h x) t, -- the section \\h -> refl))) -- the section homotopy #def flip-ext-fun-inv (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : U) (Y : psi -> X -> U) (f : (t : phi) -> (x : X) -> Y t x) : Eq ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) := (\\h t x -> (h x) t, -- the one-way map ((\\g x t -> g t x, -- the retraction \\h -> refl), -- the retracting homotopy (\\g x t -> g t x, -- the section \\g -> refl))) -- [RS17, Theorem 4.2] #def curry-uncurry (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) := (\\g (t, s) -> (g t) s, -- the one way map ((\\h t s -> h (t , s) -- its retraction ,\\g -> refl), -- the retracting homotopy (\\h t s -> h (t , s) -- its section ,\\h -> refl))) -- the section homotopy #def uncurry-opcurry (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := (\\h s t -> h (t , s) , -- the one way map ((\\g (t, s) -> (g s) t -- its retraction ,\\h -> refl), -- the retracting homotopy (\\g (t, s) -> (g s) t -- its section ,\\g -> refl))) -- the section homotopy #def fubini (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := compose_Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) (curry-uncurry I J psi phi zeta chi X f) (uncurry-opcurry I J psi phi zeta chi X f)","title":"Commutation of arguments and currying"},{"location":"simplicial-hott/4-extension-types/#extending-into-types-the-non-axiom-of-choice","text":"-- [RS17, Theorem 4.3] #def axiom-choice (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : psi -> U) (Y : (t : psi) -> (x : X t) -> U) (a : (t : phi) -> X t) (b : (t : phi) -> Y t (a t)) : Eq (<{t : I | psi t} -> (\u2211 (x : X t), Y t x) [ phi t |-> (a t , b t) ]>) (\u2211 (f : (<{t : I | psi t} -> X t [phi t |-> a t ]>)), (<{t : I | psi t} -> Y t (f t) [ phi t |-> b t ]>)) := (\\g -> (\\t -> (first (g t)), \\t -> second (g t)) , -- the one way map ((\\h t -> ((first h) t, (second h) t) -- its retraction , \\g -> refl), -- the retracting homotopy (\\h t -> ((first h) t, (second h) t) -- its section , \\h -> refl))) -- the section homotopy","title":"Extending into \u2211-types (the non-axiom of choice)"},{"location":"simplicial-hott/4-extension-types/#composites-and-unions-of-cofibrations","text":"-- [RS17, Theorem 4.4] -- Reformulated via tope disjunction instead of inclusion. -- See https://github.com/fizruk/rzk/issues/8 #def cofibration_composition' (I : CUBE) (chi psi phi : I -> TOPE) (X : chi -> U) (a : <{t : I | chi t /\\ psi t /\\ phi t} -> X t >) : Eq <{t : I | chi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]> (\u2211 (f : <{t : I | chi t /\\ psi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]>), <{t : I | chi t} -> X t [ chi t /\\ psi t |-> f t ]>) := (\\h -> (\\t -> h t, \\t -> h t), ((\\fg t -> (second fg) t, \\h -> refl), ((\\fg t -> (second fg) t, \\h -> refl)))) -- [RS17, Theorem 4.5] #def cofibration_union (I : CUBE) (phi psi : I -> TOPE) (X : <{t : I | phi t \\/ psi t} -> U >) (a : (t : psi) -> X t) : Eq <{t : I | phi t \\/ psi t} -> X t [ psi t |-> a t ]> <{t : I | phi t} -> X t [ phi t /\\ psi t |-> a t ]> := (\\h -> \\t -> h t, ((\\g -> \\t -> recOR(phi t |-> g t, psi t |-> a t), \\h -> refl), (\\g -> \\t -> recOR(phi t |-> g t, psi t |-> a t), \\h -> refl)))","title":"Composites and unions of cofibrations"},{"location":"simplicial-hott/4-extension-types/#relative-function-extensionality","text":"There are various equivalent forms of the relative function extensionality axiom. Here we state the one that will be most useful and derive an application. -- [RS17, Proposition 4.8(ii)] -- as suggested by footnote 8, we assert this as an \"extension extensionality\" axiom #def ExtExt : U := (I : CUBE) -> (psi : I -> TOPE) -> (phi : psi -> TOPE) -> (A : psi -> U) -> (a : (t : phi) -> A t) -> (f : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (g : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (_ : <{t : I | psi t} -> (f t = g t) [ phi t |-> refl ]>) -> (f = g) -- A fiberwise equivalence defines an equivalence of extension types, for simplicity extending from BOT #def fibered-equiv-extension-equiv (extext : ExtExt) (I : CUBE) (psi : I -> TOPE) (A B : psi -> U) (fibequiv : (t : psi) -> (Eq (A t) (B t)) ) : Eq (<{t : I | psi t } -> A t >) (<{t : I | psi t } -> B t >) := ((\\a t -> (first (fibequiv t)) (a t)), (((\\b t -> (first (first (second (fibequiv t)))) (b t)), \\a -> extext I psi (\\t -> BOT) A (\\u -> recBOT) (\\t -> (first (first (second (fibequiv t)))) ((first (fibequiv t)) (a t))) a (\\t -> (second (first (second (fibequiv t)))) (a t))), ((\\b t -> (first (second (second (fibequiv t)))) (b t)), (\\b -> extext I psi (\\t -> BOT) B (\\u -> recBOT) (\\t -> (first (fibequiv t)) ((first (second (second (fibequiv t)))) (b t))) b (\\t -> (second (second (second (fibequiv t)))) (b t))))))","title":"Relative function extensionality"},{"location":"simplicial-hott/5-segal-types/","text":"Segal Types These formalisations correspond to Section 5 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/1-paths.md - We require basic path algebra. hott/2-contractible.md - We require the notion of contractible types and their data. hott/total-space.md \u2014 We rely on contractible-fibers-projection-equiv and total-space-projection in the proof of Theorem 5.5. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. Hom types Extension types are used to define the type of arrows between fixed terms: x y -- [RS17, Definition 5.1] -- The type of arrows in A from x to y. #def hom (A : U) -- A type. (x y : A) -- Two points in A. : U -- (hom A x y) is a 1-simplex (an arrow) := (t : \u0394\u00b9) -> A [ -- in A where t === 0_2 |-> x, -- * the left endpoint is exactly x t === 1_2 |-> y -- * the right endpoint is exactly y ] Extension types are also used to define the type of commutative triangles: x y z f g h -- [RS17, Definition 5.2] -- the type of commutative triangles in A #def hom2 (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. : U -- (hom2 A x y z f g h) is a 2-simplex (triangle) := { (t1, t2) : \u0394\u00b2 } -> A [ -- in A where t2 === 0_2 |-> f t1, -- * the top edge is exactly f, t1 === 1_2 |-> g t2, -- * the right edge is exactly g, and t2 === t1 |-> h t2 -- * the diagonal is exactly h ] The Segal condition A type is Segal if every composable pair of arrows has a unique composite. Note this is a considerable simplification of the usual Segal condition, which also requires homotopical uniqueness of higher-order composites. -- [RS17, Definition 5.3] #def isSegal (A : U) -- A type. : U := (x : A) -> (y : A) -> (z : A) -> (f : hom A x y) -> (g : hom A y z) -> isContr( \u2211 (h : hom A x z), hom2 A x y z f g h) Segal types have a composition functor and witnesses to the composition relation: -- Composition is written in diagrammatic order to match the order of arguments in isSegal. #def Segal-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom A x z := first (first (AisSegal x y z f g)) -- Segal types have composition witnesses #def Segal-comp-witness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom2 A x y z f g (Segal-comp A AisSegal x y z f g) := second (first (AisSegal x y z f g)) Composition in a Segal type is unique in the following sense. If there is a witness that an arrow h is a composite of f and g, then the specified composite equals h. x y z f g h \u03b1 = x y z f g Segal-comp Segal-comp-witness #def Segal-comp-uniqueness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. (alpha : hom2 A x y z f g h) -- A witness that h is a composite of f and g. : (Segal-comp A AisSegal x y z f g) = h := total-path-to-base-path (hom A x z) (\\k -> hom2 A x y z f g k) (Segal-comp A AisSegal x y z f g, Segal-comp-witness A AisSegal x y z f g) (h, alpha) (contracting-htpy (\u2211 (k : hom A x z), hom2 A x y z f g k) (AisSegal x y z f g) (h, alpha)) Characterizing Segal types Our aim is to prove that a type is Segal if and only if the horn-restriction map, defined below, is an equivalence. x y z f g -- A pair of composable arrows form a horn. #def horn (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u039b -> A := \\(t, s) -> recOR( s === 0_2 |-> f t, t === 1_2 |-> g s ) -- The underlying horn of a simplex #def horn-restriction (A : U) : (\u0394\u00b2 -> A) -> (\u039b -> A) := \\f t -> f t -- An alternate definition of Segal types. #def isSegal' (A : U) : U := isEquiv (\u0394\u00b2 -> A) (\u039b -> A) (horn-restriction A) Now we prove this definition is equivalent to the original one. -- Here, we prove the equivalence used in [RS17, Theorem 5.5]. -- However, we do this by constructing the equivalence directly, -- instead of using a composition of equivalences, as it is easier to write down -- and it computes better (we can use refl for the witnesses of the equivalence). #def compositions-are-horn-fillings (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : Eq (\u2211 (h : hom A x z), hom2 A x y z f g h) <{t : 2 * 2 | \u0394\u00b2 t } -> A [ \u039b t |-> horn A x y z f g t ]> := (\\hh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second hh) t, ((\\k -> (\\(t : 2) -> k (t, t), \\(t, s) -> k (t, s)), \\hh -> refl), (\\k -> (\\(t : 2) -> k (t, t), \\(t, s) -> k (t, s)), \\hh -> refl))) #def restriction-equiv (A : U) -- A type. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) := (\\k -> (\\{t : 2 * 2 | \u039b t} -> k t, (\\(t : 2) -> k (t, t), \\{t : 2 * 2 | \u0394\u00b2 t} -> k t)), ((\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}), (\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}))) -- [RS17, Theorem 5.5], the hard direction: #def Segal-restriction-equiv (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) -- (horn-restriction A) := compose_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u039b t} -> A >) (restriction-equiv A) (total-space-projection (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h), (contractible-fibers-projection-equiv (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (\\k -> AisSegal (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t))))) -- Verify that the mapping in (Segal-restriction-equiv A AisSegal) -- is exactly (horn-restriction A) #def Segal-restriction-equiv-test (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : (first (Segal-restriction-equiv A AisSegal)) = (horn-restriction A) := refl -- Segal types are Segal' types. #def isSegal-isSegal' (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal' A := second (Segal-restriction-equiv A AisSegal) -- Segal' types are Segal types. #def isSegal'-isSegal (A : U) -- A type. (AisSegal' : isSegal' A) -- A proof that A is Segal'. : isSegal A := \\x y z f g -> (projection-equiv-contractible-fibers (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (second (compose_Eq (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) (sym_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (restriction-equiv A)) (horn-restriction A, AisSegal') ))) (horn A x y z f g) -- [RS17, Theorem 5.5] proves that both notions of Segal types are logically equivalent. #def isSegal-iff-isSegal' (A : U) -- A type. : iff (isSegal A) (isSegal' A) := (isSegal-isSegal' A , isSegal'-isSegal A) Segal function and extension types Using the new characterization of Segal types, we can show that the type of functions or extensions into a family of Segal types is again a Segal type. -- [RS17, Corollary 5.6(i)] : if X is a type and A : X -> U is such that -- A(x) is a Segal type for all x then (x : X) -> A x is a Segal type #def Segal-function-types (funext : FunExt) -- This proof uses function extensionality. (X : U) -- A type. (A : (_ : X) -> U) -- A type family (fiberwiseAisSegal : (x : X) -> isSegal' (A x)) -- An assumption that the fibers are Segal types. : isSegal' ((x : X) -> A x) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> ((x : X) -> A x) >) ((x : X) -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) ((x : X) -> <{t : 2 * 2 | \u039b t} -> A x >) (<{t : 2 * 2 | \u039b t} -> ((x : X) -> A x) >) (\\g -> \\x -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t x) -- first equivalence (second (flip-ext-fun (2 * 2) \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) X (\\{t : 2 * 2 | \u0394\u00b2 t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) (\\h -> \\x -> \\{t : 2 * 2 | \u039b t} -> h x t) -- second equivalence (second (fibered-equiv-function-equiv funext X (\\x -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) (\\x -> <{t : 2 * 2 | \u039b t} -> A x >) (\\x -> (horn-restriction (A x) , fiberwiseAisSegal x)))) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\x -> (h x) t) -- third equivalence (second(flip-ext-fun-inv (2 * 2) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) X (\\{t : 2 * 2 | \u039b t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) -- [RS17, Corollary 5.6(ii)] : if X is a shape and A : X -> U is such that -- A(x) is a Segal type for all x then (x : X) -> A x is a Segal type #def Segal-extension-types (extext : ExtExt) -- This proof uses extension extensionality. (I : CUBE) -- A cube. (psi : (s : I) -> TOPE) -- A tope. (A : <{s : I | psi s} -> U >) -- An extension type. (fiberwiseAisSegal : <{s : I | psi s} -> isSegal' (A s) >) -- An assumption that the fibers are Segal types. : isSegal' (<{s : I | psi s} -> A s >) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> <{s : I | psi s} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s > >) (<{t : 2 * 2 | \u039b t} -> <{s : I | psi s} -> A s > >) (\\g -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t s) -- first equivalence (second(fubini (2 * 2) I \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) psi (\\{s : I | psi s} -> BOT) (\\{t : 2 * 2 | \u0394\u00b2 t} -> \\{s : I | psi s} -> A s) (\\{u : (2 * 2) * I | BOT} -> recBOT))) (\\h -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> h s t) -- second equivalence (second (fibered-equiv-extension-equiv extext I psi (\\{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s >) (\\{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s >) (\\{s : I | psi s} -> (horn-restriction (A s), fiberwiseAisSegal s)) )) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\{s : I | psi s} -> (h s) t) -- third equivalence (second(fubini I (2 * 2) psi (\\{s : I | psi s} -> BOT) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) (\\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> A s) (\\{u : I * (2 * 2) | BOT} -> recBOT))) In particular, the arrow type of a Segal type is Segal. -- The type of arrows in a type. #def arr -- A type (A : U) : U := (t : \u0394\u00b9) -> A -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal'. #def Segal'-arrow-types (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal' A) -- A proof that A isSegal'. : isSegal' (arr A) := Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> AisSegal) -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal. #def Segal-arrow-types (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal (arr A) := isSegal'-isSegal (arr A) (Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> (isSegal-isSegal' A AisSegal))) Identity All types have identity arrows and witnesses to the identity composition law. x x x -- [RS17, Definition 5.7] -- all types have identity arrows #def id-arr (A : U) -- A type. (x : A) -- A point in A. : hom A x x := \\{t : 2 | \u0394\u00b9 t} -> x Witness for the right identity law: x y y f y f f -- [RS17, Proposition 5.8a] -- the right unit law for identity #def comp-id-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x y y f (id-arr A y) f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f t Witness for the left identity law: x x y x f f f -- [RS17, Proposition 5.8b] -- the left unit law for identity #def id-comp-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x x y (id-arr A x) f f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f s In a Segal type, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. Thus, an identity axiom was not needed in the definition of Segal types. -- If A is Segal then the right unit law holds #def Segal-comp-id (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x y y f (id-arr A y)) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x y y f (id-arr A y) f (comp-id-witness A x y f) -- If A is Segal then the left unit law holds #def Segal-id-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x x y (id-arr A x) f) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x x y (id-arr A x) f f (id-comp-witness A x y f) Associativity We now prove that composition in a Segal type is associative, by using the fact that the type of arrows in a Segal type is itself a Segal type. \u2022 \u2022 \u2022 \u2022 #def unfolding-square (A : U) -- A type. (triangle : \u0394\u00b2 -> A) -- A triangle in A. : \u0394\u00b9\u00d7\u0394\u00b9 -> A -- A square in A, defined by gluing := \\(t, s) -> -- two copies of the triangle along the common diagonal edge. recOR(t <= s |-> triangle (s , t), s <= t |-> triangle (t , s)) For use in the proof of associativity: x y z y f g Segal-comp g f #def Segal-comp-witness-square (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u0394\u00b9\u00d7\u0394\u00b9 -> A := unfolding-square A (Segal-comp-witness A AisSegal x y z f g) The Segal-comp-witness-square as an arrow in the arrow type: x y z y f g #def Segal-arr-in-arr (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom (arr A) f g := \\t -> \\s -> (Segal-comp-witness-square A AisSegal x y z f g) (t, s) w x x y y z f g h #def Segal-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 (arr A) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h) (Segal-comp (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) := (Segal-comp-witness (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) w x y z g f h -- The Segal-associativity-witness curries to define a diagram \u0394\u00b2\u00d7\u0394\u00b9 -> A. -- The Segal-associativity-tetrahedron is extracted via the middle-simplex map \\((t, s), r) -> ((t, r), s) from \u0394\u00b3 to \u0394\u00b2\u00d7\u0394\u00b9 #def Segal-associativity-tetrahedron (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : \u0394\u00b3 -> A := \\((t, s), r) -> (Segal-associativity-witness extext A AisSegal w x y z f g h) (t, r) s w x y z g f h -- the diagonal composite of three arrows extracted from the Segal-associativity-tetrahedron #def Segal-triple-composite (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom A w z := \\t -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), t) w x y z g f h #def Segal-left-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), s) The front face: w x y z g f h #def Segal-right-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, s), s) #def Segal-left-associativity (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-left-associativity-witness extext A AisSegal w x y z f g h) #def Segal-right-associativity (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-right-associativity-witness extext A AisSegal w x y z f g h) #def Segal-associativity (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) := zig-zag-concat (hom A w z) (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) (Segal-left-associativity extext A AisSegal w x y z f g h) (Segal-right-associativity extext A AisSegal w x y z f g h) @import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap); text, textPath { font-family: Noto Serif; font-size: 20px; dominant-baseline: middle; text-anchor: middle; }","title":"Segal Types"},{"location":"simplicial-hott/5-segal-types/#segal-types","text":"These formalisations correspond to Section 5 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Segal Types"},{"location":"simplicial-hott/5-segal-types/#prerequisites","text":"hott/1-paths.md - We require basic path algebra. hott/2-contractible.md - We require the notion of contractible types and their data. hott/total-space.md \u2014 We rely on contractible-fibers-projection-equiv and total-space-projection in the proof of Theorem 5.5. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality.","title":"Prerequisites"},{"location":"simplicial-hott/5-segal-types/#hom-types","text":"Extension types are used to define the type of arrows between fixed terms: x y -- [RS17, Definition 5.1] -- The type of arrows in A from x to y. #def hom (A : U) -- A type. (x y : A) -- Two points in A. : U -- (hom A x y) is a 1-simplex (an arrow) := (t : \u0394\u00b9) -> A [ -- in A where t === 0_2 |-> x, -- * the left endpoint is exactly x t === 1_2 |-> y -- * the right endpoint is exactly y ] Extension types are also used to define the type of commutative triangles: x y z f g h -- [RS17, Definition 5.2] -- the type of commutative triangles in A #def hom2 (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. : U -- (hom2 A x y z f g h) is a 2-simplex (triangle) := { (t1, t2) : \u0394\u00b2 } -> A [ -- in A where t2 === 0_2 |-> f t1, -- * the top edge is exactly f, t1 === 1_2 |-> g t2, -- * the right edge is exactly g, and t2 === t1 |-> h t2 -- * the diagonal is exactly h ]","title":"Hom types"},{"location":"simplicial-hott/5-segal-types/#the-segal-condition","text":"A type is Segal if every composable pair of arrows has a unique composite. Note this is a considerable simplification of the usual Segal condition, which also requires homotopical uniqueness of higher-order composites. -- [RS17, Definition 5.3] #def isSegal (A : U) -- A type. : U := (x : A) -> (y : A) -> (z : A) -> (f : hom A x y) -> (g : hom A y z) -> isContr( \u2211 (h : hom A x z), hom2 A x y z f g h) Segal types have a composition functor and witnesses to the composition relation: -- Composition is written in diagrammatic order to match the order of arguments in isSegal. #def Segal-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom A x z := first (first (AisSegal x y z f g)) -- Segal types have composition witnesses #def Segal-comp-witness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom2 A x y z f g (Segal-comp A AisSegal x y z f g) := second (first (AisSegal x y z f g)) Composition in a Segal type is unique in the following sense. If there is a witness that an arrow h is a composite of f and g, then the specified composite equals h. x y z f g h \u03b1 = x y z f g Segal-comp Segal-comp-witness #def Segal-comp-uniqueness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. (alpha : hom2 A x y z f g h) -- A witness that h is a composite of f and g. : (Segal-comp A AisSegal x y z f g) = h := total-path-to-base-path (hom A x z) (\\k -> hom2 A x y z f g k) (Segal-comp A AisSegal x y z f g, Segal-comp-witness A AisSegal x y z f g) (h, alpha) (contracting-htpy (\u2211 (k : hom A x z), hom2 A x y z f g k) (AisSegal x y z f g) (h, alpha))","title":"The Segal condition"},{"location":"simplicial-hott/5-segal-types/#characterizing-segal-types","text":"Our aim is to prove that a type is Segal if and only if the horn-restriction map, defined below, is an equivalence. x y z f g -- A pair of composable arrows form a horn. #def horn (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u039b -> A := \\(t, s) -> recOR( s === 0_2 |-> f t, t === 1_2 |-> g s ) -- The underlying horn of a simplex #def horn-restriction (A : U) : (\u0394\u00b2 -> A) -> (\u039b -> A) := \\f t -> f t -- An alternate definition of Segal types. #def isSegal' (A : U) : U := isEquiv (\u0394\u00b2 -> A) (\u039b -> A) (horn-restriction A) Now we prove this definition is equivalent to the original one. -- Here, we prove the equivalence used in [RS17, Theorem 5.5]. -- However, we do this by constructing the equivalence directly, -- instead of using a composition of equivalences, as it is easier to write down -- and it computes better (we can use refl for the witnesses of the equivalence). #def compositions-are-horn-fillings (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : Eq (\u2211 (h : hom A x z), hom2 A x y z f g h) <{t : 2 * 2 | \u0394\u00b2 t } -> A [ \u039b t |-> horn A x y z f g t ]> := (\\hh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second hh) t, ((\\k -> (\\(t : 2) -> k (t, t), \\(t, s) -> k (t, s)), \\hh -> refl), (\\k -> (\\(t : 2) -> k (t, t), \\(t, s) -> k (t, s)), \\hh -> refl))) #def restriction-equiv (A : U) -- A type. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) := (\\k -> (\\{t : 2 * 2 | \u039b t} -> k t, (\\(t : 2) -> k (t, t), \\{t : 2 * 2 | \u0394\u00b2 t} -> k t)), ((\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}), (\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}))) -- [RS17, Theorem 5.5], the hard direction: #def Segal-restriction-equiv (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) -- (horn-restriction A) := compose_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u039b t} -> A >) (restriction-equiv A) (total-space-projection (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h), (contractible-fibers-projection-equiv (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (\\k -> AisSegal (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t))))) -- Verify that the mapping in (Segal-restriction-equiv A AisSegal) -- is exactly (horn-restriction A) #def Segal-restriction-equiv-test (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : (first (Segal-restriction-equiv A AisSegal)) = (horn-restriction A) := refl -- Segal types are Segal' types. #def isSegal-isSegal' (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal' A := second (Segal-restriction-equiv A AisSegal) -- Segal' types are Segal types. #def isSegal'-isSegal (A : U) -- A type. (AisSegal' : isSegal' A) -- A proof that A is Segal'. : isSegal A := \\x y z f g -> (projection-equiv-contractible-fibers (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (second (compose_Eq (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) (sym_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (restriction-equiv A)) (horn-restriction A, AisSegal') ))) (horn A x y z f g) -- [RS17, Theorem 5.5] proves that both notions of Segal types are logically equivalent. #def isSegal-iff-isSegal' (A : U) -- A type. : iff (isSegal A) (isSegal' A) := (isSegal-isSegal' A , isSegal'-isSegal A)","title":"Characterizing Segal types"},{"location":"simplicial-hott/5-segal-types/#segal-function-and-extension-types","text":"Using the new characterization of Segal types, we can show that the type of functions or extensions into a family of Segal types is again a Segal type. -- [RS17, Corollary 5.6(i)] : if X is a type and A : X -> U is such that -- A(x) is a Segal type for all x then (x : X) -> A x is a Segal type #def Segal-function-types (funext : FunExt) -- This proof uses function extensionality. (X : U) -- A type. (A : (_ : X) -> U) -- A type family (fiberwiseAisSegal : (x : X) -> isSegal' (A x)) -- An assumption that the fibers are Segal types. : isSegal' ((x : X) -> A x) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> ((x : X) -> A x) >) ((x : X) -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) ((x : X) -> <{t : 2 * 2 | \u039b t} -> A x >) (<{t : 2 * 2 | \u039b t} -> ((x : X) -> A x) >) (\\g -> \\x -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t x) -- first equivalence (second (flip-ext-fun (2 * 2) \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) X (\\{t : 2 * 2 | \u0394\u00b2 t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) (\\h -> \\x -> \\{t : 2 * 2 | \u039b t} -> h x t) -- second equivalence (second (fibered-equiv-function-equiv funext X (\\x -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) (\\x -> <{t : 2 * 2 | \u039b t} -> A x >) (\\x -> (horn-restriction (A x) , fiberwiseAisSegal x)))) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\x -> (h x) t) -- third equivalence (second(flip-ext-fun-inv (2 * 2) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) X (\\{t : 2 * 2 | \u039b t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) -- [RS17, Corollary 5.6(ii)] : if X is a shape and A : X -> U is such that -- A(x) is a Segal type for all x then (x : X) -> A x is a Segal type #def Segal-extension-types (extext : ExtExt) -- This proof uses extension extensionality. (I : CUBE) -- A cube. (psi : (s : I) -> TOPE) -- A tope. (A : <{s : I | psi s} -> U >) -- An extension type. (fiberwiseAisSegal : <{s : I | psi s} -> isSegal' (A s) >) -- An assumption that the fibers are Segal types. : isSegal' (<{s : I | psi s} -> A s >) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> <{s : I | psi s} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s > >) (<{t : 2 * 2 | \u039b t} -> <{s : I | psi s} -> A s > >) (\\g -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t s) -- first equivalence (second(fubini (2 * 2) I \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) psi (\\{s : I | psi s} -> BOT) (\\{t : 2 * 2 | \u0394\u00b2 t} -> \\{s : I | psi s} -> A s) (\\{u : (2 * 2) * I | BOT} -> recBOT))) (\\h -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> h s t) -- second equivalence (second (fibered-equiv-extension-equiv extext I psi (\\{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s >) (\\{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s >) (\\{s : I | psi s} -> (horn-restriction (A s), fiberwiseAisSegal s)) )) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\{s : I | psi s} -> (h s) t) -- third equivalence (second(fubini I (2 * 2) psi (\\{s : I | psi s} -> BOT) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) (\\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> A s) (\\{u : I * (2 * 2) | BOT} -> recBOT))) In particular, the arrow type of a Segal type is Segal. -- The type of arrows in a type. #def arr -- A type (A : U) : U := (t : \u0394\u00b9) -> A -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal'. #def Segal'-arrow-types (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal' A) -- A proof that A isSegal'. : isSegal' (arr A) := Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> AisSegal) -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal. #def Segal-arrow-types (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal (arr A) := isSegal'-isSegal (arr A) (Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> (isSegal-isSegal' A AisSegal)))","title":"Segal function and extension types"},{"location":"simplicial-hott/5-segal-types/#identity","text":"All types have identity arrows and witnesses to the identity composition law. x x x -- [RS17, Definition 5.7] -- all types have identity arrows #def id-arr (A : U) -- A type. (x : A) -- A point in A. : hom A x x := \\{t : 2 | \u0394\u00b9 t} -> x Witness for the right identity law: x y y f y f f -- [RS17, Proposition 5.8a] -- the right unit law for identity #def comp-id-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x y y f (id-arr A y) f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f t Witness for the left identity law: x x y x f f f -- [RS17, Proposition 5.8b] -- the left unit law for identity #def id-comp-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x x y (id-arr A x) f f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f s In a Segal type, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. Thus, an identity axiom was not needed in the definition of Segal types. -- If A is Segal then the right unit law holds #def Segal-comp-id (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x y y f (id-arr A y)) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x y y f (id-arr A y) f (comp-id-witness A x y f) -- If A is Segal then the left unit law holds #def Segal-id-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x x y (id-arr A x) f) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x x y (id-arr A x) f f (id-comp-witness A x y f)","title":"Identity"},{"location":"simplicial-hott/5-segal-types/#associativity","text":"We now prove that composition in a Segal type is associative, by using the fact that the type of arrows in a Segal type is itself a Segal type. \u2022 \u2022 \u2022 \u2022 #def unfolding-square (A : U) -- A type. (triangle : \u0394\u00b2 -> A) -- A triangle in A. : \u0394\u00b9\u00d7\u0394\u00b9 -> A -- A square in A, defined by gluing := \\(t, s) -> -- two copies of the triangle along the common diagonal edge. recOR(t <= s |-> triangle (s , t), s <= t |-> triangle (t , s)) For use in the proof of associativity: x y z y f g Segal-comp g f #def Segal-comp-witness-square (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u0394\u00b9\u00d7\u0394\u00b9 -> A := unfolding-square A (Segal-comp-witness A AisSegal x y z f g) The Segal-comp-witness-square as an arrow in the arrow type: x y z y f g #def Segal-arr-in-arr (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom (arr A) f g := \\t -> \\s -> (Segal-comp-witness-square A AisSegal x y z f g) (t, s) w x x y y z f g h #def Segal-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 (arr A) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h) (Segal-comp (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) := (Segal-comp-witness (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) w x y z g f h -- The Segal-associativity-witness curries to define a diagram \u0394\u00b2\u00d7\u0394\u00b9 -> A. -- The Segal-associativity-tetrahedron is extracted via the middle-simplex map \\((t, s), r) -> ((t, r), s) from \u0394\u00b3 to \u0394\u00b2\u00d7\u0394\u00b9 #def Segal-associativity-tetrahedron (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : \u0394\u00b3 -> A := \\((t, s), r) -> (Segal-associativity-witness extext A AisSegal w x y z f g h) (t, r) s w x y z g f h -- the diagonal composite of three arrows extracted from the Segal-associativity-tetrahedron #def Segal-triple-composite (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom A w z := \\t -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), t) w x y z g f h #def Segal-left-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), s) The front face: w x y z g f h #def Segal-right-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, s), s) #def Segal-left-associativity (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-left-associativity-witness extext A AisSegal w x y z f g h) #def Segal-right-associativity (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-right-associativity-witness extext A AisSegal w x y z f g h) #def Segal-associativity (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) := zig-zag-concat (hom A w z) (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) (Segal-left-associativity extext A AisSegal w x y z f g h) (Segal-right-associativity extext A AisSegal w x y z f g h) @import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap); text, textPath { font-family: Noto Serif; font-size: 20px; dominant-baseline: middle; text-anchor: middle; }","title":"Associativity"},{"location":"simplicial-hott/6-2cat-of-segal-types/","text":"The 2-category of Segal types These formalisations correspond to Section 6 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types. Functors Functions between types induce an action on hom types, preserving sources and targets. -- [RS17, Section 6.1] -- Action of maps on homs. Called \"ap-arr\" to avoid conflicting with \"ap\". #def ap-arr (A B : U) (F : A -> B) (x y : A) (f : hom A x y) : hom B (F x) (F y) := \\t -> F (f t) Functions between types automatically preserve identity arrows. -- [RS17, Proposition 6.1] -- Preservation of identities follows from extension extensionality because these arrows are pointwise equal. #def functors-pres-id (extext : ExtExt) (A B : U) (F : A -> B) (x : A) : (ap-arr A B F x x (id-arr A x)) = (id-arr B (F x)) := extext 2 \u0394\u00b9 \u2202\u0394\u00b9 (\\t -> B) (\\t -> recOR( t === 0_2 |-> F x, t === 1_2 |-> F x)) (ap-arr A B F x x (id-arr A x)) (id-arr B (F x)) (\\t -> refl)","title":"2-Category of Segal Types"},{"location":"simplicial-hott/6-2cat-of-segal-types/#the-2-category-of-segal-types","text":"These formalisations correspond to Section 6 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"The 2-category of Segal types"},{"location":"simplicial-hott/6-2cat-of-segal-types/#prerequisites","text":"3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types.","title":"Prerequisites"},{"location":"simplicial-hott/6-2cat-of-segal-types/#functors","text":"Functions between types induce an action on hom types, preserving sources and targets. -- [RS17, Section 6.1] -- Action of maps on homs. Called \"ap-arr\" to avoid conflicting with \"ap\". #def ap-arr (A B : U) (F : A -> B) (x y : A) (f : hom A x y) : hom B (F x) (F y) := \\t -> F (f t) Functions between types automatically preserve identity arrows. -- [RS17, Proposition 6.1] -- Preservation of identities follows from extension extensionality because these arrows are pointwise equal. #def functors-pres-id (extext : ExtExt) (A B : U) (F : A -> B) (x : A) : (ap-arr A B F x x (id-arr A x)) = (id-arr B (F x)) := extext 2 \u0394\u00b9 \u2202\u0394\u00b9 (\\t -> B) (\\t -> recOR( t === 0_2 |-> F x, t === 1_2 |-> F x)) (ap-arr A B F x x (id-arr A x)) (id-arr B (F x)) (\\t -> refl)","title":"Functors"},{"location":"simplicial-hott/7-discrete/","text":"Discrete types These formalisations correspond to Section 7 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/1-paths.md - We require basic path algebra. hott/4-equivalences.md - We require the notion of equivalence between types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types. The definition Discrete types are types in which the hom-types are canonically equivalent to identity types. -- [RS17, Definition 7.1] #def id-to-arr (A : U) -- A type. (x y : A) -- Two points of type A. (p : x = y) -- A path p from x to y in A. : hom A x y -- An arrow p from x to y in A. := idJ(A, x, \\y' -> \\p' -> hom A x y', (id-arr A x), y, p) #def isDiscrete (A : U) -- A type. : U := (x : A) -> (y : A) -> isEquiv (x =_{A} y) (hom A x y) (id-to-arr A x y)","title":"Discrete Types"},{"location":"simplicial-hott/7-discrete/#discrete-types","text":"These formalisations correspond to Section 7 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Discrete types"},{"location":"simplicial-hott/7-discrete/#prerequisites","text":"hott/1-paths.md - We require basic path algebra. hott/4-equivalences.md - We require the notion of equivalence between types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types.","title":"Prerequisites"},{"location":"simplicial-hott/7-discrete/#the-definition","text":"Discrete types are types in which the hom-types are canonically equivalent to identity types. -- [RS17, Definition 7.1] #def id-to-arr (A : U) -- A type. (x y : A) -- Two points of type A. (p : x = y) -- A path p from x to y in A. : hom A x y -- An arrow p from x to y in A. := idJ(A, x, \\y' -> \\p' -> hom A x y', (id-arr A x), y, p) #def isDiscrete (A : U) -- A type. : U := (x : A) -> (y : A) -> isEquiv (x =_{A} y) (hom A x y) (id-to-arr A x y)","title":"The definition"},{"location":"simplicial-hott/8-covariant/","text":"Covariantly functorial type families These formalisations correspond to Section 8 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/* - We require various prerequisites from homotopy type theory. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 5-segal-types.md - We make use of the notion of Segal types and their structures. Dependent hom types In a type family over a base type, there is a dependent hom type of arrows that live over a specified arrow in the base type. -- [RS17, Section 8 Prelim] -- The type of dependent arrows in C over f from u to v #def dhom (A : U) -- The base type. (x y : A) -- Two points in the base. (f : hom A x y) -- An arrow in the base. (C : A -> U) -- A type family. (u : C x) -- A lift of the domain. (v : C y) -- A lift of the codomain. : U := <{t : 2 | \u0394\u00b9 t } -> C (f t) [t === 0_2 |-> u, t === 1_2 |-> v ]> It will be convenient to collect together dependent hom types with fixed domain but varying codomain. #def dhomFrom (A : U) -- The base type. (x y : A) -- Two points in the base. (f : hom A x y) -- An arrow in the base. (C : A -> U) -- A type family. (u : C x) -- A lift of the domain. : U := (\u2211 (v : C y), dhom A x y f C u v) We also have types of dependent composition witnesses over a base composition witness. #def dhom2 (A : U) -- The base type. (x y z : A) -- Three points in the base. (f : hom A x y) -- An arrow in the base. (g : hom A y z) -- An arrow in the base. (h : hom A x z) -- An arrow in the base. (alpha : hom2 A x y z f g h) -- A composition witness in the base. (C : A -> U) -- A type family. (u : C x) -- A lift of the initial point. (v : C y) -- A lift of the second point. (w : C z) -- A lift of the third point. (ff : dhom A x y f C u v) -- A lift of the first arrow. (gg : dhom A y z g C v w) -- A lift of the second arrow. (hh : dhom A x z h C u w) -- A lift of the diagonal arrow. : U := <{(t1, t2) : 2 * 2 | \u0394\u00b2 (t1, t2)} -> C (alpha (t1, t2)) [t2 === 0_2 |-> ff t1, t1 === 1_2 |-> gg t2, t2 === t1 |-> hh t2 ]> Covariant families A family of types over a base type is covariant if every arrow in the base has a unique lift with specified domain. -- [RS17, Definition 8.2] #def isCovFam (A : U) (C : A -> U) : U := (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -> isContr (dhomFrom A x y f C u) -- Type of covariant families over a fixed type #def covFam (A : U) : U := (\u2211 (C : ((a : A) -> U)), isCovFam A C) Covariant lifts, transport, and uniqueness In a covariant family C over a base type A, a term u : C x may be transported along an arrow f : hom A x y to give a term in C y. -- [RS17, covariant transport from beginning of Section 8.2] #def covTrans (A : U) (x y : A) (f : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (u : C x) : C y := first (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, covariant lift from beginning of Section 8.2] #def covLift (A : U) (x y : A) (f : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (u : C x) : (dhom A x y f C u (covTrans A x y f C CisCov u)) := second (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) #def covUniqueness (A : U) (x y : A) (f : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (u : C x) (lift : dhomFrom A x y f C u) : (covTrans A x y f C CisCov u) = (first lift) := total-path-to-base-path (C y) (\\v -> dhom A x y f C u v) (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) lift (contracting-htpy (dhomFrom A x y f C u) (CisCov x y f u) lift) Covariant functoriality The covariant transport operation defines a covariantly functorial action of arrows in the base on terms in the fibers. To start to demonstrate this, we prove an identity transport law. #def d-id-arr (A : U) (x : A) (C : A -> U) (u : C x) : dhom A x x (id-arr A x) C u u := \\t -> u -- [RS17, Proposition 8.16, Part 2] -- Covariant families preserve identities #def covPresId (A : U) (x : A) (C : A -> U) (CisCov : isCovFam A C) (u : C x) : (covTrans A x x (id-arr A x) C CisCov u) = u := covUniqueness A x x (id-arr A x) C CisCov u (u, d-id-arr A x C u) Natural transformations A fiberwise map between covariant families is automatically \"natural\" commuting with the covariant lifts. -- [RS17, Proposition 8.17] -- Covariant naturality #def covariant-transformation-application (A : U) (x y : A) (f : hom A x y) (C D : A -> U) (CisCov : isCovFam A C) (DisCov : isCovFam A D) (phi : (z : A) -> C z -> D z) (u : C x) : dhomFrom A x y f D (phi x u) := (phi y (covTrans A x y f C CisCov u), \\t -> phi (f t) (covLift A x y f C CisCov u t)) #def covariant-transformation-naturality (A : U) (x y : A) (f : hom A x y) (C D : A -> U) (CisCov : isCovFam A C) (DisCov : isCovFam A D) (phi : (z : A) -> C z -> D z) (u : C x) : (covTrans A x y f D DisCov (phi x u)) = (phi y (covTrans A x y f C CisCov u)) := covUniqueness A x y f D DisCov (phi x u) (covariant-transformation-application A x y f C D CisCov DisCov phi u)","title":"Covariantly Functorial Type Families"},{"location":"simplicial-hott/8-covariant/#covariantly-functorial-type-families","text":"These formalisations correspond to Section 8 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Covariantly functorial type families"},{"location":"simplicial-hott/8-covariant/#prerequisites","text":"hott/* - We require various prerequisites from homotopy type theory. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 5-segal-types.md - We make use of the notion of Segal types and their structures.","title":"Prerequisites"},{"location":"simplicial-hott/8-covariant/#dependent-hom-types","text":"In a type family over a base type, there is a dependent hom type of arrows that live over a specified arrow in the base type. -- [RS17, Section 8 Prelim] -- The type of dependent arrows in C over f from u to v #def dhom (A : U) -- The base type. (x y : A) -- Two points in the base. (f : hom A x y) -- An arrow in the base. (C : A -> U) -- A type family. (u : C x) -- A lift of the domain. (v : C y) -- A lift of the codomain. : U := <{t : 2 | \u0394\u00b9 t } -> C (f t) [t === 0_2 |-> u, t === 1_2 |-> v ]> It will be convenient to collect together dependent hom types with fixed domain but varying codomain. #def dhomFrom (A : U) -- The base type. (x y : A) -- Two points in the base. (f : hom A x y) -- An arrow in the base. (C : A -> U) -- A type family. (u : C x) -- A lift of the domain. : U := (\u2211 (v : C y), dhom A x y f C u v) We also have types of dependent composition witnesses over a base composition witness. #def dhom2 (A : U) -- The base type. (x y z : A) -- Three points in the base. (f : hom A x y) -- An arrow in the base. (g : hom A y z) -- An arrow in the base. (h : hom A x z) -- An arrow in the base. (alpha : hom2 A x y z f g h) -- A composition witness in the base. (C : A -> U) -- A type family. (u : C x) -- A lift of the initial point. (v : C y) -- A lift of the second point. (w : C z) -- A lift of the third point. (ff : dhom A x y f C u v) -- A lift of the first arrow. (gg : dhom A y z g C v w) -- A lift of the second arrow. (hh : dhom A x z h C u w) -- A lift of the diagonal arrow. : U := <{(t1, t2) : 2 * 2 | \u0394\u00b2 (t1, t2)} -> C (alpha (t1, t2)) [t2 === 0_2 |-> ff t1, t1 === 1_2 |-> gg t2, t2 === t1 |-> hh t2 ]>","title":"Dependent hom types"},{"location":"simplicial-hott/8-covariant/#covariant-families","text":"A family of types over a base type is covariant if every arrow in the base has a unique lift with specified domain. -- [RS17, Definition 8.2] #def isCovFam (A : U) (C : A -> U) : U := (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -> isContr (dhomFrom A x y f C u) -- Type of covariant families over a fixed type #def covFam (A : U) : U := (\u2211 (C : ((a : A) -> U)), isCovFam A C)","title":"Covariant families"},{"location":"simplicial-hott/8-covariant/#covariant-lifts-transport-and-uniqueness","text":"In a covariant family C over a base type A, a term u : C x may be transported along an arrow f : hom A x y to give a term in C y. -- [RS17, covariant transport from beginning of Section 8.2] #def covTrans (A : U) (x y : A) (f : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (u : C x) : C y := first (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, covariant lift from beginning of Section 8.2] #def covLift (A : U) (x y : A) (f : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (u : C x) : (dhom A x y f C u (covTrans A x y f C CisCov u)) := second (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) #def covUniqueness (A : U) (x y : A) (f : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (u : C x) (lift : dhomFrom A x y f C u) : (covTrans A x y f C CisCov u) = (first lift) := total-path-to-base-path (C y) (\\v -> dhom A x y f C u v) (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) lift (contracting-htpy (dhomFrom A x y f C u) (CisCov x y f u) lift)","title":"Covariant lifts, transport, and uniqueness"},{"location":"simplicial-hott/8-covariant/#covariant-functoriality","text":"The covariant transport operation defines a covariantly functorial action of arrows in the base on terms in the fibers. To start to demonstrate this, we prove an identity transport law. #def d-id-arr (A : U) (x : A) (C : A -> U) (u : C x) : dhom A x x (id-arr A x) C u u := \\t -> u -- [RS17, Proposition 8.16, Part 2] -- Covariant families preserve identities #def covPresId (A : U) (x : A) (C : A -> U) (CisCov : isCovFam A C) (u : C x) : (covTrans A x x (id-arr A x) C CisCov u) = u := covUniqueness A x x (id-arr A x) C CisCov u (u, d-id-arr A x C u)","title":"Covariant functoriality"},{"location":"simplicial-hott/8-covariant/#natural-transformations","text":"A fiberwise map between covariant families is automatically \"natural\" commuting with the covariant lifts. -- [RS17, Proposition 8.17] -- Covariant naturality #def covariant-transformation-application (A : U) (x y : A) (f : hom A x y) (C D : A -> U) (CisCov : isCovFam A C) (DisCov : isCovFam A D) (phi : (z : A) -> C z -> D z) (u : C x) : dhomFrom A x y f D (phi x u) := (phi y (covTrans A x y f C CisCov u), \\t -> phi (f t) (covLift A x y f C CisCov u t)) #def covariant-transformation-naturality (A : U) (x y : A) (f : hom A x y) (C D : A -> U) (CisCov : isCovFam A C) (DisCov : isCovFam A D) (phi : (z : A) -> C z -> D z) (u : C x) : (covTrans A x y f D DisCov (phi x u)) = (phi y (covTrans A x y f C CisCov u)) := covUniqueness A x y f D DisCov (phi x u) (covariant-transformation-application A x y f C D CisCov DisCov phi u)","title":"Natural transformations"},{"location":"simplicial-hott/9-yoneda/","text":"The Yoneda lemma These formalisations correspond to Section 9 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 8-covariant.md - We use covariant type families. Natural transformations involving a representable functor Fix a Segal type A and a term a : A. The Yoneda lemma characterizes natural transformations from the representable functor (hom A a) to a covariant type fmaily C. Ordinary, such a natural transformation would involve a family of maps (phi : (z : A) -> hom A a z -> C z) together with a proof of naturality of these components, but as is the case for covariant-transformation-naturality the naturality condition is automatic. -- This unfolds a composition triangle to a square with an identity component #def id-domain-square (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a x y : A) -- Three objects (g : hom A a x) (k : hom A x y) : (s : \u0394\u00b9) -> hom A a (k s) := \\s t -> recOR(t <= s |-> (id-comp-witness A a y (Segal-comp A AisSegal a x y g k)) (s , t), s <= t |-> (Segal-comp-witness A AisSegal a x y g k) (t , s)) #def covariant-representable-transformation-application (A : U) (AisSegal : isSegal A) (a x y : A) (f : hom A a x) (g : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (phi : (z : A) -> hom A a z -> C z) : dhomFrom A x y g C (phi x f) := (phi y (Segal-comp A AisSegal a x y f g), \\s -> phi (g s) (\\t -> (id-domain-square A AisSegal a x y f g s t))) #def covariant-representable-transformation-naturality (A : U) (AisSegal : isSegal A) (a x y : A) (f : hom A a x) (g : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (phi : (z : A) -> hom A a z -> C z) : (covTrans A x y g C CisCov (phi x f)) = (phi y (Segal-comp A AisSegal a x y f g)) := covUniqueness A x y g C CisCov (phi x f) (covariant-representable-transformation-application A AisSegal a x y f g C CisCov phi) The Yoneda maps For any Segal type A and term a : A, the Yoneda lemma provides an equivalence between the type (z : A) -> hom A a z -> C z of natural transformations out of the functor (hom A a) and valued in an arbitrary covariant family C and the type (C a). One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the covariant transport operation. -- The map evid evaluates a natural transformation -- out of a representable functor at the identity arrow. #def evid (A : U) -- The ambient type. (a : A) -- The representing object. (C : A -> U) -- A type family. : ((z : A) -> hom A a z -> C z) -> C a := \\phi -> phi a (id-arr A a) -- The inverse map only exists for Segal types. #def yon (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. : C a -> ((z : A) -> hom A a z -> C z) := \\u z f -> covTrans A a z f C CisCov u The Yoneda composites It remains to show that the Yoneda maps are inverses. -- One retraction is straightforward: #def evid-yon (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (u : C a) : (evid A a C) ((yon A AisSegal a C CisCov) u) = u := covPresId A a C CisCov u The other composite carries phi to an a priori distinct natural transformation. We first show that these are pointwise equal at all x : A and f : hom A a x in two steps. -- The first step: #def yon-evid-partial (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) (f : hom A a x) : ((yon A AisSegal a C CisCov)((evid A a C) phi)) x f = (phi x (Segal-comp A AisSegal a a x (id-arr A a) f)) -- phi x f := covariant-representable-transformation-naturality A AisSegal a a x (id-arr A a) f C CisCov phi -- The second step: #def yon-evid-ap (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) (f : hom A a x) : (phi x (Segal-comp A AisSegal a a x (id-arr A a) f)) = phi x f := ap (hom A a x) (C x) (Segal-comp A AisSegal a a x (id-arr A a) f) f (phi x) (Segal-id-comp A AisSegal a x f) -- The composite yon-evid of phi equals phi at all x : A and f : hom A a x. #def yon-evid-twice-pointwise (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) (f : hom A a x) : ((yon A AisSegal a C CisCov)((evid A a C) phi)) x f = phi x f := concat (C x) (((yon A AisSegal a C CisCov)((evid A a C) phi)) x f) (phi x (Segal-comp A AisSegal a a x (id-arr A a) f)) (phi x f) (yon-evid-partial A AisSegal a C CisCov phi x f) (yon-evid-ap A AisSegal a C CisCov phi x f) -- By funext, these are equals as functions of f pointwise in x. #def yon-evid-once-pointwise (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) : ((yon A AisSegal a C CisCov)((evid A a C) phi)) x = phi x := funext (hom A a x) (\\f -> C x) (\\f -> ((yon A AisSegal a C CisCov)((evid A a C) phi)) x f) (\\f -> (phi x f)) (\\f -> yon-evid-twice-pointwise A AisSegal a C CisCov phi x f) -- By funext again, these are equal as functions of x and f. #def yon-evid (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. : ((yon A AisSegal a C CisCov)((evid A a C) phi)) = phi := funext A (\\x -> (hom A a x -> C x)) (\\x -> ((yon A AisSegal a C CisCov)((evid A a C) phi)) x) (\\x -> (phi x)) (\\x -> yon-evid-once-pointwise funext A AisSegal a C CisCov phi x) The Yoneda lemma The Yoneda lemma says that evaluation at the identity defines an equivalence. #def Yoneda-lemma (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. : isEquiv ((z : A) -> hom A a z -> C z) (C a) (evid A a C) := ((yon A AisSegal a C CisCov, yon-evid funext A AisSegal a C CisCov), (yon A AisSegal a C CisCov, evid-yon A AisSegal a C CisCov))","title":"The Yoneda Lemma"},{"location":"simplicial-hott/9-yoneda/#the-yoneda-lemma","text":"These formalisations correspond to Section 9 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"The Yoneda lemma"},{"location":"simplicial-hott/9-yoneda/#prerequisites","text":"hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 8-covariant.md - We use covariant type families.","title":"Prerequisites"},{"location":"simplicial-hott/9-yoneda/#natural-transformations-involving-a-representable-functor","text":"Fix a Segal type A and a term a : A. The Yoneda lemma characterizes natural transformations from the representable functor (hom A a) to a covariant type fmaily C. Ordinary, such a natural transformation would involve a family of maps (phi : (z : A) -> hom A a z -> C z) together with a proof of naturality of these components, but as is the case for covariant-transformation-naturality the naturality condition is automatic. -- This unfolds a composition triangle to a square with an identity component #def id-domain-square (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a x y : A) -- Three objects (g : hom A a x) (k : hom A x y) : (s : \u0394\u00b9) -> hom A a (k s) := \\s t -> recOR(t <= s |-> (id-comp-witness A a y (Segal-comp A AisSegal a x y g k)) (s , t), s <= t |-> (Segal-comp-witness A AisSegal a x y g k) (t , s)) #def covariant-representable-transformation-application (A : U) (AisSegal : isSegal A) (a x y : A) (f : hom A a x) (g : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (phi : (z : A) -> hom A a z -> C z) : dhomFrom A x y g C (phi x f) := (phi y (Segal-comp A AisSegal a x y f g), \\s -> phi (g s) (\\t -> (id-domain-square A AisSegal a x y f g s t))) #def covariant-representable-transformation-naturality (A : U) (AisSegal : isSegal A) (a x y : A) (f : hom A a x) (g : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (phi : (z : A) -> hom A a z -> C z) : (covTrans A x y g C CisCov (phi x f)) = (phi y (Segal-comp A AisSegal a x y f g)) := covUniqueness A x y g C CisCov (phi x f) (covariant-representable-transformation-application A AisSegal a x y f g C CisCov phi)","title":"Natural transformations involving a representable functor"},{"location":"simplicial-hott/9-yoneda/#the-yoneda-maps","text":"For any Segal type A and term a : A, the Yoneda lemma provides an equivalence between the type (z : A) -> hom A a z -> C z of natural transformations out of the functor (hom A a) and valued in an arbitrary covariant family C and the type (C a). One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the covariant transport operation. -- The map evid evaluates a natural transformation -- out of a representable functor at the identity arrow. #def evid (A : U) -- The ambient type. (a : A) -- The representing object. (C : A -> U) -- A type family. : ((z : A) -> hom A a z -> C z) -> C a := \\phi -> phi a (id-arr A a) -- The inverse map only exists for Segal types. #def yon (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. : C a -> ((z : A) -> hom A a z -> C z) := \\u z f -> covTrans A a z f C CisCov u","title":"The Yoneda maps"},{"location":"simplicial-hott/9-yoneda/#the-yoneda-composites","text":"It remains to show that the Yoneda maps are inverses. -- One retraction is straightforward: #def evid-yon (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (u : C a) : (evid A a C) ((yon A AisSegal a C CisCov) u) = u := covPresId A a C CisCov u The other composite carries phi to an a priori distinct natural transformation. We first show that these are pointwise equal at all x : A and f : hom A a x in two steps. -- The first step: #def yon-evid-partial (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) (f : hom A a x) : ((yon A AisSegal a C CisCov)((evid A a C) phi)) x f = (phi x (Segal-comp A AisSegal a a x (id-arr A a) f)) -- phi x f := covariant-representable-transformation-naturality A AisSegal a a x (id-arr A a) f C CisCov phi -- The second step: #def yon-evid-ap (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) (f : hom A a x) : (phi x (Segal-comp A AisSegal a a x (id-arr A a) f)) = phi x f := ap (hom A a x) (C x) (Segal-comp A AisSegal a a x (id-arr A a) f) f (phi x) (Segal-id-comp A AisSegal a x f) -- The composite yon-evid of phi equals phi at all x : A and f : hom A a x. #def yon-evid-twice-pointwise (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) (f : hom A a x) : ((yon A AisSegal a C CisCov)((evid A a C) phi)) x f = phi x f := concat (C x) (((yon A AisSegal a C CisCov)((evid A a C) phi)) x f) (phi x (Segal-comp A AisSegal a a x (id-arr A a) f)) (phi x f) (yon-evid-partial A AisSegal a C CisCov phi x f) (yon-evid-ap A AisSegal a C CisCov phi x f) -- By funext, these are equals as functions of f pointwise in x. #def yon-evid-once-pointwise (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) : ((yon A AisSegal a C CisCov)((evid A a C) phi)) x = phi x := funext (hom A a x) (\\f -> C x) (\\f -> ((yon A AisSegal a C CisCov)((evid A a C) phi)) x f) (\\f -> (phi x f)) (\\f -> yon-evid-twice-pointwise A AisSegal a C CisCov phi x f) -- By funext again, these are equal as functions of x and f. #def yon-evid (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. : ((yon A AisSegal a C CisCov)((evid A a C) phi)) = phi := funext A (\\x -> (hom A a x -> C x)) (\\x -> ((yon A AisSegal a C CisCov)((evid A a C) phi)) x) (\\x -> (phi x)) (\\x -> yon-evid-once-pointwise funext A AisSegal a C CisCov phi x)","title":"The Yoneda composites"},{"location":"simplicial-hott/9-yoneda/#the-yoneda-lemma_1","text":"The Yoneda lemma says that evaluation at the identity defines an equivalence. #def Yoneda-lemma (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. : isEquiv ((z : A) -> hom A a z -> C z) (C a) (evid A a C) := ((yon A AisSegal a C CisCov, yon-evid funext A AisSegal a C CisCov), (yon A AisSegal a C CisCov, evid-yon A AisSegal a C CisCov))","title":"The Yoneda lemma"}]}