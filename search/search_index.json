{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yoneda for \u221e-categories \u00b6 This is a formalization library for simplicial Homotopy Type Theory (HoTT) with the aim of proving the Yoneda lemma for \u221e-categories following the paper \" A type theory for synthetic \u221e-categories \" [1]. This formalization project could be regarded as a companion to the article \" Could \u221e-category theory be taught to undergraduates? \" [2]. The formalizations are implemented using rzk , an experimental proof assistant for a variant of type theory with shapes developed by Nikolai Kudasov . Formalizations were contributed by Fredrik Bakke , Nikolai Kudasov , Emily Riehl , and Jonathan Weinberger . Our source files are available on github . Another aim of this project is to compare the proof of the Yoneda lemma for \u221e-categories in simplicial HoTT with proofs of the Yoneda lemma for 1-categories in other proof assistants. To that end Sina Hazratpour has contributed a formalization in Lean3 extracted from materials he prepared to teach Introduction to Proofs at Johns Hopkins, which can be found here . We also contributed a proof of the Yoneda lemma for precategories to the Agda-Unimath library. Here we prove the Yoneda lemma for pre-\u221e-categories, since the univalence/completeness condition is not required for this result. By analogy, precategories are the non-univalent 1-categories in HoTT. Checking the Formalisations Locally \u00b6 Install rzk proof assistant. Then run the following command from the root of our repository : stack exec rzk typecheck src/hott/* src/simplicial-hott/* References \u00b6 Emily Riehl & Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 Emily Riehl. Could \u221e-category theory be taught to undergraduates? Notices of the AMS. May 2023. https://www.ams.org/journals/notices/202305/noti2692/noti2692.html","title":"About"},{"location":"#yoneda-for-categories","text":"This is a formalization library for simplicial Homotopy Type Theory (HoTT) with the aim of proving the Yoneda lemma for \u221e-categories following the paper \" A type theory for synthetic \u221e-categories \" [1]. This formalization project could be regarded as a companion to the article \" Could \u221e-category theory be taught to undergraduates? \" [2]. The formalizations are implemented using rzk , an experimental proof assistant for a variant of type theory with shapes developed by Nikolai Kudasov . Formalizations were contributed by Fredrik Bakke , Nikolai Kudasov , Emily Riehl , and Jonathan Weinberger . Our source files are available on github . Another aim of this project is to compare the proof of the Yoneda lemma for \u221e-categories in simplicial HoTT with proofs of the Yoneda lemma for 1-categories in other proof assistants. To that end Sina Hazratpour has contributed a formalization in Lean3 extracted from materials he prepared to teach Introduction to Proofs at Johns Hopkins, which can be found here . We also contributed a proof of the Yoneda lemma for precategories to the Agda-Unimath library. Here we prove the Yoneda lemma for pre-\u221e-categories, since the univalence/completeness condition is not required for this result. By analogy, precategories are the non-univalent 1-categories in HoTT.","title":"Yoneda for \u221e-categories"},{"location":"#checking-the-formalisations-locally","text":"Install rzk proof assistant. Then run the following command from the root of our repository : stack exec rzk typecheck src/hott/* src/simplicial-hott/*","title":"Checking the Formalisations Locally"},{"location":"#references","text":"Emily Riehl & Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 Emily Riehl. Could \u221e-category theory be taught to undergraduates? Notices of the AMS. May 2023. https://www.ams.org/journals/notices/202305/noti2692/noti2692.html","title":"References"},{"location":"hott/00-common.rzk/","text":"0. Common \u00b6 This is a literate rzk file: #lang rzk-1 products of types \u00b6 #def prod ( A B : U ) : U := \u2211 ( x : A), B -- defined to illustrate the syntax for terms in sigma types #def diagonal ( A : U ) ( a : A) : prod A A := (a , a) The type of logical equivalences between types \u00b6 #def iff ( A B : U ) : U := prod (A -> B) (B -> A) Basic function definitions \u00b6 #section basic-functions #variables A B C D : U #def composition ( g : B -> C) -- The second function. ( f : A -> B) -- The first function. : A -> C -- The composite function. := \\ z -> g (f z) #def triple-composition ( h : C -> D) ( g : B -> C) ( f : A -> B) : A -> D := \\ z -> h (g (f z)) #def identity : A -> A := \\ a -> a #def constant ( b : B) -- The constant output value. : A -> B := \\ a -> b #end basic-functions Substitution \u00b6 -- Reindexing a type family along a function into the base type. #def reindex ( A B : U ) ( f : B -> A) ( C : A -> U ) : (B -> U ) := \\ b -> C (f b)","title":"Common"},{"location":"hott/00-common.rzk/#0-common","text":"This is a literate rzk file: #lang rzk-1","title":"0. Common"},{"location":"hott/00-common.rzk/#products-of-types","text":"#def prod ( A B : U ) : U := \u2211 ( x : A), B -- defined to illustrate the syntax for terms in sigma types #def diagonal ( A : U ) ( a : A) : prod A A := (a , a)","title":"products of types"},{"location":"hott/00-common.rzk/#the-type-of-logical-equivalences-between-types","text":"#def iff ( A B : U ) : U := prod (A -> B) (B -> A)","title":"The type of logical equivalences between types"},{"location":"hott/00-common.rzk/#basic-function-definitions","text":"#section basic-functions #variables A B C D : U #def composition ( g : B -> C) -- The second function. ( f : A -> B) -- The first function. : A -> C -- The composite function. := \\ z -> g (f z) #def triple-composition ( h : C -> D) ( g : B -> C) ( f : A -> B) : A -> D := \\ z -> h (g (f z)) #def identity : A -> A := \\ a -> a #def constant ( b : B) -- The constant output value. : A -> B := \\ a -> b #end basic-functions","title":"Basic function definitions"},{"location":"hott/00-common.rzk/#substitution","text":"-- Reindexing a type family along a function into the base type. #def reindex ( A B : U ) ( f : B -> A) ( C : A -> U ) : (B -> U ) := \\ b -> C (f b)","title":"Substitution"},{"location":"hott/01-paths.rzk/","text":"1. Paths \u00b6 This is a literate rzk file: #lang rzk-1 Some basic path algebra \u00b6 #section path-algebra #variable A : U #variables x y z : A -- path reversal #def rev ( p : x = y) -- A path from x to y in A. : y = x -- The reversal will be defined by path induction on p. := idJ (A, x, \\ y' p' -> y' = x, refl , y, p) -- path composition by induction on the second path #def concat ( p : x = y) -- A path from x to y in A. ( q : y = z) -- A path from y to z in A. : (x = z) := idJ (A, y, \\ z' q' -> (x = z'), p, z, q) -- an alternative construction of path composition by induction on the first path -- this is useful in situations where it's easier to induct on the first path #def concat' ( p : x = y) -- A path from x to y in A. : (y = z) -> (x = z) := idJ (A, x, \\ y' p' -> (y' = z) -> (x = z), \\ q' -> q', y, p) #end path-algebra Some basic coherences in path algebra \u00b6 #section basic-path-coherence #variable A : U #variables w x y z : A #def rev-rev ( p : x = y) -- A path from x to y in A. : (rev A y x (rev A x y p)) = p := idJ (A, x, \\ y' p' -> (rev A y' x (rev A x y' p')) = p', refl , y, p) -- the coherence we don't have definitionally #def refl-concat ( p : x = y) : (concat A x x y refl p) = p := idJ (A, x, \\ y' p' -> (concat A x x y' refl p') = p', refl , y, p) -- associativity #def concat-assoc ( p : w = x) -- A path from w to x in A. ( q : x = y) -- A path from x to y in A. ( r : y = z) -- A path from y to z in A. : concat A w y z (concat A w x y p q) r = concat A w x z p (concat A x y z q r) := idJ ( A, y, \\ z' r' -> concat A w y z' (concat A w x y p q) r' = concat A w x z' p (concat A x y z' q r'), refl , z, r) #def assoc-concat ( p : w = x) -- A path from w to x in A. ( q : x = y) -- A path from x to y in A. ( r : y = z) -- A path from y to z in A. : concat A w x z p (concat A x y z q r) = concat A w y z (concat A w x y p q) r := idJ ( A, y, \\ z' r' -> concat A w x z' p (concat A x y z' q r') = concat A w y z' (concat A w x y p q) r', refl , z, r) #def right-inverse ( p : x = y) : concat A x y x p (rev A x y p) = refl := idJ ( A, x, \\ y' p' -> concat A x y' x p' (rev A x y' p') = refl , refl , y, p) #def left-inverse ( p : x = y) : concat A y x y (rev A x y p) p = refl := idJ ( A, x, \\ y' p' -> concat A y' x y' (rev A x y' p') p' = refl , refl , y, p) -- concatenation of two paths with common codomain; defined using concat and rev #def zig-zag-concat ( p : x = y) -- A path from x to y in A. ( q : z = y) -- A path from z to y in A. : (x = z) := concat A x y z p (rev A z y q) -- concatenation of two paths with common domain; defined using concat and rev #def zag-zig-concat ( p : y = x) -- A path from y to x in A. ( q : y = z) -- A path from y to z in A. : (x = z) := concat A x y z (rev A y x p) q #def concat-right-cancel ( p q : x = y) -- Two paths from x to y in A. ( r : y = z) -- A path from y to z in A. : ((concat A x y z p r) = (concat A x y z q r)) -> (p = q) := idJ ( A, y, \\ z' r' -> ((concat A x y z' p r') = (concat A x y z' q r')) -> (p = q), \\ H -> H, z, r) #end basic-path-coherence Some derived coherences in path algebra \u00b6 The statements or proofs of the following path algebra coherences reference one of the path algebra coherences defined above. #section derived-path-coherence #variable A : U #variables x y z : A #def rev-concat ( p : x = y) -- A path from x to y in A. ( q : y = z) -- A path from y to z in A. : (rev A x z (concat A x y z p q)) = (concat A z y x (rev A y z q) (rev A x y p)) := idJ ( A, y, \\ z' q' -> (rev A x z' (concat A x y z' p q')) = (concat A z' y x (rev A y z' q') (rev A x y p)), rev ( y = x) ( concat A y y x refl (rev A x y p)) ( rev A x y p) ( refl-concat A y x (rev A x y p)), z, q) -- postwhiskering paths of paths #def homotopy-concat ( p q : x = y) -- Two paths from x to y in A. ( H : p = q) ( r : y = z) : (concat A x y z p r) = (concat A x y z q r) := idJ ( A, y, \\ z' r' -> (concat A x y z' p r') = (concat A x y z' q r'), H, z, r) -- prewhiskering paths of paths is much harder #def concat-homotopy ( p : x = y) : ( q : y = z) -> ( r : y = z) -> ( H : q = r) -> (concat A x y z p q) = (concat A x y z p r) := idJ ( A, x, \\ y' p' -> (q : y' = z) -> ( r : y' = z) -> ( H : q = r) -> (concat A x y' z p' q) = (concat A x y' z p' r), \\ q r H -> concat ( x = z) ( concat A x x z refl q) r ( concat A x x z refl r) ( concat (x = z) (concat A x x z refl q) q r (refl-concat A x z q) H) ( rev (x = z) (concat A x x z refl r) r (refl-concat A x z r)), y, p) -- a higher path comparing the two compositions #def concat-concat' ( p : x = y) -- A path from x to y in A. : ( q : y = z) -> (concat A x y z p q) = (concat' A x y z p q) := idJ ( A, x, \\ y' p' -> (q' : y' =_{A} z) -> (concat A x y' z p' q') =_{x =_{A} z} concat' A x y' z p' q', \\ q' -> refl-concat A x z q', y, p) -- a higher path comparing the two compositions in the other order #def concat'-concat ( p : x = y) -- A path from x to y in A. ( q : y = z) -- A path from y to z in A. : (concat' A x y z p q) = concat A x y z p q := rev ( x = z) ( concat A x y z p q) ( concat' A x y z p q) ( concat-concat' p q) -- this is easier to prove for concat' then for concat #def alt-triangle-rotation ( p : x = z) ( q : x = y) : ( r : y = z) -> ( H : p = concat' A x y z q r) -> (concat' A y x z (rev A x y q) p) = r := idJ ( A, x, \\ y' q' -> (r' : y' =_{A} z) -> ( H' : p = concat' A x y' z q' r') -> (concat' A y' x z (rev A x y' q') p) = r', \\ r' H' -> H', y, q) #end derived-path-coherence -- This needs to be outside the previous section because of the usage of concat-concat' A y x #def triangle-rotation ( A : U ) ( x y z : A) ( p : x = z) ( q : x = y) ( r : y = z) ( H : p = concat A x y z q r) : (concat A y x z (rev A x y q) p) = r := concat ( y = z) ( concat A y x z (rev A x y q) p) ( concat' A y x z (rev A x y q) p) r ( concat-concat' A y x z (rev A x y q) p) ( alt-triangle-rotation A x y z p q r ( concat ( x = z) ( p) ( concat A x y z q r) ( concat' A x y z q r) ( H) (concat-concat' A x y z q r))) Application of functions to paths \u00b6 #def ap ( A B : U ) ( x y : A) ( f : A -> B) ( p : x = y) : (f x = f y) := idJ (A, x, \\ y' -> \\ p' -> (f x = f y'), refl , y, p) #def ap-rev ( A B : U ) ( x y : A) ( f : A -> B) ( p : x = y) : ap A B y x f (rev A x y p) = rev B (f x) (f y) (ap A B x y f p) := idJ ( A, x, \\ y' p' -> ap A B y' x f (rev A x y' p') = rev B (f x) (f y') (ap A B x y' f p'), refl , y, p) #def ap-concat ( A B : U ) ( x y z : A) ( f : A -> B) ( p : x = y) ( q : y = z) : (ap A B x z f (concat A x y z p q)) = (concat B (f x) (f y) (f z) (ap A B x y f p) (ap A B y z f q)) := idJ ( A, y, \\ z' q' -> (ap A B x z' f (concat A x y z' p q')) = (concat B (f x) (f y) (f z') (ap A B x y f p) (ap A B y z' f q')), refl , z, q) #def rev-ap-rev ( A B : U ) ( x y : A) ( f : A -> B) ( p : x = y) : (rev B (f y) (f x) (ap A B y x f (rev A x y p))) = (ap A B x y f p) := idJ ( A, x, \\ y' p' -> (rev B (f y') (f x) (ap A B y' x f (rev A x y' p'))) = (ap A B x y' f p'), refl , y, p) -- For specific use #def concat-ap-rev-ap-id ( A B : U ) ( x y : A) ( f : A -> B) ( p : x = y) : (concat B (f y) (f x) (f y) (ap A B y x f (rev A x y p)) (ap A B x y f p)) = refl := idJ ( A, x, \\ y' p' -> (concat ( B) (f y') (f x) (f y') ( ap A B y' x f (rev A x y' p')) (ap A B x y' f p')) = refl , refl , y, p) #def ap-id ( A : U ) ( x y : A) ( p : x = y) : (ap A A x y (identity A) p) = p := idJ (A, x, \\ y' p' -> (ap A A x y' ( \\ z -> z) p') = p', refl , y, p) -- application of a function to homotopic paths yields homotopic paths #def ap-htpy ( A B : U ) ( x y : A) ( f : A -> B) ( p q : x = y) ( H : p = q) : (ap A B x y f p) = (ap A B x y f q) := idJ (x = y, p, \\ q' H' -> (ap A B x y f p) = (ap A B x y f q'), refl , q, H) #def ap-comp ( A B C : U ) ( x y : A) ( f : A -> B) ( g : B -> C) ( p : x = y) : (ap A C x y (composition A B C g f) p) = (ap B C (f x) (f y) g (ap A B x y f p)) := idJ ( A, x, \\ y' p' -> (ap A C x y' ( \\ z -> g (f z)) p') = (ap B C (f x) (f y') g (ap A B x y' f p')), refl , y, p) #def rev-ap-comp ( A B C : U ) ( x y : A) ( f : A -> B) ( g : B -> C) ( p : x = y) : (ap B C (f x) (f y) g (ap A B x y f p)) = (ap A C x y (composition A B C g f) p) := rev ( g (f x) = g (f y)) ( ap A C x y ( \\ z -> g (f z)) p) ( ap B C (f x) (f y) g (ap A B x y f p)) ( ap-comp A B C x y f g p) Transport \u00b6 #section transport #variable A : U #variable B : A -> U -- transport in a type family along a path in the base #def transport ( x y : A) ( p : x = y) ( u : B x) : B y := idJ (A, x, \\ y' p' -> B y', u, y, p) -- The lift of a base path to a path from a term in the total space to its transport. #def transport-lift ( x y : A) ( p : x = y) ( u : B x) : (x, u) =_{ \u2211 ( z : A), B z} (y, transport x y p u) := idJ ( A, x, \\ y' p' -> (x, u) =_{ \u2211 ( z : A), B z} (y', transport x y' p' u), refl , y, p) -- transport along concatenated paths #def transport-concat ( x y z : A) ( p : x = y) ( q : y = z) ( u : B x) : (transport x z (concat A x y z p q) u) = (transport y z q (transport x y p u)) := idJ ( A, y, \\ z' q' -> (transport x z' (concat A x y z' p q') u) = (transport y z' q' (transport x y p u)), refl , z, q) #def transport-concat-rev ( x y z : A) ( p : x = y) ( q : y = z) ( u : B x) : (transport y z q (transport x y p u)) = (transport x z (concat A x y z p q) u) := idJ ( A, y, \\ z' q' -> (transport y z' q' (transport x y p u)) = (transport x z' (concat A x y z' p q') u), refl , z, q) -- A path between transportation along homotopic paths #def transport2 ( x y : A) ( p q : x = y) ( H : p = q) ( u : B x) : (transport x y p u) = (transport x y q u) := idJ ( x = y, p, \\ q' H' -> (transport x y p u) = (transport x y q' u), refl , q, H) #def transport-loop ( a : A) ( b : B a) : (a = a) -> B a := \\ p -> (transport a a p b) #end transport Dependent application \u00b6 -- Application of dependent functions on paths #def apd ( A : U ) ( B : A -> U ) ( x y : A) ( f : ( z : A) -> B z) ( p : x = y) : ((transport A B x y p (f x)) = f y) := idJ (A, x, \\ y' p' -> ((transport A B x y' p' (f x)) = f y'), refl , y, p) Higher-order concatenation \u00b6 #section higher-concatenation #variable A : U -- triple concatenation #def triple-concat ( a0 a1 a2 a3 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) : a0 = a3 := concat A a0 a1 a3 p1 (concat A a1 a2 a3 p2 p3) #def quadruple-concat ( a0 a1 a2 a3 a4 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) ( p4 : a3 = a4) : a0 = a4 := triple-concat a0 a1 a2 a4 p1 p2 (concat A a2 a3 a4 p3 p4) #def quintuple-concat ( a0 a1 a2 a3 a4 a5 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) ( p4 : a3 = a4) ( p5 : a4 = a5) : a0 = a5 := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5) #def quintuple-concat-alternating ( a0 a1 : A) ( p1 : a0 = a1) ( a2 : A) ( p2 : a1 = a2) ( a3 : A) ( p3 : a2 = a3) ( a4 : A) ( p4 : a3 = a4) ( a5 : A) ( p5 : a4 = a5) : a0 = a5 := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5) #def 12ary-concat ( a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) ( p4 : a3 = a4) ( p5 : a4 = a5) ( p6 : a5 = a6) ( p7 : a6 = a7) ( p8 : a7 = a8) ( p9 : a8 = a9) ( p10 : a9 = a10) ( p11 : a10 = a11) ( p12 : a11 = a12) : a0 = a12 := quintuple-concat a0 a1 a2 a3 a4 a12 p1 p2 p3 p4 (quintuple-concat a4 a5 a6 a7 a8 a12 p5 p6 p7 p8 (quadruple-concat a8 a9 a10 a11 a12 p9 p10 p11 p12)) -- Same as above but with alternating arguments #def 12ary-concat-alternating ( a0 a1 : A) ( p1 : a0 = a1) ( a2 : A) ( p2 : a1 = a2) ( a3 : A) ( p3 : a2 = a3) ( a4 : A) ( p4 : a3 = a4) ( a5 : A) ( p5 : a4 = a5) ( a6 : A) ( p6 : a5 = a6) ( a7 : A) ( p7 : a6 = a7) ( a8 : A) ( p8 : a7 = a8) ( a9 : A) ( p9 : a8 = a9) ( a10 : A) ( p10 : a9 = a10) ( a11 : A) ( p11 : a10 = a11) ( a12 : A) ( p12 : a11 = a12) : a0 = a12 := 12ary-concat a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 #end higher-concatenation Higher-order coherences \u00b6 #def rev-refl-id-triple-concat ( A : U ) ( x y : A) ( p : x = y) : triple-concat A y x x y (rev A x y p) refl p = refl := idJ ( A, x, \\ y' p' -> triple-concat A y' x x y' (rev A x y' p') refl p' = refl , refl , y, p) #def ap-rev-refl-id-triple-concat ( A B : U ) ( x y : A) ( f : A -> B) ( p : x = y) : ap A B y y f (triple-concat A y x x y (rev A x y p) refl p) = refl := idJ ( A, x, \\ y' p' -> ap A B y' y' f (triple-concat A y' x x y' (rev A x y' p') refl p') = refl , refl , y, p) #def ap-triple-concat ( A B : U ) ( w x y z : A) ( f : A -> B) ( p : w = x) ( q : x = y) ( r : y = z) : ap A B w z f (triple-concat A w x y z p q r) = triple-concat B ( f w) ( f x) ( f y) ( f z) ( ap A B w x f p) ( ap A B x y f q) ( ap A B y z f r) := idJ ( A, y, \\ z' r' -> ap A B w z' f (triple-concat A w x y z' p q r') = triple-concat B ( f w) ( f x) ( f y) ( f z') ( ap A B w x f p) ( ap A B x y f q) ( ap A B y z' f r'), ap-concat A B w x y f p q, z, r) #def homotopy-triple-concat ( A : U ) ( w x y z : A) ( p q : w = x) ( r : x = y) ( s : y = z) ( H : p = q) : triple-concat A w x y z p r s = triple-concat A w x y z q r s := homotopy-concat A w x z p q H (concat A x y z r s) #def triple-homotopy-concat ( A : U ) ( w x y z : A) ( p : w = x) ( q r : x = y) ( s : y = z) ( H : q = r) : triple-concat A w x y z p q s = triple-concat A w x y z p r s := idJ ( x = y, q, \\ r' H' -> triple-concat A w x y z p q s = triple-concat A w x y z p r' s, refl , r, H)","title":"Paths"},{"location":"hott/01-paths.rzk/#1-paths","text":"This is a literate rzk file: #lang rzk-1","title":"1. Paths"},{"location":"hott/01-paths.rzk/#some-basic-path-algebra","text":"#section path-algebra #variable A : U #variables x y z : A -- path reversal #def rev ( p : x = y) -- A path from x to y in A. : y = x -- The reversal will be defined by path induction on p. := idJ (A, x, \\ y' p' -> y' = x, refl , y, p) -- path composition by induction on the second path #def concat ( p : x = y) -- A path from x to y in A. ( q : y = z) -- A path from y to z in A. : (x = z) := idJ (A, y, \\ z' q' -> (x = z'), p, z, q) -- an alternative construction of path composition by induction on the first path -- this is useful in situations where it's easier to induct on the first path #def concat' ( p : x = y) -- A path from x to y in A. : (y = z) -> (x = z) := idJ (A, x, \\ y' p' -> (y' = z) -> (x = z), \\ q' -> q', y, p) #end path-algebra","title":"Some basic path algebra"},{"location":"hott/01-paths.rzk/#some-basic-coherences-in-path-algebra","text":"#section basic-path-coherence #variable A : U #variables w x y z : A #def rev-rev ( p : x = y) -- A path from x to y in A. : (rev A y x (rev A x y p)) = p := idJ (A, x, \\ y' p' -> (rev A y' x (rev A x y' p')) = p', refl , y, p) -- the coherence we don't have definitionally #def refl-concat ( p : x = y) : (concat A x x y refl p) = p := idJ (A, x, \\ y' p' -> (concat A x x y' refl p') = p', refl , y, p) -- associativity #def concat-assoc ( p : w = x) -- A path from w to x in A. ( q : x = y) -- A path from x to y in A. ( r : y = z) -- A path from y to z in A. : concat A w y z (concat A w x y p q) r = concat A w x z p (concat A x y z q r) := idJ ( A, y, \\ z' r' -> concat A w y z' (concat A w x y p q) r' = concat A w x z' p (concat A x y z' q r'), refl , z, r) #def assoc-concat ( p : w = x) -- A path from w to x in A. ( q : x = y) -- A path from x to y in A. ( r : y = z) -- A path from y to z in A. : concat A w x z p (concat A x y z q r) = concat A w y z (concat A w x y p q) r := idJ ( A, y, \\ z' r' -> concat A w x z' p (concat A x y z' q r') = concat A w y z' (concat A w x y p q) r', refl , z, r) #def right-inverse ( p : x = y) : concat A x y x p (rev A x y p) = refl := idJ ( A, x, \\ y' p' -> concat A x y' x p' (rev A x y' p') = refl , refl , y, p) #def left-inverse ( p : x = y) : concat A y x y (rev A x y p) p = refl := idJ ( A, x, \\ y' p' -> concat A y' x y' (rev A x y' p') p' = refl , refl , y, p) -- concatenation of two paths with common codomain; defined using concat and rev #def zig-zag-concat ( p : x = y) -- A path from x to y in A. ( q : z = y) -- A path from z to y in A. : (x = z) := concat A x y z p (rev A z y q) -- concatenation of two paths with common domain; defined using concat and rev #def zag-zig-concat ( p : y = x) -- A path from y to x in A. ( q : y = z) -- A path from y to z in A. : (x = z) := concat A x y z (rev A y x p) q #def concat-right-cancel ( p q : x = y) -- Two paths from x to y in A. ( r : y = z) -- A path from y to z in A. : ((concat A x y z p r) = (concat A x y z q r)) -> (p = q) := idJ ( A, y, \\ z' r' -> ((concat A x y z' p r') = (concat A x y z' q r')) -> (p = q), \\ H -> H, z, r) #end basic-path-coherence","title":"Some basic coherences in path algebra"},{"location":"hott/01-paths.rzk/#some-derived-coherences-in-path-algebra","text":"The statements or proofs of the following path algebra coherences reference one of the path algebra coherences defined above. #section derived-path-coherence #variable A : U #variables x y z : A #def rev-concat ( p : x = y) -- A path from x to y in A. ( q : y = z) -- A path from y to z in A. : (rev A x z (concat A x y z p q)) = (concat A z y x (rev A y z q) (rev A x y p)) := idJ ( A, y, \\ z' q' -> (rev A x z' (concat A x y z' p q')) = (concat A z' y x (rev A y z' q') (rev A x y p)), rev ( y = x) ( concat A y y x refl (rev A x y p)) ( rev A x y p) ( refl-concat A y x (rev A x y p)), z, q) -- postwhiskering paths of paths #def homotopy-concat ( p q : x = y) -- Two paths from x to y in A. ( H : p = q) ( r : y = z) : (concat A x y z p r) = (concat A x y z q r) := idJ ( A, y, \\ z' r' -> (concat A x y z' p r') = (concat A x y z' q r'), H, z, r) -- prewhiskering paths of paths is much harder #def concat-homotopy ( p : x = y) : ( q : y = z) -> ( r : y = z) -> ( H : q = r) -> (concat A x y z p q) = (concat A x y z p r) := idJ ( A, x, \\ y' p' -> (q : y' = z) -> ( r : y' = z) -> ( H : q = r) -> (concat A x y' z p' q) = (concat A x y' z p' r), \\ q r H -> concat ( x = z) ( concat A x x z refl q) r ( concat A x x z refl r) ( concat (x = z) (concat A x x z refl q) q r (refl-concat A x z q) H) ( rev (x = z) (concat A x x z refl r) r (refl-concat A x z r)), y, p) -- a higher path comparing the two compositions #def concat-concat' ( p : x = y) -- A path from x to y in A. : ( q : y = z) -> (concat A x y z p q) = (concat' A x y z p q) := idJ ( A, x, \\ y' p' -> (q' : y' =_{A} z) -> (concat A x y' z p' q') =_{x =_{A} z} concat' A x y' z p' q', \\ q' -> refl-concat A x z q', y, p) -- a higher path comparing the two compositions in the other order #def concat'-concat ( p : x = y) -- A path from x to y in A. ( q : y = z) -- A path from y to z in A. : (concat' A x y z p q) = concat A x y z p q := rev ( x = z) ( concat A x y z p q) ( concat' A x y z p q) ( concat-concat' p q) -- this is easier to prove for concat' then for concat #def alt-triangle-rotation ( p : x = z) ( q : x = y) : ( r : y = z) -> ( H : p = concat' A x y z q r) -> (concat' A y x z (rev A x y q) p) = r := idJ ( A, x, \\ y' q' -> (r' : y' =_{A} z) -> ( H' : p = concat' A x y' z q' r') -> (concat' A y' x z (rev A x y' q') p) = r', \\ r' H' -> H', y, q) #end derived-path-coherence -- This needs to be outside the previous section because of the usage of concat-concat' A y x #def triangle-rotation ( A : U ) ( x y z : A) ( p : x = z) ( q : x = y) ( r : y = z) ( H : p = concat A x y z q r) : (concat A y x z (rev A x y q) p) = r := concat ( y = z) ( concat A y x z (rev A x y q) p) ( concat' A y x z (rev A x y q) p) r ( concat-concat' A y x z (rev A x y q) p) ( alt-triangle-rotation A x y z p q r ( concat ( x = z) ( p) ( concat A x y z q r) ( concat' A x y z q r) ( H) (concat-concat' A x y z q r)))","title":"Some derived coherences in path algebra"},{"location":"hott/01-paths.rzk/#application-of-functions-to-paths","text":"#def ap ( A B : U ) ( x y : A) ( f : A -> B) ( p : x = y) : (f x = f y) := idJ (A, x, \\ y' -> \\ p' -> (f x = f y'), refl , y, p) #def ap-rev ( A B : U ) ( x y : A) ( f : A -> B) ( p : x = y) : ap A B y x f (rev A x y p) = rev B (f x) (f y) (ap A B x y f p) := idJ ( A, x, \\ y' p' -> ap A B y' x f (rev A x y' p') = rev B (f x) (f y') (ap A B x y' f p'), refl , y, p) #def ap-concat ( A B : U ) ( x y z : A) ( f : A -> B) ( p : x = y) ( q : y = z) : (ap A B x z f (concat A x y z p q)) = (concat B (f x) (f y) (f z) (ap A B x y f p) (ap A B y z f q)) := idJ ( A, y, \\ z' q' -> (ap A B x z' f (concat A x y z' p q')) = (concat B (f x) (f y) (f z') (ap A B x y f p) (ap A B y z' f q')), refl , z, q) #def rev-ap-rev ( A B : U ) ( x y : A) ( f : A -> B) ( p : x = y) : (rev B (f y) (f x) (ap A B y x f (rev A x y p))) = (ap A B x y f p) := idJ ( A, x, \\ y' p' -> (rev B (f y') (f x) (ap A B y' x f (rev A x y' p'))) = (ap A B x y' f p'), refl , y, p) -- For specific use #def concat-ap-rev-ap-id ( A B : U ) ( x y : A) ( f : A -> B) ( p : x = y) : (concat B (f y) (f x) (f y) (ap A B y x f (rev A x y p)) (ap A B x y f p)) = refl := idJ ( A, x, \\ y' p' -> (concat ( B) (f y') (f x) (f y') ( ap A B y' x f (rev A x y' p')) (ap A B x y' f p')) = refl , refl , y, p) #def ap-id ( A : U ) ( x y : A) ( p : x = y) : (ap A A x y (identity A) p) = p := idJ (A, x, \\ y' p' -> (ap A A x y' ( \\ z -> z) p') = p', refl , y, p) -- application of a function to homotopic paths yields homotopic paths #def ap-htpy ( A B : U ) ( x y : A) ( f : A -> B) ( p q : x = y) ( H : p = q) : (ap A B x y f p) = (ap A B x y f q) := idJ (x = y, p, \\ q' H' -> (ap A B x y f p) = (ap A B x y f q'), refl , q, H) #def ap-comp ( A B C : U ) ( x y : A) ( f : A -> B) ( g : B -> C) ( p : x = y) : (ap A C x y (composition A B C g f) p) = (ap B C (f x) (f y) g (ap A B x y f p)) := idJ ( A, x, \\ y' p' -> (ap A C x y' ( \\ z -> g (f z)) p') = (ap B C (f x) (f y') g (ap A B x y' f p')), refl , y, p) #def rev-ap-comp ( A B C : U ) ( x y : A) ( f : A -> B) ( g : B -> C) ( p : x = y) : (ap B C (f x) (f y) g (ap A B x y f p)) = (ap A C x y (composition A B C g f) p) := rev ( g (f x) = g (f y)) ( ap A C x y ( \\ z -> g (f z)) p) ( ap B C (f x) (f y) g (ap A B x y f p)) ( ap-comp A B C x y f g p)","title":"Application of functions to paths"},{"location":"hott/01-paths.rzk/#transport","text":"#section transport #variable A : U #variable B : A -> U -- transport in a type family along a path in the base #def transport ( x y : A) ( p : x = y) ( u : B x) : B y := idJ (A, x, \\ y' p' -> B y', u, y, p) -- The lift of a base path to a path from a term in the total space to its transport. #def transport-lift ( x y : A) ( p : x = y) ( u : B x) : (x, u) =_{ \u2211 ( z : A), B z} (y, transport x y p u) := idJ ( A, x, \\ y' p' -> (x, u) =_{ \u2211 ( z : A), B z} (y', transport x y' p' u), refl , y, p) -- transport along concatenated paths #def transport-concat ( x y z : A) ( p : x = y) ( q : y = z) ( u : B x) : (transport x z (concat A x y z p q) u) = (transport y z q (transport x y p u)) := idJ ( A, y, \\ z' q' -> (transport x z' (concat A x y z' p q') u) = (transport y z' q' (transport x y p u)), refl , z, q) #def transport-concat-rev ( x y z : A) ( p : x = y) ( q : y = z) ( u : B x) : (transport y z q (transport x y p u)) = (transport x z (concat A x y z p q) u) := idJ ( A, y, \\ z' q' -> (transport y z' q' (transport x y p u)) = (transport x z' (concat A x y z' p q') u), refl , z, q) -- A path between transportation along homotopic paths #def transport2 ( x y : A) ( p q : x = y) ( H : p = q) ( u : B x) : (transport x y p u) = (transport x y q u) := idJ ( x = y, p, \\ q' H' -> (transport x y p u) = (transport x y q' u), refl , q, H) #def transport-loop ( a : A) ( b : B a) : (a = a) -> B a := \\ p -> (transport a a p b) #end transport","title":"Transport"},{"location":"hott/01-paths.rzk/#dependent-application","text":"-- Application of dependent functions on paths #def apd ( A : U ) ( B : A -> U ) ( x y : A) ( f : ( z : A) -> B z) ( p : x = y) : ((transport A B x y p (f x)) = f y) := idJ (A, x, \\ y' p' -> ((transport A B x y' p' (f x)) = f y'), refl , y, p)","title":"Dependent application"},{"location":"hott/01-paths.rzk/#higher-order-concatenation","text":"#section higher-concatenation #variable A : U -- triple concatenation #def triple-concat ( a0 a1 a2 a3 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) : a0 = a3 := concat A a0 a1 a3 p1 (concat A a1 a2 a3 p2 p3) #def quadruple-concat ( a0 a1 a2 a3 a4 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) ( p4 : a3 = a4) : a0 = a4 := triple-concat a0 a1 a2 a4 p1 p2 (concat A a2 a3 a4 p3 p4) #def quintuple-concat ( a0 a1 a2 a3 a4 a5 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) ( p4 : a3 = a4) ( p5 : a4 = a5) : a0 = a5 := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5) #def quintuple-concat-alternating ( a0 a1 : A) ( p1 : a0 = a1) ( a2 : A) ( p2 : a1 = a2) ( a3 : A) ( p3 : a2 = a3) ( a4 : A) ( p4 : a3 = a4) ( a5 : A) ( p5 : a4 = a5) : a0 = a5 := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5) #def 12ary-concat ( a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) ( p4 : a3 = a4) ( p5 : a4 = a5) ( p6 : a5 = a6) ( p7 : a6 = a7) ( p8 : a7 = a8) ( p9 : a8 = a9) ( p10 : a9 = a10) ( p11 : a10 = a11) ( p12 : a11 = a12) : a0 = a12 := quintuple-concat a0 a1 a2 a3 a4 a12 p1 p2 p3 p4 (quintuple-concat a4 a5 a6 a7 a8 a12 p5 p6 p7 p8 (quadruple-concat a8 a9 a10 a11 a12 p9 p10 p11 p12)) -- Same as above but with alternating arguments #def 12ary-concat-alternating ( a0 a1 : A) ( p1 : a0 = a1) ( a2 : A) ( p2 : a1 = a2) ( a3 : A) ( p3 : a2 = a3) ( a4 : A) ( p4 : a3 = a4) ( a5 : A) ( p5 : a4 = a5) ( a6 : A) ( p6 : a5 = a6) ( a7 : A) ( p7 : a6 = a7) ( a8 : A) ( p8 : a7 = a8) ( a9 : A) ( p9 : a8 = a9) ( a10 : A) ( p10 : a9 = a10) ( a11 : A) ( p11 : a10 = a11) ( a12 : A) ( p12 : a11 = a12) : a0 = a12 := 12ary-concat a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 #end higher-concatenation","title":"Higher-order concatenation"},{"location":"hott/01-paths.rzk/#higher-order-coherences","text":"#def rev-refl-id-triple-concat ( A : U ) ( x y : A) ( p : x = y) : triple-concat A y x x y (rev A x y p) refl p = refl := idJ ( A, x, \\ y' p' -> triple-concat A y' x x y' (rev A x y' p') refl p' = refl , refl , y, p) #def ap-rev-refl-id-triple-concat ( A B : U ) ( x y : A) ( f : A -> B) ( p : x = y) : ap A B y y f (triple-concat A y x x y (rev A x y p) refl p) = refl := idJ ( A, x, \\ y' p' -> ap A B y' y' f (triple-concat A y' x x y' (rev A x y' p') refl p') = refl , refl , y, p) #def ap-triple-concat ( A B : U ) ( w x y z : A) ( f : A -> B) ( p : w = x) ( q : x = y) ( r : y = z) : ap A B w z f (triple-concat A w x y z p q r) = triple-concat B ( f w) ( f x) ( f y) ( f z) ( ap A B w x f p) ( ap A B x y f q) ( ap A B y z f r) := idJ ( A, y, \\ z' r' -> ap A B w z' f (triple-concat A w x y z' p q r') = triple-concat B ( f w) ( f x) ( f y) ( f z') ( ap A B w x f p) ( ap A B x y f q) ( ap A B y z' f r'), ap-concat A B w x y f p q, z, r) #def homotopy-triple-concat ( A : U ) ( w x y z : A) ( p q : w = x) ( r : x = y) ( s : y = z) ( H : p = q) : triple-concat A w x y z p r s = triple-concat A w x y z q r s := homotopy-concat A w x z p q H (concat A x y z r s) #def triple-homotopy-concat ( A : U ) ( w x y z : A) ( p : w = x) ( q r : x = y) ( s : y = z) ( H : q = r) : triple-concat A w x y z p q s = triple-concat A w x y z p r s := idJ ( x = y, q, \\ r' H' -> triple-concat A w x y z p q s = triple-concat A w x y z p r' s, refl , r, H)","title":"Higher-order coherences"},{"location":"hott/02-homotopies.rzk/","text":"2. Homotopies \u00b6 This is a literate rzk file: #lang rzk-1 Homotopies and their algebra \u00b6 #section homotopies #variables A B : U -- The type of homotopies between parallel functions. #def homotopy ( f g : A -> B) -- Two parallel functions. : U := ( a : A) -> (f a = g a) -- The reversal of a homotopy #def homotopy-rev ( f g : A -> B) -- Two parallel functions. ( H : homotopy f g) -- A homotopy from f to g. : homotopy g f := \\ a -> rev B (f a) (g a) (H a) -- Homotopy composition is defined in diagrammatic order like concat but unlike composition. #def homotopy-composition ( f g h : A -> B) -- Three parallel functions. ( H : homotopy f g) ( K : homotopy g h) : homotopy f h := \\ a -> concat B (f a) (g a) (h a) (H a) (K a) #end homotopies Whiskering homotopies \u00b6 #section homotopy-whiskering #variables A B C : U #def homotopy-postwhisker ( f g : A -> B) ( H : homotopy A B f g) ( h : B -> C) : homotopy A C (composition A B C h f) (composition A B C h g) := \\ a -> ap B C (f a) (g a) h (H a) #def homotopy-prewhisker ( f g : B -> C) ( H : homotopy B C f g) ( h : A -> B) : homotopy A C (composition A B C f h) (composition A B C g h) := \\ a -> H (h a) #end homotopy-whiskering #def homotopy-whisker ( A B C D : U ) ( h k : B -> C) ( H : homotopy B C h k) ( f : A -> B) ( g : C -> D) : homotopy A D (triple-composition A B C D g h f) (triple-composition A B C D g k f) := homotopy-postwhisker A C D ( composition A B C h f) ( composition A B C k f) ( homotopy-prewhisker A B C h k H f) g Naturality \u00b6 -- The naturality square associated to a homotopy and a path. #def nat-htpy ( A B : U ) ( f g : A -> B) ( H : homotopy A B f g) ( x y : A) ( p : x = y) : (concat B (f x) (f y) (g y) (ap A B x y f p) (H y)) = (concat B (f x) (g x) (g y) (H x) (ap A B x y g p)) := idJ ( A, x, \\ y' p' -> (concat B (f x) (f y') (g y') (ap A B x y' f p') (H y')) = (concat B (f x) (g x) (g y') (H x) (ap A B x y' g p')), refl-concat B (f x) (g x) (H x), y, p) -- Naturality in another form #def triple-concat-nat-htpy ( A B : U ) ( f g : A -> B) ( H : homotopy A B f g) ( x y : A) ( p : x = y) : triple-concat ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (H x)) (ap A B x y f p) (H y) = ap A B x y g p := idJ ( A, x, \\ y' p' -> triple-concat ( B) ( g x) ( f x) ( f y') ( g y') ( rev B (f x) (g x) (H x)) ( ap A B x y' f p') ( H y') = ap A B x y' g p', rev-refl-id-triple-concat B (f x) (g x) (H x), y, p) An application \u00b6 #section cocone-naturality #variable A : U #variable f : A -> A #variable H : homotopy A A f (identity A) #variable a : A -- In the case of a homotopy H from f to the identity the previous square applies to the path H a to produce the following naturality square. #def cocone-naturality : (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = (concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a))) := nat-htpy A A f (identity A) H (f a) a (H a) -- After composing with ap-id, this naturality square transforms to the -- following: #def reduced-cocone-naturality : (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = (concat A (f (f a)) (f a) (a) (H (f a)) (H a)) := concat ( (f (f a)) = a) ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) ( concat ( A) ( f (f a)) ( f a) ( a) ( H (f a)) ( ap A A (f a) a (identity A) (H a))) ( concat A (f (f a)) (f a) (a) (H (f a)) (H a)) (cocone-naturality) (concat-homotopy ( A) ( f (f a)) ( f a) ( a) ( H (f a)) ( ap A A (f a) a (identity A) (H a)) ( H a) ( ap-id A (f a) a (H a))) -- Cancelling the path (H a) on the right and reversing yields a path we need: #def cocone-naturality-coherence : (H (f a)) =(ap A A (f a) a f (H a)) := rev ( f (f a) = f a) ( ap A A (f a) a f (H a)) (H (f a)) ( concat-right-cancel ( A) ( f (f a)) ( f a) ( a) ( ap A A (f a) a f (H a)) ( H (f a)) ( H a) ( reduced-cocone-naturality)) #end cocone-naturality Conjugation with higher homotopies \u00b6 -- Conjugation between higher homotopies #def triple-concat-higher-homotopy ( A B : U ) -- Two types. ( f g : A -> B) -- Two parallel functions. ( H K : homotopy A B f g) -- Two homotopies from f to g. ( \u03b1 : ( a : A) -> H a = K a) ( x y : A) ( p : f x = f y) : triple-concat B (g x) (f x) (f y) (g y) (rev B (f x) (g x) (H x)) p (H y) = triple-concat B (g x) (f x) (f y) (g y) (rev B (f x) (g x) (K x)) p (K y) := idJ ( f y = g y, H y, \\ Ky \u03b1' -> triple-concat ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (H x)) (p) (H y) = triple-concat ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (K x)) (p) (Ky), homotopy-triple-concat B ( g x) ( f x) ( f y) ( g y) ( rev B (f x) (g x) (H x)) ( rev B (f x) (g x) (K x)) p ( H y) ( ap ( f x = g x) ( g x = f x) ( H x) ( K x) ( \\ G -> rev B (f x)(g x) G) (\u03b1 x)), K y, \u03b1 y)","title":"Homotopies"},{"location":"hott/02-homotopies.rzk/#2-homotopies","text":"This is a literate rzk file: #lang rzk-1","title":"2. Homotopies"},{"location":"hott/02-homotopies.rzk/#homotopies-and-their-algebra","text":"#section homotopies #variables A B : U -- The type of homotopies between parallel functions. #def homotopy ( f g : A -> B) -- Two parallel functions. : U := ( a : A) -> (f a = g a) -- The reversal of a homotopy #def homotopy-rev ( f g : A -> B) -- Two parallel functions. ( H : homotopy f g) -- A homotopy from f to g. : homotopy g f := \\ a -> rev B (f a) (g a) (H a) -- Homotopy composition is defined in diagrammatic order like concat but unlike composition. #def homotopy-composition ( f g h : A -> B) -- Three parallel functions. ( H : homotopy f g) ( K : homotopy g h) : homotopy f h := \\ a -> concat B (f a) (g a) (h a) (H a) (K a) #end homotopies","title":"Homotopies and their algebra"},{"location":"hott/02-homotopies.rzk/#whiskering-homotopies","text":"#section homotopy-whiskering #variables A B C : U #def homotopy-postwhisker ( f g : A -> B) ( H : homotopy A B f g) ( h : B -> C) : homotopy A C (composition A B C h f) (composition A B C h g) := \\ a -> ap B C (f a) (g a) h (H a) #def homotopy-prewhisker ( f g : B -> C) ( H : homotopy B C f g) ( h : A -> B) : homotopy A C (composition A B C f h) (composition A B C g h) := \\ a -> H (h a) #end homotopy-whiskering #def homotopy-whisker ( A B C D : U ) ( h k : B -> C) ( H : homotopy B C h k) ( f : A -> B) ( g : C -> D) : homotopy A D (triple-composition A B C D g h f) (triple-composition A B C D g k f) := homotopy-postwhisker A C D ( composition A B C h f) ( composition A B C k f) ( homotopy-prewhisker A B C h k H f) g","title":"Whiskering homotopies"},{"location":"hott/02-homotopies.rzk/#naturality","text":"-- The naturality square associated to a homotopy and a path. #def nat-htpy ( A B : U ) ( f g : A -> B) ( H : homotopy A B f g) ( x y : A) ( p : x = y) : (concat B (f x) (f y) (g y) (ap A B x y f p) (H y)) = (concat B (f x) (g x) (g y) (H x) (ap A B x y g p)) := idJ ( A, x, \\ y' p' -> (concat B (f x) (f y') (g y') (ap A B x y' f p') (H y')) = (concat B (f x) (g x) (g y') (H x) (ap A B x y' g p')), refl-concat B (f x) (g x) (H x), y, p) -- Naturality in another form #def triple-concat-nat-htpy ( A B : U ) ( f g : A -> B) ( H : homotopy A B f g) ( x y : A) ( p : x = y) : triple-concat ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (H x)) (ap A B x y f p) (H y) = ap A B x y g p := idJ ( A, x, \\ y' p' -> triple-concat ( B) ( g x) ( f x) ( f y') ( g y') ( rev B (f x) (g x) (H x)) ( ap A B x y' f p') ( H y') = ap A B x y' g p', rev-refl-id-triple-concat B (f x) (g x) (H x), y, p)","title":"Naturality"},{"location":"hott/02-homotopies.rzk/#an-application","text":"#section cocone-naturality #variable A : U #variable f : A -> A #variable H : homotopy A A f (identity A) #variable a : A -- In the case of a homotopy H from f to the identity the previous square applies to the path H a to produce the following naturality square. #def cocone-naturality : (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = (concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a))) := nat-htpy A A f (identity A) H (f a) a (H a) -- After composing with ap-id, this naturality square transforms to the -- following: #def reduced-cocone-naturality : (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = (concat A (f (f a)) (f a) (a) (H (f a)) (H a)) := concat ( (f (f a)) = a) ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) ( concat ( A) ( f (f a)) ( f a) ( a) ( H (f a)) ( ap A A (f a) a (identity A) (H a))) ( concat A (f (f a)) (f a) (a) (H (f a)) (H a)) (cocone-naturality) (concat-homotopy ( A) ( f (f a)) ( f a) ( a) ( H (f a)) ( ap A A (f a) a (identity A) (H a)) ( H a) ( ap-id A (f a) a (H a))) -- Cancelling the path (H a) on the right and reversing yields a path we need: #def cocone-naturality-coherence : (H (f a)) =(ap A A (f a) a f (H a)) := rev ( f (f a) = f a) ( ap A A (f a) a f (H a)) (H (f a)) ( concat-right-cancel ( A) ( f (f a)) ( f a) ( a) ( ap A A (f a) a f (H a)) ( H (f a)) ( H a) ( reduced-cocone-naturality)) #end cocone-naturality","title":"An application"},{"location":"hott/02-homotopies.rzk/#conjugation-with-higher-homotopies","text":"-- Conjugation between higher homotopies #def triple-concat-higher-homotopy ( A B : U ) -- Two types. ( f g : A -> B) -- Two parallel functions. ( H K : homotopy A B f g) -- Two homotopies from f to g. ( \u03b1 : ( a : A) -> H a = K a) ( x y : A) ( p : f x = f y) : triple-concat B (g x) (f x) (f y) (g y) (rev B (f x) (g x) (H x)) p (H y) = triple-concat B (g x) (f x) (f y) (g y) (rev B (f x) (g x) (K x)) p (K y) := idJ ( f y = g y, H y, \\ Ky \u03b1' -> triple-concat ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (H x)) (p) (H y) = triple-concat ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (K x)) (p) (Ky), homotopy-triple-concat B ( g x) ( f x) ( f y) ( g y) ( rev B (f x) (g x) (H x)) ( rev B (f x) (g x) (K x)) p ( H y) ( ap ( f x = g x) ( g x = f x) ( H x) ( K x) ( \\ G -> rev B (f x)(g x) G) (\u03b1 x)), K y, \u03b1 y)","title":"Conjugation with higher homotopies"},{"location":"hott/03-equivalences.rzk/","text":"3. Equivalences \u00b6 This is a literate rzk file: #lang rzk-1 Sections, retractions, and equivalences \u00b6 #section is-equiv #variables A B : U #def has-section ( f : A -> B) : U := \u2211 ( s : B -> A), homotopy B B (composition B A B f s)(identity B) #def has-retraction ( f : A -> B) : U := \u2211 ( r : B -> A), homotopy A A (composition A B A r f)(identity A) -- equivalences are bi-invertible maps #def is-equiv ( f : A -> B) : U := prod (has-retraction f) (has-section f) #end is-equiv Equivalence data \u00b6 #section equivalence-data #variables A B : U #variable f : A -> B #variable fisequiv : is-equiv A B f #def is-equiv-section uses ( f ) : B -> A := ( first ( second fisequiv)) #def is-equiv-retraction uses ( f ) : B -> A := ( first ( first fisequiv)) -- the homotopy between the section and retraction of an equivalence #def homotopic-inverses-is-equiv uses ( f ) : homotopy B A is-equiv-section is-equiv-retraction := homotopy-composition B A ( is-equiv-section) ( triple-composition B A B A is-equiv-retraction f is-equiv-section) ( is-equiv-retraction) ( homotopy-rev B A ( triple-composition B A B A is-equiv-retraction f is-equiv-section) ( is-equiv-section) ( homotopy-prewhisker B A A ( composition A B A is-equiv-retraction f) ( identity A) ( second ( first fisequiv)) ( is-equiv-section))) ( homotopy-postwhisker B B A ( composition B A B f is-equiv-section) ( identity B) ( second ( second fisequiv)) ( is-equiv-retraction)) #end equivalence-data Invertible maps \u00b6 -- the following type of more coherent equivalences is not a proposition #def has-inverse ( A B : U ) ( f : A -> B) : U := \u2211 ( g : B -> A), ( prod ( homotopy A A (composition A B A g f)(identity A)) -- The retracting homotopy ( homotopy B B (composition B A B f g)(identity B))) -- The section homotopy Equivalences are invertible maps \u00b6 -- invertible maps are equivalences #def is-equiv-has-inverse ( A B : U ) ( f : A -> B) ( fhasinverse : has-inverse A B f) : is-equiv A B f := ( ( first fhasinverse, first ( second fhasinverse)), ( first fhasinverse, second ( second fhasinverse))) -- equivalences are invertible #def has-inverse-is-equiv ( A B : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) : has-inverse A B f := ( is-equiv-section A B f fisequiv, ( homotopy-composition A A ( composition A B A (is-equiv-section A B f fisequiv) f) ( composition A B A (is-equiv-retraction A B f fisequiv) f) ( identity A) ( homotopy-prewhisker A B A ( is-equiv-section A B f fisequiv) ( is-equiv-retraction A B f fisequiv) ( homotopic-inverses-is-equiv A B f fisequiv) ( f)) ( second ( first fisequiv)) , ( second ( second fisequiv)))) Invertible map data \u00b6 #section has-inverse-data #variables A B : U #variable f : A -> B #variable fhasinverse : has-inverse A B f -- The inverse of a map with an inverse #def has-inverse-inverse uses ( f ) : B -> A := first (fhasinverse) -- Some iterated composites associated to a pair of invertible maps. #def has-inverse-retraction-composite uses ( B fhasinverse ) : A -> A := composition A B A has-inverse-inverse f #def has-inverse-section-composite uses ( A fhasinverse ) : B -> B := composition B A B f has-inverse-inverse -- This composite is parallel to f; we won't need the dual notion. #def has-inverse-triple-composite uses ( fhasinverse ) : A -> B := triple-composition A B A B f has-inverse-inverse f -- This composite is also parallel to f; again we won't need the dual notion. #def has-inverse-quintuple-composite uses ( fhasinverse ) : A -> B := \\ a -> f (has-inverse-inverse (f (has-inverse-inverse (f a)))) #end has-inverse-data Composing equivalences \u00b6 The type of equivalences between types uses is-equiv rather than has-inverse. #def Equiv ( A B : U ) : U := \u2211 ( f : A -> B), ((is-equiv A) B) f The data of an equivalence is not symmetric so we promote an equivalence to an invertible map to prove symmetry. #def inv-equiv ( A B : U ) ( e : Equiv A B) : Equiv B A := ( first (has-inverse-is-equiv A B ( first e) ( second e)) , ( ( first e , second ( second (has-inverse-is-equiv A B ( first e) ( second e)))) , ( first e , first ( second (has-inverse-is-equiv A B ( first e) ( second e)))))) Composition of equivalences in diagrammatic order. #def comp-equiv ( A B C : U ) ( A=B : Equiv A B) ( B=C : Equiv B C) : Equiv A C := ( \\ a -> ( first B=C) (( first A=B) a), -- the composite equivalence ( ( \\ c -> ( first ( first ( second A=B))) (( first ( first ( second (B=C)))) c), ( \\ a -> concat A ( ( first ( first ( second A=B))) (( first ( first ( second B=C))) (( first B=C) (( first A=B) a)))) ( ( first ( first ( second A=B))) (( first A=B) a)) ( a) ( ap B A ( ( first ( first ( second B=C))) (( first B=C) (( first A=B) a))) -- should be inferred ( ( first A=B) a) -- should be inferred ( first ( first ( second A=B))) ( ( second ( first ( second B=C))) (( first A=B) a))) ( ( second ( first ( second A=B))) a))), ( \\ c -> ( first ( second ( second A=B))) ( ( first ( second ( second (B=C)))) c), ( \\ c -> concat C ( ( first B=C) (( first A=B) (( first ( second ( second A=B))) (( first ( second ( second B=C))) c)))) ( ( first B=C) (( first ( second ( second B=C))) c)) ( c) ( ap B C ( ( first A=B) (( first ( second ( second A=B))) (( first ( second ( second B=C))) c))) -- should be inferred ( ( first ( second ( second B=C))) c) -- should be inferred ( first B=C) ( ( second ( second ( second A=B))) (( first ( second ( second B=C))) c))) ( ( second ( second ( second B=C))) c))))) -- now we compose the functions that are equivalences #def compose-is-equiv ( A B C : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) ( g : B -> C) ( gisequiv : is-equiv B C g) : is-equiv A C (composition A B C g f) := ( ( composition C B A ( is-equiv-retraction A B f fisequiv) ( is-equiv-retraction B C g gisequiv), \\ a -> concat A ( (is-equiv-retraction A B f fisequiv) ((is-equiv-retraction B C g gisequiv) (g (f a)))) ( (is-equiv-retraction A B f fisequiv) (f a)) ( a) ( ap B A ( (is-equiv-retraction B C g gisequiv) (g (f a))) -- should be inferred ( f a) -- should be inferred ( is-equiv-retraction A B f fisequiv) ( ( second ( first gisequiv)) (f a))) ( ( second ( first fisequiv)) a)), ( composition C B A ( is-equiv-section A B f fisequiv) ( is-equiv-section B C g gisequiv), \\ c -> concat C ( g (f (( first ( second fisequiv)) (( first ( second gisequiv)) c)))) ( g (( first ( second gisequiv)) c)) ( c) ( ap B C ( f (( first ( second fisequiv)) (( first ( second gisequiv)) c))) -- should be inferred ( ( first ( second gisequiv)) c) -- should be inferred ( g) ( ( second ( second fisequiv)) (( first ( second gisequiv)) c))) (( second ( second gisequiv)) c))) -- Right cancellation of equivalences in diagrammatic order. #def right-cancel-equiv ( A B C : U ) ( A=C : Equiv A C) ( B=C : Equiv B C) : Equiv A B := comp-equiv A C B (A=C) (inv-equiv B C B=C) -- Left cancellation of equivalences in diagrammatic order. #def left-cancel-equiv ( A B C : U ) ( A=B : Equiv A B) ( A=C : Equiv A C) : Equiv B C := comp-equiv B A C (inv-equiv A B A=B) (A=C) -- a composition of three equivalences #def triple-comp-equiv ( A B C D : U ) ( A=B : Equiv A B) ( B=C : Equiv B C) ( C=D : Equiv C D) : Equiv A D := comp-equiv A B D (A=B) (comp-equiv B C D B=C C=D) #def triple-compose-is-equiv ( A B C D : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) ( g : B -> C) ( gisequiv : is-equiv B C g) ( h : C -> D) ( hisequiv : is-equiv C D h) : is-equiv A D (triple-composition A B C D h g f) := compose-is-equiv A B D ( f) ( fisequiv) ( composition B C D h g) ( compose-is-equiv B C D g gisequiv h hisequiv) Equivalences and homotopy \u00b6 If a map is homotopic to an equivalence it is an equivalence. #def is-equiv-homotopic-is-equiv ( A B : U ) ( f g : A -> B) ( H : homotopy A B f g) ( gisequiv : is-equiv A B g) : is-equiv A B f := ( ( first ( first gisequiv), \\ a -> concat A ( ( first ( first gisequiv)) (f a)) ( ( first ( first gisequiv)) (g a)) ( a) ( ap B A (f a) (g a) ( first ( first gisequiv)) (H a)) ( ( second ( first gisequiv)) a)), ( first ( second gisequiv), \\ b -> concat B ( f (( first ( second gisequiv)) b)) ( g (( first ( second gisequiv)) b)) ( b) ( H (( first ( second gisequiv)) b)) ( ( second ( second gisequiv)) b))) #def is-equiv-rev-homotopic-is-equiv ( A B : U ) ( f g : A -> B) ( H : homotopy A B f g) ( fisequiv : is-equiv A B f) : is-equiv A B g := is-equiv-homotopic-is-equiv A B g f (homotopy-rev A B f g H) fisequiv Function extensionality \u00b6 By path induction, an identification between functions defines a homotopy #def htpy-eq ( X : U ) ( A : X -> U ) ( f g : ( x : X) -> A x) ( p : f = g) : ( x : X) -> (f x = g x) := idJ ( (x : X) -> A x, f, \\ g' p' -> ( x : X) -> (f x = g' x), \\ x -> refl , g, p) The function extensionality axiom asserts that this map defines a family of equivalences. -- The type that encodes the function extensionality axiom. #def FunExt : U := ( X : U ) -> ( A : X -> U ) -> ( f : ( x : X) -> A x) -> ( g : ( x : X) -> A x) -> is-equiv (f = g) ( (x : X) -> f x = g x)(htpy-eq X A f g) -- The equivalence provided by function extensionality. #def FunExt-equiv ( funext : FunExt) ( X : U ) ( A : X -> U ) ( f g : ( x : X) -> A x) : Equiv (f = g) ( (x : X) -> f x = g x) := (htpy-eq X A f g, funext X A f g) -- In particular, function extensionality implies that homotopies give rise to identifications. This defines eq-htpy to be the retraction to htpy-eq. #def eq-htpy ( funext : FunExt) ( X : U ) ( A : X -> U ) ( f g : ( x : X) -> A x) : ( (x : X) -> f x = g x) -> (f = g) := first ( first (funext X A f g)) -- Using function extensionality, a fiberwise equivalence defines an equivalence of dependent function types #def function-equiv-fibered-equiv ( funext : FunExt) ( X : U ) ( A B : X -> U ) ( fibequiv : ( x : X) -> Equiv (A x) (B x)) : Equiv ( (x : X) -> A x) ( (x : X) -> B x) := ( ( \\ a x -> ( first (fibequiv x)) (a x)), ( ( ( \\ b x -> ( first ( first ( second (fibequiv x)))) (b x)), \\ a -> eq-htpy funext X A ( \\ x -> ( first ( first ( second (fibequiv x)))) (( first (fibequiv x)) (a x))) a ( \\ x -> ( second ( first ( second (fibequiv x)))) (a x))), ( ( \\ b x -> ( first ( second ( second (fibequiv x)))) (b x)), ( \\ b -> eq-htpy funext X B ( \\ x -> ( first (fibequiv x)) (( first ( second ( second (fibequiv x)))) (b x))) b ( \\ x -> ( second ( second ( second (fibequiv x)))) (b x)))))) Embeddings \u00b6 #def is-emb ( A B : U ) ( f : A -> B) : U := ( x : A) -> ( y : A) -> is-equiv (x = y) (f x = f y) (ap A B x y f) #def Emb ( A B : U ) : U := ( \u2211 (f : A -> B), is-emb A B f) #def is-emb-is-inhabited-emb ( A B : U ) ( f : A -> B) ( e : A -> is-emb A B f) : is-emb A B f := \\ x y -> e x x y #def inv-ap-is-emb ( A B : U ) ( f : A -> B) ( fisemb : is-emb A B f) ( x y : A) ( p : f x = f y) : (x = y) := ( first ( first (fisemb x y))) p Reversal is an equivalence \u00b6 #def has-retraction-rev ( A : U ) ( y : A) : ( x : A) -> has-retraction (x = y) (y = x) (( \\ p -> ((rev A x y) p))) := \\ x -> ((rev A y x), \\ p -> idJ (A, x, \\ y' p' -> ((composition (x = y') (y' = x) (x = y') (rev A y' x) (rev A x y'))(p') =_{x = y'} p'), refl , y, p)) #def has-section-rev ( A : U ) ( y : A) : ( x : A) -> has-section (x = y) (y = x) (( \\ p -> ((rev A x y) p))) := \\ x -> ((rev A y x), \\ p -> idJ (A, y, \\ x' p' -> ((composition (y = x') (x' = y) (y = x') (rev A x' y) (rev A y x'))(p') =_{y = x'} p'), refl , x, p)) #def is-equiv-rev ( A : U ) ( x y : A) : is-equiv (x = y) (y = x) (rev A x y) := ((has-retraction-rev A y x), (has-section-rev A y x))","title":"Equivalences"},{"location":"hott/03-equivalences.rzk/#3-equivalences","text":"This is a literate rzk file: #lang rzk-1","title":"3. Equivalences"},{"location":"hott/03-equivalences.rzk/#sections-retractions-and-equivalences","text":"#section is-equiv #variables A B : U #def has-section ( f : A -> B) : U := \u2211 ( s : B -> A), homotopy B B (composition B A B f s)(identity B) #def has-retraction ( f : A -> B) : U := \u2211 ( r : B -> A), homotopy A A (composition A B A r f)(identity A) -- equivalences are bi-invertible maps #def is-equiv ( f : A -> B) : U := prod (has-retraction f) (has-section f) #end is-equiv","title":"Sections, retractions, and equivalences"},{"location":"hott/03-equivalences.rzk/#equivalence-data","text":"#section equivalence-data #variables A B : U #variable f : A -> B #variable fisequiv : is-equiv A B f #def is-equiv-section uses ( f ) : B -> A := ( first ( second fisequiv)) #def is-equiv-retraction uses ( f ) : B -> A := ( first ( first fisequiv)) -- the homotopy between the section and retraction of an equivalence #def homotopic-inverses-is-equiv uses ( f ) : homotopy B A is-equiv-section is-equiv-retraction := homotopy-composition B A ( is-equiv-section) ( triple-composition B A B A is-equiv-retraction f is-equiv-section) ( is-equiv-retraction) ( homotopy-rev B A ( triple-composition B A B A is-equiv-retraction f is-equiv-section) ( is-equiv-section) ( homotopy-prewhisker B A A ( composition A B A is-equiv-retraction f) ( identity A) ( second ( first fisequiv)) ( is-equiv-section))) ( homotopy-postwhisker B B A ( composition B A B f is-equiv-section) ( identity B) ( second ( second fisequiv)) ( is-equiv-retraction)) #end equivalence-data","title":"Equivalence data"},{"location":"hott/03-equivalences.rzk/#invertible-maps","text":"-- the following type of more coherent equivalences is not a proposition #def has-inverse ( A B : U ) ( f : A -> B) : U := \u2211 ( g : B -> A), ( prod ( homotopy A A (composition A B A g f)(identity A)) -- The retracting homotopy ( homotopy B B (composition B A B f g)(identity B))) -- The section homotopy","title":"Invertible maps"},{"location":"hott/03-equivalences.rzk/#equivalences-are-invertible-maps","text":"-- invertible maps are equivalences #def is-equiv-has-inverse ( A B : U ) ( f : A -> B) ( fhasinverse : has-inverse A B f) : is-equiv A B f := ( ( first fhasinverse, first ( second fhasinverse)), ( first fhasinverse, second ( second fhasinverse))) -- equivalences are invertible #def has-inverse-is-equiv ( A B : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) : has-inverse A B f := ( is-equiv-section A B f fisequiv, ( homotopy-composition A A ( composition A B A (is-equiv-section A B f fisequiv) f) ( composition A B A (is-equiv-retraction A B f fisequiv) f) ( identity A) ( homotopy-prewhisker A B A ( is-equiv-section A B f fisequiv) ( is-equiv-retraction A B f fisequiv) ( homotopic-inverses-is-equiv A B f fisequiv) ( f)) ( second ( first fisequiv)) , ( second ( second fisequiv))))","title":"Equivalences are invertible maps"},{"location":"hott/03-equivalences.rzk/#invertible-map-data","text":"#section has-inverse-data #variables A B : U #variable f : A -> B #variable fhasinverse : has-inverse A B f -- The inverse of a map with an inverse #def has-inverse-inverse uses ( f ) : B -> A := first (fhasinverse) -- Some iterated composites associated to a pair of invertible maps. #def has-inverse-retraction-composite uses ( B fhasinverse ) : A -> A := composition A B A has-inverse-inverse f #def has-inverse-section-composite uses ( A fhasinverse ) : B -> B := composition B A B f has-inverse-inverse -- This composite is parallel to f; we won't need the dual notion. #def has-inverse-triple-composite uses ( fhasinverse ) : A -> B := triple-composition A B A B f has-inverse-inverse f -- This composite is also parallel to f; again we won't need the dual notion. #def has-inverse-quintuple-composite uses ( fhasinverse ) : A -> B := \\ a -> f (has-inverse-inverse (f (has-inverse-inverse (f a)))) #end has-inverse-data","title":"Invertible map data"},{"location":"hott/03-equivalences.rzk/#composing-equivalences","text":"The type of equivalences between types uses is-equiv rather than has-inverse. #def Equiv ( A B : U ) : U := \u2211 ( f : A -> B), ((is-equiv A) B) f The data of an equivalence is not symmetric so we promote an equivalence to an invertible map to prove symmetry. #def inv-equiv ( A B : U ) ( e : Equiv A B) : Equiv B A := ( first (has-inverse-is-equiv A B ( first e) ( second e)) , ( ( first e , second ( second (has-inverse-is-equiv A B ( first e) ( second e)))) , ( first e , first ( second (has-inverse-is-equiv A B ( first e) ( second e)))))) Composition of equivalences in diagrammatic order. #def comp-equiv ( A B C : U ) ( A=B : Equiv A B) ( B=C : Equiv B C) : Equiv A C := ( \\ a -> ( first B=C) (( first A=B) a), -- the composite equivalence ( ( \\ c -> ( first ( first ( second A=B))) (( first ( first ( second (B=C)))) c), ( \\ a -> concat A ( ( first ( first ( second A=B))) (( first ( first ( second B=C))) (( first B=C) (( first A=B) a)))) ( ( first ( first ( second A=B))) (( first A=B) a)) ( a) ( ap B A ( ( first ( first ( second B=C))) (( first B=C) (( first A=B) a))) -- should be inferred ( ( first A=B) a) -- should be inferred ( first ( first ( second A=B))) ( ( second ( first ( second B=C))) (( first A=B) a))) ( ( second ( first ( second A=B))) a))), ( \\ c -> ( first ( second ( second A=B))) ( ( first ( second ( second (B=C)))) c), ( \\ c -> concat C ( ( first B=C) (( first A=B) (( first ( second ( second A=B))) (( first ( second ( second B=C))) c)))) ( ( first B=C) (( first ( second ( second B=C))) c)) ( c) ( ap B C ( ( first A=B) (( first ( second ( second A=B))) (( first ( second ( second B=C))) c))) -- should be inferred ( ( first ( second ( second B=C))) c) -- should be inferred ( first B=C) ( ( second ( second ( second A=B))) (( first ( second ( second B=C))) c))) ( ( second ( second ( second B=C))) c))))) -- now we compose the functions that are equivalences #def compose-is-equiv ( A B C : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) ( g : B -> C) ( gisequiv : is-equiv B C g) : is-equiv A C (composition A B C g f) := ( ( composition C B A ( is-equiv-retraction A B f fisequiv) ( is-equiv-retraction B C g gisequiv), \\ a -> concat A ( (is-equiv-retraction A B f fisequiv) ((is-equiv-retraction B C g gisequiv) (g (f a)))) ( (is-equiv-retraction A B f fisequiv) (f a)) ( a) ( ap B A ( (is-equiv-retraction B C g gisequiv) (g (f a))) -- should be inferred ( f a) -- should be inferred ( is-equiv-retraction A B f fisequiv) ( ( second ( first gisequiv)) (f a))) ( ( second ( first fisequiv)) a)), ( composition C B A ( is-equiv-section A B f fisequiv) ( is-equiv-section B C g gisequiv), \\ c -> concat C ( g (f (( first ( second fisequiv)) (( first ( second gisequiv)) c)))) ( g (( first ( second gisequiv)) c)) ( c) ( ap B C ( f (( first ( second fisequiv)) (( first ( second gisequiv)) c))) -- should be inferred ( ( first ( second gisequiv)) c) -- should be inferred ( g) ( ( second ( second fisequiv)) (( first ( second gisequiv)) c))) (( second ( second gisequiv)) c))) -- Right cancellation of equivalences in diagrammatic order. #def right-cancel-equiv ( A B C : U ) ( A=C : Equiv A C) ( B=C : Equiv B C) : Equiv A B := comp-equiv A C B (A=C) (inv-equiv B C B=C) -- Left cancellation of equivalences in diagrammatic order. #def left-cancel-equiv ( A B C : U ) ( A=B : Equiv A B) ( A=C : Equiv A C) : Equiv B C := comp-equiv B A C (inv-equiv A B A=B) (A=C) -- a composition of three equivalences #def triple-comp-equiv ( A B C D : U ) ( A=B : Equiv A B) ( B=C : Equiv B C) ( C=D : Equiv C D) : Equiv A D := comp-equiv A B D (A=B) (comp-equiv B C D B=C C=D) #def triple-compose-is-equiv ( A B C D : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) ( g : B -> C) ( gisequiv : is-equiv B C g) ( h : C -> D) ( hisequiv : is-equiv C D h) : is-equiv A D (triple-composition A B C D h g f) := compose-is-equiv A B D ( f) ( fisequiv) ( composition B C D h g) ( compose-is-equiv B C D g gisequiv h hisequiv)","title":"Composing equivalences"},{"location":"hott/03-equivalences.rzk/#equivalences-and-homotopy","text":"If a map is homotopic to an equivalence it is an equivalence. #def is-equiv-homotopic-is-equiv ( A B : U ) ( f g : A -> B) ( H : homotopy A B f g) ( gisequiv : is-equiv A B g) : is-equiv A B f := ( ( first ( first gisequiv), \\ a -> concat A ( ( first ( first gisequiv)) (f a)) ( ( first ( first gisequiv)) (g a)) ( a) ( ap B A (f a) (g a) ( first ( first gisequiv)) (H a)) ( ( second ( first gisequiv)) a)), ( first ( second gisequiv), \\ b -> concat B ( f (( first ( second gisequiv)) b)) ( g (( first ( second gisequiv)) b)) ( b) ( H (( first ( second gisequiv)) b)) ( ( second ( second gisequiv)) b))) #def is-equiv-rev-homotopic-is-equiv ( A B : U ) ( f g : A -> B) ( H : homotopy A B f g) ( fisequiv : is-equiv A B f) : is-equiv A B g := is-equiv-homotopic-is-equiv A B g f (homotopy-rev A B f g H) fisequiv","title":"Equivalences and homotopy"},{"location":"hott/03-equivalences.rzk/#function-extensionality","text":"By path induction, an identification between functions defines a homotopy #def htpy-eq ( X : U ) ( A : X -> U ) ( f g : ( x : X) -> A x) ( p : f = g) : ( x : X) -> (f x = g x) := idJ ( (x : X) -> A x, f, \\ g' p' -> ( x : X) -> (f x = g' x), \\ x -> refl , g, p) The function extensionality axiom asserts that this map defines a family of equivalences. -- The type that encodes the function extensionality axiom. #def FunExt : U := ( X : U ) -> ( A : X -> U ) -> ( f : ( x : X) -> A x) -> ( g : ( x : X) -> A x) -> is-equiv (f = g) ( (x : X) -> f x = g x)(htpy-eq X A f g) -- The equivalence provided by function extensionality. #def FunExt-equiv ( funext : FunExt) ( X : U ) ( A : X -> U ) ( f g : ( x : X) -> A x) : Equiv (f = g) ( (x : X) -> f x = g x) := (htpy-eq X A f g, funext X A f g) -- In particular, function extensionality implies that homotopies give rise to identifications. This defines eq-htpy to be the retraction to htpy-eq. #def eq-htpy ( funext : FunExt) ( X : U ) ( A : X -> U ) ( f g : ( x : X) -> A x) : ( (x : X) -> f x = g x) -> (f = g) := first ( first (funext X A f g)) -- Using function extensionality, a fiberwise equivalence defines an equivalence of dependent function types #def function-equiv-fibered-equiv ( funext : FunExt) ( X : U ) ( A B : X -> U ) ( fibequiv : ( x : X) -> Equiv (A x) (B x)) : Equiv ( (x : X) -> A x) ( (x : X) -> B x) := ( ( \\ a x -> ( first (fibequiv x)) (a x)), ( ( ( \\ b x -> ( first ( first ( second (fibequiv x)))) (b x)), \\ a -> eq-htpy funext X A ( \\ x -> ( first ( first ( second (fibequiv x)))) (( first (fibequiv x)) (a x))) a ( \\ x -> ( second ( first ( second (fibequiv x)))) (a x))), ( ( \\ b x -> ( first ( second ( second (fibequiv x)))) (b x)), ( \\ b -> eq-htpy funext X B ( \\ x -> ( first (fibequiv x)) (( first ( second ( second (fibequiv x)))) (b x))) b ( \\ x -> ( second ( second ( second (fibequiv x)))) (b x))))))","title":"Function extensionality"},{"location":"hott/03-equivalences.rzk/#embeddings","text":"#def is-emb ( A B : U ) ( f : A -> B) : U := ( x : A) -> ( y : A) -> is-equiv (x = y) (f x = f y) (ap A B x y f) #def Emb ( A B : U ) : U := ( \u2211 (f : A -> B), is-emb A B f) #def is-emb-is-inhabited-emb ( A B : U ) ( f : A -> B) ( e : A -> is-emb A B f) : is-emb A B f := \\ x y -> e x x y #def inv-ap-is-emb ( A B : U ) ( f : A -> B) ( fisemb : is-emb A B f) ( x y : A) ( p : f x = f y) : (x = y) := ( first ( first (fisemb x y))) p","title":"Embeddings"},{"location":"hott/03-equivalences.rzk/#reversal-is-an-equivalence","text":"#def has-retraction-rev ( A : U ) ( y : A) : ( x : A) -> has-retraction (x = y) (y = x) (( \\ p -> ((rev A x y) p))) := \\ x -> ((rev A y x), \\ p -> idJ (A, x, \\ y' p' -> ((composition (x = y') (y' = x) (x = y') (rev A y' x) (rev A x y'))(p') =_{x = y'} p'), refl , y, p)) #def has-section-rev ( A : U ) ( y : A) : ( x : A) -> has-section (x = y) (y = x) (( \\ p -> ((rev A x y) p))) := \\ x -> ((rev A y x), \\ p -> idJ (A, y, \\ x' p' -> ((composition (y = x') (x' = y) (y = x') (rev A x' y) (rev A y x'))(p') =_{y = x'} p'), refl , x, p)) #def is-equiv-rev ( A : U ) ( x y : A) : is-equiv (x = y) (y = x) (rev A x y) := ((has-retraction-rev A y x), (has-section-rev A y x))","title":"Reversal is an equivalence"},{"location":"hott/04-half-adjoint-equivalences.rzk/","text":"4. Half Adjoint Equivalences \u00b6 This is a literate rzk file: #lang rzk-1 Half adjoint equivalences \u00b6 -- We'll require a more coherent notion of equivalence #def is-half-adjoint-equiv ( A B : U ) ( f : A -> B) : U := \u2211 ( fhasinverse : (has-inverse A B f)), ( a : A) -> (( second ( second fhasinverse)) (f a)) = (ap A B (has-inverse-retraction-composite A B f fhasinverse a) a ( f) ((( first ( second fhasinverse))) a)) -- By function extensionality, the previous definition coincides with the -- following one: #def is-half-adjoint-equiv' ( A B : U ) ( f : A -> B) : U := \u2211 ( fhasinverse : (has-inverse A B f)), ( homotopy-prewhisker A B B ( has-inverse-section-composite A B f fhasinverse) ( identity B) ( second ( second fhasinverse)) f = ( homotopy-postwhisker A A B ( has-inverse-retraction-composite A B f fhasinverse) ( identity A) ( first ( second fhasinverse)) f)) Coherence data from an invertible map \u00b6 To promote an invertible map to a half adjoint equivalence we keep one homotopy and discard the other. #def has-inverse-kept-htpy ( A B : U ) ( f : A -> B) ( fhasinverse : has-inverse A B f) : homotopy A A ( has-inverse-retraction-composite A B f fhasinverse) (identity A) := ( first ( second fhasinverse)) #def has-inverse-discarded-htpy ( A B : U ) ( f : A -> B) ( fhasinverse : has-inverse A B f) : homotopy B B ( has-inverse-section-composite A B f fhasinverse) (identity B) := ( second ( second fhasinverse)) The required coherence will be built by transforming an instance of the following naturality square. #section has-inverse-coherence #variables A B : U #variable f : A -> B #variable fhasinverse : has-inverse A B f #variable a : A #def has-inverse-discarded-naturality-square : concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-triple-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) ( has-inverse-discarded-htpy A B f fhasinverse (f a)) = concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( has-inverse-discarded-htpy A B f fhasinverse ( has-inverse-triple-composite A B f fhasinverse a)) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a f (has-inverse-kept-htpy A B f fhasinverse a)) := nat-htpy A B ( has-inverse-triple-composite A B f fhasinverse) ( f) ( \\ x -> has-inverse-discarded-htpy A B f fhasinverse (f x)) ( has-inverse-retraction-composite A B f fhasinverse a) ( a) ( has-inverse-kept-htpy A B f fhasinverse a) -- building a path that will be whiskered into the naturality square above #def has-inverse-cocone-homotopy-coherence : has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a) = ap A A (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-retraction-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a) := cocone-naturality-coherence ( A) ( has-inverse-retraction-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse) ( a) #def has-inverse-ap-cocone-homotopy-coherence : ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) = ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( ap A A (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-retraction-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) := ap-htpy A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( ap A A (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-retraction-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) ( has-inverse-cocone-homotopy-coherence) #def has-inverse-cocone-coherence : ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) = ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-triple-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) := concat ( has-inverse-quintuple-composite A B f fhasinverse a = has-inverse-triple-composite A B f fhasinverse a) ( ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a))) ( ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( ap A A ( has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-retraction-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a))) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-triple-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) ( has-inverse-ap-cocone-homotopy-coherence) ( rev-ap-comp A A B ( has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-retraction-composite A B f fhasinverse) ( f) ( has-inverse-kept-htpy A B f fhasinverse a)) -- This morally gives the half adjoint inverse coherence. -- It just requires rotation. #def has-inverse-replaced-naturality-square : concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a))) ( has-inverse-discarded-htpy A B f fhasinverse (f a)) = concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( has-inverse-discarded-htpy A B f fhasinverse ( has-inverse-triple-composite A B f fhasinverse a)) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a f ( has-inverse-kept-htpy A B f fhasinverse a)) := concat (has-inverse-quintuple-composite A B f fhasinverse a = f a) ( concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) f ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a))) ( has-inverse-discarded-htpy A B f fhasinverse (f a))) ( concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-triple-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) ( has-inverse-discarded-htpy A B f fhasinverse (f a))) ( concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) (f a) ( has-inverse-discarded-htpy A B f fhasinverse ( has-inverse-triple-composite A B f fhasinverse a)) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a f ( has-inverse-kept-htpy A B f fhasinverse a))) ( homotopy-concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a))) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-triple-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) ( has-inverse-cocone-coherence) ( has-inverse-discarded-htpy A B f fhasinverse (f a))) ( has-inverse-discarded-naturality-square) -- This will replace the discarded homotopy #def has-inverse-corrected-htpy : homotopy B B (has-inverse-section-composite A B f fhasinverse) ( \\ b -> b) := \\ b -> concat B ( (has-inverse-section-composite A B f fhasinverse) b) ( (has-inverse-section-composite A B f fhasinverse) ((has-inverse-section-composite A B f fhasinverse) b)) ( b) ( rev B ( (has-inverse-section-composite A B f fhasinverse) ((has-inverse-section-composite A B f fhasinverse) b)) ( (has-inverse-section-composite A B f fhasinverse) b) ( has-inverse-discarded-htpy A B f fhasinverse ((has-inverse-section-composite A B f fhasinverse) b))) ( concat B ( (has-inverse-section-composite A B f fhasinverse) ((has-inverse-section-composite A B f fhasinverse) b)) ( (has-inverse-section-composite A B f fhasinverse) b) ( b) ( ap A B ( (has-inverse-retraction-composite A B f fhasinverse) (has-inverse-inverse A B f fhasinverse b)) ( has-inverse-inverse A B f fhasinverse b) f ( ( first ( second fhasinverse)) (has-inverse-inverse A B f fhasinverse b))) ( (has-inverse-discarded-htpy A B f fhasinverse b))) -- this is the half adjoint coherence #def has-inverse-coherence : ( has-inverse-corrected-htpy (f a)) = ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a f ( has-inverse-kept-htpy A B f fhasinverse a)) := triangle-rotation B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( concat B ( (has-inverse-section-composite A B f fhasinverse) ((has-inverse-section-composite A B f fhasinverse) (f a))) ( (has-inverse-section-composite A B f fhasinverse) (f a)) ( f a) ( ap A B ( (has-inverse-retraction-composite A B f fhasinverse) (has-inverse-inverse A B f fhasinverse (f a))) ( has-inverse-inverse A B f fhasinverse (f a)) ( f) ( ( first ( second fhasinverse)) (has-inverse-inverse A B f fhasinverse (f a)))) ( (has-inverse-discarded-htpy A B f fhasinverse (f a)))) ( has-inverse-discarded-htpy A B f fhasinverse ( has-inverse-triple-composite A B f fhasinverse a)) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a f ( has-inverse-kept-htpy A B f fhasinverse a)) ( has-inverse-replaced-naturality-square) #end has-inverse-coherence Invertible maps are half adjoint equivalences \u00b6 To promote an invertible map to a half adjoint equivalence we change the data of the invertible map by replacing the discarded homotopy with the corrected one. #def corrected-has-inverse-has-inverse ( A B : U ) ( f : A -> B) ( fhasinverse : has-inverse A B f) : has-inverse A B f := ( has-inverse-inverse A B f fhasinverse, ( has-inverse-kept-htpy A B f fhasinverse, has-inverse-corrected-htpy A B f fhasinverse)) -- Invertible maps are half adjoint equivalences! #def is-half-adjoint-equiv-has-inverse ( A B : U ) ( f : A -> B) ( fhasinverse : has-inverse A B f) : is-half-adjoint-equiv A B f := ( corrected-has-inverse-has-inverse A B f fhasinverse, has-inverse-coherence A B f fhasinverse) -- Equivalences are half adjoint equivalences! #def is-half-adjoint-equiv-is-equiv ( A B : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) : is-half-adjoint-equiv A B f := is-half-adjoint-equiv-has-inverse A B f ( has-inverse-is-equiv A B f fisequiv) Equivalences of identity types \u00b6 We use the notion of half adjoint equivalence to prove that equivalent types have equivalent identity types. #section equiv-identity-types-equiv #variables A B : U #variable f : A -> B #variable fisHAE : is-half-adjoint-equiv A B f #def iff-ap-is-half-adjoint-equiv ( x y : A) : iff (x = y) (f x = f y) := (ap A B x y f , \\ q -> triple-concat A ( x) ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( y) ( rev A (has-inverse-retraction-composite A B f ( first fisHAE) x) x ( ( first ( second ( first fisHAE))) x)) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q) ( ( first ( second ( first fisHAE))) y)) #def has-retraction-ap-is-half-adjoint-equiv ( x y : A) : has-retraction (x = y) (f x = f y) (ap A B x y f) := ( second (iff-ap-is-half-adjoint-equiv x y), \\ p -> idJ ( A, x, \\ y' p' -> ( second (iff-ap-is-half-adjoint-equiv x y'))(ap A B x y' f p') = p', ( rev-refl-id-triple-concat A ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) x ( ( first ( second ( first fisHAE))) x)), y, p)) #def ap-triple-concat-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : ap A B x y f (( second (iff-ap-is-half-adjoint-equiv x y)) q) = (triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( ap A B x ((has-inverse-inverse A B f ( first fisHAE)) (f x)) f ( rev A (has-inverse-retraction-composite A B f ( first fisHAE) x) x ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( f) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y))) := ap-triple-concat A B ( x) ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( y) ( f) ( rev A (has-inverse-retraction-composite A B f ( first fisHAE) x) x ( ( first ( second ( first fisHAE))) x)) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q) ( ( first ( second ( first fisHAE))) y) #def ap-rev-homotopy-triple-concat-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( ap A B x ((has-inverse-inverse A B f ( first fisHAE)) (f x)) f (rev A (has-inverse-retraction-composite A B f ( first fisHAE) x) x ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( f) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y)) = triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B (f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( f) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( y) ( f) ( ( first ( second ( first fisHAE))) y)) := homotopy-triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( ap A B ( x) ((has-inverse-inverse A B f ( first fisHAE)) (f x)) f ( rev A (has-inverse-retraction-composite A B f ( first fisHAE) x) x ( ( first ( second ( first fisHAE))) x))) ( rev B (f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( f) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y)) ( ap-rev A B (has-inverse-retraction-composite A B f ( first fisHAE) x) x f ( ( first ( second ( first fisHAE))) x)) #def ap-ap-homotopy-triple-concat-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : (triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B ( f (has-inverse-retraction-composite A B f ( first fisHAE) x)) ( f x) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( f) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y))) = ( triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B ( f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap B B (f x) (f y) ( has-inverse-section-composite A B f ( first fisHAE)) q) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y ( f) (( first ( second ( first fisHAE))) y))) := triple-homotopy-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B (f(has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( f) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap B B (f x) (f y) (has-inverse-section-composite A B f ( first fisHAE)) q) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y)) ( rev-ap-comp B A B (f x) (f y) ( has-inverse-inverse A B f ( first fisHAE)) f q) -- This needs to be reversed later. #def triple-concat-higher-homotopy-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B (f(has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ( second ( second ( first fisHAE))) (f x))) ( ap B B (f x) (f y) ( has-inverse-section-composite A B f ( first fisHAE)) q) ( ( second ( second ( first fisHAE))) (f y)) = triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) (rev B (f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) (ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f (( first ( second ( first fisHAE))) x))) (ap B B (f x) (f y) (has-inverse-section-composite A B f ( first fisHAE)) q) (ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f (( first ( second ( first fisHAE))) y)) := triple-concat-higher-homotopy A B ( has-inverse-triple-composite A B f ( first fisHAE)) f ( \\ a -> ((( second ( second ( first fisHAE)))) (f a))) ( \\ a -> ( ap A B (has-inverse-retraction-composite A B f ( first fisHAE) a) a f ( (( first ( second ( first fisHAE)))) a))) ( second fisHAE) ( x) ( y) ( ap B B (f x) (f y) ( has-inverse-section-composite A B f ( first fisHAE)) q) #def triple-concat-nat-htpy-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B (f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( (( second ( second ( first fisHAE)))) (f x))) ( ap B B (f x) (f y) (has-inverse-section-composite A B f ( first fisHAE)) q) ( (( second ( second ( first fisHAE)))) (f y)) = ap B B (f x) (f y) (identity B) q := triple-concat-nat-htpy B B ( has-inverse-section-composite A B f ( first fisHAE)) ( identity B) ( ( second ( second ( first fisHAE)))) ( f x) ( f y) q #def zag-zig-concat-triple-concat-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B (f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap B B (f x) (f y) (has-inverse-section-composite A B f ( first fisHAE)) q) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y)) = ap B B (f x) (f y) (identity B) q := zag-zig-concat (f x = f y) ( triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B ( f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap B B (f x) (f y) ( has-inverse-section-composite A B f ( first fisHAE)) q) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f (( first ( second ( first fisHAE))) y))) ( triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B ( f(has-inverse-retraction-composite A B f ( first fisHAE) x)) ( f x) ( (( second ( second ( first fisHAE)))) (f x))) ( ap B B (f x) (f y) ( has-inverse-section-composite A B f ( first fisHAE)) q) ( (( second ( second ( first fisHAE)))) (f y))) ( ap B B (f x) (f y) (identity B) q) ( triple-concat-higher-homotopy-is-half-adjoint-equiv x y q) ( triple-concat-nat-htpy-is-half-adjoint-equiv x y q) #def triple-concat-reduction-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : ap B B (f x) (f y) (identity B) q = q := ap-id B (f x) (f y) q #def section-htpy-ap-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : ap A B x y f (( second (iff-ap-is-half-adjoint-equiv x y)) q) = q := quintuple-concat-alternating (f x = f y) ( ap A B x y f (( second (iff-ap-is-half-adjoint-equiv x y)) q)) ( triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( ap A B x ((has-inverse-inverse A B f ( first fisHAE)) (f x)) f ( rev A (has-inverse-retraction-composite A B f ( first fisHAE) x) x ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) f ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y))) ( ap-triple-concat-is-half-adjoint-equiv x y q) ( triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B ( f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) f ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y))) ( ap-rev-homotopy-triple-concat-is-half-adjoint-equiv x y q) ( triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B ( f (has-inverse-retraction-composite A B f ( first fisHAE) x)) ( f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap B B (f x) (f y) ( has-inverse-section-composite A B f ( first fisHAE)) q) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f (( first ( second ( first fisHAE))) y))) ( ap-ap-homotopy-triple-concat-is-half-adjoint-equiv x y q) ( ap B B (f x) (f y) (identity B) q) ( zag-zig-concat-triple-concat-is-half-adjoint-equiv x y q) ( q) ( triple-concat-reduction-is-half-adjoint-equiv x y q) #def has-section-ap-is-half-adjoint-equiv uses ( fisHAE ) ( x y : A) : has-section (x = y) (f x = f y) (ap A B x y f) := ( second (iff-ap-is-half-adjoint-equiv x y), section-htpy-ap-is-half-adjoint-equiv x y) #def is-equiv-ap-is-half-adjoint-equiv uses ( fisHAE ) ( x y : A) : is-equiv (x = y) (f x = f y) (ap A B x y f) := ( has-retraction-ap-is-half-adjoint-equiv x y, has-section-ap-is-half-adjoint-equiv x y) #end equiv-identity-types-equiv #def is-equiv-ap-is-equiv ( A B : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) ( x y : A) : is-equiv (x = y) (f x = f y)(ap A B x y f) := is-equiv-ap-is-half-adjoint-equiv A B f ( is-half-adjoint-equiv-is-equiv A B f fisequiv) x y #def Eq-ap-is-equiv ( A B : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) ( x y : A) : Equiv (x = y) (f x = f y) := (ap A B x y f, is-equiv-ap-is-equiv A B f fisequiv x y)","title":"Half Adjoint Equivalences"},{"location":"hott/04-half-adjoint-equivalences.rzk/#4-half-adjoint-equivalences","text":"This is a literate rzk file: #lang rzk-1","title":"4. Half Adjoint Equivalences"},{"location":"hott/04-half-adjoint-equivalences.rzk/#half-adjoint-equivalences","text":"-- We'll require a more coherent notion of equivalence #def is-half-adjoint-equiv ( A B : U ) ( f : A -> B) : U := \u2211 ( fhasinverse : (has-inverse A B f)), ( a : A) -> (( second ( second fhasinverse)) (f a)) = (ap A B (has-inverse-retraction-composite A B f fhasinverse a) a ( f) ((( first ( second fhasinverse))) a)) -- By function extensionality, the previous definition coincides with the -- following one: #def is-half-adjoint-equiv' ( A B : U ) ( f : A -> B) : U := \u2211 ( fhasinverse : (has-inverse A B f)), ( homotopy-prewhisker A B B ( has-inverse-section-composite A B f fhasinverse) ( identity B) ( second ( second fhasinverse)) f = ( homotopy-postwhisker A A B ( has-inverse-retraction-composite A B f fhasinverse) ( identity A) ( first ( second fhasinverse)) f))","title":"Half adjoint equivalences"},{"location":"hott/04-half-adjoint-equivalences.rzk/#coherence-data-from-an-invertible-map","text":"To promote an invertible map to a half adjoint equivalence we keep one homotopy and discard the other. #def has-inverse-kept-htpy ( A B : U ) ( f : A -> B) ( fhasinverse : has-inverse A B f) : homotopy A A ( has-inverse-retraction-composite A B f fhasinverse) (identity A) := ( first ( second fhasinverse)) #def has-inverse-discarded-htpy ( A B : U ) ( f : A -> B) ( fhasinverse : has-inverse A B f) : homotopy B B ( has-inverse-section-composite A B f fhasinverse) (identity B) := ( second ( second fhasinverse)) The required coherence will be built by transforming an instance of the following naturality square. #section has-inverse-coherence #variables A B : U #variable f : A -> B #variable fhasinverse : has-inverse A B f #variable a : A #def has-inverse-discarded-naturality-square : concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-triple-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) ( has-inverse-discarded-htpy A B f fhasinverse (f a)) = concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( has-inverse-discarded-htpy A B f fhasinverse ( has-inverse-triple-composite A B f fhasinverse a)) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a f (has-inverse-kept-htpy A B f fhasinverse a)) := nat-htpy A B ( has-inverse-triple-composite A B f fhasinverse) ( f) ( \\ x -> has-inverse-discarded-htpy A B f fhasinverse (f x)) ( has-inverse-retraction-composite A B f fhasinverse a) ( a) ( has-inverse-kept-htpy A B f fhasinverse a) -- building a path that will be whiskered into the naturality square above #def has-inverse-cocone-homotopy-coherence : has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a) = ap A A (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-retraction-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a) := cocone-naturality-coherence ( A) ( has-inverse-retraction-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse) ( a) #def has-inverse-ap-cocone-homotopy-coherence : ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) = ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( ap A A (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-retraction-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) := ap-htpy A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( ap A A (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-retraction-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) ( has-inverse-cocone-homotopy-coherence) #def has-inverse-cocone-coherence : ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) = ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-triple-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) := concat ( has-inverse-quintuple-composite A B f fhasinverse a = has-inverse-triple-composite A B f fhasinverse a) ( ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a))) ( ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( ap A A ( has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-retraction-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a))) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-triple-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) ( has-inverse-ap-cocone-homotopy-coherence) ( rev-ap-comp A A B ( has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-retraction-composite A B f fhasinverse) ( f) ( has-inverse-kept-htpy A B f fhasinverse a)) -- This morally gives the half adjoint inverse coherence. -- It just requires rotation. #def has-inverse-replaced-naturality-square : concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a))) ( has-inverse-discarded-htpy A B f fhasinverse (f a)) = concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( has-inverse-discarded-htpy A B f fhasinverse ( has-inverse-triple-composite A B f fhasinverse a)) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a f ( has-inverse-kept-htpy A B f fhasinverse a)) := concat (has-inverse-quintuple-composite A B f fhasinverse a = f a) ( concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) f ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a))) ( has-inverse-discarded-htpy A B f fhasinverse (f a))) ( concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-triple-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) ( has-inverse-discarded-htpy A B f fhasinverse (f a))) ( concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) (f a) ( has-inverse-discarded-htpy A B f fhasinverse ( has-inverse-triple-composite A B f fhasinverse a)) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a f ( has-inverse-kept-htpy A B f fhasinverse a))) ( homotopy-concat B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( ap A B ( has-inverse-retraction-composite A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a)) ( has-inverse-retraction-composite A B f fhasinverse a) ( f) ( has-inverse-kept-htpy A B f fhasinverse ( has-inverse-retraction-composite A B f fhasinverse a))) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a ( has-inverse-triple-composite A B f fhasinverse) ( has-inverse-kept-htpy A B f fhasinverse a)) ( has-inverse-cocone-coherence) ( has-inverse-discarded-htpy A B f fhasinverse (f a))) ( has-inverse-discarded-naturality-square) -- This will replace the discarded homotopy #def has-inverse-corrected-htpy : homotopy B B (has-inverse-section-composite A B f fhasinverse) ( \\ b -> b) := \\ b -> concat B ( (has-inverse-section-composite A B f fhasinverse) b) ( (has-inverse-section-composite A B f fhasinverse) ((has-inverse-section-composite A B f fhasinverse) b)) ( b) ( rev B ( (has-inverse-section-composite A B f fhasinverse) ((has-inverse-section-composite A B f fhasinverse) b)) ( (has-inverse-section-composite A B f fhasinverse) b) ( has-inverse-discarded-htpy A B f fhasinverse ((has-inverse-section-composite A B f fhasinverse) b))) ( concat B ( (has-inverse-section-composite A B f fhasinverse) ((has-inverse-section-composite A B f fhasinverse) b)) ( (has-inverse-section-composite A B f fhasinverse) b) ( b) ( ap A B ( (has-inverse-retraction-composite A B f fhasinverse) (has-inverse-inverse A B f fhasinverse b)) ( has-inverse-inverse A B f fhasinverse b) f ( ( first ( second fhasinverse)) (has-inverse-inverse A B f fhasinverse b))) ( (has-inverse-discarded-htpy A B f fhasinverse b))) -- this is the half adjoint coherence #def has-inverse-coherence : ( has-inverse-corrected-htpy (f a)) = ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a f ( has-inverse-kept-htpy A B f fhasinverse a)) := triangle-rotation B ( has-inverse-quintuple-composite A B f fhasinverse a) ( has-inverse-triple-composite A B f fhasinverse a) ( f a) ( concat B ( (has-inverse-section-composite A B f fhasinverse) ((has-inverse-section-composite A B f fhasinverse) (f a))) ( (has-inverse-section-composite A B f fhasinverse) (f a)) ( f a) ( ap A B ( (has-inverse-retraction-composite A B f fhasinverse) (has-inverse-inverse A B f fhasinverse (f a))) ( has-inverse-inverse A B f fhasinverse (f a)) ( f) ( ( first ( second fhasinverse)) (has-inverse-inverse A B f fhasinverse (f a)))) ( (has-inverse-discarded-htpy A B f fhasinverse (f a)))) ( has-inverse-discarded-htpy A B f fhasinverse ( has-inverse-triple-composite A B f fhasinverse a)) ( ap A B (has-inverse-retraction-composite A B f fhasinverse a) a f ( has-inverse-kept-htpy A B f fhasinverse a)) ( has-inverse-replaced-naturality-square) #end has-inverse-coherence","title":"Coherence data from an invertible map"},{"location":"hott/04-half-adjoint-equivalences.rzk/#invertible-maps-are-half-adjoint-equivalences","text":"To promote an invertible map to a half adjoint equivalence we change the data of the invertible map by replacing the discarded homotopy with the corrected one. #def corrected-has-inverse-has-inverse ( A B : U ) ( f : A -> B) ( fhasinverse : has-inverse A B f) : has-inverse A B f := ( has-inverse-inverse A B f fhasinverse, ( has-inverse-kept-htpy A B f fhasinverse, has-inverse-corrected-htpy A B f fhasinverse)) -- Invertible maps are half adjoint equivalences! #def is-half-adjoint-equiv-has-inverse ( A B : U ) ( f : A -> B) ( fhasinverse : has-inverse A B f) : is-half-adjoint-equiv A B f := ( corrected-has-inverse-has-inverse A B f fhasinverse, has-inverse-coherence A B f fhasinverse) -- Equivalences are half adjoint equivalences! #def is-half-adjoint-equiv-is-equiv ( A B : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) : is-half-adjoint-equiv A B f := is-half-adjoint-equiv-has-inverse A B f ( has-inverse-is-equiv A B f fisequiv)","title":"Invertible maps are half adjoint equivalences"},{"location":"hott/04-half-adjoint-equivalences.rzk/#equivalences-of-identity-types","text":"We use the notion of half adjoint equivalence to prove that equivalent types have equivalent identity types. #section equiv-identity-types-equiv #variables A B : U #variable f : A -> B #variable fisHAE : is-half-adjoint-equiv A B f #def iff-ap-is-half-adjoint-equiv ( x y : A) : iff (x = y) (f x = f y) := (ap A B x y f , \\ q -> triple-concat A ( x) ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( y) ( rev A (has-inverse-retraction-composite A B f ( first fisHAE) x) x ( ( first ( second ( first fisHAE))) x)) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q) ( ( first ( second ( first fisHAE))) y)) #def has-retraction-ap-is-half-adjoint-equiv ( x y : A) : has-retraction (x = y) (f x = f y) (ap A B x y f) := ( second (iff-ap-is-half-adjoint-equiv x y), \\ p -> idJ ( A, x, \\ y' p' -> ( second (iff-ap-is-half-adjoint-equiv x y'))(ap A B x y' f p') = p', ( rev-refl-id-triple-concat A ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) x ( ( first ( second ( first fisHAE))) x)), y, p)) #def ap-triple-concat-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : ap A B x y f (( second (iff-ap-is-half-adjoint-equiv x y)) q) = (triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( ap A B x ((has-inverse-inverse A B f ( first fisHAE)) (f x)) f ( rev A (has-inverse-retraction-composite A B f ( first fisHAE) x) x ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( f) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y))) := ap-triple-concat A B ( x) ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( y) ( f) ( rev A (has-inverse-retraction-composite A B f ( first fisHAE) x) x ( ( first ( second ( first fisHAE))) x)) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q) ( ( first ( second ( first fisHAE))) y) #def ap-rev-homotopy-triple-concat-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( ap A B x ((has-inverse-inverse A B f ( first fisHAE)) (f x)) f (rev A (has-inverse-retraction-composite A B f ( first fisHAE) x) x ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( f) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y)) = triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B (f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( f) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( y) ( f) ( ( first ( second ( first fisHAE))) y)) := homotopy-triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( ap A B ( x) ((has-inverse-inverse A B f ( first fisHAE)) (f x)) f ( rev A (has-inverse-retraction-composite A B f ( first fisHAE) x) x ( ( first ( second ( first fisHAE))) x))) ( rev B (f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( f) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y)) ( ap-rev A B (has-inverse-retraction-composite A B f ( first fisHAE) x) x f ( ( first ( second ( first fisHAE))) x)) #def ap-ap-homotopy-triple-concat-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : (triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B ( f (has-inverse-retraction-composite A B f ( first fisHAE) x)) ( f x) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( f) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y))) = ( triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B ( f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap B B (f x) (f y) ( has-inverse-section-composite A B f ( first fisHAE)) q) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y ( f) (( first ( second ( first fisHAE))) y))) := triple-homotopy-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B (f(has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) ( f) ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap B B (f x) (f y) (has-inverse-section-composite A B f ( first fisHAE)) q) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y)) ( rev-ap-comp B A B (f x) (f y) ( has-inverse-inverse A B f ( first fisHAE)) f q) -- This needs to be reversed later. #def triple-concat-higher-homotopy-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B (f(has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ( second ( second ( first fisHAE))) (f x))) ( ap B B (f x) (f y) ( has-inverse-section-composite A B f ( first fisHAE)) q) ( ( second ( second ( first fisHAE))) (f y)) = triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) (rev B (f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) (ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f (( first ( second ( first fisHAE))) x))) (ap B B (f x) (f y) (has-inverse-section-composite A B f ( first fisHAE)) q) (ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f (( first ( second ( first fisHAE))) y)) := triple-concat-higher-homotopy A B ( has-inverse-triple-composite A B f ( first fisHAE)) f ( \\ a -> ((( second ( second ( first fisHAE)))) (f a))) ( \\ a -> ( ap A B (has-inverse-retraction-composite A B f ( first fisHAE) a) a f ( (( first ( second ( first fisHAE)))) a))) ( second fisHAE) ( x) ( y) ( ap B B (f x) (f y) ( has-inverse-section-composite A B f ( first fisHAE)) q) #def triple-concat-nat-htpy-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B (f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( (( second ( second ( first fisHAE)))) (f x))) ( ap B B (f x) (f y) (has-inverse-section-composite A B f ( first fisHAE)) q) ( (( second ( second ( first fisHAE)))) (f y)) = ap B B (f x) (f y) (identity B) q := triple-concat-nat-htpy B B ( has-inverse-section-composite A B f ( first fisHAE)) ( identity B) ( ( second ( second ( first fisHAE)))) ( f x) ( f y) q #def zag-zig-concat-triple-concat-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B (f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap B B (f x) (f y) (has-inverse-section-composite A B f ( first fisHAE)) q) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y)) = ap B B (f x) (f y) (identity B) q := zag-zig-concat (f x = f y) ( triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B ( f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap B B (f x) (f y) ( has-inverse-section-composite A B f ( first fisHAE)) q) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f (( first ( second ( first fisHAE))) y))) ( triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B ( f(has-inverse-retraction-composite A B f ( first fisHAE) x)) ( f x) ( (( second ( second ( first fisHAE)))) (f x))) ( ap B B (f x) (f y) ( has-inverse-section-composite A B f ( first fisHAE)) q) ( (( second ( second ( first fisHAE)))) (f y))) ( ap B B (f x) (f y) (identity B) q) ( triple-concat-higher-homotopy-is-half-adjoint-equiv x y q) ( triple-concat-nat-htpy-is-half-adjoint-equiv x y q) #def triple-concat-reduction-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : ap B B (f x) (f y) (identity B) q = q := ap-id B (f x) (f y) q #def section-htpy-ap-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : ap A B x y f (( second (iff-ap-is-half-adjoint-equiv x y)) q) = q := quintuple-concat-alternating (f x = f y) ( ap A B x y f (( second (iff-ap-is-half-adjoint-equiv x y)) q)) ( triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( ap A B x ((has-inverse-inverse A B f ( first fisHAE)) (f x)) f ( rev A (has-inverse-retraction-composite A B f ( first fisHAE) x) x ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) f ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y))) ( ap-triple-concat-is-half-adjoint-equiv x y q) ( triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B ( f (has-inverse-retraction-composite A B f ( first fisHAE) x)) (f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f x)) ( (has-inverse-inverse A B f ( first fisHAE)) (f y)) f ( ap B A (f x) (f y) (has-inverse-inverse A B f ( first fisHAE)) q)) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f ( ( first ( second ( first fisHAE))) y))) ( ap-rev-homotopy-triple-concat-is-half-adjoint-equiv x y q) ( triple-concat B ( f x) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f x))) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f y))) ( f y) ( rev B ( f (has-inverse-retraction-composite A B f ( first fisHAE) x)) ( f x) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f x)) x f ( ( first ( second ( first fisHAE))) x))) ( ap B B (f x) (f y) ( has-inverse-section-composite A B f ( first fisHAE)) q) ( ap A B ((has-inverse-inverse A B f ( first fisHAE)) (f y)) y f (( first ( second ( first fisHAE))) y))) ( ap-ap-homotopy-triple-concat-is-half-adjoint-equiv x y q) ( ap B B (f x) (f y) (identity B) q) ( zag-zig-concat-triple-concat-is-half-adjoint-equiv x y q) ( q) ( triple-concat-reduction-is-half-adjoint-equiv x y q) #def has-section-ap-is-half-adjoint-equiv uses ( fisHAE ) ( x y : A) : has-section (x = y) (f x = f y) (ap A B x y f) := ( second (iff-ap-is-half-adjoint-equiv x y), section-htpy-ap-is-half-adjoint-equiv x y) #def is-equiv-ap-is-half-adjoint-equiv uses ( fisHAE ) ( x y : A) : is-equiv (x = y) (f x = f y) (ap A B x y f) := ( has-retraction-ap-is-half-adjoint-equiv x y, has-section-ap-is-half-adjoint-equiv x y) #end equiv-identity-types-equiv #def is-equiv-ap-is-equiv ( A B : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) ( x y : A) : is-equiv (x = y) (f x = f y)(ap A B x y f) := is-equiv-ap-is-half-adjoint-equiv A B f ( is-half-adjoint-equiv-is-equiv A B f fisequiv) x y #def Eq-ap-is-equiv ( A B : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) ( x y : A) : Equiv (x = y) (f x = f y) := (ap A B x y f, is-equiv-ap-is-equiv A B f fisequiv x y)","title":"Equivalences of identity types"},{"location":"hott/05-sigma.rzk/","text":"5. Sigma types \u00b6 This is a literate rzk file: #lang rzk-1 Paths involving products \u00b6 #section paths-in-products #variables A B : U #def path-product ( a a' : A) ( b b' : B) ( e_A : a = a') ( e_B : b = b') : (a, b) =_{prod A B} (a', b') := transport A ( \\ x -> (a, b) =_{prod A B} (x, b')) a a' e_A ( transport B ( \\ y -> (a, b) =_{prod A B} (a, y)) b b' e_B refl ) #def first-path-product ( x y : prod A B) ( e : x =_{prod A B} y) : first x = first y := ap (prod A B) A x y ( \\ z -> first z) e #def second-path-product ( x y : prod A B) ( e : x =_{prod A B} y) : second x = second y := ap (prod A B) B x y ( \\ z -> second z) e #end paths-in-products Identity types of sigma types \u00b6 #section paths-in-sigma #variable A : U #variable B : A -> U #def first-path-sigma ( s t : \u2211 ( a : A), B a) ( e : s = t) : first s = first t := ap ( \u2211 (a : A), B a) A s t ( \\ z -> first z) e #def second-path-sigma ( s t : \u2211 ( a : A), B a) ( e : s = t) : (transport A B ( first s) ( first t) (first-path-sigma s t e) ( second s)) = ( second t) := idJ ( (\u2211 (a : A), B a), s, \\ t' e' -> ( transport A B ( first s)( first t')(first-path-sigma s t' e')( second s)) = ( second t'), refl , t, e) -- [Rijke 22, Definition 9.3.1] #def Eq-sigma ( s t : \u2211 ( a : A), B a) : U := \u2211 ( p : ( first s) = ( first t)), ( transport A B ( first s) ( first t) p ( second s)) = ( second t) -- [Rijke 22, Definition 9.3.3] #def pair-eq ( s t : \u2211 ( a : A), B a) ( e : s = t) : (Eq-sigma s t) := (first-path-sigma s t e, second-path-sigma s t e) -- A path in a fiber defines a path in the total space #def sigma-path-fibered-path ( x : A) ( u v : B x) ( p : u = v) : (x , u) =_{ \u2211 ( a : A), B a} (x , v) := idJ (B x, u, \\ v' p' -> (x , u) = (x , v'), refl , v, p) -- Essentially eq-pair but with explicit arguments. #def path-of-pairs-pair-of-paths ( x y : A) ( p : x = y) : ( u : B x) -> ( v : B y) -> ((transport A B x y p u) = v) -> (x, u) =_{ \u2211 ( z : A), B z} (y, v) := idJ ( A, x, \\ y' p' -> (u' : B x) -> ( v' : B y') -> ((transport A B x y' p' u') = v') -> (x, u') =_{ \u2211 ( z : A), B z} (y', v'), \\ u' v' q' -> (sigma-path-fibered-path x u' v' q'), y, p) -- The inverse to pair-eq. #def eq-pair ( s t : \u2211 ( a : A), B a) ( e : Eq-sigma s t) : (s = t) := path-of-pairs-pair-of-paths ( first s) ( first t) ( first e) ( second s) ( second t) ( second e) #def eq-pair-pair-eq ( s t : \u2211 ( a : A), B a) ( e : s = t) : (eq-pair s t (pair-eq s t e)) = e := idJ ( \u2211(a : A), B a, s, \\ t' e' -> (eq-pair s t' (pair-eq s t' e')) = e', refl , t, e) -- Here we've decomposed e : Eq-sigma s t as (e0, e1) and decomposed s and t -- similarly for induction purposes #def pair-eq-eq-pair-split ( s0 : A) ( s1 : B s0) ( t0 : A) ( e0 : s0 = t0) : ( t1 : B t0) -> ( e1 : (transport A B s0 t0 e0 s1) = t1) -> (pair-eq (s0, s1) (t0, t1) (eq-pair (s0, s1) (t0, t1) (e0, e1))) =_{Eq-sigma (s0, s1) (t0, t1)} (e0, e1) := idJ ( A, s0, \\ t0' e0' -> (t1 : B t0') -> ( e1 : (transport A B s0 t0' e0' s1) = t1) -> (pair-eq (s0, s1) (t0', t1) (eq-pair (s0, s1) (t0', t1) (e0', e1))) =_{Eq-sigma (s0, s1) (t0', t1)} (e0', e1), \\ t1 e1 -> idJ ( B s0, s1, \\ t1' e1' -> ( pair-eq (s0, s1) (s0, t1') ( eq-pair (s0, s1) (s0, t1') ( refl , e1'))) =_{Eq-sigma (s0, s1) (s0, t1')} ( refl , e1'), refl , t1, e1), t0, e0) #def pair-eq-eq-pair ( s t : \u2211 ( a : A), B a) ( e : Eq-sigma s t) : (pair-eq s t (eq-pair s t e)) =_{Eq-sigma s t} e := pair-eq-eq-pair-split ( first s) ( second s) ( first t) ( first e) ( second t) ( second e) #def Eq-sigma-equiv ( s t : \u2211 ( a : A), B a) : Equiv (s = t) (Eq-sigma s t) := ( pair-eq s t, ( ( eq-pair s t, eq-pair-pair-eq s t), ( eq-pair s t, pair-eq-eq-pair s t))) #end paths-in-sigma Identity types of sigma types over a product \u00b6 #section paths-in-sigma-over-prod #variables A B : U #variable C : A -> B -> U #def prod-transport ( a a' : A) ( b b' : B) ( p : a = a') ( q : b = b') ( c : C a b) : C a' b' := idJ ( B, b, \\ b'' q' -> C a' b'', idJ (A, a, \\ a'' p' -> C a'' b, c, a', p), b', q) #def Eq-sigma-over-prod ( s t : \u2211 ( a : A), ( \u2211(b : B), C a b)) : U := \u2211 ( p : ( first s) = ( first t)), ( \u2211(q : ( first ( second s)) = ( first ( second t))), ( prod-transport ( first s) ( first t) ( first ( second s)) ( first ( second t)) p q ( second ( second s)) = ( second ( second t)))) -- This is the lazy definition with bad computational properties. #def triple-eq ( s t : \u2211 ( a : A), ( \u2211(b : B), C a b)) ( e : s = t) : (Eq-sigma-over-prod s t) := idJ ( \u2211(a : A), ( \u2211(b : B), C a b), s, \\ t' e' -> (Eq-sigma-over-prod s t'), ( refl , ( refl , refl )), t, e) -- The inverse with explicit arguments. -- It's surprising this typechecks since we defined prod-transport by a dual -- path induction over both p and q, rather than by saying that when p is refl -- this is ordinary transport #def path-of-triples-to-triple-of-paths ( a a' : A) ( b b' : B) ( c : C a b) ( p : a = a') : ( q : b = b') -> ( c' : C a' b') -> ( r : prod-transport a a' b b' p q c = c') -> ((a, (b, c)) =_{ ( \u2211(x : A), ( \u2211(y : B), C x y))} (a', (b', c'))) := idJ ( A, a, \\ a'' p' -> (q : b = b') -> ( c' : C a'' b') -> ( r : prod-transport a a'' b b' p' q c = c') -> ((a, (b, c)) =_{ ( \u2211(x : A), ( \u2211(y : B), C x y))} (a'', (b', c'))), \\ q c' r -> ( sigma-path-fibered-path A (\\x -> (\u2211(b : B), C x b)) a ( b, c) ( b', c') ( path-of-pairs-pair-of-paths B ( \\ y -> C a y) b b' q c c' r)), a', p) #def eq-triple ( s t : \u2211 ( a : A), ( \u2211(b : B), C a b)) ( e : Eq-sigma-over-prod s t) : (s = t) := path-of-triples-to-triple-of-paths ( first s) ( first t) ( first ( second s)) ( first ( second t)) ( second ( second s)) ( first e) ( first ( second e)) ( second ( second t)) ( second ( second e)) #def eq-triple-triple-eq ( s t : \u2211 ( a : A), ( \u2211(b : B), C a b)) ( e : s = t) : (eq-triple s t (triple-eq s t e)) = e := idJ ( \u2211(a : A), ( \u2211(b : B), C a b), s, \\ t' e' -> (eq-triple s t' (triple-eq s t' e')) = e', refl , t, e) -- Here we've decomposed s t e for induction purposes #def triple-eq-eq-triple-split ( a a' : A) ( b b' : B) ( c : C a b) ( p : a = a') : ( q : b = b') -> ( c' : C a' b') -> ( r : prod-transport a a' b b' p q c = c') -> triple-eq (a, (b, c)) (a', (b', c')) (eq-triple (a, (b, c)) (a', (b', c')) (p, (q, r))) = (p, (q, r)) := idJ ( A, a, \\ a'' p' -> (q : b = b') -> ( c' : C a'' b') -> ( r : prod-transport a a'' b b' p' q c = c') -> triple-eq (a, (b, c)) (a'', (b', c')) (eq-triple (a, (b, c)) (a'', (b', c')) (p', (q, r))) = (p', (q, r)), \\ q -> idJ ( B, b, \\ b'' q' -> (c' : C a b'') -> ( r : prod-transport a a b b'' refl q' c = c') -> triple-eq (a, (b, c)) (a, (b'', c')) ( eq-triple (a, (b, c)) (a, (b'', c')) ( refl , (q', r))) = ( refl , (q', r)), \\ c' r -> idJ ( C a b, c, \\ c'' r' -> triple-eq (a, (b, c)) (a, (b, c'')) ( eq-triple (a, (b, c)) (a, (b, c'')) ( refl , ( refl , r'))) = ( refl , ( refl , r')), refl , c', r), b', q), a', p) #def triple-eq-eq-triple ( s t : \u2211 ( a : A), ( \u2211(b : B), C a b)) ( e : Eq-sigma-over-prod s t) : (triple-eq s t (eq-triple s t e)) = e := triple-eq-eq-triple-split ( first s) ( first t) ( first ( second s)) ( first ( second t)) ( second ( second s)) ( first e) ( first ( second e)) ( second ( second t)) ( second ( second e)) #def Eq-sigma-over-prod-equiv ( s t : \u2211 ( a : A), ( \u2211(b : B), C a b)) : Equiv (s = t) (Eq-sigma-over-prod s t) := (triple-eq s t, ((eq-triple s t, eq-triple-triple-eq s t), (eq-triple s t, triple-eq-eq-triple s t))) #end paths-in-sigma-over-prod Symmetry of products \u00b6 #def sym-prod ( A B : U ) : Equiv (prod A B)(prod B A) := ( \\ (a, b) -> (b, a), ( ( \\ (b, a) -> (a, b), \\ p -> refl ), ( \\ (b, a) -> (a, b), \\ p -> refl ))) Fubini \u00b6 Given a family over a pair of independent types, the order of summation is unimportant. #def sigma-fubini ( A B : U ) ( C : A -> B -> U ) : Equiv ( \u2211 (x : A), \u2211 ( y : B), C x y) ( \u2211 (y : B), \u2211 ( x : A), C x y) := ( \\ t -> ( first ( second t), ( first t, second ( second t))), ( ( \\ t -> ( first ( second t), ( first t, second ( second t))), \\ t -> refl ), ( \\ t -> ( first ( second t), ( first t, second ( second t))), \\ t -> refl ))) Products distribute inside a sigma type: #def prod-distribute-sigma ( A B : U ) ( C : B -> U ) : Equiv ( prod A (\u2211 (b : B), C b)) ( \u2211 (b : B), prod A (C b)) := ( \\ (a, (b, c)) -> (b, (a, c)), ( ( \\ (b, (a, c)) -> (a, (b, c)), \\ z -> refl ), ( \\ (b, (a, c)) -> (a, (b, c)), \\ z -> refl ))) Associativity \u00b6 #def assoc-sigma ( A : U ) ( B : A -> U ) ( C : ( a : A) -> B a -> U ) : Equiv ( \u2211 (a : A), \u2211 ( b : B a), C a b) ( \u2211 (ab : \u2211 ( a : A), B a), C ( first ab) ( second ab)) := ( \\ (a, (b, c)) -> ((a, b), c), ( ( \\ ((a, b), c) -> (a, (b, c)), \\ _ -> refl ), ( \\ ((a, b), c) -> (a, (b, c)), \\ _ -> refl )))","title":"Sigma types"},{"location":"hott/05-sigma.rzk/#5-sigma-types","text":"This is a literate rzk file: #lang rzk-1","title":"5. Sigma types"},{"location":"hott/05-sigma.rzk/#paths-involving-products","text":"#section paths-in-products #variables A B : U #def path-product ( a a' : A) ( b b' : B) ( e_A : a = a') ( e_B : b = b') : (a, b) =_{prod A B} (a', b') := transport A ( \\ x -> (a, b) =_{prod A B} (x, b')) a a' e_A ( transport B ( \\ y -> (a, b) =_{prod A B} (a, y)) b b' e_B refl ) #def first-path-product ( x y : prod A B) ( e : x =_{prod A B} y) : first x = first y := ap (prod A B) A x y ( \\ z -> first z) e #def second-path-product ( x y : prod A B) ( e : x =_{prod A B} y) : second x = second y := ap (prod A B) B x y ( \\ z -> second z) e #end paths-in-products","title":"Paths involving products"},{"location":"hott/05-sigma.rzk/#identity-types-of-sigma-types","text":"#section paths-in-sigma #variable A : U #variable B : A -> U #def first-path-sigma ( s t : \u2211 ( a : A), B a) ( e : s = t) : first s = first t := ap ( \u2211 (a : A), B a) A s t ( \\ z -> first z) e #def second-path-sigma ( s t : \u2211 ( a : A), B a) ( e : s = t) : (transport A B ( first s) ( first t) (first-path-sigma s t e) ( second s)) = ( second t) := idJ ( (\u2211 (a : A), B a), s, \\ t' e' -> ( transport A B ( first s)( first t')(first-path-sigma s t' e')( second s)) = ( second t'), refl , t, e) -- [Rijke 22, Definition 9.3.1] #def Eq-sigma ( s t : \u2211 ( a : A), B a) : U := \u2211 ( p : ( first s) = ( first t)), ( transport A B ( first s) ( first t) p ( second s)) = ( second t) -- [Rijke 22, Definition 9.3.3] #def pair-eq ( s t : \u2211 ( a : A), B a) ( e : s = t) : (Eq-sigma s t) := (first-path-sigma s t e, second-path-sigma s t e) -- A path in a fiber defines a path in the total space #def sigma-path-fibered-path ( x : A) ( u v : B x) ( p : u = v) : (x , u) =_{ \u2211 ( a : A), B a} (x , v) := idJ (B x, u, \\ v' p' -> (x , u) = (x , v'), refl , v, p) -- Essentially eq-pair but with explicit arguments. #def path-of-pairs-pair-of-paths ( x y : A) ( p : x = y) : ( u : B x) -> ( v : B y) -> ((transport A B x y p u) = v) -> (x, u) =_{ \u2211 ( z : A), B z} (y, v) := idJ ( A, x, \\ y' p' -> (u' : B x) -> ( v' : B y') -> ((transport A B x y' p' u') = v') -> (x, u') =_{ \u2211 ( z : A), B z} (y', v'), \\ u' v' q' -> (sigma-path-fibered-path x u' v' q'), y, p) -- The inverse to pair-eq. #def eq-pair ( s t : \u2211 ( a : A), B a) ( e : Eq-sigma s t) : (s = t) := path-of-pairs-pair-of-paths ( first s) ( first t) ( first e) ( second s) ( second t) ( second e) #def eq-pair-pair-eq ( s t : \u2211 ( a : A), B a) ( e : s = t) : (eq-pair s t (pair-eq s t e)) = e := idJ ( \u2211(a : A), B a, s, \\ t' e' -> (eq-pair s t' (pair-eq s t' e')) = e', refl , t, e) -- Here we've decomposed e : Eq-sigma s t as (e0, e1) and decomposed s and t -- similarly for induction purposes #def pair-eq-eq-pair-split ( s0 : A) ( s1 : B s0) ( t0 : A) ( e0 : s0 = t0) : ( t1 : B t0) -> ( e1 : (transport A B s0 t0 e0 s1) = t1) -> (pair-eq (s0, s1) (t0, t1) (eq-pair (s0, s1) (t0, t1) (e0, e1))) =_{Eq-sigma (s0, s1) (t0, t1)} (e0, e1) := idJ ( A, s0, \\ t0' e0' -> (t1 : B t0') -> ( e1 : (transport A B s0 t0' e0' s1) = t1) -> (pair-eq (s0, s1) (t0', t1) (eq-pair (s0, s1) (t0', t1) (e0', e1))) =_{Eq-sigma (s0, s1) (t0', t1)} (e0', e1), \\ t1 e1 -> idJ ( B s0, s1, \\ t1' e1' -> ( pair-eq (s0, s1) (s0, t1') ( eq-pair (s0, s1) (s0, t1') ( refl , e1'))) =_{Eq-sigma (s0, s1) (s0, t1')} ( refl , e1'), refl , t1, e1), t0, e0) #def pair-eq-eq-pair ( s t : \u2211 ( a : A), B a) ( e : Eq-sigma s t) : (pair-eq s t (eq-pair s t e)) =_{Eq-sigma s t} e := pair-eq-eq-pair-split ( first s) ( second s) ( first t) ( first e) ( second t) ( second e) #def Eq-sigma-equiv ( s t : \u2211 ( a : A), B a) : Equiv (s = t) (Eq-sigma s t) := ( pair-eq s t, ( ( eq-pair s t, eq-pair-pair-eq s t), ( eq-pair s t, pair-eq-eq-pair s t))) #end paths-in-sigma","title":"Identity types of sigma types"},{"location":"hott/05-sigma.rzk/#identity-types-of-sigma-types-over-a-product","text":"#section paths-in-sigma-over-prod #variables A B : U #variable C : A -> B -> U #def prod-transport ( a a' : A) ( b b' : B) ( p : a = a') ( q : b = b') ( c : C a b) : C a' b' := idJ ( B, b, \\ b'' q' -> C a' b'', idJ (A, a, \\ a'' p' -> C a'' b, c, a', p), b', q) #def Eq-sigma-over-prod ( s t : \u2211 ( a : A), ( \u2211(b : B), C a b)) : U := \u2211 ( p : ( first s) = ( first t)), ( \u2211(q : ( first ( second s)) = ( first ( second t))), ( prod-transport ( first s) ( first t) ( first ( second s)) ( first ( second t)) p q ( second ( second s)) = ( second ( second t)))) -- This is the lazy definition with bad computational properties. #def triple-eq ( s t : \u2211 ( a : A), ( \u2211(b : B), C a b)) ( e : s = t) : (Eq-sigma-over-prod s t) := idJ ( \u2211(a : A), ( \u2211(b : B), C a b), s, \\ t' e' -> (Eq-sigma-over-prod s t'), ( refl , ( refl , refl )), t, e) -- The inverse with explicit arguments. -- It's surprising this typechecks since we defined prod-transport by a dual -- path induction over both p and q, rather than by saying that when p is refl -- this is ordinary transport #def path-of-triples-to-triple-of-paths ( a a' : A) ( b b' : B) ( c : C a b) ( p : a = a') : ( q : b = b') -> ( c' : C a' b') -> ( r : prod-transport a a' b b' p q c = c') -> ((a, (b, c)) =_{ ( \u2211(x : A), ( \u2211(y : B), C x y))} (a', (b', c'))) := idJ ( A, a, \\ a'' p' -> (q : b = b') -> ( c' : C a'' b') -> ( r : prod-transport a a'' b b' p' q c = c') -> ((a, (b, c)) =_{ ( \u2211(x : A), ( \u2211(y : B), C x y))} (a'', (b', c'))), \\ q c' r -> ( sigma-path-fibered-path A (\\x -> (\u2211(b : B), C x b)) a ( b, c) ( b', c') ( path-of-pairs-pair-of-paths B ( \\ y -> C a y) b b' q c c' r)), a', p) #def eq-triple ( s t : \u2211 ( a : A), ( \u2211(b : B), C a b)) ( e : Eq-sigma-over-prod s t) : (s = t) := path-of-triples-to-triple-of-paths ( first s) ( first t) ( first ( second s)) ( first ( second t)) ( second ( second s)) ( first e) ( first ( second e)) ( second ( second t)) ( second ( second e)) #def eq-triple-triple-eq ( s t : \u2211 ( a : A), ( \u2211(b : B), C a b)) ( e : s = t) : (eq-triple s t (triple-eq s t e)) = e := idJ ( \u2211(a : A), ( \u2211(b : B), C a b), s, \\ t' e' -> (eq-triple s t' (triple-eq s t' e')) = e', refl , t, e) -- Here we've decomposed s t e for induction purposes #def triple-eq-eq-triple-split ( a a' : A) ( b b' : B) ( c : C a b) ( p : a = a') : ( q : b = b') -> ( c' : C a' b') -> ( r : prod-transport a a' b b' p q c = c') -> triple-eq (a, (b, c)) (a', (b', c')) (eq-triple (a, (b, c)) (a', (b', c')) (p, (q, r))) = (p, (q, r)) := idJ ( A, a, \\ a'' p' -> (q : b = b') -> ( c' : C a'' b') -> ( r : prod-transport a a'' b b' p' q c = c') -> triple-eq (a, (b, c)) (a'', (b', c')) (eq-triple (a, (b, c)) (a'', (b', c')) (p', (q, r))) = (p', (q, r)), \\ q -> idJ ( B, b, \\ b'' q' -> (c' : C a b'') -> ( r : prod-transport a a b b'' refl q' c = c') -> triple-eq (a, (b, c)) (a, (b'', c')) ( eq-triple (a, (b, c)) (a, (b'', c')) ( refl , (q', r))) = ( refl , (q', r)), \\ c' r -> idJ ( C a b, c, \\ c'' r' -> triple-eq (a, (b, c)) (a, (b, c'')) ( eq-triple (a, (b, c)) (a, (b, c'')) ( refl , ( refl , r'))) = ( refl , ( refl , r')), refl , c', r), b', q), a', p) #def triple-eq-eq-triple ( s t : \u2211 ( a : A), ( \u2211(b : B), C a b)) ( e : Eq-sigma-over-prod s t) : (triple-eq s t (eq-triple s t e)) = e := triple-eq-eq-triple-split ( first s) ( first t) ( first ( second s)) ( first ( second t)) ( second ( second s)) ( first e) ( first ( second e)) ( second ( second t)) ( second ( second e)) #def Eq-sigma-over-prod-equiv ( s t : \u2211 ( a : A), ( \u2211(b : B), C a b)) : Equiv (s = t) (Eq-sigma-over-prod s t) := (triple-eq s t, ((eq-triple s t, eq-triple-triple-eq s t), (eq-triple s t, triple-eq-eq-triple s t))) #end paths-in-sigma-over-prod","title":"Identity types of sigma types over a product"},{"location":"hott/05-sigma.rzk/#symmetry-of-products","text":"#def sym-prod ( A B : U ) : Equiv (prod A B)(prod B A) := ( \\ (a, b) -> (b, a), ( ( \\ (b, a) -> (a, b), \\ p -> refl ), ( \\ (b, a) -> (a, b), \\ p -> refl )))","title":"Symmetry of products"},{"location":"hott/05-sigma.rzk/#fubini","text":"Given a family over a pair of independent types, the order of summation is unimportant. #def sigma-fubini ( A B : U ) ( C : A -> B -> U ) : Equiv ( \u2211 (x : A), \u2211 ( y : B), C x y) ( \u2211 (y : B), \u2211 ( x : A), C x y) := ( \\ t -> ( first ( second t), ( first t, second ( second t))), ( ( \\ t -> ( first ( second t), ( first t, second ( second t))), \\ t -> refl ), ( \\ t -> ( first ( second t), ( first t, second ( second t))), \\ t -> refl ))) Products distribute inside a sigma type: #def prod-distribute-sigma ( A B : U ) ( C : B -> U ) : Equiv ( prod A (\u2211 (b : B), C b)) ( \u2211 (b : B), prod A (C b)) := ( \\ (a, (b, c)) -> (b, (a, c)), ( ( \\ (b, (a, c)) -> (a, (b, c)), \\ z -> refl ), ( \\ (b, (a, c)) -> (a, (b, c)), \\ z -> refl )))","title":"Fubini"},{"location":"hott/05-sigma.rzk/#associativity","text":"#def assoc-sigma ( A : U ) ( B : A -> U ) ( C : ( a : A) -> B a -> U ) : Equiv ( \u2211 (a : A), \u2211 ( b : B a), C a b) ( \u2211 (ab : \u2211 ( a : A), B a), C ( first ab) ( second ab)) := ( \\ (a, (b, c)) -> ((a, b), c), ( ( \\ ((a, b), c) -> (a, (b, c)), \\ _ -> refl ), ( \\ ((a, b), c) -> (a, (b, c)), \\ _ -> refl )))","title":"Associativity"},{"location":"hott/06-contractible.rzk/","text":"6. Contractible \u00b6 This is a literate rzk file: #lang rzk-1 Contractible types \u00b6 -- contractible types #def is-contr ( A : U ) : U := \u2211 ( x : A), ( y : A) -> x = y Contractible type data \u00b6 #section contractible-data #variable A : U #variable Aiscontr : is-contr A #def contraction-center : A := ( first Aiscontr) -- The path from the contraction center to any point. #def contracting-htpy : ( z : A) -> contraction-center = z := second Aiscontr #def contracting-htpy-realigned uses ( Aiscontr ) : ( z : A) -> contraction-center = z := \\ z -> ( concat A contraction-center contraction-center z (rev A contraction-center contraction-center ( contracting-htpy contraction-center)) (contracting-htpy z)) #def contracting-htpy-realigned-path uses ( Aiscontr ) : (contracting-htpy-realigned contraction-center) = refl := ( left-inverse A contraction-center contraction-center ( contracting-htpy contraction-center)) -- A path between an arbitrary pair of types in a contractible type. #def contractible-connecting-htpy uses ( Aiscontr ) ( x y : A) : x = y := zag-zig-concat A x contraction-center y ( contracting-htpy x) (contracting-htpy y) #end contractible-data Unit type \u00b6 The prototypical contractible type is the unit type, which is built-in to rzk. #def ind-unit ( C : Unit -> U ) ( C-unit : C unit ) ( x : Unit ) : C x := C-unit #def is-prop-unit ( x y : Unit ) : x = y := refl -- Terminal projection as a constant map #def terminal-map ( A : U ) : A -> Unit := constant A Unit unit Identity types of unit types \u00b6 #def terminal-map-of-path-types-of-Unit-has-retr ( x y : Unit ) : has-retraction (x = y) Unit (terminal-map (x = y)) := ( \\ a -> refl , \\ p -> idJ ( Unit , x, \\ y' p' -> refl =_{x = y'} p', refl , y, p)) #def terminal-map-of-path-types-of-Unit-has-sec ( x y : Unit ) : has-section (x = y) Unit (terminal-map (x = y)) := ( \\ a -> refl , \\ a -> refl ) #def terminal-map-of-path-types-of-Unit-is-equiv ( x y : Unit ) : is-equiv (x = y) Unit (terminal-map (x = y)) := ( terminal-map-of-path-types-of-Unit-has-retr x y, terminal-map-of-path-types-of-Unit-has-sec x y) Characterization of contractibility \u00b6 A type is contractible if and only if its terminal map is an equivalence. #def terminal-map-is-equiv ( A : U ) : U := is-equiv A Unit (terminal-map A) #def contr-implies-terminal-map-is-equiv-retr ( A : U ) ( AisContr : is-contr A) : has-retraction A Unit (terminal-map A) := ( constant Unit A (contraction-center A AisContr), \\ y -> (contracting-htpy A AisContr) y) #def contr-implies-terminal-map-is-equiv-sec ( A : U ) ( AisContr : is-contr A) : has-section A Unit (terminal-map A) := (constant Unit A (contraction-center A AisContr), \\ z -> refl ) #def contr-implies-terminal-map-is-equiv ( A : U ) ( AisContr : is-contr A) : is-equiv A Unit (terminal-map A) := ( contr-implies-terminal-map-is-equiv-retr A AisContr, contr-implies-terminal-map-is-equiv-sec A AisContr) #def terminal-map-is-equiv-implies-contr ( A : U ) ( e : terminal-map-is-equiv A) : is-contr A := (( first ( first e)) unit , ( second ( first e))) #def contr-iff-terminal-map-is-equiv ( A : U ) : iff (is-contr A) (terminal-map-is-equiv A) := ( (contr-implies-terminal-map-is-equiv A), (terminal-map-is-equiv-implies-contr A)) #def equiv-with-contractible-domain-implies-contractible-codomain ( A B : U ) ( f : Equiv A B) ( Aiscontr : is-contr A) : is-contr B := (terminal-map-is-equiv-implies-contr B ( second (comp-equiv B A Unit (inv-equiv A B f) (terminal-map A, (contr-implies-terminal-map-is-equiv A Aiscontr))))) #def equiv-with-contractible-codomain-implies-contractible-domain ( A B : U ) ( f : Equiv A B) ( Biscontr : is-contr B) : is-contr A := ( equiv-with-contractible-domain-implies-contractible-codomain B A ( inv-equiv A B f) Biscontr) #def equiv-then-domain-contractible-iff-codomain-contractible ( A B : U ) ( f : Equiv A B) : (iff (is-contr A) (is-contr B)) := ( \\ Aiscontr -> ( equiv-with-contractible-domain-implies-contractible-codomain A B f Aiscontr), \\ Biscontr -> ( equiv-with-contractible-codomain-implies-contractible-domain A B f Biscontr)) #def path-types-of-Unit-are-contractible ( x y : Unit ) : is-contr (x = y) := ( terminal-map-is-equiv-implies-contr ( x = y)(terminal-map-of-path-types-of-Unit-is-equiv x y)) Retracts of contractible types \u00b6 A retract of contractible types is contractible. -- A type that records a proof that A is a retract of B. -- Very similar to has-retraction. #def is-retract-of ( A B : U ) : U := \u2211 ( s : A -> B), has-retraction A B s #section retraction-data #variables A B : U #variable AretractB : is-retract-of A B #def is-retract-of-section : A -> B := first AretractB #def is-retract-of-retraction : B -> A := first ( second AretractB) #def is-retract-of-homotopy : homotopy A A (composition A B A is-retract-of-retraction is-retract-of-section)(identity A) := second ( second AretractB) -- If A is a retract of a contractible type it has a term. #def is-retract-of-is-contr-isInhabited uses ( AretractB ) ( Biscontr : is-contr B) : A := is-retract-of-retraction (contraction-center B Biscontr) -- If A is a retract of a contractible type it has a contracting homotopy. #def is-retract-of-is-contr-hasHtpy uses ( AretractB ) ( Biscontr : is-contr B) ( a : A) : (is-retract-of-is-contr-isInhabited Biscontr) = a := concat A (is-retract-of-is-contr-isInhabited Biscontr) ((composition A B A is-retract-of-retraction is-retract-of-section) a) a (ap B A (contraction-center B Biscontr) (is-retract-of-section a) ( is-retract-of-retraction) ( contracting-htpy B Biscontr (is-retract-of-section a))) (is-retract-of-homotopy a) -- If A is a retract of a contractible type it is contractible. #def is-retract-of-is-contr-is-contr uses ( AretractB ) ( Biscontr : is-contr B) : is-contr A := ( is-retract-of-is-contr-isInhabited Biscontr, is-retract-of-is-contr-hasHtpy Biscontr) #end retraction-data Functions between contractible types \u00b6 A function between contractible types is an equivalence #def areContr-is-equiv ( A B : U ) ( Aiscontr : is-contr A) ( Biscontr : is-contr B) ( f : A -> B) : is-equiv A B f := ( ( \\ b -> contraction-center A Aiscontr, \\ a -> contracting-htpy A Aiscontr a), ( \\ b -> contraction-center A Aiscontr, \\ b -> contractible-connecting-htpy B Biscontr (f (contraction-center A Aiscontr)) b)) A type equivalent to a contractible type is contractible. #def is-contr-is-equiv-to-contr ( A B : U ) ( e : Equiv A B) ( Biscontr : is-contr B) : is-contr A := is-retract-of-is-contr-is-contr A B ( first e, first ( second e)) Biscontr #def is-contr-is-equiv-from-contr ( A B : U ) ( e : Equiv A B) ( Aiscontr : is-contr A) : is-contr B := is-retract-of-is-contr-is-contr B A ( first ( second ( second e)), ( first e, second ( second ( second e)))) ( Aiscontr) Based path spaces \u00b6 For example, we prove that based path spaces are contractible. -- Transport in the space of paths starting at a is concatenation. #def concat-as-based-transport ( A : U ) -- The ambient type. ( a x y : A) -- The basepoint and two other points. ( p : a = x) -- An element of the based path space. ( q : x = y) -- A path in the base. : (transport A ( \\ z -> (a = z)) x y q p) = (concat A a x y p q) := idJ ( A, x, \\ y' q' -> ( transport A ( \\ z -> (a = z)) x y' q' p) = (concat A a x y' p q'), refl , y, q) -- The center of contraction in the based path space is (a, refl) #def based-paths-center ( A : U ) -- The ambient type. ( a : A) -- The basepoint. : \u2211 ( x : A), a = x := (a, refl ) -- The contracting homotopy. #def based-paths-contracting-homotopy ( A : U ) -- The ambient type. ( a : A) -- The basepoint. ( p : \u2211 ( x : A), a = x) -- Another based path. : (based-paths-center A a) =_{ \u2211 ( x : A), a = x} p := path-of-pairs-pair-of-paths A ( \\ z -> a = z) a ( first p) ( second p) ( refl ) ( second p) (concat ( a = ( first p)) ( transport A ( \\ z -> (a = z)) a ( first p) ( second p) ( refl )) ( concat A a a ( first p) ( refl ) ( second p)) ( second p) ( concat-as-based-transport A a a ( first p) ( refl ) ( second p)) ( refl-concat A a ( first p) ( second p))) -- Based path spaces are contractible #def is-contr-based-paths ( A : U ) -- The ambient type. ( a : A) -- The basepoint. : is-contr ( \u2211 (x : A), a = x) := (based-paths-center A a, based-paths-contracting-homotopy A a) Contractible products \u00b6 #def is-contr-product ( A B : U ) ( AisContr : is-contr A) ( BisContr : is-contr B) : is-contr (prod A B) := ( ( first AisContr, first BisContr), \\ p -> path-product A B ( first AisContr) ( first p) ( first BisContr) ( second p) ( second AisContr ( first p)) ( second BisContr ( second p))) #def first-is-contr-product ( A B : U ) ( AxBisContr : is-contr (prod A B)) : is-contr A := ( first ( first AxBisContr), \\ a -> first-path-product A B ( first AxBisContr) ( a, second ( first AxBisContr)) ( second AxBisContr (a, second ( first AxBisContr)))) #def first-is-contr-sigma ( A : U ) ( B : A -> U ) ( b : ( a : A) -> B a) ( ABisContr : is-contr ( \u2211 (a : A), B a)) : is-contr A := ( first ( first ABisContr), \\ a -> first-path-sigma A B ( first ABisContr) ( a, b a) ( second ABisContr (a, b a))) Singleton induction \u00b6 A type is contractible if and only if it has singleton induction. #def ev-pt ( A : U ) ( a : A) ( B : A -> U ) : ( (x : A) -> B x) -> B a := \\ f -> f a #def has-singleton-induction-pointed ( A : U ) ( a : A) ( B : A -> U ) : U := has-section ( (x : A) -> B x) (B a) (ev-pt A a B) #def has-singleton-induction-pointed-structure ( A : U ) ( a : A) : U := ( B : A -> U ) -> has-section ( (x : A) -> B x) (B a) (ev-pt A a B) #def has-singleton-induction ( A : U ) : U := \u2211 ( a : A), ( B : A -> U ) -> (has-singleton-induction-pointed A a B) #def ind-sing ( A : U ) ( a : A) ( B : A -> U ) ( AhasSingInd : has-singleton-induction-pointed A a B) : (B a) -> ( (x : A) -> B x) := ( first AhasSingInd) #def comp-sing ( A : U ) ( a : A) ( B : A -> U ) ( AhasSingInd : has-singleton-induction-pointed A a B) : (homotopy (B a) (B a) (composition (B a) ( (x : A) -> B x) (B a) (ev-pt A a B) (ind-sing A a B AhasSingInd)) (identity (B a))) := ( second AhasSingInd) #def contr-implies-singleton-induction-ind ( A : U ) ( Aiscontr : is-contr A) : (has-singleton-induction A) := ( ( contraction-center A Aiscontr), \\ B -> ( ( \\ b x -> ( transport A B ( contraction-center A Aiscontr) x ( contracting-htpy-realigned A Aiscontr x) b)), ( \\ b -> ( ap ( (contraction-center A Aiscontr) = (contraction-center A Aiscontr)) ( B (contraction-center A Aiscontr)) ( contracting-htpy-realigned A Aiscontr ( contraction-center A Aiscontr)) refl _{(contraction-center A Aiscontr)} ( \\ p -> ( transport-loop A B (contraction-center A Aiscontr) b p)) ( contracting-htpy-realigned-path A Aiscontr))))) #def contr-implies-singleton-induction-pointed ( A : U ) ( Aiscontr : is-contr A) ( B : A -> U ) : has-singleton-induction-pointed A (contraction-center A Aiscontr) B := ( second (contr-implies-singleton-induction-ind A Aiscontr)) B #def singleton-induction-ind-implies-contr ( A : U ) ( a : A) ( f : has-singleton-induction-pointed-structure A a) : (is-contr A) := ( a, ( first (f ( \\ x -> a = x)))( refl _{a}))","title":"Contractible"},{"location":"hott/06-contractible.rzk/#6-contractible","text":"This is a literate rzk file: #lang rzk-1","title":"6. Contractible"},{"location":"hott/06-contractible.rzk/#contractible-types","text":"-- contractible types #def is-contr ( A : U ) : U := \u2211 ( x : A), ( y : A) -> x = y","title":"Contractible types"},{"location":"hott/06-contractible.rzk/#contractible-type-data","text":"#section contractible-data #variable A : U #variable Aiscontr : is-contr A #def contraction-center : A := ( first Aiscontr) -- The path from the contraction center to any point. #def contracting-htpy : ( z : A) -> contraction-center = z := second Aiscontr #def contracting-htpy-realigned uses ( Aiscontr ) : ( z : A) -> contraction-center = z := \\ z -> ( concat A contraction-center contraction-center z (rev A contraction-center contraction-center ( contracting-htpy contraction-center)) (contracting-htpy z)) #def contracting-htpy-realigned-path uses ( Aiscontr ) : (contracting-htpy-realigned contraction-center) = refl := ( left-inverse A contraction-center contraction-center ( contracting-htpy contraction-center)) -- A path between an arbitrary pair of types in a contractible type. #def contractible-connecting-htpy uses ( Aiscontr ) ( x y : A) : x = y := zag-zig-concat A x contraction-center y ( contracting-htpy x) (contracting-htpy y) #end contractible-data","title":"Contractible type data"},{"location":"hott/06-contractible.rzk/#unit-type","text":"The prototypical contractible type is the unit type, which is built-in to rzk. #def ind-unit ( C : Unit -> U ) ( C-unit : C unit ) ( x : Unit ) : C x := C-unit #def is-prop-unit ( x y : Unit ) : x = y := refl -- Terminal projection as a constant map #def terminal-map ( A : U ) : A -> Unit := constant A Unit unit","title":"Unit type"},{"location":"hott/06-contractible.rzk/#identity-types-of-unit-types","text":"#def terminal-map-of-path-types-of-Unit-has-retr ( x y : Unit ) : has-retraction (x = y) Unit (terminal-map (x = y)) := ( \\ a -> refl , \\ p -> idJ ( Unit , x, \\ y' p' -> refl =_{x = y'} p', refl , y, p)) #def terminal-map-of-path-types-of-Unit-has-sec ( x y : Unit ) : has-section (x = y) Unit (terminal-map (x = y)) := ( \\ a -> refl , \\ a -> refl ) #def terminal-map-of-path-types-of-Unit-is-equiv ( x y : Unit ) : is-equiv (x = y) Unit (terminal-map (x = y)) := ( terminal-map-of-path-types-of-Unit-has-retr x y, terminal-map-of-path-types-of-Unit-has-sec x y)","title":"Identity types of unit types"},{"location":"hott/06-contractible.rzk/#characterization-of-contractibility","text":"A type is contractible if and only if its terminal map is an equivalence. #def terminal-map-is-equiv ( A : U ) : U := is-equiv A Unit (terminal-map A) #def contr-implies-terminal-map-is-equiv-retr ( A : U ) ( AisContr : is-contr A) : has-retraction A Unit (terminal-map A) := ( constant Unit A (contraction-center A AisContr), \\ y -> (contracting-htpy A AisContr) y) #def contr-implies-terminal-map-is-equiv-sec ( A : U ) ( AisContr : is-contr A) : has-section A Unit (terminal-map A) := (constant Unit A (contraction-center A AisContr), \\ z -> refl ) #def contr-implies-terminal-map-is-equiv ( A : U ) ( AisContr : is-contr A) : is-equiv A Unit (terminal-map A) := ( contr-implies-terminal-map-is-equiv-retr A AisContr, contr-implies-terminal-map-is-equiv-sec A AisContr) #def terminal-map-is-equiv-implies-contr ( A : U ) ( e : terminal-map-is-equiv A) : is-contr A := (( first ( first e)) unit , ( second ( first e))) #def contr-iff-terminal-map-is-equiv ( A : U ) : iff (is-contr A) (terminal-map-is-equiv A) := ( (contr-implies-terminal-map-is-equiv A), (terminal-map-is-equiv-implies-contr A)) #def equiv-with-contractible-domain-implies-contractible-codomain ( A B : U ) ( f : Equiv A B) ( Aiscontr : is-contr A) : is-contr B := (terminal-map-is-equiv-implies-contr B ( second (comp-equiv B A Unit (inv-equiv A B f) (terminal-map A, (contr-implies-terminal-map-is-equiv A Aiscontr))))) #def equiv-with-contractible-codomain-implies-contractible-domain ( A B : U ) ( f : Equiv A B) ( Biscontr : is-contr B) : is-contr A := ( equiv-with-contractible-domain-implies-contractible-codomain B A ( inv-equiv A B f) Biscontr) #def equiv-then-domain-contractible-iff-codomain-contractible ( A B : U ) ( f : Equiv A B) : (iff (is-contr A) (is-contr B)) := ( \\ Aiscontr -> ( equiv-with-contractible-domain-implies-contractible-codomain A B f Aiscontr), \\ Biscontr -> ( equiv-with-contractible-codomain-implies-contractible-domain A B f Biscontr)) #def path-types-of-Unit-are-contractible ( x y : Unit ) : is-contr (x = y) := ( terminal-map-is-equiv-implies-contr ( x = y)(terminal-map-of-path-types-of-Unit-is-equiv x y))","title":"Characterization of contractibility"},{"location":"hott/06-contractible.rzk/#retracts-of-contractible-types","text":"A retract of contractible types is contractible. -- A type that records a proof that A is a retract of B. -- Very similar to has-retraction. #def is-retract-of ( A B : U ) : U := \u2211 ( s : A -> B), has-retraction A B s #section retraction-data #variables A B : U #variable AretractB : is-retract-of A B #def is-retract-of-section : A -> B := first AretractB #def is-retract-of-retraction : B -> A := first ( second AretractB) #def is-retract-of-homotopy : homotopy A A (composition A B A is-retract-of-retraction is-retract-of-section)(identity A) := second ( second AretractB) -- If A is a retract of a contractible type it has a term. #def is-retract-of-is-contr-isInhabited uses ( AretractB ) ( Biscontr : is-contr B) : A := is-retract-of-retraction (contraction-center B Biscontr) -- If A is a retract of a contractible type it has a contracting homotopy. #def is-retract-of-is-contr-hasHtpy uses ( AretractB ) ( Biscontr : is-contr B) ( a : A) : (is-retract-of-is-contr-isInhabited Biscontr) = a := concat A (is-retract-of-is-contr-isInhabited Biscontr) ((composition A B A is-retract-of-retraction is-retract-of-section) a) a (ap B A (contraction-center B Biscontr) (is-retract-of-section a) ( is-retract-of-retraction) ( contracting-htpy B Biscontr (is-retract-of-section a))) (is-retract-of-homotopy a) -- If A is a retract of a contractible type it is contractible. #def is-retract-of-is-contr-is-contr uses ( AretractB ) ( Biscontr : is-contr B) : is-contr A := ( is-retract-of-is-contr-isInhabited Biscontr, is-retract-of-is-contr-hasHtpy Biscontr) #end retraction-data","title":"Retracts of contractible types"},{"location":"hott/06-contractible.rzk/#functions-between-contractible-types","text":"A function between contractible types is an equivalence #def areContr-is-equiv ( A B : U ) ( Aiscontr : is-contr A) ( Biscontr : is-contr B) ( f : A -> B) : is-equiv A B f := ( ( \\ b -> contraction-center A Aiscontr, \\ a -> contracting-htpy A Aiscontr a), ( \\ b -> contraction-center A Aiscontr, \\ b -> contractible-connecting-htpy B Biscontr (f (contraction-center A Aiscontr)) b)) A type equivalent to a contractible type is contractible. #def is-contr-is-equiv-to-contr ( A B : U ) ( e : Equiv A B) ( Biscontr : is-contr B) : is-contr A := is-retract-of-is-contr-is-contr A B ( first e, first ( second e)) Biscontr #def is-contr-is-equiv-from-contr ( A B : U ) ( e : Equiv A B) ( Aiscontr : is-contr A) : is-contr B := is-retract-of-is-contr-is-contr B A ( first ( second ( second e)), ( first e, second ( second ( second e)))) ( Aiscontr)","title":"Functions between contractible types"},{"location":"hott/06-contractible.rzk/#based-path-spaces","text":"For example, we prove that based path spaces are contractible. -- Transport in the space of paths starting at a is concatenation. #def concat-as-based-transport ( A : U ) -- The ambient type. ( a x y : A) -- The basepoint and two other points. ( p : a = x) -- An element of the based path space. ( q : x = y) -- A path in the base. : (transport A ( \\ z -> (a = z)) x y q p) = (concat A a x y p q) := idJ ( A, x, \\ y' q' -> ( transport A ( \\ z -> (a = z)) x y' q' p) = (concat A a x y' p q'), refl , y, q) -- The center of contraction in the based path space is (a, refl) #def based-paths-center ( A : U ) -- The ambient type. ( a : A) -- The basepoint. : \u2211 ( x : A), a = x := (a, refl ) -- The contracting homotopy. #def based-paths-contracting-homotopy ( A : U ) -- The ambient type. ( a : A) -- The basepoint. ( p : \u2211 ( x : A), a = x) -- Another based path. : (based-paths-center A a) =_{ \u2211 ( x : A), a = x} p := path-of-pairs-pair-of-paths A ( \\ z -> a = z) a ( first p) ( second p) ( refl ) ( second p) (concat ( a = ( first p)) ( transport A ( \\ z -> (a = z)) a ( first p) ( second p) ( refl )) ( concat A a a ( first p) ( refl ) ( second p)) ( second p) ( concat-as-based-transport A a a ( first p) ( refl ) ( second p)) ( refl-concat A a ( first p) ( second p))) -- Based path spaces are contractible #def is-contr-based-paths ( A : U ) -- The ambient type. ( a : A) -- The basepoint. : is-contr ( \u2211 (x : A), a = x) := (based-paths-center A a, based-paths-contracting-homotopy A a)","title":"Based path spaces"},{"location":"hott/06-contractible.rzk/#contractible-products","text":"#def is-contr-product ( A B : U ) ( AisContr : is-contr A) ( BisContr : is-contr B) : is-contr (prod A B) := ( ( first AisContr, first BisContr), \\ p -> path-product A B ( first AisContr) ( first p) ( first BisContr) ( second p) ( second AisContr ( first p)) ( second BisContr ( second p))) #def first-is-contr-product ( A B : U ) ( AxBisContr : is-contr (prod A B)) : is-contr A := ( first ( first AxBisContr), \\ a -> first-path-product A B ( first AxBisContr) ( a, second ( first AxBisContr)) ( second AxBisContr (a, second ( first AxBisContr)))) #def first-is-contr-sigma ( A : U ) ( B : A -> U ) ( b : ( a : A) -> B a) ( ABisContr : is-contr ( \u2211 (a : A), B a)) : is-contr A := ( first ( first ABisContr), \\ a -> first-path-sigma A B ( first ABisContr) ( a, b a) ( second ABisContr (a, b a)))","title":"Contractible products"},{"location":"hott/06-contractible.rzk/#singleton-induction","text":"A type is contractible if and only if it has singleton induction. #def ev-pt ( A : U ) ( a : A) ( B : A -> U ) : ( (x : A) -> B x) -> B a := \\ f -> f a #def has-singleton-induction-pointed ( A : U ) ( a : A) ( B : A -> U ) : U := has-section ( (x : A) -> B x) (B a) (ev-pt A a B) #def has-singleton-induction-pointed-structure ( A : U ) ( a : A) : U := ( B : A -> U ) -> has-section ( (x : A) -> B x) (B a) (ev-pt A a B) #def has-singleton-induction ( A : U ) : U := \u2211 ( a : A), ( B : A -> U ) -> (has-singleton-induction-pointed A a B) #def ind-sing ( A : U ) ( a : A) ( B : A -> U ) ( AhasSingInd : has-singleton-induction-pointed A a B) : (B a) -> ( (x : A) -> B x) := ( first AhasSingInd) #def comp-sing ( A : U ) ( a : A) ( B : A -> U ) ( AhasSingInd : has-singleton-induction-pointed A a B) : (homotopy (B a) (B a) (composition (B a) ( (x : A) -> B x) (B a) (ev-pt A a B) (ind-sing A a B AhasSingInd)) (identity (B a))) := ( second AhasSingInd) #def contr-implies-singleton-induction-ind ( A : U ) ( Aiscontr : is-contr A) : (has-singleton-induction A) := ( ( contraction-center A Aiscontr), \\ B -> ( ( \\ b x -> ( transport A B ( contraction-center A Aiscontr) x ( contracting-htpy-realigned A Aiscontr x) b)), ( \\ b -> ( ap ( (contraction-center A Aiscontr) = (contraction-center A Aiscontr)) ( B (contraction-center A Aiscontr)) ( contracting-htpy-realigned A Aiscontr ( contraction-center A Aiscontr)) refl _{(contraction-center A Aiscontr)} ( \\ p -> ( transport-loop A B (contraction-center A Aiscontr) b p)) ( contracting-htpy-realigned-path A Aiscontr))))) #def contr-implies-singleton-induction-pointed ( A : U ) ( Aiscontr : is-contr A) ( B : A -> U ) : has-singleton-induction-pointed A (contraction-center A Aiscontr) B := ( second (contr-implies-singleton-induction-ind A Aiscontr)) B #def singleton-induction-ind-implies-contr ( A : U ) ( a : A) ( f : has-singleton-induction-pointed-structure A a) : (is-contr A) := ( a, ( first (f ( \\ x -> a = x)))( refl _{a}))","title":"Singleton induction"},{"location":"hott/07-fibers.rzk/","text":"7. Fibers \u00b6 This is a literate rzk file: #lang rzk-1 Fibers \u00b6 The homotopy fiber of a map is the following type: -- The fiber of a map #def fib ( A B : U ) ( f : A -> B) ( b : B) : U := \u2211 ( a : A), (f a) = b -- We calculate the transport of (a, q) : fib b along p : a = a' #def transport-in-fiber ( A B : U ) ( f : A -> B) ( b : B) ( a a' : A) ( u : (f a) = b) ( p : a = a') : (transport A ( \\ x -> (f x) = b) a a' p u) = (concat B (f a') (f a) b (ap A B a' a f (rev A a a' p)) u) := idJ ( A, a, \\ a'' p' -> (transport A ( \\ x -> (f x) = b) a a'' p' u) = (concat B (f a'') (f a) b (ap A B a'' a f (rev A a a'' p')) u), ( rev ((f a) = b) (concat B (f a) (f a) b refl u) u ( refl-concat B (f a) b u)), a', p) Contractible maps \u00b6 A map is contractible just when its fibers are contractible. -- Contractible maps #def is-contr-map ( A B : U ) ( f : A -> B) : U := ( b : B) -> is-contr (fib A B f b) Contractible maps are equivalences: #section is-contr-map-is-equiv #variables A B : U #variable f : A -> B #variable fiscontr : is-contr-map A B f -- The inverse to a contractible map #def is-contr-map-inverse : B -> A := \\ b -> first (contraction-center (fib A B f b) (fiscontr b)) #def has-section-is-contr-map : has-section A B f := ( is-contr-map-inverse, \\ b -> second (contraction-center (fib A B f b) (fiscontr b))) #def is-contr-map-data-in-fiber uses ( fiscontr ) ( a : A) : fib A B f (f a) := (is-contr-map-inverse (f a), ( second has-section-is-contr-map) (f a)) #def is-contr-map-path-in-fiber ( a : A) : (is-contr-map-data-in-fiber a) =_{fib A B f (f a)} (a, refl ) := contractible-connecting-htpy ( fib A B f (f a)) ( fiscontr (f a)) ( is-contr-map-data-in-fiber a) ( a, refl ) #def is-contr-map-has-retraction uses ( fiscontr ) : has-retraction A B f := ( is-contr-map-inverse, \\ a -> ( ap (fib A B f (f a)) A ( is-contr-map-data-in-fiber a) ( (a, refl )) ( \\ u -> first u) ( is-contr-map-path-in-fiber a))) #def is-equiv-is-contr-map uses ( fiscontr ) : is-equiv A B f := (is-contr-map-has-retraction, has-section-is-contr-map) #end is-contr-map-is-equiv Half adjoint equivalences are contractible. \u00b6 We now show that half adjoint equivalences are contractible maps. -- If f is a half adjoint equivalence, its fibers are inhabited. #def is-surj-is-half-adjoint-equiv ( A B : U ) ( f : A -> B) ( fisHAE : is-half-adjoint-equiv A B f) -- first fisHAE : has-inverse A B f ( b : B) : fib A B f b := ( (has-inverse-inverse A B f ( first fisHAE)) b, ( second ( second ( first fisHAE))) b) It takes much more work to construct the contracting homotopy. The bath path of this homotopy is straightforward. #section half-adjoint-equivalence-fiber-data #variables A B : U #variable f : A -> B #variable fisHAE : is-half-adjoint-equiv A B f #variable b : B #variable z : fib A B f b #def isHAE-fib-base-path : ((has-inverse-inverse A B f ( first fisHAE)) b) = ( first z) := concat A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z))) ( ( first ( second ( first fisHAE))) ( first z)) -- Specializing the above to isHAE-fib-base-path #def isHAE-fib-base-path-transport : transport A ( \\ x -> (f x) = b) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ) ( ( second ( second ( first fisHAE))) b) = concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( rev A ((has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ))) ( ( second ( second ( first fisHAE))) b) := transport-in-fiber A B f b ( (has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( ( second ( second ( first fisHAE))) b) ( isHAE-fib-base-path ) #def isHAE-fib-base-path-rev-coherence : rev A ((has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path) = concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))) := rev-concat A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z))) ( ( first ( second ( first fisHAE))) ( first z)) #def isHAE-fib-base-path-transport-rev-calculation : concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( rev A ((has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ))) ( ( second ( second ( first fisHAE))) b) = concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first fisHAE))) b) := homotopy-concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( rev A ((has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ))) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ap-htpy A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( rev A ((has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path )) ( concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z))))) ( isHAE-fib-base-path-rev-coherence )) ( ( second ( second ( first fisHAE))) b) #def isHAE-fib-base-path-transport-ap-calculation : concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first fisHAE))) b) = concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first fisHAE))) b) := homotopy-concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ap-concat A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z))))) ( ( second ( second ( first fisHAE))) b) #def isHAE-fib-base-path-transport-rev-ap-rev-calculation : concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first fisHAE))) b) = concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( ap B A (f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z)))) ( ( second ( second ( first fisHAE))) b) := homotopy-concat B ( f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( ap B A ( f ( first z)) b (has-inverse-inverse A B f ( first fisHAE)) ( second z)))) ( concat-homotopy B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z))))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) f ( ap B A (f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z))) ( ap-htpy A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b ( f ( first z)) ( has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))) ( ap B A ( f ( first z)) ( b) ( has-inverse-inverse A B f ( first fisHAE)) ( second z)) ( rev-ap-rev B A (f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z)))) ( ( second ( second ( first fisHAE))) b) #def isHAE-fib-base-path-transport-ap-ap-calculation : concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( ap B A (f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z)))) ( ( second ( second ( first fisHAE))) b) = concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z))) ( ( second ( second ( first fisHAE))) b) := homotopy-concat B ( f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( ap B A ( f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z)))) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z))) ( concat-homotopy B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( ap B A (f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z))) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z)) ( rev-ap-comp B A B ( f ( first z)) ( b) ( has-inverse-inverse A B f ( first fisHAE)) ( f) ( second z))) ( ( second ( second ( first fisHAE))) b) #def isHAE-fib-base-path-transport-assoc-calculation : concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z))) ( ( second ( second ( first fisHAE))) b) = concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z)) ( ( second ( second ( first fisHAE))) b)) := concat-assoc B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z)) ( ( second ( second ( first fisHAE))) b) #def isHAE-fib-base-path-transport-nat-calculation : concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z)) ( ( second ( second ( first fisHAE))) b)) = concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) := concat-homotopy B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap B B ( f ( first z)) ( b) ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z)) ( ( second ( second ( first fisHAE))) b)) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) ( nat-htpy B B ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( identity B) ( second ( second ( first fisHAE))) ( f ( first z)) ( b) ( second z)) #def isHAE-fib-base-path-transport-ap-id-calculation : concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) = concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( second z)) := concat-homotopy B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( second z)) ( concat-homotopy B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z)) ( second z) ( ap-id B (f ( first z)) b ( second z))) #def isHAE-fib-base-path-transport-reassoc-calculation : concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( second z)) = concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ( second ( second ( first fisHAE))) (f ( first z)))) ( second z) := assoc-concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ( second ( second ( first fisHAE))) (f ( first z))) ( second z) #def isHAE-fib-base-path-transport-HAE-calculation : concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ( second ( second ( first fisHAE))) (f ( first z)))) ( second z) = concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) f ( (( first ( second ( first fisHAE)))) ( first z)))) ( second z) := homotopy-concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ( second ( second ( first fisHAE))) (f ( first z)))) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) ( f) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat-homotopy B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) f ( (( first ( second ( first fisHAE)))) ( first z))) ( ( second fisHAE) ( first z))) ( second z) #def isHAE-fib-base-path-transport-HAE-reduction : concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) f ( (( first ( second ( first fisHAE)))) ( first z)))) ( second z) = concat B (f ( first z)) (f ( first z)) b ( refl ) ( second z) := homotopy-concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) f ( (( first ( second ( first fisHAE)))) ( first z)))) ( refl ) ( concat-ap-rev-ap-id A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) ( f) ( (( first ( second ( first fisHAE)))) ( first z))) ( second z) #def isHAE-fib-base-path-transport-HAE-final-reduction uses ( A ) : concat B (f ( first z)) (f ( first z)) b ( refl ) ( second z) = second z := refl-concat B (f ( first z)) b ( second z) #def isHAE-fib-base-path-transport-path : transport A ( \\ x -> (f x) = b) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ) ( ( second ( second ( first fisHAE))) b) = second z := 12ary-concat-alternating ( (f ( first z)) = b) ( transport A ( \\ x -> (f x) = b) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ) ( ( second ( second ( first fisHAE))) b)) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( rev A ((has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ))) ( ( second ( second ( first fisHAE))) b)) ( isHAE-fib-base-path-transport ) ( concat B ( f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first fisHAE))) b)) ( isHAE-fib-base-path-transport-rev-calculation) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first fisHAE))) b)) ( isHAE-fib-base-path-transport-ap-calculation ) ( concat B ( f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) f ( ap B A (f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z)))) ( ( second ( second ( first fisHAE))) b)) ( isHAE-fib-base-path-transport-rev-ap-rev-calculation ) ( concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z))) ( ( second ( second ( first fisHAE))) b)) ( isHAE-fib-base-path-transport-ap-ap-calculation ) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap B B ( f ( first z)) ( b) ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z)) ( ( second ( second ( first fisHAE))) b))) ( isHAE-fib-base-path-transport-assoc-calculation) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z)))) ( isHAE-fib-base-path-transport-nat-calculation) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( second z))) (isHAE-fib-base-path-transport-ap-id-calculation) ( concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ( second ( second ( first fisHAE))) (f ( first z)))) ( second z)) ( isHAE-fib-base-path-transport-reassoc-calculation) ( concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) f ( ( first ( second ( first fisHAE))) ( first z)))) ( second z)) ( isHAE-fib-base-path-transport-HAE-calculation) ( concat B (f ( first z)) (f ( first z)) b ( refl ) ( second z)) ( isHAE-fib-base-path-transport-HAE-reduction) ( second z) ( isHAE-fib-base-path-transport-HAE-final-reduction) Finally, we may define the contracting homotopy: #def isHAE-fib-contracting-homotopy : (is-surj-is-half-adjoint-equiv A B f fisHAE b) = z := path-of-pairs-pair-of-paths A ( \\ x -> (f x) = b) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path) ( ( second ( second ( first fisHAE))) b) ( second z) ( isHAE-fib-base-path-transport-path) #end half-adjoint-equivalence-fiber-data Half adjoint equivalences define contractible maps: #def is-contr-map-is-half-adjoint-equiv ( A B : U ) ( f : A -> B) ( fisHAE : is-half-adjoint-equiv A B f) : is-contr-map A B f := \\ b -> ( is-surj-is-half-adjoint-equiv A B f fisHAE b, \\ z -> isHAE-fib-contracting-homotopy A B f fisHAE b z) Equivalences are contractible maps \u00b6 #def is-contr-map-is-equiv ( A B : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) : is-contr-map A B f := \\ b -> ( is-surj-is-half-adjoint-equiv A B f ( is-half-adjoint-equiv-is-equiv A B f fisequiv) b, \\ z -> isHAE-fib-contracting-homotopy A B f ( is-half-adjoint-equiv-is-equiv A B f fisequiv) b z) #def is-contr-map-iff-is-equiv ( A B : U ) ( f : A -> B) : iff (is-contr-map A B f) (is-equiv A B f) := (is-equiv-is-contr-map A B f, is-contr-map-is-equiv A B f)","title":"Fibers"},{"location":"hott/07-fibers.rzk/#7-fibers","text":"This is a literate rzk file: #lang rzk-1","title":"7. Fibers"},{"location":"hott/07-fibers.rzk/#fibers","text":"The homotopy fiber of a map is the following type: -- The fiber of a map #def fib ( A B : U ) ( f : A -> B) ( b : B) : U := \u2211 ( a : A), (f a) = b -- We calculate the transport of (a, q) : fib b along p : a = a' #def transport-in-fiber ( A B : U ) ( f : A -> B) ( b : B) ( a a' : A) ( u : (f a) = b) ( p : a = a') : (transport A ( \\ x -> (f x) = b) a a' p u) = (concat B (f a') (f a) b (ap A B a' a f (rev A a a' p)) u) := idJ ( A, a, \\ a'' p' -> (transport A ( \\ x -> (f x) = b) a a'' p' u) = (concat B (f a'') (f a) b (ap A B a'' a f (rev A a a'' p')) u), ( rev ((f a) = b) (concat B (f a) (f a) b refl u) u ( refl-concat B (f a) b u)), a', p)","title":"Fibers"},{"location":"hott/07-fibers.rzk/#contractible-maps","text":"A map is contractible just when its fibers are contractible. -- Contractible maps #def is-contr-map ( A B : U ) ( f : A -> B) : U := ( b : B) -> is-contr (fib A B f b) Contractible maps are equivalences: #section is-contr-map-is-equiv #variables A B : U #variable f : A -> B #variable fiscontr : is-contr-map A B f -- The inverse to a contractible map #def is-contr-map-inverse : B -> A := \\ b -> first (contraction-center (fib A B f b) (fiscontr b)) #def has-section-is-contr-map : has-section A B f := ( is-contr-map-inverse, \\ b -> second (contraction-center (fib A B f b) (fiscontr b))) #def is-contr-map-data-in-fiber uses ( fiscontr ) ( a : A) : fib A B f (f a) := (is-contr-map-inverse (f a), ( second has-section-is-contr-map) (f a)) #def is-contr-map-path-in-fiber ( a : A) : (is-contr-map-data-in-fiber a) =_{fib A B f (f a)} (a, refl ) := contractible-connecting-htpy ( fib A B f (f a)) ( fiscontr (f a)) ( is-contr-map-data-in-fiber a) ( a, refl ) #def is-contr-map-has-retraction uses ( fiscontr ) : has-retraction A B f := ( is-contr-map-inverse, \\ a -> ( ap (fib A B f (f a)) A ( is-contr-map-data-in-fiber a) ( (a, refl )) ( \\ u -> first u) ( is-contr-map-path-in-fiber a))) #def is-equiv-is-contr-map uses ( fiscontr ) : is-equiv A B f := (is-contr-map-has-retraction, has-section-is-contr-map) #end is-contr-map-is-equiv","title":"Contractible maps"},{"location":"hott/07-fibers.rzk/#half-adjoint-equivalences-are-contractible","text":"We now show that half adjoint equivalences are contractible maps. -- If f is a half adjoint equivalence, its fibers are inhabited. #def is-surj-is-half-adjoint-equiv ( A B : U ) ( f : A -> B) ( fisHAE : is-half-adjoint-equiv A B f) -- first fisHAE : has-inverse A B f ( b : B) : fib A B f b := ( (has-inverse-inverse A B f ( first fisHAE)) b, ( second ( second ( first fisHAE))) b) It takes much more work to construct the contracting homotopy. The bath path of this homotopy is straightforward. #section half-adjoint-equivalence-fiber-data #variables A B : U #variable f : A -> B #variable fisHAE : is-half-adjoint-equiv A B f #variable b : B #variable z : fib A B f b #def isHAE-fib-base-path : ((has-inverse-inverse A B f ( first fisHAE)) b) = ( first z) := concat A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z))) ( ( first ( second ( first fisHAE))) ( first z)) -- Specializing the above to isHAE-fib-base-path #def isHAE-fib-base-path-transport : transport A ( \\ x -> (f x) = b) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ) ( ( second ( second ( first fisHAE))) b) = concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( rev A ((has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ))) ( ( second ( second ( first fisHAE))) b) := transport-in-fiber A B f b ( (has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( ( second ( second ( first fisHAE))) b) ( isHAE-fib-base-path ) #def isHAE-fib-base-path-rev-coherence : rev A ((has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path) = concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))) := rev-concat A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z))) ( ( first ( second ( first fisHAE))) ( first z)) #def isHAE-fib-base-path-transport-rev-calculation : concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( rev A ((has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ))) ( ( second ( second ( first fisHAE))) b) = concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first fisHAE))) b) := homotopy-concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( rev A ((has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ))) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ap-htpy A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( rev A ((has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path )) ( concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z))))) ( isHAE-fib-base-path-rev-coherence )) ( ( second ( second ( first fisHAE))) b) #def isHAE-fib-base-path-transport-ap-calculation : concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first fisHAE))) b) = concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first fisHAE))) b) := homotopy-concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ap-concat A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z))))) ( ( second ( second ( first fisHAE))) b) #def isHAE-fib-base-path-transport-rev-ap-rev-calculation : concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first fisHAE))) b) = concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( ap B A (f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z)))) ( ( second ( second ( first fisHAE))) b) := homotopy-concat B ( f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( ap B A ( f ( first z)) b (has-inverse-inverse A B f ( first fisHAE)) ( second z)))) ( concat-homotopy B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z))))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) f ( ap B A (f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z))) ( ap-htpy A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b ( f ( first z)) ( has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))) ( ap B A ( f ( first z)) ( b) ( has-inverse-inverse A B f ( first fisHAE)) ( second z)) ( rev-ap-rev B A (f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z)))) ( ( second ( second ( first fisHAE))) b) #def isHAE-fib-base-path-transport-ap-ap-calculation : concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( ap B A (f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z)))) ( ( second ( second ( first fisHAE))) b) = concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z))) ( ( second ( second ( first fisHAE))) b) := homotopy-concat B ( f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( ap B A ( f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z)))) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z))) ( concat-homotopy B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( ap B A (f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z))) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z)) ( rev-ap-comp B A B ( f ( first z)) ( b) ( has-inverse-inverse A B f ( first fisHAE)) ( f) ( second z))) ( ( second ( second ( first fisHAE))) b) #def isHAE-fib-base-path-transport-assoc-calculation : concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z))) ( ( second ( second ( first fisHAE))) b) = concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z)) ( ( second ( second ( first fisHAE))) b)) := concat-assoc B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z)) ( ( second ( second ( first fisHAE))) b) #def isHAE-fib-base-path-transport-nat-calculation : concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z)) ( ( second ( second ( first fisHAE))) b)) = concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) := concat-homotopy B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap B B ( f ( first z)) ( b) ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z)) ( ( second ( second ( first fisHAE))) b)) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) ( nat-htpy B B ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( identity B) ( second ( second ( first fisHAE))) ( f ( first z)) ( b) ( second z)) #def isHAE-fib-base-path-transport-ap-id-calculation : concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) = concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( second z)) := concat-homotopy B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( second z)) ( concat-homotopy B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z)) ( second z) ( ap-id B (f ( first z)) b ( second z))) #def isHAE-fib-base-path-transport-reassoc-calculation : concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( second z)) = concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ( second ( second ( first fisHAE))) (f ( first z)))) ( second z) := assoc-concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ( second ( second ( first fisHAE))) (f ( first z))) ( second z) #def isHAE-fib-base-path-transport-HAE-calculation : concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ( second ( second ( first fisHAE))) (f ( first z)))) ( second z) = concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) f ( (( first ( second ( first fisHAE)))) ( first z)))) ( second z) := homotopy-concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ( second ( second ( first fisHAE))) (f ( first z)))) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) ( f) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat-homotopy B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) f ( (( first ( second ( first fisHAE)))) ( first z))) ( ( second fisHAE) ( first z))) ( second z) #def isHAE-fib-base-path-transport-HAE-reduction : concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) f ( (( first ( second ( first fisHAE)))) ( first z)))) ( second z) = concat B (f ( first z)) (f ( first z)) b ( refl ) ( second z) := homotopy-concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) f ( (( first ( second ( first fisHAE)))) ( first z)))) ( refl ) ( concat-ap-rev-ap-id A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) ( f) ( (( first ( second ( first fisHAE)))) ( first z))) ( second z) #def isHAE-fib-base-path-transport-HAE-final-reduction uses ( A ) : concat B (f ( first z)) (f ( first z)) b ( refl ) ( second z) = second z := refl-concat B (f ( first z)) b ( second z) #def isHAE-fib-base-path-transport-path : transport A ( \\ x -> (f x) = b) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ) ( ( second ( second ( first fisHAE))) b) = second z := 12ary-concat-alternating ( (f ( first z)) = b) ( transport A ( \\ x -> (f x) = b) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ) ( ( second ( second ( first fisHAE))) b)) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( rev A ((has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path ))) ( ( second ( second ( first fisHAE))) b)) ( isHAE-fib-base-path-transport ) ( concat B ( f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( ap A B ( first z) ((has-inverse-inverse A B f ( first fisHAE)) b) f ( concat A ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z))) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first fisHAE))) b)) ( isHAE-fib-base-path-transport-rev-calculation) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) b) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( ap B A b (f ( first z)) (has-inverse-inverse A B f ( first fisHAE)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first fisHAE))) b)) ( isHAE-fib-base-path-transport-ap-calculation ) ( concat B ( f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( (has-inverse-inverse A B f ( first fisHAE)) b) f ( ap B A (f ( first z)) b ( has-inverse-inverse A B f ( first fisHAE)) ( second z)))) ( ( second ( second ( first fisHAE))) b)) ( isHAE-fib-base-path-transport-rev-ap-rev-calculation ) ( concat B (f ( first z)) (f ((has-inverse-inverse A B f ( first fisHAE)) b)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap B B (f ( first z)) b ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z))) ( ( second ( second ( first fisHAE))) b)) ( isHAE-fib-base-path-transport-ap-ap-calculation ) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ((has-inverse-inverse A B f ( first fisHAE)) b)) ( b) ( ap B B ( f ( first z)) ( b) ( composition B A B f (has-inverse-inverse A B f ( first fisHAE))) ( second z)) ( ( second ( second ( first fisHAE))) b))) ( isHAE-fib-base-path-transport-assoc-calculation) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z)))) ( isHAE-fib-base-path-transport-nat-calculation) ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( b) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) f ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( concat B ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first fisHAE))) (f ( first z))) ( second z))) (isHAE-fib-base-path-transport-ap-id-calculation) ( concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ( second ( second ( first fisHAE))) (f ( first z)))) ( second z)) ( isHAE-fib-base-path-transport-reassoc-calculation) ( concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((has-inverse-inverse A B f ( first fisHAE)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( f) ( rev A ( (has-inverse-inverse A B f ( first fisHAE)) (f ( first z))) ( first z) ( ( first ( second ( first fisHAE))) ( first z)))) ( ap A B ( has-inverse-retraction-composite A B f ( first fisHAE) ( first z)) ( first z) f ( ( first ( second ( first fisHAE))) ( first z)))) ( second z)) ( isHAE-fib-base-path-transport-HAE-calculation) ( concat B (f ( first z)) (f ( first z)) b ( refl ) ( second z)) ( isHAE-fib-base-path-transport-HAE-reduction) ( second z) ( isHAE-fib-base-path-transport-HAE-final-reduction) Finally, we may define the contracting homotopy: #def isHAE-fib-contracting-homotopy : (is-surj-is-half-adjoint-equiv A B f fisHAE b) = z := path-of-pairs-pair-of-paths A ( \\ x -> (f x) = b) ( (has-inverse-inverse A B f ( first fisHAE)) b) ( first z) ( isHAE-fib-base-path) ( ( second ( second ( first fisHAE))) b) ( second z) ( isHAE-fib-base-path-transport-path) #end half-adjoint-equivalence-fiber-data Half adjoint equivalences define contractible maps: #def is-contr-map-is-half-adjoint-equiv ( A B : U ) ( f : A -> B) ( fisHAE : is-half-adjoint-equiv A B f) : is-contr-map A B f := \\ b -> ( is-surj-is-half-adjoint-equiv A B f fisHAE b, \\ z -> isHAE-fib-contracting-homotopy A B f fisHAE b z)","title":"Half adjoint equivalences are contractible."},{"location":"hott/07-fibers.rzk/#equivalences-are-contractible-maps","text":"#def is-contr-map-is-equiv ( A B : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) : is-contr-map A B f := \\ b -> ( is-surj-is-half-adjoint-equiv A B f ( is-half-adjoint-equiv-is-equiv A B f fisequiv) b, \\ z -> isHAE-fib-contracting-homotopy A B f ( is-half-adjoint-equiv-is-equiv A B f fisequiv) b z) #def is-contr-map-iff-is-equiv ( A B : U ) ( f : A -> B) : iff (is-contr-map A B f) (is-equiv A B f) := (is-equiv-is-contr-map A B f, is-contr-map-is-equiv A B f)","title":"Equivalences are contractible maps"},{"location":"hott/08-families-of-maps.rzk/","text":"8. Families of maps \u00b6 This is a literate rzk file: #lang rzk-1 Fiber of total map \u00b6 We now calculate the fiber of the map on total spaces associated to a family of maps. #def total-map-family-of-maps ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps : ( \u2211 (x : A), B x) -> ( \u2211 (x : A), C x) -- the induced map on total spaces := \\ z -> ( first z, f ( first z) ( second z)) #def total-map-to-fiber ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( w : ( \u2211 (x : A), C x)) : fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w) -> ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x)(total-map-family-of-maps A B C f) w) := \\ (b, p) -> ( ( first w, b), sigma-path-fibered-path A C ( first w) (f ( first w) b) ( second w) p) #def total-map-from-fiber ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( w : ( \u2211 (x : A), C x)) : ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x) (total-map-family-of-maps A B C f) w) -> fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w) := \\ (z, p) -> idJ ( (\u2211 (x : A), C x), ((total-map-family-of-maps A B C f) z), \\ w' p' -> fib (B ( first w')) (C ( first w')) (f ( first w')) ( second w'), (( second z), refl ), w, p) #def total-map-to-fiber-retraction ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( w : ( \u2211 (x : A), C x)) : has-retraction ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x)(total-map-family-of-maps A B C f) w) ( total-map-to-fiber A B C f w) := ( total-map-from-fiber A B C f w, \\ (b, p) -> idJ ( (C ( first w)), (f ( first w) b), \\ w1 p' -> ((total-map-from-fiber A B C f (( first w, w1))) ((total-map-to-fiber A B C f ( first w, w1)) (b, p'))) =_{(fib (B ( first w)) (C ( first w)) (f ( first w)) (w1))} (b, p'), refl , ( second w), p)) #def total-map-to-fiber-section ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( w : ( \u2211 (x : A), C x)) : has-section ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x) (total-map-family-of-maps A B C f) w) ( total-map-to-fiber A B C f w) := ( total-map-from-fiber A B C f w, \\ (z, p) -> idJ ( (\u2211 (x : A), C x), (( first z, f ( first z) ( second z))), \\ w' p' -> ( (total-map-to-fiber A B C f w') ( (total-map-from-fiber A B C f w') (z, p'))) = ( z, p'), refl , w, p)) #def total-map-to-fiber-is-equiv ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( w : ( \u2211 (x : A), C x)) : is-equiv ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f) w) ( total-map-to-fiber A B C f w) := ( total-map-to-fiber-retraction A B C f w, total-map-to-fiber-section A B C f w) #def total-map-fiber-equiv ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( w : ( \u2211 (x : A), C x)) : Equiv ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f) w) := (total-map-to-fiber A B C f w, total-map-to-fiber-is-equiv A B C f w) Families of equivalences \u00b6 A family of equivalences induces an equivalence on total spaces and conversely. It will be easiest to work with the incoherent notion of two-sided-inverses. #def invertible-family-total-inverse ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( invfamily : ( a : A) -> has-inverse (B a) (C a) (f a)) : ( \u2211 (x : A), C x) -> ( \u2211 (x : A), B x) := \\ (a, c) -> (a, (has-inverse-inverse (B a) (C a) (f a) (invfamily a)) c) #def invertible-family-total-retraction ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( invfamily : ( a : A) -> has-inverse (B a) (C a) (f a)) : has-retraction ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f) := ( invertible-family-total-inverse A B C f invfamily, \\ (a, b) -> (sigma-path-fibered-path A B a ( (has-inverse-inverse (B a) (C a) (f a) (invfamily a)) (f a b)) b ( ( first ( second (invfamily a))) b))) #def invertible-family-total-section ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( invfamily : ( a : A) -> has-inverse (B a) (C a) (f a)) : has-section ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) (total-map-family-of-maps A B C f) := ( invertible-family-total-inverse A B C f invfamily, \\ (a, c) -> ( sigma-path-fibered-path A C a ( f a ((has-inverse-inverse (B a) (C a) (f a) (invfamily a)) c)) c ( ( second ( second (invfamily a))) c))) #def invertible-family-total-invertible ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( invfamily : ( a : A) -> has-inverse (B a) (C a) (f a)) : has-inverse ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f) := ( invertible-family-total-inverse A B C f invfamily, ( second (invertible-family-total-retraction A B C f invfamily), second (invertible-family-total-section A B C f invfamily))) #def family-of-equiv-total-equiv ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( familyequiv : ( a : A) -> is-equiv (B a) (C a) (f a)) : is-equiv ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) (total-map-family-of-maps A B C f) := is-equiv-has-inverse ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) (total-map-family-of-maps A B C f) ( invertible-family-total-invertible A B C f ( \\ a -> has-inverse-is-equiv (B a) (C a) (f a) (familyequiv a))) #def total-equiv-family-equiv ( A : U ) ( B C : A -> U ) ( familyeq : ( a : A) -> Equiv (B a) (C a)) : Equiv ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) := ( total-map-family-of-maps A B C ( \\ a -> first (familyeq a)), family-of-equiv-total-equiv A B C ( \\ a -> first (familyeq a)) ( \\ a -> second (familyeq a))) The one-way result: that a family of equivalence gives an invertible map (and thus an equivalence) on total spaces. #def total-has-inverse-family-equiv ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( familyequiv : ( a : A) -> is-equiv (B a) (C a) (f a)) : has-inverse ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) (total-map-family-of-maps A B C f) := invertible-family-total-invertible A B C f ( \\ a -> has-inverse-is-equiv (B a) (C a) (f a) (familyequiv a)) For the converse, we make use of our calculation on fibers. The first implication could be proven similarly. #def total-contr-map-family-of-contr-maps ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( totalcontrmap : is-contr-map ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f)) ( a : A) : is-contr-map (B a) (C a) (f a) := \\ c -> is-contr-is-equiv-to-contr ( fib (B a) (C a) (f a) c) ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f) ((a, c))) ( total-map-fiber-equiv A B C f ((a, c))) ( totalcontrmap ((a, c))) #def total-equiv-family-of-equiv ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( totalequiv : is-equiv ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f)) ( a : A) : is-equiv (B a) (C a) (f a) := is-equiv-is-contr-map (B a) (C a) (f a) ( total-contr-map-family-of-contr-maps A B C f ( is-contr-map-is-equiv ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f) totalequiv) a) In summary, a family of maps is an equivalence iff the map on total spaces is an equivalence. #def total-equiv-iff-family-of-equiv ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) : iff ( (a : A) -> is-equiv (B a) (C a) (f a)) ( is-equiv (\u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f)) := (family-of-equiv-total-equiv A B C f, total-equiv-family-of-equiv A B C f) Codomain based path spaces \u00b6 #def equiv-rev ( A : U ) ( x y : A) : Equiv (x = y) (y = x) := (rev A x y, ((rev A y x, rev-rev A x y),(rev A y x, rev-rev A y x))) -- An equivalence between the based path spaces. #def equiv-based-paths ( A : U ) ( a : A) : Equiv ( \u2211 (x : A), x = a) ( \u2211 (x : A), a = x) := total-equiv-family-equiv A ( \\ x -> x = a) ( \\ x -> a = x)( \\ x -> equiv-rev A x a) -- Codomain based path spaces are contractible #def is-contr-codomain-based-paths ( A : U ) -- The ambient type. ( a : A) -- The basepoint. : is-contr ( \u2211 (x : A), x = a) := is-contr-is-equiv-to-contr ( \u2211 (x : A), x = a) ( \u2211 (x : A), a = x) ( equiv-based-paths A a) ( is-contr-based-paths A a) Pullback of a type family \u00b6 A family of types over B pulls back along any function f : A -> B to define a family of types over A. #def pullback ( A B : U ) ( f : A -> B) ( C : B -> U ) : A -> U := \\ a -> C (f a) The pullback of a family along homotopic maps is equivalent. #section is-equiv-pullback-htpy #variables A B : U #variables f g : A -> B #variable \u03b1 : homotopy A B f g #variable C : B -> U #variable a : A #def pullback-homotopy : (pullback A B f C a) -> (pullback A B g C a) := \\ c -> transport B C (f a) (g a) (\u03b1 a) c #def pullback-homotopy-inverse : (pullback A B g C a) -> (pullback A B f C a) := \\ c -> transport B C (g a) (f a) (rev B (f a) (g a) (\u03b1 a)) c #def pullback-homotopy-has-retraction : has-retraction ( pullback A B f C a) ( pullback A B g C a) ( pullback-homotopy) := ( pullback-homotopy-inverse, \\ c -> concat ( pullback A B f C a) ( transport B C (g a) (f a) ( rev B (f a) (g a) (\u03b1 a)) ( transport B C (f a) (g a) (\u03b1 a) c)) ( transport B C (f a) (f a) ( concat B (f a) (g a) (f a) (\u03b1 a) (rev B (f a) (g a) (\u03b1 a))) c) ( c) ( transport-concat-rev B C (f a) (g a) (f a) (\u03b1 a) ( rev B (f a) (g a) (\u03b1 a)) c) ( transport2 B C (f a) (f a) ( concat B (f a) (g a) (f a) (\u03b1 a) (rev B (f a) (g a) (\u03b1 a))) refl ( right-inverse B (f a) (g a) (\u03b1 a)) c)) #def pullback-homotopy-has-section : has-section (pullback A B f C a) (pullback A B g C a) ( pullback-homotopy) := ( pullback-homotopy-inverse, \\ c -> concat (pullback A B g C a) ( transport B C (f a) (g a) (\u03b1 a) ( transport B C (g a) (f a) (rev B (f a) (g a) (\u03b1 a)) c)) ( transport B C (g a) (g a) ( concat B (g a) (f a) (g a) (rev B (f a) (g a) (\u03b1 a)) (\u03b1 a)) c) ( c) ( transport-concat-rev B C (g a) (f a) (g a) ( rev B (f a) (g a) (\u03b1 a)) (\u03b1 a) c) ( transport2 B C (g a) (g a) ( concat B (g a) (f a) (g a) (rev B (f a) (g a) (\u03b1 a)) (\u03b1 a)) refl ( left-inverse B (f a) (g a) (\u03b1 a)) c)) #def is-equiv-pullback-homotopy uses ( \u03b1 ) : is-equiv (pullback A B f C a) (pullback A B g C a) (pullback-homotopy) := ( pullback-homotopy-has-retraction, pullback-homotopy-has-section) #end is-equiv-pullback-htpy The total space of a pulled back family of types maps to the original total space. #def pullback-comparison-map ( A B : U ) ( f : A -> B) ( C : B -> U ) : ( \u2211(a : A), (pullback A B f C) a) -> ( \u2211(b : B), C b) := \\ (a, c) -> (f a, c) Now we show that if a family is pulled back along an equivalence, the total spaces are equivalent by proving that the comparison is a contractible map. For this, we first prove that each fiber is equivalent to a fiber of the original map. #def pullback-comparison-fiber ( A B : U ) ( f : A -> B) ( C : B -> U ) ( z : \u2211 ( b : B), C b) : U := fib ( \u2211(a : A), (pullback A B f C) a) ( \u2211(b : B), C b) ( pullback-comparison-map A B f C) z #def pullback-comparison-fiber-to-fiber ( A B : U ) ( f : A -> B) ( C : B -> U ) ( z : \u2211 ( b : B), C b) : (pullback-comparison-fiber A B f C z) -> (fib A B f ( first z)) := \\ (w, p) -> idJ ( (\u2211(b : B), C b), (pullback-comparison-map A B f C w), \\ z' p' -> ( fib A B f ( first z')), ( first w, refl ), z, p) #def from-base-fiber-to-pullback-comparison-fiber ( A B : U ) ( f : A -> B) ( C : B -> U ) ( b : B) : (fib A B f b) -> ( c : C b) -> (pullback-comparison-fiber A B f C (b, c)) := \\ (a, p) -> idJ ( B, f a, \\ b' p' -> (c : C b') -> (pullback-comparison-fiber A B f C ((b', c))), \\ c -> ((a, c), refl ), b, p) #def pullback-comparison-fiber-to-fiber-inv ( A B : U ) ( f : A -> B) ( C : B -> U ) ( z : \u2211 ( b : B), C b) : (fib A B f ( first z)) -> (pullback-comparison-fiber A B f C z) := \\ (a, p) -> from-base-fiber-to-pullback-comparison-fiber A B f C ( first z) (a, p) ( second z) #def pullback-comparison-fiber-to-fiber-retracting-homotopy ( A B : U ) ( f : A -> B) ( C : B -> U ) ( z : \u2211 ( b : B), C b) ((w, p) : pullback-comparison-fiber A B f C z) : ( (pullback-comparison-fiber-to-fiber-inv A B f C z) ( (pullback-comparison-fiber-to-fiber A B f C z) (w, p))) = (w, p) := idJ ( (\u2211(b : B), C b), (pullback-comparison-map A B f C w), \\ z' p' -> ((pullback-comparison-fiber-to-fiber-inv A B f C z') ((pullback-comparison-fiber-to-fiber A B f C z') (w, p'))) = (w, p'), refl , z, p) #def pullback-comparison-fiber-to-fiber-section-homotopy-map ( A B : U ) ( f : A -> B) ( C : B -> U ) ( b : B) ((a, p) : fib A B f b) : ( c : C b) -> ((pullback-comparison-fiber-to-fiber A B f C (b, c)) ((pullback-comparison-fiber-to-fiber-inv A B f C (b, c)) (a, p))) = (a, p) := idJ ( B, f a, \\ b' p' -> (c : C b') -> ( (pullback-comparison-fiber-to-fiber A B f C (b', c)) ( (pullback-comparison-fiber-to-fiber-inv A B f C (b', c))(a, p'))) = ( a, p'), \\ c -> refl , b, p) #def pullback-comparison-fiber-to-fiber-section-homotopy ( A B : U ) ( f : A -> B) ( C : B -> U ) ( z : \u2211 ( b : B), C b) ((a, p) : fib A B f ( first z)) : ((pullback-comparison-fiber-to-fiber A B f C z) ((pullback-comparison-fiber-to-fiber-inv A B f C z)(a, p))) = (a, p) := pullback-comparison-fiber-to-fiber-section-homotopy-map A B f C ( first z) (a, p) ( second z) #def equiv-pullback-comparison-fiber ( A B : U ) ( f : A -> B) ( C : B -> U ) ( z : \u2211 ( b : B), C b) : Equiv (pullback-comparison-fiber A B f C z) (fib A B f ( first z)) := ( pullback-comparison-fiber-to-fiber A B f C z, ( (pullback-comparison-fiber-to-fiber-inv A B f C z, pullback-comparison-fiber-to-fiber-retracting-homotopy A B f C z), ( pullback-comparison-fiber-to-fiber-inv A B f C z, pullback-comparison-fiber-to-fiber-section-homotopy A B f C z))) As a corollary, we show that pullback along an equivalence induces an equivalence of total spaces. #def total-equiv-pullback-is-equiv ( A B : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) ( C : B -> U ) : Equiv ( \u2211(a : A), (pullback A B f C) a) ( \u2211(b : B), C b) := ( pullback-comparison-map A B f C, is-equiv-is-contr-map ( \u2211(a : A), (pullback A B f C) a) ( \u2211(b : B), C b) ( pullback-comparison-map A B f C) ( \\ z -> ( is-contr-is-equiv-to-contr ( pullback-comparison-fiber A B f C z) ( fib A B f ( first z)) ( equiv-pullback-comparison-fiber A B f C z) ( is-contr-map-is-equiv A B f fisequiv ( first z))))) Fundamental theorem of identity types \u00b6 #section fundamental-thm-id-types #variable A : U #variable a : A #variable B : A -> U #variable f : ( x : A) -> (a = x) -> B x #def fund-id-fam-of-eqs-implies-sum-over-codomain-contr : ( (x : A) -> (is-equiv (a = x) (B x) (f x))) -> ( is-contr (\u2211(x : A), B x)) := ( \\ familyequiv -> ( equiv-with-contractible-domain-implies-contractible-codomain ( \u2211(x : A), a = x) ( \u2211(x : A), B x) ( ( total-map-family-of-maps A ( \\ x -> (a = x)) B f), ( is-equiv-has-inverse (\u2211(x : A), a = x) ( \u2211(x : A), B x) ( total-map-family-of-maps A ( \\ x -> (a = x)) B f) ( total-has-inverse-family-equiv A ( \\ x -> (a = x)) B f familyequiv))) ( is-contr-based-paths A a))) #def fund-id-sum-over-codomain-contr-implies-fam-of-eqs : ( is-contr (\u2211(x : A), B x)) -> ( (x : A) -> (is-equiv (a = x) (B x) (f x))) := ( \\ Biscontr -> ( \\ x -> ( total-equiv-family-of-equiv A ( \\ x' -> (a = x')) B f ( areContr-is-equiv (\u2211(x' : A), (a = x')) ( \u2211(x' : A), (B x')) ( is-contr-based-paths A a) Biscontr ( total-map-family-of-maps A ( \\ x' -> (a = x')) B f)) x))) -- This allows us to apply \"based path induction\" -- to a family satisfying the fundamental theorem. -- Please suggest a better name. #def ind-based-path ( familyequiv : ( z : A) -> (is-equiv (a = z) (B z) (f z))) ( P : ( z : A) -> B z -> U ) ( p0 : P a (f a refl )) ( x : A) ( p : B x) : P x p := ( ind-sing ( \u2211(x : A), B x) ( a, f a refl ) ( \\ (x', p') -> P x' p') ( contr-implies-singleton-induction-pointed ( \u2211(x : A), B x) ( fund-id-fam-of-eqs-implies-sum-over-codomain-contr familyequiv) ( \\ (x', p') -> P x' p'))) p0 (x, p) #end fundamental-thm-id-types #def emb-is-equiv ( A B : U ) ( e : A -> B) ( eisequiv : is-equiv A B e) : (Emb A B) -- For all x, y in A, ap_{e,x,y} is an equivalence := ( e, \\ x y -> ( fund-id-sum-over-codomain-contr-implies-fam-of-eqs -- By the fundamental theorem of identity types, it will suffice to show -- contractibility of sigma_{t : A} e x = e t -- for the family of maps ap_e, which is of type -- (\\t:A) -> (x = t) -> (e x = e t) A x ( \\ t -> (e x = e t)) ( \\ t -> (ap A B x t e)) -- the family of maps ap_e ( (is-contr-is-equiv-to-contr -- Contractibility of sigma_{t : A} e x = e t will follow since -- total(\\t -> rev B (e x) = (e t)), mapping from sigma_{t : A} e x = e t to -- sigma_{t : A} e t = e x -- is an equivalence, and sigma_{t : A} e t = e x ~ fib(e, e x) is -- contractible since e is an equivalence. ( \u2211(y' : A), (e x = e y')) -- source type ( \u2211(y' : A), (e y' = e x)) -- target type ((total-map-family-of-maps A ( \\ y' -> (e x) = (e y')) ( \\ y' -> (e y') = (e x)) ( \\ y' -> (rev B (e x) (e y')))), -- a) total map ( -- b) proof that total map is equivalence ( first ( total-equiv-iff-family-of-equiv A ( \\ y' -> (e x) = (e y')) ( \\ y' -> (e y') = (e x)) ( \\ y' -> (rev B (e x) (e y'))))) ( \\ y' -> (is-equiv-rev B (e x) (e y'))))) ( -- fiber of e at e(x) is contractible (is-contr-map-is-equiv A B e eisequiv) (e x)))))(y)) -- evaluate at y #def is-emb-is-equiv ( A B : U ) ( e : A -> B) ( eisequiv : is-equiv A B e) : is-emb A B e := ( second (emb-is-equiv A B e eisequiv)) 2-of-3 for equivalences \u00b6 -- It might be better to redo this without appealing to results about -- embeddings so that this could go earlier. #def RightCancel-is-equiv ( A B C : U ) ( f : A -> B) ( g : B -> C) ( gisequiv : is-equiv B C g) ( gfisequiv : is-equiv A C (composition A B C g f)) : is-equiv A B f := ( ( composition B C A (is-equiv-retraction A C (composition A B C g f) gfisequiv) g, ( second ( first gfisequiv))), ( composition B C A (is-equiv-section A C (composition A B C g f) gfisequiv) g, \\ b -> inv-ap-is-emb B C g ( is-emb-is-equiv B C g gisequiv) ( f ((is-equiv-section A C (composition A B C g f) gfisequiv)(g b))) b ( ( second ( second gfisequiv)) (g b)))) #def LeftCancel-is-equiv ( A B C : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) ( g : B -> C) ( gfisequiv : is-equiv A C (composition A B C g f)) : is-equiv B C g := ( ( composition C A B f (is-equiv-retraction A C (composition A B C g f) gfisequiv), \\ b -> triple-concat B ( f ((is-equiv-retraction A C (composition A B C g f) gfisequiv) (g b))) ( f ((is-equiv-retraction A C (composition A B C g f) gfisequiv) (g (f ((is-equiv-section A B f fisequiv) b))))) ( f ((is-equiv-section A B f fisequiv) b)) ( b) ( ap B B ( b) ( f ((is-equiv-section A B f fisequiv) b)) ( \\ b0 -> ( f ((is-equiv-retraction A C ( composition A B C g f) gfisequiv) (g b0)))) ( rev B (f ((is-equiv-section A B f fisequiv) b)) b ( ( second ( second fisequiv)) b))) ( ( homotopy-whisker B A A B ( \\ a -> ( is-equiv-retraction A C ( composition A B C g f) gfisequiv) (g (f a))) ( \\ a -> a) ( second ( first gfisequiv)) ( is-equiv-section A B f fisequiv) f) b) ( ( second ( second fisequiv)) b)), ( composition C A B ( f) ( is-equiv-section A C (composition A B C g f) gfisequiv), ( second ( second gfisequiv)))) Maps over product types \u00b6 For later use, we specialize the previous results to the case of a family of types over a product type. #section fibered-map-over-product #variables A A' B B' : U #variable C : A -> B -> U #variable C' : A' -> B' -> U #variable f : A -> A' #variable g : B -> B' #variable h : ( a : A) -> ( b : B) -> ( c : C a b) -> C' (f a) (g b) #def total-map-fibered-map-over-product : ( \u2211 (a : A), ( \u2211 (b : B), C a b)) -> ( \u2211 (a' : A'), ( \u2211 (b' : B'), C' a' b')) := \\ (a, (b, c)) -> (f a, (g b, h a b c)) #def pullback-is-equiv-base-is-equiv-total-is-equiv ( totalisequiv : is-equiv ( \u2211(a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a' : A'), ( \u2211 (b' : B'), C' a' b')) total-map-fibered-map-over-product) ( fisequiv : is-equiv A A' f) : is-equiv ( \u2211 (a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a : A), ( \u2211 (b' : B'), C' (f a) b')) ( \\ (a, (b, c)) -> (a, (g b, h a b c))) := RightCancel-is-equiv ( \u2211(a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a : A), ( \u2211 (b' : B'), C' (f a) b')) ( \u2211 (a' : A'), ( \u2211 (b' : B'), C' a' b')) ( \\ (a, (b, c)) -> (a, (g b, h a b c))) ( \\ (a, (b', c')) -> (f a, (b', c'))) ( second (total-equiv-pullback-is-equiv A A' f fisequiv ( \\ a' -> (\u2211 (b' : B'), C' a' b')))) ( totalisequiv) #def pullback-is-equiv-bases-are-equiv-total-is-equiv ( totalisequiv : is-equiv ( \u2211(a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a' : A'), ( \u2211 (b' : B'), C' a' b')) total-map-fibered-map-over-product) ( fisequiv : is-equiv A A' f) ( gisequiv : is-equiv B B' g) : is-equiv ( \u2211 (a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a : A), ( \u2211 (b : B), C' (f a) (g b))) ( \\(a, (b, c)) -> (a, (b, h a b c))) := RightCancel-is-equiv ( \u2211 (a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a : A), ( \u2211 (b : B), C' (f a) (g b))) ( \u2211 (a : A), ( \u2211 (b' : B'), C' (f a) b')) ( \\ (a, (b, c)) -> (a, (b, h a b c))) ( \\ (a, (b, c)) -> (a, (g b, c))) ( family-of-equiv-total-equiv A ( \\ a -> (\u2211 (b : B), C' (f a) (g b))) ( \\ a -> (\u2211 (b' : B'), C' (f a) b')) ( \\ a (b, c) -> (g b, c)) ( \\ a -> ( second ( total-equiv-pullback-is-equiv B B' g gisequiv ( \\ b' -> C' (f a) b'))))) ( pullback-is-equiv-base-is-equiv-total-is-equiv totalisequiv fisequiv) #def fibered-map-is-equiv-bases-are-equiv-total-map-is-equiv ( totalisequiv : is-equiv ( \u2211(a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a' : A'), ( \u2211 (b' : B'), C' a' b')) total-map-fibered-map-over-product) ( fisequiv : is-equiv A A' f) ( gisequiv : is-equiv B B' g) ( a0 : A) ( b0 : B) : is-equiv (C a0 b0) (C' (f a0) (g b0)) (h a0 b0) := total-equiv-family-of-equiv B ( \\ b -> C a0 b) ( \\ b -> C' (f a0) (g b)) ( \\ b c -> h a0 b c) ( total-equiv-family-of-equiv A ( \\ a -> (\u2211 (b : B), C a b)) ( \\ a -> (\u2211 (b : B), C' (f a) (g b))) ( \\ a (b, c) -> (b, h a b c)) ( pullback-is-equiv-bases-are-equiv-total-is-equiv totalisequiv fisequiv gisequiv) a0) b0 #end fibered-map-over-product","title":"Families of maps"},{"location":"hott/08-families-of-maps.rzk/#8-families-of-maps","text":"This is a literate rzk file: #lang rzk-1","title":"8. Families of maps"},{"location":"hott/08-families-of-maps.rzk/#fiber-of-total-map","text":"We now calculate the fiber of the map on total spaces associated to a family of maps. #def total-map-family-of-maps ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps : ( \u2211 (x : A), B x) -> ( \u2211 (x : A), C x) -- the induced map on total spaces := \\ z -> ( first z, f ( first z) ( second z)) #def total-map-to-fiber ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( w : ( \u2211 (x : A), C x)) : fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w) -> ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x)(total-map-family-of-maps A B C f) w) := \\ (b, p) -> ( ( first w, b), sigma-path-fibered-path A C ( first w) (f ( first w) b) ( second w) p) #def total-map-from-fiber ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( w : ( \u2211 (x : A), C x)) : ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x) (total-map-family-of-maps A B C f) w) -> fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w) := \\ (z, p) -> idJ ( (\u2211 (x : A), C x), ((total-map-family-of-maps A B C f) z), \\ w' p' -> fib (B ( first w')) (C ( first w')) (f ( first w')) ( second w'), (( second z), refl ), w, p) #def total-map-to-fiber-retraction ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( w : ( \u2211 (x : A), C x)) : has-retraction ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x)(total-map-family-of-maps A B C f) w) ( total-map-to-fiber A B C f w) := ( total-map-from-fiber A B C f w, \\ (b, p) -> idJ ( (C ( first w)), (f ( first w) b), \\ w1 p' -> ((total-map-from-fiber A B C f (( first w, w1))) ((total-map-to-fiber A B C f ( first w, w1)) (b, p'))) =_{(fib (B ( first w)) (C ( first w)) (f ( first w)) (w1))} (b, p'), refl , ( second w), p)) #def total-map-to-fiber-section ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( w : ( \u2211 (x : A), C x)) : has-section ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x) (total-map-family-of-maps A B C f) w) ( total-map-to-fiber A B C f w) := ( total-map-from-fiber A B C f w, \\ (z, p) -> idJ ( (\u2211 (x : A), C x), (( first z, f ( first z) ( second z))), \\ w' p' -> ( (total-map-to-fiber A B C f w') ( (total-map-from-fiber A B C f w') (z, p'))) = ( z, p'), refl , w, p)) #def total-map-to-fiber-is-equiv ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( w : ( \u2211 (x : A), C x)) : is-equiv ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f) w) ( total-map-to-fiber A B C f w) := ( total-map-to-fiber-retraction A B C f w, total-map-to-fiber-section A B C f w) #def total-map-fiber-equiv ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( w : ( \u2211 (x : A), C x)) : Equiv ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f) w) := (total-map-to-fiber A B C f w, total-map-to-fiber-is-equiv A B C f w)","title":"Fiber of total map"},{"location":"hott/08-families-of-maps.rzk/#families-of-equivalences","text":"A family of equivalences induces an equivalence on total spaces and conversely. It will be easiest to work with the incoherent notion of two-sided-inverses. #def invertible-family-total-inverse ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( invfamily : ( a : A) -> has-inverse (B a) (C a) (f a)) : ( \u2211 (x : A), C x) -> ( \u2211 (x : A), B x) := \\ (a, c) -> (a, (has-inverse-inverse (B a) (C a) (f a) (invfamily a)) c) #def invertible-family-total-retraction ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( invfamily : ( a : A) -> has-inverse (B a) (C a) (f a)) : has-retraction ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f) := ( invertible-family-total-inverse A B C f invfamily, \\ (a, b) -> (sigma-path-fibered-path A B a ( (has-inverse-inverse (B a) (C a) (f a) (invfamily a)) (f a b)) b ( ( first ( second (invfamily a))) b))) #def invertible-family-total-section ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( invfamily : ( a : A) -> has-inverse (B a) (C a) (f a)) : has-section ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) (total-map-family-of-maps A B C f) := ( invertible-family-total-inverse A B C f invfamily, \\ (a, c) -> ( sigma-path-fibered-path A C a ( f a ((has-inverse-inverse (B a) (C a) (f a) (invfamily a)) c)) c ( ( second ( second (invfamily a))) c))) #def invertible-family-total-invertible ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( invfamily : ( a : A) -> has-inverse (B a) (C a) (f a)) : has-inverse ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f) := ( invertible-family-total-inverse A B C f invfamily, ( second (invertible-family-total-retraction A B C f invfamily), second (invertible-family-total-section A B C f invfamily))) #def family-of-equiv-total-equiv ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( familyequiv : ( a : A) -> is-equiv (B a) (C a) (f a)) : is-equiv ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) (total-map-family-of-maps A B C f) := is-equiv-has-inverse ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) (total-map-family-of-maps A B C f) ( invertible-family-total-invertible A B C f ( \\ a -> has-inverse-is-equiv (B a) (C a) (f a) (familyequiv a))) #def total-equiv-family-equiv ( A : U ) ( B C : A -> U ) ( familyeq : ( a : A) -> Equiv (B a) (C a)) : Equiv ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) := ( total-map-family-of-maps A B C ( \\ a -> first (familyeq a)), family-of-equiv-total-equiv A B C ( \\ a -> first (familyeq a)) ( \\ a -> second (familyeq a))) The one-way result: that a family of equivalence gives an invertible map (and thus an equivalence) on total spaces. #def total-has-inverse-family-equiv ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) ( familyequiv : ( a : A) -> is-equiv (B a) (C a) (f a)) : has-inverse ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) (total-map-family-of-maps A B C f) := invertible-family-total-invertible A B C f ( \\ a -> has-inverse-is-equiv (B a) (C a) (f a) (familyequiv a)) For the converse, we make use of our calculation on fibers. The first implication could be proven similarly. #def total-contr-map-family-of-contr-maps ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( totalcontrmap : is-contr-map ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f)) ( a : A) : is-contr-map (B a) (C a) (f a) := \\ c -> is-contr-is-equiv-to-contr ( fib (B a) (C a) (f a) c) ( fib (\u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f) ((a, c))) ( total-map-fiber-equiv A B C f ((a, c))) ( totalcontrmap ((a, c))) #def total-equiv-family-of-equiv ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) -- a family of maps ( totalequiv : is-equiv ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f)) ( a : A) : is-equiv (B a) (C a) (f a) := is-equiv-is-contr-map (B a) (C a) (f a) ( total-contr-map-family-of-contr-maps A B C f ( is-contr-map-is-equiv ( \u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f) totalequiv) a) In summary, a family of maps is an equivalence iff the map on total spaces is an equivalence. #def total-equiv-iff-family-of-equiv ( A : U ) ( B C : A -> U ) ( f : ( a : A) -> (B a) -> (C a)) : iff ( (a : A) -> is-equiv (B a) (C a) (f a)) ( is-equiv (\u2211 (x : A), B x) ( \u2211 (x : A), C x) ( total-map-family-of-maps A B C f)) := (family-of-equiv-total-equiv A B C f, total-equiv-family-of-equiv A B C f)","title":"Families of equivalences"},{"location":"hott/08-families-of-maps.rzk/#codomain-based-path-spaces","text":"#def equiv-rev ( A : U ) ( x y : A) : Equiv (x = y) (y = x) := (rev A x y, ((rev A y x, rev-rev A x y),(rev A y x, rev-rev A y x))) -- An equivalence between the based path spaces. #def equiv-based-paths ( A : U ) ( a : A) : Equiv ( \u2211 (x : A), x = a) ( \u2211 (x : A), a = x) := total-equiv-family-equiv A ( \\ x -> x = a) ( \\ x -> a = x)( \\ x -> equiv-rev A x a) -- Codomain based path spaces are contractible #def is-contr-codomain-based-paths ( A : U ) -- The ambient type. ( a : A) -- The basepoint. : is-contr ( \u2211 (x : A), x = a) := is-contr-is-equiv-to-contr ( \u2211 (x : A), x = a) ( \u2211 (x : A), a = x) ( equiv-based-paths A a) ( is-contr-based-paths A a)","title":"Codomain based path spaces"},{"location":"hott/08-families-of-maps.rzk/#pullback-of-a-type-family","text":"A family of types over B pulls back along any function f : A -> B to define a family of types over A. #def pullback ( A B : U ) ( f : A -> B) ( C : B -> U ) : A -> U := \\ a -> C (f a) The pullback of a family along homotopic maps is equivalent. #section is-equiv-pullback-htpy #variables A B : U #variables f g : A -> B #variable \u03b1 : homotopy A B f g #variable C : B -> U #variable a : A #def pullback-homotopy : (pullback A B f C a) -> (pullback A B g C a) := \\ c -> transport B C (f a) (g a) (\u03b1 a) c #def pullback-homotopy-inverse : (pullback A B g C a) -> (pullback A B f C a) := \\ c -> transport B C (g a) (f a) (rev B (f a) (g a) (\u03b1 a)) c #def pullback-homotopy-has-retraction : has-retraction ( pullback A B f C a) ( pullback A B g C a) ( pullback-homotopy) := ( pullback-homotopy-inverse, \\ c -> concat ( pullback A B f C a) ( transport B C (g a) (f a) ( rev B (f a) (g a) (\u03b1 a)) ( transport B C (f a) (g a) (\u03b1 a) c)) ( transport B C (f a) (f a) ( concat B (f a) (g a) (f a) (\u03b1 a) (rev B (f a) (g a) (\u03b1 a))) c) ( c) ( transport-concat-rev B C (f a) (g a) (f a) (\u03b1 a) ( rev B (f a) (g a) (\u03b1 a)) c) ( transport2 B C (f a) (f a) ( concat B (f a) (g a) (f a) (\u03b1 a) (rev B (f a) (g a) (\u03b1 a))) refl ( right-inverse B (f a) (g a) (\u03b1 a)) c)) #def pullback-homotopy-has-section : has-section (pullback A B f C a) (pullback A B g C a) ( pullback-homotopy) := ( pullback-homotopy-inverse, \\ c -> concat (pullback A B g C a) ( transport B C (f a) (g a) (\u03b1 a) ( transport B C (g a) (f a) (rev B (f a) (g a) (\u03b1 a)) c)) ( transport B C (g a) (g a) ( concat B (g a) (f a) (g a) (rev B (f a) (g a) (\u03b1 a)) (\u03b1 a)) c) ( c) ( transport-concat-rev B C (g a) (f a) (g a) ( rev B (f a) (g a) (\u03b1 a)) (\u03b1 a) c) ( transport2 B C (g a) (g a) ( concat B (g a) (f a) (g a) (rev B (f a) (g a) (\u03b1 a)) (\u03b1 a)) refl ( left-inverse B (f a) (g a) (\u03b1 a)) c)) #def is-equiv-pullback-homotopy uses ( \u03b1 ) : is-equiv (pullback A B f C a) (pullback A B g C a) (pullback-homotopy) := ( pullback-homotopy-has-retraction, pullback-homotopy-has-section) #end is-equiv-pullback-htpy The total space of a pulled back family of types maps to the original total space. #def pullback-comparison-map ( A B : U ) ( f : A -> B) ( C : B -> U ) : ( \u2211(a : A), (pullback A B f C) a) -> ( \u2211(b : B), C b) := \\ (a, c) -> (f a, c) Now we show that if a family is pulled back along an equivalence, the total spaces are equivalent by proving that the comparison is a contractible map. For this, we first prove that each fiber is equivalent to a fiber of the original map. #def pullback-comparison-fiber ( A B : U ) ( f : A -> B) ( C : B -> U ) ( z : \u2211 ( b : B), C b) : U := fib ( \u2211(a : A), (pullback A B f C) a) ( \u2211(b : B), C b) ( pullback-comparison-map A B f C) z #def pullback-comparison-fiber-to-fiber ( A B : U ) ( f : A -> B) ( C : B -> U ) ( z : \u2211 ( b : B), C b) : (pullback-comparison-fiber A B f C z) -> (fib A B f ( first z)) := \\ (w, p) -> idJ ( (\u2211(b : B), C b), (pullback-comparison-map A B f C w), \\ z' p' -> ( fib A B f ( first z')), ( first w, refl ), z, p) #def from-base-fiber-to-pullback-comparison-fiber ( A B : U ) ( f : A -> B) ( C : B -> U ) ( b : B) : (fib A B f b) -> ( c : C b) -> (pullback-comparison-fiber A B f C (b, c)) := \\ (a, p) -> idJ ( B, f a, \\ b' p' -> (c : C b') -> (pullback-comparison-fiber A B f C ((b', c))), \\ c -> ((a, c), refl ), b, p) #def pullback-comparison-fiber-to-fiber-inv ( A B : U ) ( f : A -> B) ( C : B -> U ) ( z : \u2211 ( b : B), C b) : (fib A B f ( first z)) -> (pullback-comparison-fiber A B f C z) := \\ (a, p) -> from-base-fiber-to-pullback-comparison-fiber A B f C ( first z) (a, p) ( second z) #def pullback-comparison-fiber-to-fiber-retracting-homotopy ( A B : U ) ( f : A -> B) ( C : B -> U ) ( z : \u2211 ( b : B), C b) ((w, p) : pullback-comparison-fiber A B f C z) : ( (pullback-comparison-fiber-to-fiber-inv A B f C z) ( (pullback-comparison-fiber-to-fiber A B f C z) (w, p))) = (w, p) := idJ ( (\u2211(b : B), C b), (pullback-comparison-map A B f C w), \\ z' p' -> ((pullback-comparison-fiber-to-fiber-inv A B f C z') ((pullback-comparison-fiber-to-fiber A B f C z') (w, p'))) = (w, p'), refl , z, p) #def pullback-comparison-fiber-to-fiber-section-homotopy-map ( A B : U ) ( f : A -> B) ( C : B -> U ) ( b : B) ((a, p) : fib A B f b) : ( c : C b) -> ((pullback-comparison-fiber-to-fiber A B f C (b, c)) ((pullback-comparison-fiber-to-fiber-inv A B f C (b, c)) (a, p))) = (a, p) := idJ ( B, f a, \\ b' p' -> (c : C b') -> ( (pullback-comparison-fiber-to-fiber A B f C (b', c)) ( (pullback-comparison-fiber-to-fiber-inv A B f C (b', c))(a, p'))) = ( a, p'), \\ c -> refl , b, p) #def pullback-comparison-fiber-to-fiber-section-homotopy ( A B : U ) ( f : A -> B) ( C : B -> U ) ( z : \u2211 ( b : B), C b) ((a, p) : fib A B f ( first z)) : ((pullback-comparison-fiber-to-fiber A B f C z) ((pullback-comparison-fiber-to-fiber-inv A B f C z)(a, p))) = (a, p) := pullback-comparison-fiber-to-fiber-section-homotopy-map A B f C ( first z) (a, p) ( second z) #def equiv-pullback-comparison-fiber ( A B : U ) ( f : A -> B) ( C : B -> U ) ( z : \u2211 ( b : B), C b) : Equiv (pullback-comparison-fiber A B f C z) (fib A B f ( first z)) := ( pullback-comparison-fiber-to-fiber A B f C z, ( (pullback-comparison-fiber-to-fiber-inv A B f C z, pullback-comparison-fiber-to-fiber-retracting-homotopy A B f C z), ( pullback-comparison-fiber-to-fiber-inv A B f C z, pullback-comparison-fiber-to-fiber-section-homotopy A B f C z))) As a corollary, we show that pullback along an equivalence induces an equivalence of total spaces. #def total-equiv-pullback-is-equiv ( A B : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) ( C : B -> U ) : Equiv ( \u2211(a : A), (pullback A B f C) a) ( \u2211(b : B), C b) := ( pullback-comparison-map A B f C, is-equiv-is-contr-map ( \u2211(a : A), (pullback A B f C) a) ( \u2211(b : B), C b) ( pullback-comparison-map A B f C) ( \\ z -> ( is-contr-is-equiv-to-contr ( pullback-comparison-fiber A B f C z) ( fib A B f ( first z)) ( equiv-pullback-comparison-fiber A B f C z) ( is-contr-map-is-equiv A B f fisequiv ( first z)))))","title":"Pullback of a type family"},{"location":"hott/08-families-of-maps.rzk/#fundamental-theorem-of-identity-types","text":"#section fundamental-thm-id-types #variable A : U #variable a : A #variable B : A -> U #variable f : ( x : A) -> (a = x) -> B x #def fund-id-fam-of-eqs-implies-sum-over-codomain-contr : ( (x : A) -> (is-equiv (a = x) (B x) (f x))) -> ( is-contr (\u2211(x : A), B x)) := ( \\ familyequiv -> ( equiv-with-contractible-domain-implies-contractible-codomain ( \u2211(x : A), a = x) ( \u2211(x : A), B x) ( ( total-map-family-of-maps A ( \\ x -> (a = x)) B f), ( is-equiv-has-inverse (\u2211(x : A), a = x) ( \u2211(x : A), B x) ( total-map-family-of-maps A ( \\ x -> (a = x)) B f) ( total-has-inverse-family-equiv A ( \\ x -> (a = x)) B f familyequiv))) ( is-contr-based-paths A a))) #def fund-id-sum-over-codomain-contr-implies-fam-of-eqs : ( is-contr (\u2211(x : A), B x)) -> ( (x : A) -> (is-equiv (a = x) (B x) (f x))) := ( \\ Biscontr -> ( \\ x -> ( total-equiv-family-of-equiv A ( \\ x' -> (a = x')) B f ( areContr-is-equiv (\u2211(x' : A), (a = x')) ( \u2211(x' : A), (B x')) ( is-contr-based-paths A a) Biscontr ( total-map-family-of-maps A ( \\ x' -> (a = x')) B f)) x))) -- This allows us to apply \"based path induction\" -- to a family satisfying the fundamental theorem. -- Please suggest a better name. #def ind-based-path ( familyequiv : ( z : A) -> (is-equiv (a = z) (B z) (f z))) ( P : ( z : A) -> B z -> U ) ( p0 : P a (f a refl )) ( x : A) ( p : B x) : P x p := ( ind-sing ( \u2211(x : A), B x) ( a, f a refl ) ( \\ (x', p') -> P x' p') ( contr-implies-singleton-induction-pointed ( \u2211(x : A), B x) ( fund-id-fam-of-eqs-implies-sum-over-codomain-contr familyequiv) ( \\ (x', p') -> P x' p'))) p0 (x, p) #end fundamental-thm-id-types #def emb-is-equiv ( A B : U ) ( e : A -> B) ( eisequiv : is-equiv A B e) : (Emb A B) -- For all x, y in A, ap_{e,x,y} is an equivalence := ( e, \\ x y -> ( fund-id-sum-over-codomain-contr-implies-fam-of-eqs -- By the fundamental theorem of identity types, it will suffice to show -- contractibility of sigma_{t : A} e x = e t -- for the family of maps ap_e, which is of type -- (\\t:A) -> (x = t) -> (e x = e t) A x ( \\ t -> (e x = e t)) ( \\ t -> (ap A B x t e)) -- the family of maps ap_e ( (is-contr-is-equiv-to-contr -- Contractibility of sigma_{t : A} e x = e t will follow since -- total(\\t -> rev B (e x) = (e t)), mapping from sigma_{t : A} e x = e t to -- sigma_{t : A} e t = e x -- is an equivalence, and sigma_{t : A} e t = e x ~ fib(e, e x) is -- contractible since e is an equivalence. ( \u2211(y' : A), (e x = e y')) -- source type ( \u2211(y' : A), (e y' = e x)) -- target type ((total-map-family-of-maps A ( \\ y' -> (e x) = (e y')) ( \\ y' -> (e y') = (e x)) ( \\ y' -> (rev B (e x) (e y')))), -- a) total map ( -- b) proof that total map is equivalence ( first ( total-equiv-iff-family-of-equiv A ( \\ y' -> (e x) = (e y')) ( \\ y' -> (e y') = (e x)) ( \\ y' -> (rev B (e x) (e y'))))) ( \\ y' -> (is-equiv-rev B (e x) (e y'))))) ( -- fiber of e at e(x) is contractible (is-contr-map-is-equiv A B e eisequiv) (e x)))))(y)) -- evaluate at y #def is-emb-is-equiv ( A B : U ) ( e : A -> B) ( eisequiv : is-equiv A B e) : is-emb A B e := ( second (emb-is-equiv A B e eisequiv))","title":"Fundamental theorem of identity types"},{"location":"hott/08-families-of-maps.rzk/#2-of-3-for-equivalences","text":"-- It might be better to redo this without appealing to results about -- embeddings so that this could go earlier. #def RightCancel-is-equiv ( A B C : U ) ( f : A -> B) ( g : B -> C) ( gisequiv : is-equiv B C g) ( gfisequiv : is-equiv A C (composition A B C g f)) : is-equiv A B f := ( ( composition B C A (is-equiv-retraction A C (composition A B C g f) gfisequiv) g, ( second ( first gfisequiv))), ( composition B C A (is-equiv-section A C (composition A B C g f) gfisequiv) g, \\ b -> inv-ap-is-emb B C g ( is-emb-is-equiv B C g gisequiv) ( f ((is-equiv-section A C (composition A B C g f) gfisequiv)(g b))) b ( ( second ( second gfisequiv)) (g b)))) #def LeftCancel-is-equiv ( A B C : U ) ( f : A -> B) ( fisequiv : is-equiv A B f) ( g : B -> C) ( gfisequiv : is-equiv A C (composition A B C g f)) : is-equiv B C g := ( ( composition C A B f (is-equiv-retraction A C (composition A B C g f) gfisequiv), \\ b -> triple-concat B ( f ((is-equiv-retraction A C (composition A B C g f) gfisequiv) (g b))) ( f ((is-equiv-retraction A C (composition A B C g f) gfisequiv) (g (f ((is-equiv-section A B f fisequiv) b))))) ( f ((is-equiv-section A B f fisequiv) b)) ( b) ( ap B B ( b) ( f ((is-equiv-section A B f fisequiv) b)) ( \\ b0 -> ( f ((is-equiv-retraction A C ( composition A B C g f) gfisequiv) (g b0)))) ( rev B (f ((is-equiv-section A B f fisequiv) b)) b ( ( second ( second fisequiv)) b))) ( ( homotopy-whisker B A A B ( \\ a -> ( is-equiv-retraction A C ( composition A B C g f) gfisequiv) (g (f a))) ( \\ a -> a) ( second ( first gfisequiv)) ( is-equiv-section A B f fisequiv) f) b) ( ( second ( second fisequiv)) b)), ( composition C A B ( f) ( is-equiv-section A C (composition A B C g f) gfisequiv), ( second ( second gfisequiv))))","title":"2-of-3 for equivalences"},{"location":"hott/08-families-of-maps.rzk/#maps-over-product-types","text":"For later use, we specialize the previous results to the case of a family of types over a product type. #section fibered-map-over-product #variables A A' B B' : U #variable C : A -> B -> U #variable C' : A' -> B' -> U #variable f : A -> A' #variable g : B -> B' #variable h : ( a : A) -> ( b : B) -> ( c : C a b) -> C' (f a) (g b) #def total-map-fibered-map-over-product : ( \u2211 (a : A), ( \u2211 (b : B), C a b)) -> ( \u2211 (a' : A'), ( \u2211 (b' : B'), C' a' b')) := \\ (a, (b, c)) -> (f a, (g b, h a b c)) #def pullback-is-equiv-base-is-equiv-total-is-equiv ( totalisequiv : is-equiv ( \u2211(a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a' : A'), ( \u2211 (b' : B'), C' a' b')) total-map-fibered-map-over-product) ( fisequiv : is-equiv A A' f) : is-equiv ( \u2211 (a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a : A), ( \u2211 (b' : B'), C' (f a) b')) ( \\ (a, (b, c)) -> (a, (g b, h a b c))) := RightCancel-is-equiv ( \u2211(a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a : A), ( \u2211 (b' : B'), C' (f a) b')) ( \u2211 (a' : A'), ( \u2211 (b' : B'), C' a' b')) ( \\ (a, (b, c)) -> (a, (g b, h a b c))) ( \\ (a, (b', c')) -> (f a, (b', c'))) ( second (total-equiv-pullback-is-equiv A A' f fisequiv ( \\ a' -> (\u2211 (b' : B'), C' a' b')))) ( totalisequiv) #def pullback-is-equiv-bases-are-equiv-total-is-equiv ( totalisequiv : is-equiv ( \u2211(a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a' : A'), ( \u2211 (b' : B'), C' a' b')) total-map-fibered-map-over-product) ( fisequiv : is-equiv A A' f) ( gisequiv : is-equiv B B' g) : is-equiv ( \u2211 (a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a : A), ( \u2211 (b : B), C' (f a) (g b))) ( \\(a, (b, c)) -> (a, (b, h a b c))) := RightCancel-is-equiv ( \u2211 (a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a : A), ( \u2211 (b : B), C' (f a) (g b))) ( \u2211 (a : A), ( \u2211 (b' : B'), C' (f a) b')) ( \\ (a, (b, c)) -> (a, (b, h a b c))) ( \\ (a, (b, c)) -> (a, (g b, c))) ( family-of-equiv-total-equiv A ( \\ a -> (\u2211 (b : B), C' (f a) (g b))) ( \\ a -> (\u2211 (b' : B'), C' (f a) b')) ( \\ a (b, c) -> (g b, c)) ( \\ a -> ( second ( total-equiv-pullback-is-equiv B B' g gisequiv ( \\ b' -> C' (f a) b'))))) ( pullback-is-equiv-base-is-equiv-total-is-equiv totalisequiv fisequiv) #def fibered-map-is-equiv-bases-are-equiv-total-map-is-equiv ( totalisequiv : is-equiv ( \u2211(a : A), ( \u2211 (b : B), C a b)) ( \u2211 (a' : A'), ( \u2211 (b' : B'), C' a' b')) total-map-fibered-map-over-product) ( fisequiv : is-equiv A A' f) ( gisequiv : is-equiv B B' g) ( a0 : A) ( b0 : B) : is-equiv (C a0 b0) (C' (f a0) (g b0)) (h a0 b0) := total-equiv-family-of-equiv B ( \\ b -> C a0 b) ( \\ b -> C' (f a0) (g b)) ( \\ b c -> h a0 b c) ( total-equiv-family-of-equiv A ( \\ a -> (\u2211 (b : B), C a b)) ( \\ a -> (\u2211 (b : B), C' (f a) (g b))) ( \\ a (b, c) -> (b, h a b c)) ( pullback-is-equiv-bases-are-equiv-total-is-equiv totalisequiv fisequiv gisequiv) a0) b0 #end fibered-map-over-product","title":"Maps over product types"},{"location":"hott/09-propositions.rzk/","text":"9. Propositions \u00b6 This is a literate rzk file: #lang rzk-1 Propositions \u00b6 A type is a proposition when its identity types are contractible. #def is-prop ( A : U ) : U := ( a : A) -> ( b : A) -> is-contr (a = b) #def is-prop-Unit : is-prop Unit := \\ x y -> (path-types-of-Unit-are-contractible x y) Alternative characterizations: definitions \u00b6 #def all-elements-equal ( A : U ) : U := ( a : A) -> ( b : A) -> (a = b) #def is-contr-is-inhabited ( A : U ) : U := A -> is-contr A #def is-emb-terminal-map ( A : U ) : U := is-emb A Unit (terminal-map A) Alternative characterizations: proofs \u00b6 #def all-elements-equal-is-prop ( A : U ) ( AisProp : is-prop A) : all-elements-equal A := \\ a b -> ( first (AisProp a b)) #def is-contr-is-inhabited-all-elements-equal ( A : U ) ( AhasAllEltsEqual : all-elements-equal A) : is-contr-is-inhabited A := \\ a -> (a, AhasAllEltsEqual a) #def terminal-map-is-emb-is-inhabited-is-contr-is-inhabited ( A : U ) ( c : is-contr-is-inhabited A) : A -> (is-emb-terminal-map A) := \\ x -> ( is-emb-is-equiv A Unit (terminal-map A) ( contr-implies-terminal-map-is-equiv A (c x))) #def terminal-map-is-emb-is-contr-is-inhabited ( A : U ) ( c : is-contr-is-inhabited A) : (is-emb-terminal-map A) := ( is-emb-is-inhabited-emb A Unit (terminal-map A) ( terminal-map-is-emb-is-inhabited-is-contr-is-inhabited A c)) #def is-prop-is-emb-terminal-map ( A : U ) ( f : is-emb-terminal-map A) : is-prop A := \\ x y -> ( is-contr-is-equiv-to-contr (x = y) ( unit = unit ) ( (ap A Unit x y (terminal-map A)), (f x y)) ( path-types-of-Unit-are-contractible unit unit )) #def is-prop-is-contr-is-inhabited ( A : U ) ( c : is-contr-is-inhabited A) : is-prop A := ( is-prop-is-emb-terminal-map A ( terminal-map-is-emb-is-contr-is-inhabited A c))","title":"Propositions"},{"location":"hott/09-propositions.rzk/#9-propositions","text":"This is a literate rzk file: #lang rzk-1","title":"9. Propositions"},{"location":"hott/09-propositions.rzk/#propositions","text":"A type is a proposition when its identity types are contractible. #def is-prop ( A : U ) : U := ( a : A) -> ( b : A) -> is-contr (a = b) #def is-prop-Unit : is-prop Unit := \\ x y -> (path-types-of-Unit-are-contractible x y)","title":"Propositions"},{"location":"hott/09-propositions.rzk/#alternative-characterizations-definitions","text":"#def all-elements-equal ( A : U ) : U := ( a : A) -> ( b : A) -> (a = b) #def is-contr-is-inhabited ( A : U ) : U := A -> is-contr A #def is-emb-terminal-map ( A : U ) : U := is-emb A Unit (terminal-map A)","title":"Alternative characterizations: definitions"},{"location":"hott/09-propositions.rzk/#alternative-characterizations-proofs","text":"#def all-elements-equal-is-prop ( A : U ) ( AisProp : is-prop A) : all-elements-equal A := \\ a b -> ( first (AisProp a b)) #def is-contr-is-inhabited-all-elements-equal ( A : U ) ( AhasAllEltsEqual : all-elements-equal A) : is-contr-is-inhabited A := \\ a -> (a, AhasAllEltsEqual a) #def terminal-map-is-emb-is-inhabited-is-contr-is-inhabited ( A : U ) ( c : is-contr-is-inhabited A) : A -> (is-emb-terminal-map A) := \\ x -> ( is-emb-is-equiv A Unit (terminal-map A) ( contr-implies-terminal-map-is-equiv A (c x))) #def terminal-map-is-emb-is-contr-is-inhabited ( A : U ) ( c : is-contr-is-inhabited A) : (is-emb-terminal-map A) := ( is-emb-is-inhabited-emb A Unit (terminal-map A) ( terminal-map-is-emb-is-inhabited-is-contr-is-inhabited A c)) #def is-prop-is-emb-terminal-map ( A : U ) ( f : is-emb-terminal-map A) : is-prop A := \\ x y -> ( is-contr-is-equiv-to-contr (x = y) ( unit = unit ) ( (ap A Unit x y (terminal-map A)), (f x y)) ( path-types-of-Unit-are-contractible unit unit )) #def is-prop-is-contr-is-inhabited ( A : U ) ( c : is-contr-is-inhabited A) : is-prop A := ( is-prop-is-emb-terminal-map A ( terminal-map-is-emb-is-contr-is-inhabited A c))","title":"Alternative characterizations: proofs"},{"location":"hott/10-trivial-fibrations.rzk/","text":"10. Trivial Fibrations \u00b6 This is a literate rzk file: #lang rzk-1 In what follows we show that the projection from the total space of a sigma type is an equivalence if and only if its fibers are contractible. #def total-space-projection ( A : U ) ( B : A -> U ) : ( \u2211 (x : A), B x) -> A := \\ z -> first z Contractible fibers \u00b6 The following type asserts that the fibers of a type family are contractible. #def contractible-fibers ( A : U ) ( B : A -> U ) : U := ( (x : A) -> is-contr (B x)) #section contractible-fibers-data #variable A : U #variable B : A -> U #variable ABcontrfib : contractible-fibers A B -- The center of contraction in a contractible fibers #def contractible-fibers-section : ( x : A) -> B x := \\ x -> contraction-center (B x) (ABcontrfib x) -- The section of the total space projection built from the contraction centers #def contractible-fibers-actual-section uses ( ABcontrfib ) : ( a : A) -> \u2211 ( x : A), B x := \\ a -> (a , contractible-fibers-section a) #def contractible-fibers-section-htpy uses ( ABcontrfib ) : homotopy A A ( composition A (\u2211 (x : A), B x) A ( total-space-projection A B) (contractible-fibers-actual-section)) ( identity A) := \\ x -> refl #def contractible-fibers-section-is-section uses ( ABcontrfib ) : has-section ( \u2211 (x : A), B x) A (total-space-projection A B) := ( contractible-fibers-actual-section , contractible-fibers-section-htpy) -- This can be used to define the retraction homotopy for the total space projection, called \"first\" here #def contractible-fibers-retraction-htpy : ( z : \u2211 ( x : A), B x) -> (contractible-fibers-actual-section) ( first z) = z := \\ z -> sigma-path-fibered-path A B ( first z) ( (contractible-fibers-section) ( first z)) ( second z) ( contracting-htpy (B ( first z)) (ABcontrfib ( first z)) ( second z)) #def contractible-fibers-retraction uses ( ABcontrfib ) : has-retraction ( \u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-actual-section , contractible-fibers-retraction-htpy) -- The first half of our main result: #def is-equiv-projection-contractible-fibers uses ( ABcontrfib ) : is-equiv ( \u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-retraction , contractible-fibers-section-is-section) #def equiv-projection-contractible-fibers uses ( ABcontrfib ) : Equiv ( \u2211 (x : A), B x) A := (total-space-projection A B, is-equiv-projection-contractible-fibers) #end contractible-fibers-data Projection equivalences \u00b6 -- From a projection equivalence, it's not hard to inhabit fibers #def inhabited-fibers-is-equiv-projection ( A : U ) ( B : A -> U ) ( ABprojequiv : is-equiv ( \u2211 (x : A), B x) A (total-space-projection A B)) ( a : A) : B a := transport A B ( first (( first ( second ABprojequiv)) a)) a ( ( second ( second ABprojequiv)) a) ( second (( first ( second ABprojequiv)) a)) -- This is great but we need more coherence to show that the inhabited fibers -- are contractible; the following proof fails -- #def is-equiv-projection-implies-contractible-fibers -- (A : U) -- (B : A -> U) -- (ABprojequiv : is-equiv (\u2211 (x : A), B x) A (total-space-projection A B)) -- : contractible-fibers A B -- := -- \\ x -> (second ((first (first ABprojequiv)) x) , -- \\ u -> second-path-sigma A B ((first (first ABprojequiv)) x) (x, u) -- ( (second (first ABprojequiv)) (x, u)) ) #section projection-hae-data #variable A : U #variable B : A -> U #variable ABprojHAE : is-half-adjoint-equiv ( \u2211 (x : A), B x) A (total-space-projection A B) #variable w : ( \u2211 (x : A), B x) -- We start over from a stronger hypothesis of a half adjoint equivalence #def projection-hae-inverse ( a : A) : \u2211 ( x : A), B x := ( first ( first ABprojHAE)) a #def projection-hae-base-htpy uses ( B ) ( a : A) : ( first (projection-hae-inverse a)) = a := ( second ( second ( first ABprojHAE))) a #def projection-hae-section uses ( ABprojHAE ) ( a : A) : B a := transport A B ( first (projection-hae-inverse a)) a ( projection-hae-base-htpy a) ( second (projection-hae-inverse a)) #def projection-hae-total-htpy : (projection-hae-inverse ( first w)) = w := ( first ( second ( first ABprojHAE))) w #def projection-hae-fibered-htpy : (transport A B ( first ((projection-hae-inverse ( first w)))) ( first w) ( first-path-sigma A B ( projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( second (projection-hae-inverse ( first w)))) = ( second w) := second-path-sigma A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy) #def projection-hae-base-coherence : ( projection-hae-base-htpy ( first w)) = ( first-path-sigma A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) := ( second ABprojHAE) w #def projection-hae-transport-coherence : ( projection-hae-section ( first w)) = ( transport A B ( first ((projection-hae-inverse ( first w)))) ( first w) ( first-path-sigma A B ( projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( second (projection-hae-inverse ( first w)))) := transport2 A B ( first (projection-hae-inverse ( first w))) ( first w) ( projection-hae-base-htpy ( first w)) ( first-path-sigma A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( projection-hae-base-coherence) ( second (projection-hae-inverse ( first w))) #def projection-hae-fibered-contracting-htpy : (projection-hae-section ( first w)) =_{B ( first w)} ( second w) := concat (B ( first w)) ( projection-hae-section ( first w)) ( transport A B ( first ((projection-hae-inverse ( first w)))) ( first w) ( first-path-sigma A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( second (projection-hae-inverse ( first w)))) ( second w) ( projection-hae-transport-coherence) ( projection-hae-fibered-htpy) #end projection-hae-data -- Finally we have #def contractible-fibers-is-half-adjoint-equiv-projection ( A : U ) ( B : A -> U ) ( ABprojHAE : is-half-adjoint-equiv ( \u2211 (x : A), B x) A (total-space-projection A B)) : contractible-fibers A B := \\ x -> ( (projection-hae-section A B ABprojHAE x), \\ u -> (projection-hae-fibered-contracting-htpy A B ABprojHAE (x, u))) -- The converse to our first result #def contractible-fibers-is-equiv-projection ( A : U ) ( B : A -> U ) ( ABprojequiv : is-equiv ( \u2211 (x : A), B x) A (total-space-projection A B)) : contractible-fibers A B := contractible-fibers-is-half-adjoint-equiv-projection A B ( is-half-adjoint-equiv-is-equiv (\u2211 (x : A), B x) A ( total-space-projection A B) ABprojequiv) -- The main theorem #def projection-theorem ( A : U ) ( B : ( a : A) -> U ) : iff ( is-equiv (\u2211 (x : A), B x) A (total-space-projection A B)) ( contractible-fibers A B) := ( \\ ABprojequiv -> contractible-fibers-is-equiv-projection A B ABprojequiv, \\ ABcontrfib -> is-equiv-projection-contractible-fibers A B ABcontrfib)","title":"Trivial fibrations"},{"location":"hott/10-trivial-fibrations.rzk/#10-trivial-fibrations","text":"This is a literate rzk file: #lang rzk-1 In what follows we show that the projection from the total space of a sigma type is an equivalence if and only if its fibers are contractible. #def total-space-projection ( A : U ) ( B : A -> U ) : ( \u2211 (x : A), B x) -> A := \\ z -> first z","title":"10. Trivial Fibrations"},{"location":"hott/10-trivial-fibrations.rzk/#contractible-fibers","text":"The following type asserts that the fibers of a type family are contractible. #def contractible-fibers ( A : U ) ( B : A -> U ) : U := ( (x : A) -> is-contr (B x)) #section contractible-fibers-data #variable A : U #variable B : A -> U #variable ABcontrfib : contractible-fibers A B -- The center of contraction in a contractible fibers #def contractible-fibers-section : ( x : A) -> B x := \\ x -> contraction-center (B x) (ABcontrfib x) -- The section of the total space projection built from the contraction centers #def contractible-fibers-actual-section uses ( ABcontrfib ) : ( a : A) -> \u2211 ( x : A), B x := \\ a -> (a , contractible-fibers-section a) #def contractible-fibers-section-htpy uses ( ABcontrfib ) : homotopy A A ( composition A (\u2211 (x : A), B x) A ( total-space-projection A B) (contractible-fibers-actual-section)) ( identity A) := \\ x -> refl #def contractible-fibers-section-is-section uses ( ABcontrfib ) : has-section ( \u2211 (x : A), B x) A (total-space-projection A B) := ( contractible-fibers-actual-section , contractible-fibers-section-htpy) -- This can be used to define the retraction homotopy for the total space projection, called \"first\" here #def contractible-fibers-retraction-htpy : ( z : \u2211 ( x : A), B x) -> (contractible-fibers-actual-section) ( first z) = z := \\ z -> sigma-path-fibered-path A B ( first z) ( (contractible-fibers-section) ( first z)) ( second z) ( contracting-htpy (B ( first z)) (ABcontrfib ( first z)) ( second z)) #def contractible-fibers-retraction uses ( ABcontrfib ) : has-retraction ( \u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-actual-section , contractible-fibers-retraction-htpy) -- The first half of our main result: #def is-equiv-projection-contractible-fibers uses ( ABcontrfib ) : is-equiv ( \u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-retraction , contractible-fibers-section-is-section) #def equiv-projection-contractible-fibers uses ( ABcontrfib ) : Equiv ( \u2211 (x : A), B x) A := (total-space-projection A B, is-equiv-projection-contractible-fibers) #end contractible-fibers-data","title":"Contractible fibers"},{"location":"hott/10-trivial-fibrations.rzk/#projection-equivalences","text":"-- From a projection equivalence, it's not hard to inhabit fibers #def inhabited-fibers-is-equiv-projection ( A : U ) ( B : A -> U ) ( ABprojequiv : is-equiv ( \u2211 (x : A), B x) A (total-space-projection A B)) ( a : A) : B a := transport A B ( first (( first ( second ABprojequiv)) a)) a ( ( second ( second ABprojequiv)) a) ( second (( first ( second ABprojequiv)) a)) -- This is great but we need more coherence to show that the inhabited fibers -- are contractible; the following proof fails -- #def is-equiv-projection-implies-contractible-fibers -- (A : U) -- (B : A -> U) -- (ABprojequiv : is-equiv (\u2211 (x : A), B x) A (total-space-projection A B)) -- : contractible-fibers A B -- := -- \\ x -> (second ((first (first ABprojequiv)) x) , -- \\ u -> second-path-sigma A B ((first (first ABprojequiv)) x) (x, u) -- ( (second (first ABprojequiv)) (x, u)) ) #section projection-hae-data #variable A : U #variable B : A -> U #variable ABprojHAE : is-half-adjoint-equiv ( \u2211 (x : A), B x) A (total-space-projection A B) #variable w : ( \u2211 (x : A), B x) -- We start over from a stronger hypothesis of a half adjoint equivalence #def projection-hae-inverse ( a : A) : \u2211 ( x : A), B x := ( first ( first ABprojHAE)) a #def projection-hae-base-htpy uses ( B ) ( a : A) : ( first (projection-hae-inverse a)) = a := ( second ( second ( first ABprojHAE))) a #def projection-hae-section uses ( ABprojHAE ) ( a : A) : B a := transport A B ( first (projection-hae-inverse a)) a ( projection-hae-base-htpy a) ( second (projection-hae-inverse a)) #def projection-hae-total-htpy : (projection-hae-inverse ( first w)) = w := ( first ( second ( first ABprojHAE))) w #def projection-hae-fibered-htpy : (transport A B ( first ((projection-hae-inverse ( first w)))) ( first w) ( first-path-sigma A B ( projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( second (projection-hae-inverse ( first w)))) = ( second w) := second-path-sigma A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy) #def projection-hae-base-coherence : ( projection-hae-base-htpy ( first w)) = ( first-path-sigma A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) := ( second ABprojHAE) w #def projection-hae-transport-coherence : ( projection-hae-section ( first w)) = ( transport A B ( first ((projection-hae-inverse ( first w)))) ( first w) ( first-path-sigma A B ( projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( second (projection-hae-inverse ( first w)))) := transport2 A B ( first (projection-hae-inverse ( first w))) ( first w) ( projection-hae-base-htpy ( first w)) ( first-path-sigma A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( projection-hae-base-coherence) ( second (projection-hae-inverse ( first w))) #def projection-hae-fibered-contracting-htpy : (projection-hae-section ( first w)) =_{B ( first w)} ( second w) := concat (B ( first w)) ( projection-hae-section ( first w)) ( transport A B ( first ((projection-hae-inverse ( first w)))) ( first w) ( first-path-sigma A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( second (projection-hae-inverse ( first w)))) ( second w) ( projection-hae-transport-coherence) ( projection-hae-fibered-htpy) #end projection-hae-data -- Finally we have #def contractible-fibers-is-half-adjoint-equiv-projection ( A : U ) ( B : A -> U ) ( ABprojHAE : is-half-adjoint-equiv ( \u2211 (x : A), B x) A (total-space-projection A B)) : contractible-fibers A B := \\ x -> ( (projection-hae-section A B ABprojHAE x), \\ u -> (projection-hae-fibered-contracting-htpy A B ABprojHAE (x, u))) -- The converse to our first result #def contractible-fibers-is-equiv-projection ( A : U ) ( B : A -> U ) ( ABprojequiv : is-equiv ( \u2211 (x : A), B x) A (total-space-projection A B)) : contractible-fibers A B := contractible-fibers-is-half-adjoint-equiv-projection A B ( is-half-adjoint-equiv-is-equiv (\u2211 (x : A), B x) A ( total-space-projection A B) ABprojequiv) -- The main theorem #def projection-theorem ( A : U ) ( B : ( a : A) -> U ) : iff ( is-equiv (\u2211 (x : A), B x) A (total-space-projection A B)) ( contractible-fibers A B) := ( \\ ABprojequiv -> contractible-fibers-is-equiv-projection A B ABprojequiv, \\ ABcontrfib -> is-equiv-projection-contractible-fibers A B ABcontrfib)","title":"Projection equivalences"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/","text":"3. Simplicial Type Theory \u00b6 These formalisations correspond in part to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1 Simplices and their subshapes \u00b6 Simplices \u00b6 -- the 1-simplex #def \u0394\u00b9 : 2 -> TOPE := \\ t -> TOP -- the 2-simplex #def \u0394\u00b2 : ( 2 * 2 ) -> TOPE := \\ (t, s) -> s <= t -- the 3-simplex #def \u0394\u00b3 : ( 2 * 2 * 2 ) -> TOPE := \\ ((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 Boundaries of simplices \u00b6 -- the boundary of a 1-simplex #def \u2202\u0394\u00b9 : \u0394\u00b9 -> TOPE := \\ t -> (t === 0_2 \\/ t === 1_2 ) -- the boundary of a 2-simplex #def \u2202\u0394\u00b2 : \u0394\u00b2 -> TOPE := \\ ts -> (( second ts) === 0_2 \\/ ( first ts) === 1_2 \\/ ( second ts) === ( first ts)) Horns \u00b6 -- the (2,1)-horn #def \u039b : ( 2 * 2 ) -> TOPE := \\ (t, s) -> (s === 0_2 \\/ t === 1_2 ) products \u00b6 The product of topes defines the product of shapes. #def shapeprod ( I J : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03c7 : J -> TOPE ) : (I * J) -> TOPE := \\ (t, s) -> \u03c8 t /\\ \u03c7 s -- the square as a product #def \u0394\u00b9\u00d7\u0394\u00b9 : ( 2 * 2 ) -> TOPE := shapeprod 2 2 \u0394\u00b9 \u0394\u00b9 -- the total boundary of the square #def \u2202\u25a1 : ( 2 * 2 ) -> TOPE := \\ (t ,s) -> ((\u2202\u0394\u00b9 t) /\\ (\u0394\u00b9 s)) \\/ ((\u0394\u00b9 t) /\\ (\u2202\u0394\u00b9 s)) -- the vertical boundary of the square #def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : ( 2 * 2 ) -> TOPE := shapeprod 2 2 \u2202\u0394\u00b9 \u0394\u00b9 -- the horizontal boundary of the square #def \u0394\u00b9\u00d7\u2202\u0394\u00b9 : ( 2 * 2 ) -> TOPE := shapeprod 2 2 \u0394\u00b9 \u2202\u0394\u00b9 -- the prism from a 2-simplex in an arrow type #def \u0394\u00b2\u00d7\u0394\u00b9 : ( 2 * 2 * 2 ) -> TOPE := shapeprod ( 2 * 2 ) 2 \u0394\u00b2 \u0394\u00b9 Intersections \u00b6 The intersection of shapes is defined by conjunction on topes: #def shapeIntersection ( I : CUBE ) ( \u03c8 \u03c7 : I -> TOPE ) : I -> TOPE := \\ t -> \u03c8 t /\\ \u03c7 t Unions \u00b6 The union of shapes is defined by disjunction on topes: #def shapeUnion ( I : CUBE ) ( \u03c8 \u03c7 : I -> TOPE ) : I -> TOPE := \\ t -> \u03c8 t \\/ \u03c7 t","title":"Simplicial Type Theory"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#3-simplicial-type-theory","text":"These formalisations correspond in part to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"3. Simplicial Type Theory"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#simplices-and-their-subshapes","text":"","title":"Simplices and their subshapes"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#simplices","text":"-- the 1-simplex #def \u0394\u00b9 : 2 -> TOPE := \\ t -> TOP -- the 2-simplex #def \u0394\u00b2 : ( 2 * 2 ) -> TOPE := \\ (t, s) -> s <= t -- the 3-simplex #def \u0394\u00b3 : ( 2 * 2 * 2 ) -> TOPE := \\ ((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1","title":"Simplices"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#boundaries-of-simplices","text":"-- the boundary of a 1-simplex #def \u2202\u0394\u00b9 : \u0394\u00b9 -> TOPE := \\ t -> (t === 0_2 \\/ t === 1_2 ) -- the boundary of a 2-simplex #def \u2202\u0394\u00b2 : \u0394\u00b2 -> TOPE := \\ ts -> (( second ts) === 0_2 \\/ ( first ts) === 1_2 \\/ ( second ts) === ( first ts))","title":"Boundaries of simplices"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#horns","text":"-- the (2,1)-horn #def \u039b : ( 2 * 2 ) -> TOPE := \\ (t, s) -> (s === 0_2 \\/ t === 1_2 )","title":"Horns"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#products","text":"The product of topes defines the product of shapes. #def shapeprod ( I J : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03c7 : J -> TOPE ) : (I * J) -> TOPE := \\ (t, s) -> \u03c8 t /\\ \u03c7 s -- the square as a product #def \u0394\u00b9\u00d7\u0394\u00b9 : ( 2 * 2 ) -> TOPE := shapeprod 2 2 \u0394\u00b9 \u0394\u00b9 -- the total boundary of the square #def \u2202\u25a1 : ( 2 * 2 ) -> TOPE := \\ (t ,s) -> ((\u2202\u0394\u00b9 t) /\\ (\u0394\u00b9 s)) \\/ ((\u0394\u00b9 t) /\\ (\u2202\u0394\u00b9 s)) -- the vertical boundary of the square #def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : ( 2 * 2 ) -> TOPE := shapeprod 2 2 \u2202\u0394\u00b9 \u0394\u00b9 -- the horizontal boundary of the square #def \u0394\u00b9\u00d7\u2202\u0394\u00b9 : ( 2 * 2 ) -> TOPE := shapeprod 2 2 \u0394\u00b9 \u2202\u0394\u00b9 -- the prism from a 2-simplex in an arrow type #def \u0394\u00b2\u00d7\u0394\u00b9 : ( 2 * 2 * 2 ) -> TOPE := shapeprod ( 2 * 2 ) 2 \u0394\u00b2 \u0394\u00b9","title":"products"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#intersections","text":"The intersection of shapes is defined by conjunction on topes: #def shapeIntersection ( I : CUBE ) ( \u03c8 \u03c7 : I -> TOPE ) : I -> TOPE := \\ t -> \u03c8 t /\\ \u03c7 t","title":"Intersections"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#unions","text":"The union of shapes is defined by disjunction on topes: #def shapeUnion ( I : CUBE ) ( \u03c8 \u03c7 : I -> TOPE ) : I -> TOPE := \\ t -> \u03c8 t \\/ \u03c7 t","title":"Unions"},{"location":"simplicial-hott/04-extension-types.rzk/","text":"4. Equivalences involving extension types \u00b6 These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 hott/4-equivalences.rzk \u2014 contains the definitions of Eq and comp-equiv the file hott/4-equivalences.rzk relies in turn on the previous files in hott/ Commutation of arguments and currying \u00b6 -- [RS17, Theorem 4.1] #def flip-ext-fun ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( X : U ) ( Y : \u03c8 -> X -> U ) ( f : ( t : \u03d5) -> ( x : X) -> Y t x) : Equiv (<{t : I | \u03c8 t} -> ( (x : X) -> Y t x) [ \u03d5 t |-> f t ]>) ( (x : X) -> <{t : I | \u03c8 t} -> Y t x [ \u03d5 t |-> f t x]>) := ( \\ g x t -> g t x, -- the one-way map (( \\ h t x -> (h x) t, -- the retraction \\ g -> refl ), -- the retracting homotopy ( \\ h t x -> (h x) t, -- the section \\ h -> refl ))) -- the section homotopy #def flip-ext-fun-inv ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( X : U ) ( Y : \u03c8 -> X -> U ) ( f : ( t : \u03d5) -> ( x : X) -> Y t x) : Equiv ( (x : X) -> <{t : I | \u03c8 t} -> Y t x [ \u03d5 t |-> f t x]>) (<{t : I | \u03c8 t} -> ( (x : X) -> Y t x) [ \u03d5 t |-> f t ]>) := ( \\ h t x -> (h x) t, -- the one-way map (( \\ g x t -> g t x, -- the retraction \\ h -> refl ), -- the retracting homotopy ( \\ g x t -> g t x, -- the section \\ g -> refl ))) -- [RS17, Theorem 4.2] #def curry-uncurry ( I J : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( \u03b6 : J -> TOPE ) ( \u03c7 : \u03b6 -> TOPE ) ( X : \u03c8 -> \u03b6 -> U ) ( f : <{(t, s) : I * J | (\u03d5 t /\\ \u03b6 s) \\/ (\u03c8 t /\\ \u03c7 s)} -> X t s >) : Equiv (<{t : I | \u03c8 t} -> <{ s : J | \u03b6 s} -> X t s [ \u03c7 s |-> f (t, s) ]> [ \u03d5 t |-> \\{s : J | \u03b6 s} -> f (t, s) ]>) (<{(t, s) : I * J | \u03c8 t /\\ \u03b6 s} -> X t s [(\u03d5 t /\\ \u03b6 s) \\/ (\u03c8 t /\\ \u03c7 s) |-> f (t , s)]>) := ( \\ g (t, s) -> (g t) s, -- the one way map (( \\ h t s -> h (t , s) -- its retraction , \\ g -> refl ), -- the retracting homotopy ( \\ h t s -> h (t , s) -- its section , \\ h -> refl ))) -- the section homotopy #def uncurry-opcurry ( I J : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( \u03b6 : J -> TOPE ) ( \u03c7 : \u03b6 -> TOPE ) ( X : \u03c8 -> \u03b6 -> U ) ( f : <{(t, s) : I * J | (\u03d5 t /\\ \u03b6 s) \\/ (\u03c8 t /\\ \u03c7 s)} -> X t s >) : Equiv (<{(t, s) : I * J | \u03c8 t /\\ \u03b6 s} -> X t s [(\u03d5 t /\\ \u03b6 s) \\/ (\u03c8 t /\\ \u03c7 s) |-> f (t , s)]>) (<{s : J | \u03b6 s} -> <{ t : I | \u03c8 t} -> X t s [ \u03d5 t |-> f (t, s) ]> [ \u03c7 s |-> \\{t : I | \u03c8 t} -> f (t, s) ]>) := ( \\ h s t -> h (t , s) , -- the one way map (( \\ g (t, s) -> (g s) t -- its retraction , \\ h -> refl ), -- the retracting homotopy ( \\ g (t, s) -> (g s) t -- its section , \\ g -> refl ))) -- the section homotopy #def fubini ( I J : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( \u03b6 : J -> TOPE ) ( \u03c7 : \u03b6 -> TOPE ) ( X : \u03c8 -> \u03b6 -> U ) ( f : <{(t, s) : I * J | (\u03d5 t /\\ \u03b6 s) \\/ (\u03c8 t /\\ \u03c7 s)} -> X t s >) : Equiv (<{t : I | \u03c8 t} -> <{ s : J | \u03b6 s} -> X t s [ \u03c7 s |-> f (t, s) ]> [ \u03d5 t |-> \\{s : J | \u03b6 s} -> f (t, s) ]>) (<{s : J | \u03b6 s} -> <{ t : I | \u03c8 t} -> X t s [ \u03d5 t |-> f (t, s) ]> [ \u03c7 s |-> \\{t : I | \u03c8 t} -> f (t, s) ]>) := comp-equiv (<{t : I | \u03c8 t} -> <{ s : J | \u03b6 s} -> X t s [ \u03c7 s |-> f (t, s) ]> [ \u03d5 t |-> \\{s : J | \u03b6 s} -> f (t, s) ]>) (<{(t, s) : I * J | \u03c8 t /\\ \u03b6 s} -> X t s [(\u03d5 t /\\ \u03b6 s) \\/ (\u03c8 t /\\ \u03c7 s) |-> f (t , s)]>) (<{s : J | \u03b6 s} -> <{ t : I | \u03c8 t} -> X t s [ \u03d5 t |-> f (t, s) ]> [ \u03c7 s |-> \\{t : I | \u03c8 t} -> f (t, s) ]>) (curry-uncurry I J \u03c8 \u03d5 \u03b6 \u03c7 X f) (uncurry-opcurry I J \u03c8 \u03d5 \u03b6 \u03c7 X f) Extending into \u2211-types (the non-axiom of choice) \u00b6 -- [RS17, Theorem 4.3] #def axiom-choice ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( X : \u03c8 -> U ) ( Y : ( t : \u03c8) -> ( x : X t) -> U ) ( a : ( t : \u03d5) -> X t) ( b : ( t : \u03d5) -> Y t (a t)) : Equiv (<{t : I | \u03c8 t} -> ( \u2211 (x : X t), Y t x) [ \u03d5 t |-> (a t , b t) ]>) ( \u2211 (f : (<{t : I | \u03c8 t} -> X t [\u03d5 t |-> a t ]>)), (<{t : I | \u03c8 t} -> Y t (f t) [ \u03d5 t |-> b t ]>)) := ( \\ g -> ( \\ t -> ( first (g t)), \\ t -> second (g t)) , -- the one way map (( \\ h t -> (( first h) t, ( second h) t) -- its retraction , \\ g -> refl ), -- the retracting homotopy ( \\ h t -> (( first h) t, ( second h) t) -- its section , \\ h -> refl ))) -- the section homotopy Composites and unions of cofibrations \u00b6 -- [RS17, Theorem 4.4] -- Reformulated via tope disjunction instead of inclusion. -- See https://github.com/fizruk/rzk/issues/8 #def cofibration-composition' ( I : CUBE ) ( \u03c7 \u03c8 \u03d5 : I -> TOPE ) ( X : \u03c7 -> U ) ( a : <{t : I | \u03c7 t /\\ \u03c8 t /\\ \u03d5 t} -> X t >) : Equiv <{t : I | \u03c7 t} -> X t [ \u03c7 t /\\ \u03c8 t /\\ \u03d5 t |-> a t ]> ( \u2211 (f : <{t : I | \u03c7 t /\\ \u03c8 t} -> X t [ \u03c7 t /\\ \u03c8 t /\\ \u03d5 t |-> a t ]>), <{t : I | \u03c7 t} -> X t [ \u03c7 t /\\ \u03c8 t |-> f t ]>) := ( \\ h -> ( \\ t -> h t, \\ t -> h t), (( \\ fg t -> ( second fg) t, \\ h -> refl ), (( \\ fg t -> ( second fg) t, \\ h -> refl )))) -- [RS17, Theorem 4.4] -- original form #def cofibration-composition ( I : CUBE ) ( \u03c7 : I -> TOPE ) ( \u03c8 : \u03c7 -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( X : \u03c7 -> U ) ( a : ( t : \u03d5) -> X t) : Equiv <{t : I | \u03c7 t} -> X t [ \u03d5 t |-> a t ]> ( \u2211 (f : <{t : I | \u03c8 t} -> X t [ \u03d5 t |-> a t ]>), <{t : I | \u03c7 t} -> X t [ \u03c8 t |-> f t ]>) := ( \\ h -> ( \\ t -> h t, \\ t -> h t), (( \\ fg t -> ( second fg) t, \\ h -> refl ), (( \\ fg t -> ( second fg) t, \\ h -> refl )))) -- [RS17, Theorem 4.5] #def cofibration_union ( I : CUBE ) ( \u03d5 \u03c8 : I -> TOPE ) ( X : <{t : I | \u03d5 t \\/ \u03c8 t} -> U >) ( a : ( t : \u03c8) -> X t) : Equiv <{t : I | \u03d5 t \\/ \u03c8 t} -> X t [ \u03c8 t |-> a t ]> <{t : I | \u03d5 t} -> X t [ \u03d5 t /\\ \u03c8 t |-> a t ]> := ( \\ h -> \\ t -> h t, (( \\ g -> \\ t -> recOR (\u03d5 t |-> g t, \u03c8 t |-> a t), \\ h -> refl ), ( \\ g -> \\ t -> recOR (\u03d5 t |-> g t, \u03c8 t |-> a t), \\ h -> refl ))) Relative function extensionality \u00b6 There are various equivalent forms of the relative function extensionality axiom. Here we state the one that will be most useful and derive an application. #def ext-htpy-eq ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( A : \u03c8 -> U ) ( a : ( t : \u03d5) -> A t) ( f g : <{t : I | \u03c8 t} -> A t [ \u03d5 t |-> a t ]>) ( p : f = g) : <{t : I | \u03c8 t} -> (f t = g t) [ \u03d5 t |-> refl ]> := idJ (<{t : I | \u03c8 t} -> A t [ \u03d5 t |-> a t ]>, f, \\ g' p' -> <{t : I | \u03c8 t} -> (f t = g' t) [ \u03d5 t |-> refl ]>, \\ t -> refl , g, p) -- [RS17, Proposition 4.8(ii)] -- as suggested by footnote 8, we assert this as an \"extension extensionality\" axiom -- The type that encodes the extension extensionality axiom. #def ExtExt : U := ( I : CUBE ) -> ( \u03c8 : I -> TOPE ) -> ( \u03d5 : \u03c8 -> TOPE ) -> ( A : \u03c8 -> U ) -> ( a : ( t : \u03d5) -> A t) -> ( f : <{t : I | \u03c8 t} -> A t [ \u03d5 t |-> a t ]>) -> ( g : <{t : I | \u03c8 t} -> A t [ \u03d5 t |-> a t ]>) -> is-equiv (f = g) (<{t : I | \u03c8 t} -> (f t = g t) [ \u03d5 t |-> refl ]>) (ext-htpy-eq I \u03c8 \u03d5 A a f g) -- The equivalence provided by extension extensionality. #def ExtExtEquiv ( extext : ExtExt) ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( A : \u03c8 -> U ) ( a : ( t : \u03d5) -> A t) ( f g : <{t : I | \u03c8 t} -> A t [ \u03d5 t |-> a t ]>) : Equiv (f = g) (<{t : I | \u03c8 t} -> (f t = g t) [ \u03d5 t |-> refl ]>) := (ext-htpy-eq I \u03c8 \u03d5 A a f g , extext I \u03c8 \u03d5 A a f g) -- In particular, extension extensionality implies that homotopies give rise to identifications. This definition defines eq-ext-htpy to be the retraction to ext-htpy-eq. #def eq-ext-htpy ( extext : ExtExt) ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( A : \u03c8 -> U ) ( a : ( t : \u03d5) -> A t) ( f g : <{t : I | \u03c8 t} -> A t [ \u03d5 t |-> a t ]>) : (<{t : I | \u03c8 t} -> (f t = g t) [ \u03d5 t |-> refl ]>) -> (f = g) := first ( first (extext I \u03c8 \u03d5 A a f g)) By extension extensionality, fiberwise equivalences of extension types define equivalences of extension types. -- A fiberwise equivalence defines an equivalence of extension types, for simplicity extending from BOT #def fibered-Eq-extension-Equiv ( extext : ExtExt) ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( A B : \u03c8 -> U ) ( fibequiv : ( t : \u03c8) -> (Equiv (A t) (B t)) ) : Equiv (<{t : I | \u03c8 t } -> A t >) (<{t : I | \u03c8 t } -> B t >) := (( \\ a t -> ( first (fibequiv t)) (a t)), ((( \\ b t -> ( first ( first ( second (fibequiv t)))) (b t)), \\ a -> eq-ext-htpy extext I \u03c8 ( \\ t -> BOT ) A ( \\ u -> recBOT ) ( \\ t -> ( first ( first ( second (fibequiv t)))) (( first (fibequiv t)) (a t))) a ( \\ t -> ( second ( first ( second (fibequiv t)))) (a t))), (( \\ b t -> ( first ( second ( second (fibequiv t)))) (b t)), ( \\ b -> eq-ext-htpy extext I \u03c8 ( \\ t -> BOT ) B ( \\ u -> recBOT ) ( \\ t -> ( first (fibequiv t)) (( first ( second ( second (fibequiv t)))) (b t))) b ( \\ t -> ( second ( second ( second (fibequiv t)))) (b t))))))","title":"Extension Types"},{"location":"simplicial-hott/04-extension-types.rzk/#4-equivalences-involving-extension-types","text":"These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"4. Equivalences involving extension types"},{"location":"simplicial-hott/04-extension-types.rzk/#prerequisites","text":"hott/4-equivalences.rzk \u2014 contains the definitions of Eq and comp-equiv the file hott/4-equivalences.rzk relies in turn on the previous files in hott/","title":"Prerequisites"},{"location":"simplicial-hott/04-extension-types.rzk/#commutation-of-arguments-and-currying","text":"-- [RS17, Theorem 4.1] #def flip-ext-fun ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( X : U ) ( Y : \u03c8 -> X -> U ) ( f : ( t : \u03d5) -> ( x : X) -> Y t x) : Equiv (<{t : I | \u03c8 t} -> ( (x : X) -> Y t x) [ \u03d5 t |-> f t ]>) ( (x : X) -> <{t : I | \u03c8 t} -> Y t x [ \u03d5 t |-> f t x]>) := ( \\ g x t -> g t x, -- the one-way map (( \\ h t x -> (h x) t, -- the retraction \\ g -> refl ), -- the retracting homotopy ( \\ h t x -> (h x) t, -- the section \\ h -> refl ))) -- the section homotopy #def flip-ext-fun-inv ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( X : U ) ( Y : \u03c8 -> X -> U ) ( f : ( t : \u03d5) -> ( x : X) -> Y t x) : Equiv ( (x : X) -> <{t : I | \u03c8 t} -> Y t x [ \u03d5 t |-> f t x]>) (<{t : I | \u03c8 t} -> ( (x : X) -> Y t x) [ \u03d5 t |-> f t ]>) := ( \\ h t x -> (h x) t, -- the one-way map (( \\ g x t -> g t x, -- the retraction \\ h -> refl ), -- the retracting homotopy ( \\ g x t -> g t x, -- the section \\ g -> refl ))) -- [RS17, Theorem 4.2] #def curry-uncurry ( I J : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( \u03b6 : J -> TOPE ) ( \u03c7 : \u03b6 -> TOPE ) ( X : \u03c8 -> \u03b6 -> U ) ( f : <{(t, s) : I * J | (\u03d5 t /\\ \u03b6 s) \\/ (\u03c8 t /\\ \u03c7 s)} -> X t s >) : Equiv (<{t : I | \u03c8 t} -> <{ s : J | \u03b6 s} -> X t s [ \u03c7 s |-> f (t, s) ]> [ \u03d5 t |-> \\{s : J | \u03b6 s} -> f (t, s) ]>) (<{(t, s) : I * J | \u03c8 t /\\ \u03b6 s} -> X t s [(\u03d5 t /\\ \u03b6 s) \\/ (\u03c8 t /\\ \u03c7 s) |-> f (t , s)]>) := ( \\ g (t, s) -> (g t) s, -- the one way map (( \\ h t s -> h (t , s) -- its retraction , \\ g -> refl ), -- the retracting homotopy ( \\ h t s -> h (t , s) -- its section , \\ h -> refl ))) -- the section homotopy #def uncurry-opcurry ( I J : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( \u03b6 : J -> TOPE ) ( \u03c7 : \u03b6 -> TOPE ) ( X : \u03c8 -> \u03b6 -> U ) ( f : <{(t, s) : I * J | (\u03d5 t /\\ \u03b6 s) \\/ (\u03c8 t /\\ \u03c7 s)} -> X t s >) : Equiv (<{(t, s) : I * J | \u03c8 t /\\ \u03b6 s} -> X t s [(\u03d5 t /\\ \u03b6 s) \\/ (\u03c8 t /\\ \u03c7 s) |-> f (t , s)]>) (<{s : J | \u03b6 s} -> <{ t : I | \u03c8 t} -> X t s [ \u03d5 t |-> f (t, s) ]> [ \u03c7 s |-> \\{t : I | \u03c8 t} -> f (t, s) ]>) := ( \\ h s t -> h (t , s) , -- the one way map (( \\ g (t, s) -> (g s) t -- its retraction , \\ h -> refl ), -- the retracting homotopy ( \\ g (t, s) -> (g s) t -- its section , \\ g -> refl ))) -- the section homotopy #def fubini ( I J : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( \u03b6 : J -> TOPE ) ( \u03c7 : \u03b6 -> TOPE ) ( X : \u03c8 -> \u03b6 -> U ) ( f : <{(t, s) : I * J | (\u03d5 t /\\ \u03b6 s) \\/ (\u03c8 t /\\ \u03c7 s)} -> X t s >) : Equiv (<{t : I | \u03c8 t} -> <{ s : J | \u03b6 s} -> X t s [ \u03c7 s |-> f (t, s) ]> [ \u03d5 t |-> \\{s : J | \u03b6 s} -> f (t, s) ]>) (<{s : J | \u03b6 s} -> <{ t : I | \u03c8 t} -> X t s [ \u03d5 t |-> f (t, s) ]> [ \u03c7 s |-> \\{t : I | \u03c8 t} -> f (t, s) ]>) := comp-equiv (<{t : I | \u03c8 t} -> <{ s : J | \u03b6 s} -> X t s [ \u03c7 s |-> f (t, s) ]> [ \u03d5 t |-> \\{s : J | \u03b6 s} -> f (t, s) ]>) (<{(t, s) : I * J | \u03c8 t /\\ \u03b6 s} -> X t s [(\u03d5 t /\\ \u03b6 s) \\/ (\u03c8 t /\\ \u03c7 s) |-> f (t , s)]>) (<{s : J | \u03b6 s} -> <{ t : I | \u03c8 t} -> X t s [ \u03d5 t |-> f (t, s) ]> [ \u03c7 s |-> \\{t : I | \u03c8 t} -> f (t, s) ]>) (curry-uncurry I J \u03c8 \u03d5 \u03b6 \u03c7 X f) (uncurry-opcurry I J \u03c8 \u03d5 \u03b6 \u03c7 X f)","title":"Commutation of arguments and currying"},{"location":"simplicial-hott/04-extension-types.rzk/#extending-into-types-the-non-axiom-of-choice","text":"-- [RS17, Theorem 4.3] #def axiom-choice ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( X : \u03c8 -> U ) ( Y : ( t : \u03c8) -> ( x : X t) -> U ) ( a : ( t : \u03d5) -> X t) ( b : ( t : \u03d5) -> Y t (a t)) : Equiv (<{t : I | \u03c8 t} -> ( \u2211 (x : X t), Y t x) [ \u03d5 t |-> (a t , b t) ]>) ( \u2211 (f : (<{t : I | \u03c8 t} -> X t [\u03d5 t |-> a t ]>)), (<{t : I | \u03c8 t} -> Y t (f t) [ \u03d5 t |-> b t ]>)) := ( \\ g -> ( \\ t -> ( first (g t)), \\ t -> second (g t)) , -- the one way map (( \\ h t -> (( first h) t, ( second h) t) -- its retraction , \\ g -> refl ), -- the retracting homotopy ( \\ h t -> (( first h) t, ( second h) t) -- its section , \\ h -> refl ))) -- the section homotopy","title":"Extending into \u2211-types (the non-axiom of choice)"},{"location":"simplicial-hott/04-extension-types.rzk/#composites-and-unions-of-cofibrations","text":"-- [RS17, Theorem 4.4] -- Reformulated via tope disjunction instead of inclusion. -- See https://github.com/fizruk/rzk/issues/8 #def cofibration-composition' ( I : CUBE ) ( \u03c7 \u03c8 \u03d5 : I -> TOPE ) ( X : \u03c7 -> U ) ( a : <{t : I | \u03c7 t /\\ \u03c8 t /\\ \u03d5 t} -> X t >) : Equiv <{t : I | \u03c7 t} -> X t [ \u03c7 t /\\ \u03c8 t /\\ \u03d5 t |-> a t ]> ( \u2211 (f : <{t : I | \u03c7 t /\\ \u03c8 t} -> X t [ \u03c7 t /\\ \u03c8 t /\\ \u03d5 t |-> a t ]>), <{t : I | \u03c7 t} -> X t [ \u03c7 t /\\ \u03c8 t |-> f t ]>) := ( \\ h -> ( \\ t -> h t, \\ t -> h t), (( \\ fg t -> ( second fg) t, \\ h -> refl ), (( \\ fg t -> ( second fg) t, \\ h -> refl )))) -- [RS17, Theorem 4.4] -- original form #def cofibration-composition ( I : CUBE ) ( \u03c7 : I -> TOPE ) ( \u03c8 : \u03c7 -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( X : \u03c7 -> U ) ( a : ( t : \u03d5) -> X t) : Equiv <{t : I | \u03c7 t} -> X t [ \u03d5 t |-> a t ]> ( \u2211 (f : <{t : I | \u03c8 t} -> X t [ \u03d5 t |-> a t ]>), <{t : I | \u03c7 t} -> X t [ \u03c8 t |-> f t ]>) := ( \\ h -> ( \\ t -> h t, \\ t -> h t), (( \\ fg t -> ( second fg) t, \\ h -> refl ), (( \\ fg t -> ( second fg) t, \\ h -> refl )))) -- [RS17, Theorem 4.5] #def cofibration_union ( I : CUBE ) ( \u03d5 \u03c8 : I -> TOPE ) ( X : <{t : I | \u03d5 t \\/ \u03c8 t} -> U >) ( a : ( t : \u03c8) -> X t) : Equiv <{t : I | \u03d5 t \\/ \u03c8 t} -> X t [ \u03c8 t |-> a t ]> <{t : I | \u03d5 t} -> X t [ \u03d5 t /\\ \u03c8 t |-> a t ]> := ( \\ h -> \\ t -> h t, (( \\ g -> \\ t -> recOR (\u03d5 t |-> g t, \u03c8 t |-> a t), \\ h -> refl ), ( \\ g -> \\ t -> recOR (\u03d5 t |-> g t, \u03c8 t |-> a t), \\ h -> refl )))","title":"Composites and unions of cofibrations"},{"location":"simplicial-hott/04-extension-types.rzk/#relative-function-extensionality","text":"There are various equivalent forms of the relative function extensionality axiom. Here we state the one that will be most useful and derive an application. #def ext-htpy-eq ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( A : \u03c8 -> U ) ( a : ( t : \u03d5) -> A t) ( f g : <{t : I | \u03c8 t} -> A t [ \u03d5 t |-> a t ]>) ( p : f = g) : <{t : I | \u03c8 t} -> (f t = g t) [ \u03d5 t |-> refl ]> := idJ (<{t : I | \u03c8 t} -> A t [ \u03d5 t |-> a t ]>, f, \\ g' p' -> <{t : I | \u03c8 t} -> (f t = g' t) [ \u03d5 t |-> refl ]>, \\ t -> refl , g, p) -- [RS17, Proposition 4.8(ii)] -- as suggested by footnote 8, we assert this as an \"extension extensionality\" axiom -- The type that encodes the extension extensionality axiom. #def ExtExt : U := ( I : CUBE ) -> ( \u03c8 : I -> TOPE ) -> ( \u03d5 : \u03c8 -> TOPE ) -> ( A : \u03c8 -> U ) -> ( a : ( t : \u03d5) -> A t) -> ( f : <{t : I | \u03c8 t} -> A t [ \u03d5 t |-> a t ]>) -> ( g : <{t : I | \u03c8 t} -> A t [ \u03d5 t |-> a t ]>) -> is-equiv (f = g) (<{t : I | \u03c8 t} -> (f t = g t) [ \u03d5 t |-> refl ]>) (ext-htpy-eq I \u03c8 \u03d5 A a f g) -- The equivalence provided by extension extensionality. #def ExtExtEquiv ( extext : ExtExt) ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( A : \u03c8 -> U ) ( a : ( t : \u03d5) -> A t) ( f g : <{t : I | \u03c8 t} -> A t [ \u03d5 t |-> a t ]>) : Equiv (f = g) (<{t : I | \u03c8 t} -> (f t = g t) [ \u03d5 t |-> refl ]>) := (ext-htpy-eq I \u03c8 \u03d5 A a f g , extext I \u03c8 \u03d5 A a f g) -- In particular, extension extensionality implies that homotopies give rise to identifications. This definition defines eq-ext-htpy to be the retraction to ext-htpy-eq. #def eq-ext-htpy ( extext : ExtExt) ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( \u03d5 : \u03c8 -> TOPE ) ( A : \u03c8 -> U ) ( a : ( t : \u03d5) -> A t) ( f g : <{t : I | \u03c8 t} -> A t [ \u03d5 t |-> a t ]>) : (<{t : I | \u03c8 t} -> (f t = g t) [ \u03d5 t |-> refl ]>) -> (f = g) := first ( first (extext I \u03c8 \u03d5 A a f g)) By extension extensionality, fiberwise equivalences of extension types define equivalences of extension types. -- A fiberwise equivalence defines an equivalence of extension types, for simplicity extending from BOT #def fibered-Eq-extension-Equiv ( extext : ExtExt) ( I : CUBE ) ( \u03c8 : I -> TOPE ) ( A B : \u03c8 -> U ) ( fibequiv : ( t : \u03c8) -> (Equiv (A t) (B t)) ) : Equiv (<{t : I | \u03c8 t } -> A t >) (<{t : I | \u03c8 t } -> B t >) := (( \\ a t -> ( first (fibequiv t)) (a t)), ((( \\ b t -> ( first ( first ( second (fibequiv t)))) (b t)), \\ a -> eq-ext-htpy extext I \u03c8 ( \\ t -> BOT ) A ( \\ u -> recBOT ) ( \\ t -> ( first ( first ( second (fibequiv t)))) (( first (fibequiv t)) (a t))) a ( \\ t -> ( second ( first ( second (fibequiv t)))) (a t))), (( \\ b t -> ( first ( second ( second (fibequiv t)))) (b t)), ( \\ b -> eq-ext-htpy extext I \u03c8 ( \\ t -> BOT ) B ( \\ u -> recBOT ) ( \\ t -> ( first (fibequiv t)) (( first ( second ( second (fibequiv t)))) (b t))) b ( \\ t -> ( second ( second ( second (fibequiv t)))) (b t))))))","title":"Relative function extensionality"},{"location":"simplicial-hott/05-segal-types.rzk/","text":"Segal Types \u00b6 These formalisations correspond to Section 5 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 hott/1-paths.md - We require basic path algebra. hott/2-contractible.md - We require the notion of contractible types and their data. hott/total-space.md \u2014 We rely on is-equiv-projection-contractible-fibers and total-space-projection in the proof of Theorem 5.5. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. Hom types \u00b6 Extension types are used \u2202to define the type of arrows between fixed terms: x y -- [RS17, Definition 5.1] -- The type of arrows in A from x to y. #def hom ( A : U ) -- A type. ( x y : A) -- Two points in A. : U -- (hom A x y) is a 1-simplex (an arrow) := ( t : \u0394\u00b9) -> A [ -- in A where t === 0_2 |-> x, -- * the left endpoint is exactly x t === 1_2 |-> y -- * the right endpoint is exactly y ] Extension types are also used to define the type of commutative triangles: x y z f g h -- [RS17, Definition 5.2] -- the type of commutative triangles in A #def hom2 ( A : U ) -- A type. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. ( h : hom A x z) -- An arrow in A from x to z. : U -- (hom2 A x y z f g h) is a 2-simplex (triangle) := { (t1, t2) : \u0394\u00b2 } -> A [ -- in A where t2 === 0_2 |-> f t1, -- * the top edge is exactly f, t1 === 1_2 |-> g t2, -- * the right edge is exactly g, and t2 === t1 |-> h t2 -- * the diagonal is exactly h ] The Segal condition \u00b6 A type is Segal if every composable pair of arrows has a unique composite. Note this is a considerable simplification of the usual Segal condition, which also requires homotopical uniqueness of higher-order composites. -- [RS17, Definition 5.3] #def is-segal ( A : U ) -- A type. : U := ( x : A) -> ( y : A) -> ( z : A) -> ( f : hom A x y) -> ( g : hom A y z) -> is-contr ( \u03a3 (h : hom A x z), hom2 A x y z f g h) Segal types have a composition functor and witnesses to the composition relation: -- Composition is written in diagrammatic order to match the order of arguments in is-segal. #def Segal-comp ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. : hom A x z := first ( first (AisSegal x y z f g)) -- Segal types have composition witnesses #def Segal-comp-witness ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. : hom2 A x y z f g (Segal-comp A AisSegal x y z f g) := second ( first (AisSegal x y z f g)) Composition in a Segal type is unique in the following sense. If there is a witness that an arrow h is a composite of f and g, then the specified composite equals h. x y z f g h \u03b1 = x y z f g Segal-comp Segal-comp-witness #def Segal-comp-uniqueness ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. ( h : hom A x z) -- An arrow in A from x to z. ( alpha : hom2 A x y z f g h) -- A witness that h is a composite of f and g. : (Segal-comp A AisSegal x y z f g) = h := first-path-sigma (hom A x z) ( \\ k -> hom2 A x y z f g k) (Segal-comp A AisSegal x y z f g, Segal-comp-witness A AisSegal x y z f g) (h, alpha) ( contracting-htpy (\u03a3 (k : hom A x z), hom2 A x y z f g k) (AisSegal x y z f g) (h, alpha)) Characterizing Segal types \u00b6 Our aim is to prove that a type is Segal if and only if the horn-restriction map, defined below, is an equivalence. x y z f g -- A pair of composable arrows form a horn. #def horn ( A : U ) -- A type. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. : \u039b -> A := \\(t, s) -> recOR ( s === 0_2 |-> f t, t === 1_2 |-> g s ) -- The underlying horn of a simplex #def horn-restriction ( A : U ) : (\u0394\u00b2 -> A) -> (\u039b -> A) := \\ f t -> f t -- An alternate definition of Segal types. #def is-local-horn-inclusion ( A : U ) : U := is-equiv (\u0394\u00b2 -> A) (\u039b -> A) (horn-restriction A) Now we prove this definition is equivalent to the original one. -- Here, we prove the equivalence used in [RS17, Theorem 5.5]. -- However, we do this by constructing the equivalence directly, -- instead of using a composition of equivalences, as it is easier to write down -- and it computes better (we can use refl for the witnesses of the equivalence). #def compositions-are-horn-fillings ( A : U ) -- A type. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. : Equiv ( \u03a3 (h : hom A x z), hom2 A x y z f g h) <{t : 2 * 2 | \u0394\u00b2 t } -> A [ \u039b t |-> horn A x y z f g t ]> := ( \\ hh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> ( second hh) t, ( (\\k -> (\\(t : 2 ) -> k (t, t), \\(t, s) -> k (t, s)), \\ hh -> refl ), ( \\k -> (\\(t : 2 ) -> k (t, t), \\(t, s) -> k (t, s)), \\ hh -> refl ))) #def equiv-horn-restriction ( A : U ) -- A type. : Equiv (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) ( \u03a3 (k : <{t : 2 * 2 | \u039b t} -> A >), \u03a3 ( h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))), hom2 A (k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t, 0_2 )) ( \\ t -> k ( 1_2 , t)) h) := ( \\ k -> (\\{t : 2 * 2 | \u039b t} -> k t, ( \\(t : 2 ) -> k (t, t), \\{t : 2 * 2 | \u0394\u00b2 t} -> k t)), (( \\ khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> ( second ( second khh)) t, \\ k -> refl _{k}), ( \\ khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> ( second ( second khh)) t, \\ k -> refl _{k}))) -- [RS17, Theorem 5.5], the hard direction: #def Segal-equiv-horn-restriction ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. : Equiv (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) -- (horn-restriction A) := comp-equiv (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) ( \u03a3 (k : <{t : 2 * 2 | \u039b t} -> A >), \u03a3 ( h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))), hom2 A (k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t, 0_2 )) ( \\ t -> k ( 1_2 , t)) h) (<{t : 2 * 2 | \u039b t} -> A >) (equiv-horn-restriction A) (total-space-projection (<{t : 2 * 2 | \u039b t} -> A >) ( \\k -> \u03a3 (h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))), hom2 A (k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t, 0_2 )) ( \\ t -> k ( 1_2 , t)) h), (is-equiv-projection-contractible-fibers (<{t : 2 * 2 | \u039b t} -> A >) ( \\k -> \u03a3 (h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))), hom2 A (k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t, 0_2 )) ( \\ t -> k ( 1_2 , t)) h) ( \\ k -> AisSegal (k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t, 0_2 )) ( \\ t -> k ( 1_2 , t))))) -- Verify that the mapping in (Segal-equiv-horn-restriction A AisSegal) -- is exactly (horn-restriction A) #def Segal-equiv-horn-restriction-test ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. : ( first (Segal-equiv-horn-restriction A AisSegal)) = (horn-restriction A) := refl -- Segal types are Segal' types. #def is-local-horn-inclusion-is-segal ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. : is-local-horn-inclusion A := second (Segal-equiv-horn-restriction A AisSegal) -- Segal' types are Segal types. #def is-segal-is-local-horn-inclusion ( A : U ) ( is-local-horn-inclusion-A : is-local-horn-inclusion A) : is-segal A := \\ x y z f g -> contractible-fibers-is-equiv-projection ( < {t : 2 * 2 | \u039b t} -> A >) ( \\ k -> \u03a3 ( h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))) , ( hom2 A ( k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t , 0_2 )) ( \\ t -> k ( 1_2 , t)) ( h))) ( second ( comp-equiv ( \u03a3 ( k : < {t : 2 * 2 | \u039b t} -> A >) , \u03a3 ( h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))) , ( hom2 A ( k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t , 0_2 )) ( \\ t -> k ( 1_2 , t)) ( h))) ( < {t : 2 * 2 | \u0394\u00b2 t} -> A >) ( < {t : 2 * 2 | \u039b t} -> A >) ( inv-equiv ( < {t : 2 * 2 | \u0394\u00b2 t} -> A >) ( \u03a3 ( k : < {t : 2 * 2 | \u039b t} -> A >) , \u03a3 ( h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))) , ( hom2 A ( k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t , 0_2 )) ( \\ t -> k ( 1_2 , t)) ( h))) ( equiv-horn-restriction A)) ( horn-restriction A , is-local-horn-inclusion-A))) ( horn A x y z f g) -- [RS17, Theorem 5.5] proves that both notions of Segal types are logically equivalent. #def is-segal-iff-is-local-horn-inclusion ( A : U ) -- A type. : iff (is-segal A) (is-local-horn-inclusion A) := (is-local-horn-inclusion-is-segal A , is-segal-is-local-horn-inclusion A) Segal function and extension types \u00b6 Using the new characterization of Segal types, we can show that the type of functions or extensions into a family of Segal types is again a Segal type. -- [RS17, Corollary 5.6(i)] : if X is a type and A : X -> U is such that -- A(x) is a Segal type for all x then (x : X) -> A x is a Segal type #def Segal-function-types ( funext : FunExt) -- This proof uses function extensionality. ( X : U ) -- A type. ( A : ( _ : X) -> U ) -- A type family ( fiberwiseAisSegal : ( x : X) -> is-local-horn-inclusion (A x)) -- An assumption that the fibers are Segal types. : is-local-horn-inclusion ( (x : X) -> A x) := triple-compose-is-equiv (<{t : 2 * 2 | \u0394\u00b2 t} -> ( (x : X) -> A x) >) ( (x : X) -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) ( (x : X) -> <{t : 2 * 2 | \u039b t} -> A x >) (<{t : 2 * 2 | \u039b t} -> ( (x : X) -> A x) >) ( \\ g -> \\ x -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t x) -- first equivalence ( second (flip-ext-fun ( 2 * 2 ) \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT ) X (\\{t : 2 * 2 | \u0394\u00b2 t} -> A) (\\{t : 2 * 2 | BOT } -> recBOT ))) ( \\ h -> \\ x -> \\{t : 2 * 2 | \u039b t} -> h x t) -- second equivalence ( second (function-equiv-fibered-equiv funext X ( \\ x -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) ( \\ x -> <{t : 2 * 2 | \u039b t} -> A x >) ( \\ x -> (horn-restriction (A x) , fiberwiseAisSegal x)))) ( \\ h -> \\{t : 2 * 2 | \u039b t} -> \\ x -> (h x) t) -- third equivalence ( second (flip-ext-fun-inv ( 2 * 2 ) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT ) X (\\{t : 2 * 2 | \u039b t} -> A) (\\{t : 2 * 2 | BOT } -> recBOT ))) -- [RS17, Corollary 5.6(ii)] : if X is a shape and A : X -> U is such that -- A(x) is a Segal type for all x then (x : X) -> A x is a Segal type #def Segal-extension-types ( extext : ExtExt) -- This proof uses extension extensionality. ( I : CUBE ) -- A cube. ( \u03c8 : ( s : I) -> TOPE ) -- A tope. ( A : <{s : I | \u03c8 s} -> U >) -- An extension type. ( fiberwiseAisSegal : <{s : I | \u03c8 s} -> is-local-horn-inclusion (A s) >) -- An assumption that the fibers are Segal types. : is-local-horn-inclusion (<{s : I | \u03c8 s} -> A s >) := triple-compose-is-equiv (<{t : 2 * 2 | \u0394\u00b2 t} -> <{s : I | \u03c8 s} -> A s > >) (<{s : I | \u03c8 s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s > >) (<{s : I | \u03c8 s} -> <{t : 2 * 2 | \u039b t} -> A s > >) (<{t : 2 * 2 | \u039b t} -> <{s : I | \u03c8 s} -> A s > >) ( \\ g -> \\{s : I | \u03c8 s} -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t s) -- first equivalence ( second (fubini ( 2 * 2 ) I \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT ) \u03c8 (\\{s : I | \u03c8 s} -> BOT ) (\\{t : 2 * 2 | \u0394\u00b2 t} -> \\{s : I | \u03c8 s} -> A s) (\\{u : ( 2 * 2 ) * I | BOT } -> recBOT ))) ( \\ h -> \\{s : I | \u03c8 s} -> \\{t : 2 * 2 | \u039b t} -> h s t) -- second equivalence ( second (fibered-Eq-extension-Equiv extext I \u03c8 (\\{s : I | \u03c8 s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s >) (\\{s : I | \u03c8 s} -> <{t : 2 * 2 | \u039b t} -> A s >) (\\{s : I | \u03c8 s} -> (horn-restriction (A s), fiberwiseAisSegal s)) )) ( \\ h -> \\{t : 2 * 2 | \u039b t} -> \\{s : I | \u03c8 s} -> (h s) t) -- third equivalence ( second (fubini I ( 2 * 2 ) \u03c8 (\\{s : I | \u03c8 s} -> BOT ) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT ) (\\{s : I | \u03c8 s} -> \\{t : 2 * 2 | \u039b t} -> A s) (\\{u : I * ( 2 * 2 ) | BOT } -> recBOT ))) In particular, the arrow type of a Segal type is Segal. -- The type of arrows in a type. #def arr -- A type ( A : U ) : U := ( t : \u0394\u00b9) -> A -- For later use, an equivalent characterization of the arrow type. #def Eq-arr ( A : U ) : Equiv (arr A) ( \u03a3 (x : A), ( \u03a3 (y : A), hom A x y)) := ( \\ f -> (f 0_2 , (f 1_2 , f)), ((\\(x, (y, f)) -> f, \\ f -> refl ) , (\\(x, (y, f)) -> f, \\ xyf -> refl ))) -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal'. #def Segal'-arrow-types ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-local-horn-inclusion A) -- A proof that A is-local-horn-inclusion. : is-local-horn-inclusion (arr A) := Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> AisSegal) -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal. #def Segal-arrow-types ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. : is-segal (arr A) := is-segal-is-local-horn-inclusion (arr A) (Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> (is-local-horn-inclusion-is-segal A AisSegal))) Identity \u00b6 All types have identity arrows and witnesses to the identity composition law. x x x -- [RS17, Definition 5.7] -- all types have identity arrows #def id-arr ( A : U ) -- A type. ( x : A) -- A point in A. : hom A x x := \\{t : 2 | \u0394\u00b9 t} -> x Witness for the right identity law: x y y f y f f -- [RS17, Proposition 5.8a] -- the right unit law for identity #def comp-id-witness ( A : U ) -- A type. ( x y : A) -- Two points in A. ( f : hom A x y) -- An arrow from x to y in A. : hom2 A x y y f (id-arr A y) f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f t Witness for the left identity law: x x y x f f f -- [RS17, Proposition 5.8b] -- the left unit law for identity #def id-comp-witness ( A : U ) -- A type. ( x y : A) -- Two points in A. ( f : hom A x y) -- An arrow from x to y in A. : hom2 A x x y (id-arr A x) f f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f s In a Segal type, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. Thus, an identity axiom was not needed in the definition of Segal types. -- If A is Segal then the right unit law holds #def Segal-comp-id ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y : A) -- Two points in A. ( f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x y y f (id-arr A y)) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x y y f (id-arr A y) f (comp-id-witness A x y f) -- If A is Segal then the left unit law holds #def Segal-id-comp ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y : A) -- Two points in A. ( f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x x y (id-arr A x) f) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x x y (id-arr A x) f f (id-comp-witness A x y f) Associativity \u00b6 We now prove that composition in a Segal type is associative, by using the fact that the type of arrows in a Segal type is itself a Segal type. \u2022 \u2022 \u2022 \u2022 #def unfolding-square ( A : U ) -- A type. ( triangle : \u0394\u00b2 -> A) -- A triangle in A. : \u0394\u00b9\u00d7\u0394\u00b9 -> A -- A square in A, defined by gluing := \\(t, s) -> -- two copies of the triangle along the common diagonal edge. recOR (t <= s |-> triangle (s , t), s <= t |-> triangle (t , s)) For use in the proof of associativity: x y z y f g Segal-comp g f #def Segal-comp-witness-square ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. : \u0394\u00b9\u00d7\u0394\u00b9 -> A := unfolding-square A (Segal-comp-witness A AisSegal x y z f g) The Segal-comp-witness-square as an arrow in the arrow type: x y z y f g #def Segal-arr-in-arr ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. : hom (arr A) f g := \\ t -> \\ s -> (Segal-comp-witness-square A AisSegal x y z f g) (t, s) w x x y y z f g h #def Segal-associativity-witness ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : hom2 (arr A) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h) (Segal-comp (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) := (Segal-comp-witness (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) w x y z g f h -- The Segal-associativity-witness curries to define a diagram \u0394\u00b2\u00d7\u0394\u00b9 -> A. -- The Segal-associativity-tetrahedron is extracted via the middle-simplex map \\((t, s), r) -> ((t, r), s) from \u0394\u00b3 to \u0394\u00b2\u00d7\u0394\u00b9 #def Segal-associativity-tetrahedron ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : \u0394\u00b3 -> A := \\((t, s), r) -> (Segal-associativity-witness extext A AisSegal w x y z f g h) (t, r) s w x y z g f h -- the diagonal composite of three arrows extracted from the Segal-associativity-tetrahedron #def Segal-triple-composite ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : hom A w z := \\ t -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), t) w x y z g f h #def Segal-left-associativity-witness ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : hom2 A w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), s) The front face: w x y z g f h #def Segal-right-associativity-witness ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : hom2 A w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, s), s) #def Segal-left-associativity ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-left-associativity-witness extext A AisSegal w x y z f g h) #def Segal-right-associativity ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-right-associativity-witness extext A AisSegal w x y z f g h) #def Segal-associativity ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) := zig-zag-concat (hom A w z) (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) (Segal-left-associativity extext A AisSegal w x y z f g h) (Segal-right-associativity extext A AisSegal w x y z f g h) #def Segal-postcomp ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : ( z : A) -> (hom A z x) -> (hom A z y) := \\ z -> \\ g -> (Segal-comp A AisSegal z x y g f) #def Segal-precomp ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : ( z : A) -> (hom A y z) -> (hom A x z) := \\ z -> \\ g -> (Segal-comp A AisSegal x y z f g) Homotopies \u00b6 We may define a \"homotopy\" to be a path between parallel arrows. In a Segal type, homotopies are equivalent to terms in hom2 types involving an identity arrow. #def homotopy-to-hom2 ( A : U ) ( x y : A) ( f g : hom A x y) ( p : f = g) : (hom2 A x x y (id-arr A x) f g) := idJ (hom A x y, f, \\ g' p' -> (hom2 A x x y (id-arr A x) f g'), (id-comp-witness A x y f), g, p) #def homotopy-to-hom2-total-map ( A : U ) ( x y : A) ( f : hom A x y) : ( \u03a3 (g : hom A x y), f = g) -> ( \u03a3 (g : hom A x y), (hom2 A x x y (id-arr A x) f g)) := \\(g, p) -> (g, homotopy-to-hom2 A x y f g p) #def Segal-homotopy-to-hom2-total-map-is-equiv ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : is-equiv ( \u03a3 (g : hom A x y), f = g) ( \u03a3 (g : hom A x y), (hom2 A x x y (id-arr A x) f g)) (homotopy-to-hom2-total-map A x y f) := areContr-is-equiv ( \u03a3 (g : hom A x y), f = g) ( \u03a3 (g : hom A x y), (hom2 A x x y (id-arr A x) f g)) (is-contr-based-paths (hom A x y) f) (AisSegal x x y (id-arr A x) f) (homotopy-to-hom2-total-map A x y f) -- [RS17, Proposition 5.10] #def Eq-Segal-homotopy-hom2 ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f g : hom A x y) : Equiv (f = g) (hom2 A x x y (id-arr A x) f g) := (homotopy-to-hom2 A x y f g, total-equiv-family-of-equiv (hom A x y) ( \\ g -> (f = g)) ( \\ g -> (hom2 A x x y (id-arr A x) f g)) (homotopy-to-hom2 A x y f) (Segal-homotopy-to-hom2-total-map-is-equiv A AisSegal x y f) g) A dual notion of homotopy can be defined similarly. #def homotopy-to-hom2' ( A : U ) ( x y : A) ( f g : hom A x y) ( p : f = g) : (hom2 A x y y f (id-arr A y) g) := idJ (hom A x y, f, \\ g' p' -> (hom2 A x y y f (id-arr A y) g'), (comp-id-witness A x y f), g, p) #def homotopy-to-hom2'-total-map ( A : U ) ( x y : A) ( f : hom A x y) : ( \u03a3 (g : hom A x y), f = g) -> ( \u03a3 (g : hom A x y), (hom2 A x y y f (id-arr A y) g)) := \\(g, p) -> (g, homotopy-to-hom2' A x y f g p) #def Segal-homotopy-to-hom2'-total-map-is-equiv ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : is-equiv ( \u03a3 (g : hom A x y), f = g) ( \u03a3 (g : hom A x y), (hom2 A x y y f (id-arr A y) g)) (homotopy-to-hom2'-total-map A x y f) := areContr-is-equiv ( \u03a3 (g : hom A x y), f = g) ( \u03a3 (g : hom A x y), (hom2 A x y y f (id-arr A y) g)) (is-contr-based-paths (hom A x y) f) (AisSegal x y y f (id-arr A y)) (homotopy-to-hom2'-total-map A x y f) -- [RS17, Proposition 5.10] #def Eq-Segal-homotopy-hom2' ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f g : hom A x y) : Equiv (f = g) (hom2 A x y y f (id-arr A y) g) := (homotopy-to-hom2' A x y f g, total-equiv-family-of-equiv (hom A x y) ( \\ g -> (f = g)) ( \\ g -> (hom2 A x y y f (id-arr A y) g)) (homotopy-to-hom2' A x y f) (Segal-homotopy-to-hom2'-total-map-is-equiv A AisSegal x y f) g) More generally, a homotopy between a composite and another map is equivalent to the data provided by a commutative triangle with that boundary. #def Segal-eq-to-hom2 ( A : U ) ( AisSegal : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) ( p : (Segal-comp A AisSegal x y z f g) = h) : (hom2 A x y z f g h) := idJ (hom A x z, (Segal-comp A AisSegal x y z f g), \\ h' p' -> (hom2 A x y z f g h'), Segal-comp-witness A AisSegal x y z f g, h, p) #def Segal-eq-to-hom2-total-map ( A : U ) ( AisSegal : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : ( \u03a3 (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) -> ( \u03a3 (h : hom A x z), (hom2 A x y z f g h)) := \\(h, p) -> (h, Segal-eq-to-hom2 A AisSegal x y z f g h p) #def Segal-eq-to-hom2-total-map-is-equiv ( A : U ) ( AisSegal : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : is-equiv ( \u03a3 (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) ( \u03a3 (h : hom A x z), (hom2 A x y z f g h)) (Segal-eq-to-hom2-total-map A AisSegal x y z f g) := areContr-is-equiv ( \u03a3 (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) ( \u03a3 (h : hom A x z), (hom2 A x y z f g h)) (is-contr-based-paths (hom A x z) (Segal-comp A AisSegal x y z f g) ) (AisSegal x y z f g) (Segal-eq-to-hom2-total-map A AisSegal x y z f g) -- [RS17, Proposition 5.12] #def Eq-Segal-eq-hom2 ( A : U ) ( AisSegal : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) : Equiv ((Segal-comp A AisSegal x y z f g) = h) (hom2 A x y z f g h) := (Segal-eq-to-hom2 A AisSegal x y z f g h, total-equiv-family-of-equiv (hom A x z) ( \\ h -> (Segal-comp A AisSegal x y z f g) = h) ( \\ h -> hom2 A x y z f g h) (Segal-eq-to-hom2 A AisSegal x y z f g) (Segal-eq-to-hom2-total-map-is-equiv A AisSegal x y z f g) h) Homotopies form a congruence, meaning that homotopies are respected by composition: -- [RS17, Proposition 5.13] #def Segal-homotopy-congruence ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) ( f g : hom A x y) ( h k : hom A y z) ( p : f = g) ( q : h = k) : (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g k) := idJ (hom A y z, h, \\ k' q' -> (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g k'), idJ (hom A x y, f, \\ g' p' -> (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g' h), refl , g, p) , k, q) -- As a special case of the above: #def Segal-homotopy-postwhisker ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) ( f g : hom A x y) ( h : hom A y z) ( p : f = g) : (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g h) := Segal-homotopy-congruence A AisSegal x y z f g h h p refl -- As a special case of the above: #def Segal-homotopy-prewhisker ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y : A) ( k : hom A w x) ( f g : hom A x y) ( p : f = g) : (Segal-comp A AisSegal w x y k f) = (Segal-comp A AisSegal w x y k g) := Segal-homotopy-congruence A AisSegal w x y k k f g refl p -- [RS17, Proposition 5.14(a)] #def Segal-homotopy-postwhisker-is-ap ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) ( f g : hom A x y) ( h : hom A y z) ( p : f = g) : (Segal-homotopy-postwhisker A AisSegal x y z f g h p) = ap (hom A x y) (hom A x z) f g ( \\ k -> Segal-comp A AisSegal x y z k h) p := idJ (hom A x y, f, \\ g' p' -> (Segal-homotopy-postwhisker A AisSegal x y z f g' h p') = ap (hom A x y) (hom A x z) f g' ( \\ k -> Segal-comp A AisSegal x y z k h) p', refl , g, p) -- [RS17, Proposition 5.14(b)] #def Segal-homotopy-prewhisker-is-ap ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y : A) ( k : hom A w x) ( f g : hom A x y) ( p : f = g) : (Segal-homotopy-prewhisker A AisSegal w x y k f g p) = ap (hom A x y) (hom A w y) f g (Segal-comp A AisSegal w x y k) p := idJ (hom A x y, f, \\ g' p' -> (Segal-homotopy-prewhisker A AisSegal w x y k f g' p') = ap (hom A x y) (hom A w y) f g' (Segal-comp A AisSegal w x y k) p', refl , g, p) #section is-segal-Unit #variable extext : ExtExt #def iscontr-Unit : is-contr Unit := ( unit , \\ _ -> refl ) #def is-contr-\u0394\u00b2\u2192Unit uses ( extext ) : is-contr (\u0394\u00b2 -> Unit ) := ( \\ _ -> unit , \\ k -> eq-ext-htpy extext ( 2 * 2 ) \u0394\u00b2 ( \\ _ -> BOT ) ( \\ _ -> Unit ) ( \\ _ -> recBOT ) ( \\ _ -> unit ) k ( \\ _ -> refl ) ) #def is-segal-Unit uses ( extext ) : is-segal Unit := \\ x y z f g -> is-retract-of-is-contr-is-contr ( \u03a3 (h : hom Unit x z), hom2 Unit x y z f g h) (\u0394\u00b2 -> Unit ) (\\(_, k) -> k, ( \\ k -> ( \\ t -> k (t, t), k), \\ _ -> refl )) is-contr-\u0394\u00b2\u2192Unit #end is-segal-Unit @import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap); text, textPath { font-family: Noto Serif; font-size: 20px; dominant-baseline: middle; text-anchor: middle; }","title":"Segal Types"},{"location":"simplicial-hott/05-segal-types.rzk/#segal-types","text":"These formalisations correspond to Section 5 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Segal Types"},{"location":"simplicial-hott/05-segal-types.rzk/#prerequisites","text":"hott/1-paths.md - We require basic path algebra. hott/2-contractible.md - We require the notion of contractible types and their data. hott/total-space.md \u2014 We rely on is-equiv-projection-contractible-fibers and total-space-projection in the proof of Theorem 5.5. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality.","title":"Prerequisites"},{"location":"simplicial-hott/05-segal-types.rzk/#hom-types","text":"Extension types are used \u2202to define the type of arrows between fixed terms: x y -- [RS17, Definition 5.1] -- The type of arrows in A from x to y. #def hom ( A : U ) -- A type. ( x y : A) -- Two points in A. : U -- (hom A x y) is a 1-simplex (an arrow) := ( t : \u0394\u00b9) -> A [ -- in A where t === 0_2 |-> x, -- * the left endpoint is exactly x t === 1_2 |-> y -- * the right endpoint is exactly y ] Extension types are also used to define the type of commutative triangles: x y z f g h -- [RS17, Definition 5.2] -- the type of commutative triangles in A #def hom2 ( A : U ) -- A type. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. ( h : hom A x z) -- An arrow in A from x to z. : U -- (hom2 A x y z f g h) is a 2-simplex (triangle) := { (t1, t2) : \u0394\u00b2 } -> A [ -- in A where t2 === 0_2 |-> f t1, -- * the top edge is exactly f, t1 === 1_2 |-> g t2, -- * the right edge is exactly g, and t2 === t1 |-> h t2 -- * the diagonal is exactly h ]","title":"Hom types"},{"location":"simplicial-hott/05-segal-types.rzk/#the-segal-condition","text":"A type is Segal if every composable pair of arrows has a unique composite. Note this is a considerable simplification of the usual Segal condition, which also requires homotopical uniqueness of higher-order composites. -- [RS17, Definition 5.3] #def is-segal ( A : U ) -- A type. : U := ( x : A) -> ( y : A) -> ( z : A) -> ( f : hom A x y) -> ( g : hom A y z) -> is-contr ( \u03a3 (h : hom A x z), hom2 A x y z f g h) Segal types have a composition functor and witnesses to the composition relation: -- Composition is written in diagrammatic order to match the order of arguments in is-segal. #def Segal-comp ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. : hom A x z := first ( first (AisSegal x y z f g)) -- Segal types have composition witnesses #def Segal-comp-witness ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. : hom2 A x y z f g (Segal-comp A AisSegal x y z f g) := second ( first (AisSegal x y z f g)) Composition in a Segal type is unique in the following sense. If there is a witness that an arrow h is a composite of f and g, then the specified composite equals h. x y z f g h \u03b1 = x y z f g Segal-comp Segal-comp-witness #def Segal-comp-uniqueness ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. ( h : hom A x z) -- An arrow in A from x to z. ( alpha : hom2 A x y z f g h) -- A witness that h is a composite of f and g. : (Segal-comp A AisSegal x y z f g) = h := first-path-sigma (hom A x z) ( \\ k -> hom2 A x y z f g k) (Segal-comp A AisSegal x y z f g, Segal-comp-witness A AisSegal x y z f g) (h, alpha) ( contracting-htpy (\u03a3 (k : hom A x z), hom2 A x y z f g k) (AisSegal x y z f g) (h, alpha))","title":"The Segal condition"},{"location":"simplicial-hott/05-segal-types.rzk/#characterizing-segal-types","text":"Our aim is to prove that a type is Segal if and only if the horn-restriction map, defined below, is an equivalence. x y z f g -- A pair of composable arrows form a horn. #def horn ( A : U ) -- A type. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. : \u039b -> A := \\(t, s) -> recOR ( s === 0_2 |-> f t, t === 1_2 |-> g s ) -- The underlying horn of a simplex #def horn-restriction ( A : U ) : (\u0394\u00b2 -> A) -> (\u039b -> A) := \\ f t -> f t -- An alternate definition of Segal types. #def is-local-horn-inclusion ( A : U ) : U := is-equiv (\u0394\u00b2 -> A) (\u039b -> A) (horn-restriction A) Now we prove this definition is equivalent to the original one. -- Here, we prove the equivalence used in [RS17, Theorem 5.5]. -- However, we do this by constructing the equivalence directly, -- instead of using a composition of equivalences, as it is easier to write down -- and it computes better (we can use refl for the witnesses of the equivalence). #def compositions-are-horn-fillings ( A : U ) -- A type. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. : Equiv ( \u03a3 (h : hom A x z), hom2 A x y z f g h) <{t : 2 * 2 | \u0394\u00b2 t } -> A [ \u039b t |-> horn A x y z f g t ]> := ( \\ hh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> ( second hh) t, ( (\\k -> (\\(t : 2 ) -> k (t, t), \\(t, s) -> k (t, s)), \\ hh -> refl ), ( \\k -> (\\(t : 2 ) -> k (t, t), \\(t, s) -> k (t, s)), \\ hh -> refl ))) #def equiv-horn-restriction ( A : U ) -- A type. : Equiv (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) ( \u03a3 (k : <{t : 2 * 2 | \u039b t} -> A >), \u03a3 ( h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))), hom2 A (k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t, 0_2 )) ( \\ t -> k ( 1_2 , t)) h) := ( \\ k -> (\\{t : 2 * 2 | \u039b t} -> k t, ( \\(t : 2 ) -> k (t, t), \\{t : 2 * 2 | \u0394\u00b2 t} -> k t)), (( \\ khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> ( second ( second khh)) t, \\ k -> refl _{k}), ( \\ khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> ( second ( second khh)) t, \\ k -> refl _{k}))) -- [RS17, Theorem 5.5], the hard direction: #def Segal-equiv-horn-restriction ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. : Equiv (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) -- (horn-restriction A) := comp-equiv (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) ( \u03a3 (k : <{t : 2 * 2 | \u039b t} -> A >), \u03a3 ( h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))), hom2 A (k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t, 0_2 )) ( \\ t -> k ( 1_2 , t)) h) (<{t : 2 * 2 | \u039b t} -> A >) (equiv-horn-restriction A) (total-space-projection (<{t : 2 * 2 | \u039b t} -> A >) ( \\k -> \u03a3 (h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))), hom2 A (k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t, 0_2 )) ( \\ t -> k ( 1_2 , t)) h), (is-equiv-projection-contractible-fibers (<{t : 2 * 2 | \u039b t} -> A >) ( \\k -> \u03a3 (h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))), hom2 A (k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t, 0_2 )) ( \\ t -> k ( 1_2 , t)) h) ( \\ k -> AisSegal (k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t, 0_2 )) ( \\ t -> k ( 1_2 , t))))) -- Verify that the mapping in (Segal-equiv-horn-restriction A AisSegal) -- is exactly (horn-restriction A) #def Segal-equiv-horn-restriction-test ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. : ( first (Segal-equiv-horn-restriction A AisSegal)) = (horn-restriction A) := refl -- Segal types are Segal' types. #def is-local-horn-inclusion-is-segal ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. : is-local-horn-inclusion A := second (Segal-equiv-horn-restriction A AisSegal) -- Segal' types are Segal types. #def is-segal-is-local-horn-inclusion ( A : U ) ( is-local-horn-inclusion-A : is-local-horn-inclusion A) : is-segal A := \\ x y z f g -> contractible-fibers-is-equiv-projection ( < {t : 2 * 2 | \u039b t} -> A >) ( \\ k -> \u03a3 ( h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))) , ( hom2 A ( k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t , 0_2 )) ( \\ t -> k ( 1_2 , t)) ( h))) ( second ( comp-equiv ( \u03a3 ( k : < {t : 2 * 2 | \u039b t} -> A >) , \u03a3 ( h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))) , ( hom2 A ( k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t , 0_2 )) ( \\ t -> k ( 1_2 , t)) ( h))) ( < {t : 2 * 2 | \u0394\u00b2 t} -> A >) ( < {t : 2 * 2 | \u039b t} -> A >) ( inv-equiv ( < {t : 2 * 2 | \u0394\u00b2 t} -> A >) ( \u03a3 ( k : < {t : 2 * 2 | \u039b t} -> A >) , \u03a3 ( h : hom A (k ( 0_2 , 0_2 )) (k ( 1_2 , 1_2 ))) , ( hom2 A ( k ( 0_2 , 0_2 )) (k ( 1_2 , 0_2 )) (k ( 1_2 , 1_2 )) ( \\ t -> k (t , 0_2 )) ( \\ t -> k ( 1_2 , t)) ( h))) ( equiv-horn-restriction A)) ( horn-restriction A , is-local-horn-inclusion-A))) ( horn A x y z f g) -- [RS17, Theorem 5.5] proves that both notions of Segal types are logically equivalent. #def is-segal-iff-is-local-horn-inclusion ( A : U ) -- A type. : iff (is-segal A) (is-local-horn-inclusion A) := (is-local-horn-inclusion-is-segal A , is-segal-is-local-horn-inclusion A)","title":"Characterizing Segal types"},{"location":"simplicial-hott/05-segal-types.rzk/#segal-function-and-extension-types","text":"Using the new characterization of Segal types, we can show that the type of functions or extensions into a family of Segal types is again a Segal type. -- [RS17, Corollary 5.6(i)] : if X is a type and A : X -> U is such that -- A(x) is a Segal type for all x then (x : X) -> A x is a Segal type #def Segal-function-types ( funext : FunExt) -- This proof uses function extensionality. ( X : U ) -- A type. ( A : ( _ : X) -> U ) -- A type family ( fiberwiseAisSegal : ( x : X) -> is-local-horn-inclusion (A x)) -- An assumption that the fibers are Segal types. : is-local-horn-inclusion ( (x : X) -> A x) := triple-compose-is-equiv (<{t : 2 * 2 | \u0394\u00b2 t} -> ( (x : X) -> A x) >) ( (x : X) -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) ( (x : X) -> <{t : 2 * 2 | \u039b t} -> A x >) (<{t : 2 * 2 | \u039b t} -> ( (x : X) -> A x) >) ( \\ g -> \\ x -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t x) -- first equivalence ( second (flip-ext-fun ( 2 * 2 ) \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT ) X (\\{t : 2 * 2 | \u0394\u00b2 t} -> A) (\\{t : 2 * 2 | BOT } -> recBOT ))) ( \\ h -> \\ x -> \\{t : 2 * 2 | \u039b t} -> h x t) -- second equivalence ( second (function-equiv-fibered-equiv funext X ( \\ x -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) ( \\ x -> <{t : 2 * 2 | \u039b t} -> A x >) ( \\ x -> (horn-restriction (A x) , fiberwiseAisSegal x)))) ( \\ h -> \\{t : 2 * 2 | \u039b t} -> \\ x -> (h x) t) -- third equivalence ( second (flip-ext-fun-inv ( 2 * 2 ) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT ) X (\\{t : 2 * 2 | \u039b t} -> A) (\\{t : 2 * 2 | BOT } -> recBOT ))) -- [RS17, Corollary 5.6(ii)] : if X is a shape and A : X -> U is such that -- A(x) is a Segal type for all x then (x : X) -> A x is a Segal type #def Segal-extension-types ( extext : ExtExt) -- This proof uses extension extensionality. ( I : CUBE ) -- A cube. ( \u03c8 : ( s : I) -> TOPE ) -- A tope. ( A : <{s : I | \u03c8 s} -> U >) -- An extension type. ( fiberwiseAisSegal : <{s : I | \u03c8 s} -> is-local-horn-inclusion (A s) >) -- An assumption that the fibers are Segal types. : is-local-horn-inclusion (<{s : I | \u03c8 s} -> A s >) := triple-compose-is-equiv (<{t : 2 * 2 | \u0394\u00b2 t} -> <{s : I | \u03c8 s} -> A s > >) (<{s : I | \u03c8 s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s > >) (<{s : I | \u03c8 s} -> <{t : 2 * 2 | \u039b t} -> A s > >) (<{t : 2 * 2 | \u039b t} -> <{s : I | \u03c8 s} -> A s > >) ( \\ g -> \\{s : I | \u03c8 s} -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t s) -- first equivalence ( second (fubini ( 2 * 2 ) I \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT ) \u03c8 (\\{s : I | \u03c8 s} -> BOT ) (\\{t : 2 * 2 | \u0394\u00b2 t} -> \\{s : I | \u03c8 s} -> A s) (\\{u : ( 2 * 2 ) * I | BOT } -> recBOT ))) ( \\ h -> \\{s : I | \u03c8 s} -> \\{t : 2 * 2 | \u039b t} -> h s t) -- second equivalence ( second (fibered-Eq-extension-Equiv extext I \u03c8 (\\{s : I | \u03c8 s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s >) (\\{s : I | \u03c8 s} -> <{t : 2 * 2 | \u039b t} -> A s >) (\\{s : I | \u03c8 s} -> (horn-restriction (A s), fiberwiseAisSegal s)) )) ( \\ h -> \\{t : 2 * 2 | \u039b t} -> \\{s : I | \u03c8 s} -> (h s) t) -- third equivalence ( second (fubini I ( 2 * 2 ) \u03c8 (\\{s : I | \u03c8 s} -> BOT ) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT ) (\\{s : I | \u03c8 s} -> \\{t : 2 * 2 | \u039b t} -> A s) (\\{u : I * ( 2 * 2 ) | BOT } -> recBOT ))) In particular, the arrow type of a Segal type is Segal. -- The type of arrows in a type. #def arr -- A type ( A : U ) : U := ( t : \u0394\u00b9) -> A -- For later use, an equivalent characterization of the arrow type. #def Eq-arr ( A : U ) : Equiv (arr A) ( \u03a3 (x : A), ( \u03a3 (y : A), hom A x y)) := ( \\ f -> (f 0_2 , (f 1_2 , f)), ((\\(x, (y, f)) -> f, \\ f -> refl ) , (\\(x, (y, f)) -> f, \\ xyf -> refl ))) -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal'. #def Segal'-arrow-types ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-local-horn-inclusion A) -- A proof that A is-local-horn-inclusion. : is-local-horn-inclusion (arr A) := Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> AisSegal) -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal. #def Segal-arrow-types ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. : is-segal (arr A) := is-segal-is-local-horn-inclusion (arr A) (Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> (is-local-horn-inclusion-is-segal A AisSegal)))","title":"Segal function and extension types"},{"location":"simplicial-hott/05-segal-types.rzk/#identity","text":"All types have identity arrows and witnesses to the identity composition law. x x x -- [RS17, Definition 5.7] -- all types have identity arrows #def id-arr ( A : U ) -- A type. ( x : A) -- A point in A. : hom A x x := \\{t : 2 | \u0394\u00b9 t} -> x Witness for the right identity law: x y y f y f f -- [RS17, Proposition 5.8a] -- the right unit law for identity #def comp-id-witness ( A : U ) -- A type. ( x y : A) -- Two points in A. ( f : hom A x y) -- An arrow from x to y in A. : hom2 A x y y f (id-arr A y) f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f t Witness for the left identity law: x x y x f f f -- [RS17, Proposition 5.8b] -- the left unit law for identity #def id-comp-witness ( A : U ) -- A type. ( x y : A) -- Two points in A. ( f : hom A x y) -- An arrow from x to y in A. : hom2 A x x y (id-arr A x) f f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f s In a Segal type, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. Thus, an identity axiom was not needed in the definition of Segal types. -- If A is Segal then the right unit law holds #def Segal-comp-id ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y : A) -- Two points in A. ( f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x y y f (id-arr A y)) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x y y f (id-arr A y) f (comp-id-witness A x y f) -- If A is Segal then the left unit law holds #def Segal-id-comp ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y : A) -- Two points in A. ( f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x x y (id-arr A x) f) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x x y (id-arr A x) f f (id-comp-witness A x y f)","title":"Identity"},{"location":"simplicial-hott/05-segal-types.rzk/#associativity","text":"We now prove that composition in a Segal type is associative, by using the fact that the type of arrows in a Segal type is itself a Segal type. \u2022 \u2022 \u2022 \u2022 #def unfolding-square ( A : U ) -- A type. ( triangle : \u0394\u00b2 -> A) -- A triangle in A. : \u0394\u00b9\u00d7\u0394\u00b9 -> A -- A square in A, defined by gluing := \\(t, s) -> -- two copies of the triangle along the common diagonal edge. recOR (t <= s |-> triangle (s , t), s <= t |-> triangle (t , s)) For use in the proof of associativity: x y z y f g Segal-comp g f #def Segal-comp-witness-square ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. : \u0394\u00b9\u00d7\u0394\u00b9 -> A := unfolding-square A (Segal-comp-witness A AisSegal x y z f g) The Segal-comp-witness-square as an arrow in the arrow type: x y z y f g #def Segal-arr-in-arr ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) -- Three points in A. ( f : hom A x y) -- An arrow in A from x to y. ( g : hom A y z) -- An arrow in A from y to z. : hom (arr A) f g := \\ t -> \\ s -> (Segal-comp-witness-square A AisSegal x y z f g) (t, s) w x x y y z f g h #def Segal-associativity-witness ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : hom2 (arr A) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h) (Segal-comp (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) := (Segal-comp-witness (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) w x y z g f h -- The Segal-associativity-witness curries to define a diagram \u0394\u00b2\u00d7\u0394\u00b9 -> A. -- The Segal-associativity-tetrahedron is extracted via the middle-simplex map \\((t, s), r) -> ((t, r), s) from \u0394\u00b3 to \u0394\u00b2\u00d7\u0394\u00b9 #def Segal-associativity-tetrahedron ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : \u0394\u00b3 -> A := \\((t, s), r) -> (Segal-associativity-witness extext A AisSegal w x y z f g h) (t, r) s w x y z g f h -- the diagonal composite of three arrows extracted from the Segal-associativity-tetrahedron #def Segal-triple-composite ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : hom A w z := \\ t -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), t) w x y z g f h #def Segal-left-associativity-witness ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : hom2 A w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), s) The front face: w x y z g f h #def Segal-right-associativity-witness ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : hom2 A w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, s), s) #def Segal-left-associativity ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-left-associativity-witness extext A AisSegal w x y z f g h) #def Segal-right-associativity ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-right-associativity-witness extext A AisSegal w x y z f g h) #def Segal-associativity ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y z : A) -- Four points in A. ( f : hom A w x) -- An arrow in A from w to x. ( g : hom A x y) -- An arrow in A from x to y. ( h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) := zig-zag-concat (hom A w z) (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) (Segal-left-associativity extext A AisSegal w x y z f g h) (Segal-right-associativity extext A AisSegal w x y z f g h) #def Segal-postcomp ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : ( z : A) -> (hom A z x) -> (hom A z y) := \\ z -> \\ g -> (Segal-comp A AisSegal z x y g f) #def Segal-precomp ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : ( z : A) -> (hom A y z) -> (hom A x z) := \\ z -> \\ g -> (Segal-comp A AisSegal x y z f g)","title":"Associativity"},{"location":"simplicial-hott/05-segal-types.rzk/#homotopies","text":"We may define a \"homotopy\" to be a path between parallel arrows. In a Segal type, homotopies are equivalent to terms in hom2 types involving an identity arrow. #def homotopy-to-hom2 ( A : U ) ( x y : A) ( f g : hom A x y) ( p : f = g) : (hom2 A x x y (id-arr A x) f g) := idJ (hom A x y, f, \\ g' p' -> (hom2 A x x y (id-arr A x) f g'), (id-comp-witness A x y f), g, p) #def homotopy-to-hom2-total-map ( A : U ) ( x y : A) ( f : hom A x y) : ( \u03a3 (g : hom A x y), f = g) -> ( \u03a3 (g : hom A x y), (hom2 A x x y (id-arr A x) f g)) := \\(g, p) -> (g, homotopy-to-hom2 A x y f g p) #def Segal-homotopy-to-hom2-total-map-is-equiv ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : is-equiv ( \u03a3 (g : hom A x y), f = g) ( \u03a3 (g : hom A x y), (hom2 A x x y (id-arr A x) f g)) (homotopy-to-hom2-total-map A x y f) := areContr-is-equiv ( \u03a3 (g : hom A x y), f = g) ( \u03a3 (g : hom A x y), (hom2 A x x y (id-arr A x) f g)) (is-contr-based-paths (hom A x y) f) (AisSegal x x y (id-arr A x) f) (homotopy-to-hom2-total-map A x y f) -- [RS17, Proposition 5.10] #def Eq-Segal-homotopy-hom2 ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f g : hom A x y) : Equiv (f = g) (hom2 A x x y (id-arr A x) f g) := (homotopy-to-hom2 A x y f g, total-equiv-family-of-equiv (hom A x y) ( \\ g -> (f = g)) ( \\ g -> (hom2 A x x y (id-arr A x) f g)) (homotopy-to-hom2 A x y f) (Segal-homotopy-to-hom2-total-map-is-equiv A AisSegal x y f) g) A dual notion of homotopy can be defined similarly. #def homotopy-to-hom2' ( A : U ) ( x y : A) ( f g : hom A x y) ( p : f = g) : (hom2 A x y y f (id-arr A y) g) := idJ (hom A x y, f, \\ g' p' -> (hom2 A x y y f (id-arr A y) g'), (comp-id-witness A x y f), g, p) #def homotopy-to-hom2'-total-map ( A : U ) ( x y : A) ( f : hom A x y) : ( \u03a3 (g : hom A x y), f = g) -> ( \u03a3 (g : hom A x y), (hom2 A x y y f (id-arr A y) g)) := \\(g, p) -> (g, homotopy-to-hom2' A x y f g p) #def Segal-homotopy-to-hom2'-total-map-is-equiv ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : is-equiv ( \u03a3 (g : hom A x y), f = g) ( \u03a3 (g : hom A x y), (hom2 A x y y f (id-arr A y) g)) (homotopy-to-hom2'-total-map A x y f) := areContr-is-equiv ( \u03a3 (g : hom A x y), f = g) ( \u03a3 (g : hom A x y), (hom2 A x y y f (id-arr A y) g)) (is-contr-based-paths (hom A x y) f) (AisSegal x y y f (id-arr A y)) (homotopy-to-hom2'-total-map A x y f) -- [RS17, Proposition 5.10] #def Eq-Segal-homotopy-hom2' ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f g : hom A x y) : Equiv (f = g) (hom2 A x y y f (id-arr A y) g) := (homotopy-to-hom2' A x y f g, total-equiv-family-of-equiv (hom A x y) ( \\ g -> (f = g)) ( \\ g -> (hom2 A x y y f (id-arr A y) g)) (homotopy-to-hom2' A x y f) (Segal-homotopy-to-hom2'-total-map-is-equiv A AisSegal x y f) g) More generally, a homotopy between a composite and another map is equivalent to the data provided by a commutative triangle with that boundary. #def Segal-eq-to-hom2 ( A : U ) ( AisSegal : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) ( p : (Segal-comp A AisSegal x y z f g) = h) : (hom2 A x y z f g h) := idJ (hom A x z, (Segal-comp A AisSegal x y z f g), \\ h' p' -> (hom2 A x y z f g h'), Segal-comp-witness A AisSegal x y z f g, h, p) #def Segal-eq-to-hom2-total-map ( A : U ) ( AisSegal : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : ( \u03a3 (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) -> ( \u03a3 (h : hom A x z), (hom2 A x y z f g h)) := \\(h, p) -> (h, Segal-eq-to-hom2 A AisSegal x y z f g h p) #def Segal-eq-to-hom2-total-map-is-equiv ( A : U ) ( AisSegal : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : is-equiv ( \u03a3 (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) ( \u03a3 (h : hom A x z), (hom2 A x y z f g h)) (Segal-eq-to-hom2-total-map A AisSegal x y z f g) := areContr-is-equiv ( \u03a3 (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) ( \u03a3 (h : hom A x z), (hom2 A x y z f g h)) (is-contr-based-paths (hom A x z) (Segal-comp A AisSegal x y z f g) ) (AisSegal x y z f g) (Segal-eq-to-hom2-total-map A AisSegal x y z f g) -- [RS17, Proposition 5.12] #def Eq-Segal-eq-hom2 ( A : U ) ( AisSegal : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) : Equiv ((Segal-comp A AisSegal x y z f g) = h) (hom2 A x y z f g h) := (Segal-eq-to-hom2 A AisSegal x y z f g h, total-equiv-family-of-equiv (hom A x z) ( \\ h -> (Segal-comp A AisSegal x y z f g) = h) ( \\ h -> hom2 A x y z f g h) (Segal-eq-to-hom2 A AisSegal x y z f g) (Segal-eq-to-hom2-total-map-is-equiv A AisSegal x y z f g) h) Homotopies form a congruence, meaning that homotopies are respected by composition: -- [RS17, Proposition 5.13] #def Segal-homotopy-congruence ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) ( f g : hom A x y) ( h k : hom A y z) ( p : f = g) ( q : h = k) : (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g k) := idJ (hom A y z, h, \\ k' q' -> (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g k'), idJ (hom A x y, f, \\ g' p' -> (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g' h), refl , g, p) , k, q) -- As a special case of the above: #def Segal-homotopy-postwhisker ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) ( f g : hom A x y) ( h : hom A y z) ( p : f = g) : (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g h) := Segal-homotopy-congruence A AisSegal x y z f g h h p refl -- As a special case of the above: #def Segal-homotopy-prewhisker ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y : A) ( k : hom A w x) ( f g : hom A x y) ( p : f = g) : (Segal-comp A AisSegal w x y k f) = (Segal-comp A AisSegal w x y k g) := Segal-homotopy-congruence A AisSegal w x y k k f g refl p -- [RS17, Proposition 5.14(a)] #def Segal-homotopy-postwhisker-is-ap ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( x y z : A) ( f g : hom A x y) ( h : hom A y z) ( p : f = g) : (Segal-homotopy-postwhisker A AisSegal x y z f g h p) = ap (hom A x y) (hom A x z) f g ( \\ k -> Segal-comp A AisSegal x y z k h) p := idJ (hom A x y, f, \\ g' p' -> (Segal-homotopy-postwhisker A AisSegal x y z f g' h p') = ap (hom A x y) (hom A x z) f g' ( \\ k -> Segal-comp A AisSegal x y z k h) p', refl , g, p) -- [RS17, Proposition 5.14(b)] #def Segal-homotopy-prewhisker-is-ap ( A : U ) -- A type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( w x y : A) ( k : hom A w x) ( f g : hom A x y) ( p : f = g) : (Segal-homotopy-prewhisker A AisSegal w x y k f g p) = ap (hom A x y) (hom A w y) f g (Segal-comp A AisSegal w x y k) p := idJ (hom A x y, f, \\ g' p' -> (Segal-homotopy-prewhisker A AisSegal w x y k f g' p') = ap (hom A x y) (hom A w y) f g' (Segal-comp A AisSegal w x y k) p', refl , g, p) #section is-segal-Unit #variable extext : ExtExt #def iscontr-Unit : is-contr Unit := ( unit , \\ _ -> refl ) #def is-contr-\u0394\u00b2\u2192Unit uses ( extext ) : is-contr (\u0394\u00b2 -> Unit ) := ( \\ _ -> unit , \\ k -> eq-ext-htpy extext ( 2 * 2 ) \u0394\u00b2 ( \\ _ -> BOT ) ( \\ _ -> Unit ) ( \\ _ -> recBOT ) ( \\ _ -> unit ) k ( \\ _ -> refl ) ) #def is-segal-Unit uses ( extext ) : is-segal Unit := \\ x y z f g -> is-retract-of-is-contr-is-contr ( \u03a3 (h : hom Unit x z), hom2 Unit x y z f g h) (\u0394\u00b2 -> Unit ) (\\(_, k) -> k, ( \\ k -> ( \\ t -> k (t, t), k), \\ _ -> refl )) is-contr-\u0394\u00b2\u2192Unit #end is-segal-Unit @import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap); text, textPath { font-family: Noto Serif; font-size: 20px; dominant-baseline: middle; text-anchor: middle; }","title":"Homotopies"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/","text":"The 2-category of Segal types \u00b6 These formalisations correspond to Section 6 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types. Functors \u00b6 Functions between types induce an action on hom types, preserving sources and targets. -- [RS17, Section 6.1] -- Action of maps on homs. Called \"ap-hom\" to avoid conflicting with \"ap\". #def ap-hom ( A B : U ) ( F : A -> B) ( x y : A) ( f : hom A x y) : hom B (F x) (F y) := \\ t -> F (f t) #def ap-hom2 ( A B : U ) ( F : A -> B) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) ( alpha : hom2 A x y z f g h) : hom2 B (F x) (F y) (F z) ( ap-hom A B F x y f) (ap-hom A B F y z g) (ap-hom A B F x z h) := \\ t -> F (alpha t) Functions between types automatically preserve identity arrows. -- [RS17, Proposition 6.1.a] -- Preservation of identities follows from extension extensionality because these arrows are pointwise equal. #def functors-pres-id ( extext : ExtExt) ( A B : U ) ( F : A -> B) ( x : A) : (ap-hom A B F x x (id-arr A x)) = (id-arr B (F x)) := eq-ext-htpy extext 2 \u0394\u00b9 \u2202\u0394\u00b9 ( \\ t -> B) ( \\ t -> recOR ( t === 0_2 |-> F x, t === 1_2 |-> F x)) (ap-hom A B F x x (id-arr A x)) (id-arr B (F x)) ( \\ t -> refl ) -- [RS17, Proposition 6.1.b] -- Preservation of composition requires the Segal hypothesis. #def functors-pres-comp ( A B : U ) ( AisSegal : is-segal A) ( BisSegal : is-segal B) ( F : A -> B) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : ( Segal-comp B BisSegal ( F x) (F y) (F z) ( ap-hom A B F x y f) ( ap-hom A B F y z g)) = ( ap-hom A B F x z (Segal-comp A AisSegal x y z f g)) := Segal-comp-uniqueness B BisSegal ( F x) (F y) (F z) ( ap-hom A B F x y f) ( ap-hom A B F y z g) ( ap-hom A B F x z (Segal-comp A AisSegal x y z f g)) ( ap-hom2 A B F x y z f g ( Segal-comp A AisSegal x y z f g) ( Segal-comp-witness A AisSegal x y z f g)) Natural transformations \u00b6 This corresponds to Section 6.2 in [RS17]. Given two simplicial maps f g : (x : A) -> B x , a natural transformation from f to g is an arrow \u03b7 : hom ((x : A) -> B x) f g between them. #def nat-trans ( A : U ) ( B : A -> U ) ( f g : ( x : A) -> (B x)) : U := hom ( (x : A) -> (B x)) f g Equivalently, natural transformations can be determined by their components , i.e. as a family of arrows (x : A) \u2192 hom (B x) (f x) (g x) . #def nat-trans-components ( A : U ) ( B : A -> U ) ( f g : ( x : A) -> (B x)) : U := ( x : A) -> hom (B x) (f x) (g x) #def ev-components-nat-trans ( A : U ) ( B : A -> U ) ( f g : ( x : A) -> (B x)) ( \u03b7 : nat-trans A B f g) : nat-trans-components A B f g := \\ x t -> \u03b7 t x #def nat-trans-nat-trans-components ( A : U ) ( B : A -> U ) ( f g : ( x : A) -> (B x)) ( \u03b7 : nat-trans-components A B f g) : nat-trans A B f g := \\ t x -> \u03b7 x t Natural transformation extensionality \u00b6 -- [RS17, Proposition 6.3] #def is-equiv-ev-components-nat-trans ( A : U ) ( B : A -> U ) ( f g : ( x : A) -> (B x)) : is-equiv ( nat-trans A B f g) ( nat-trans-components A B f g) ( ev-components-nat-trans A B f g) := ( ( \\ \u03b7 t x -> \u03b7 x t , \\ _ -> refl ) , ( \\ \u03b7 t x -> \u03b7 x t , \\ _ -> refl )) #def equiv-components-nat-trans ( A : U ) ( B : A -> U ) ( f g : ( x : A) -> (B x)) : Equiv (nat-trans A B f g) (nat-trans-components A B f g) := ( ev-components-nat-trans A B f g , is-equiv-ev-components-nat-trans A B f g) Horizontal composition \u00b6 Horizontal composition of natural transformations makes sense over any type. In particular, contrary to what is written in [RS17] we do not need C to be Segal. #def horizontal-comp-nat-trans ( A B C : U ) ( f g : A -> B) ( f' g' : B -> C) ( \u03b7 : nat-trans A ( \\ _ -> B) f g) ( \u03b7' : nat-trans B ( \\ _ -> C) f' g') : nat-trans A ( \\ _ -> C) ( \\ x -> f' (f x)) ( \\ x -> g' (g x)) := \\ t x -> \u03b7' t (\u03b7 t x) #def horizontal-comp-nat-trans-components ( A B C : U ) ( f g : A -> B) ( f' g' : B -> C) ( \u03b7 : nat-trans-components A ( \\ _ -> B) f g) ( \u03b7' : nat-trans-components B ( \\ _ -> C) f' g') : nat-trans-components A ( \\ _ -> C) ( \\ x -> f' (f x)) ( \\ x -> g' (g x)) := \\ x t -> \u03b7' (\u03b7 x t) t Vertical composition \u00b6 We can define vertical composition for natural transformations in families of Segal types. #def vertical-comp-nat-trans-components ( A : U ) ( B : A -> U ) ( BisSegal : ( x : A) -> is-segal (B x)) ( f g h : ( x : A) -> (B x)) ( \u03b7 : nat-trans-components A B f g) ( \u03b7' : nat-trans-components A B g h) : nat-trans-components A B f h := \\ x -> Segal-comp (B x) (BisSegal x) (f x) (g x) (h x) (\u03b7 x) (\u03b7' x) #def vertical-comp-nat-trans ( A : U ) ( B : A -> U ) ( BisSegal : ( x : A) -> is-segal (B x)) ( f g h : ( x : A) -> (B x)) ( \u03b7 : nat-trans A B f g) ( \u03b7' : nat-trans A B g h) : nat-trans A B f h := \\ t x -> vertical-comp-nat-trans-components A B BisSegal f g h ( \\ x' t' -> \u03b7 t' x') ( \\ x' t' -> \u03b7' t' x') ( x) ( t) The identity natural transformation is identity arrows on components -- [RS17, Proposition 6.5(ii)] #def id-arr-components-id-nat-trans ( A : U ) ( B : A -> U ) ( f : ( x : A) -> (B x)) ( a : A) : ( \\ t -> id-arr ((x : A) -> B x) f t a) =_{\u0394\u00b9 -> B a} id-arr (B a) (f a) := refl","title":"2-Category of Segal Types"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#the-2-category-of-segal-types","text":"These formalisations correspond to Section 6 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"The 2-category of Segal types"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#prerequisites","text":"3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types.","title":"Prerequisites"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#functors","text":"Functions between types induce an action on hom types, preserving sources and targets. -- [RS17, Section 6.1] -- Action of maps on homs. Called \"ap-hom\" to avoid conflicting with \"ap\". #def ap-hom ( A B : U ) ( F : A -> B) ( x y : A) ( f : hom A x y) : hom B (F x) (F y) := \\ t -> F (f t) #def ap-hom2 ( A B : U ) ( F : A -> B) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) ( alpha : hom2 A x y z f g h) : hom2 B (F x) (F y) (F z) ( ap-hom A B F x y f) (ap-hom A B F y z g) (ap-hom A B F x z h) := \\ t -> F (alpha t) Functions between types automatically preserve identity arrows. -- [RS17, Proposition 6.1.a] -- Preservation of identities follows from extension extensionality because these arrows are pointwise equal. #def functors-pres-id ( extext : ExtExt) ( A B : U ) ( F : A -> B) ( x : A) : (ap-hom A B F x x (id-arr A x)) = (id-arr B (F x)) := eq-ext-htpy extext 2 \u0394\u00b9 \u2202\u0394\u00b9 ( \\ t -> B) ( \\ t -> recOR ( t === 0_2 |-> F x, t === 1_2 |-> F x)) (ap-hom A B F x x (id-arr A x)) (id-arr B (F x)) ( \\ t -> refl ) -- [RS17, Proposition 6.1.b] -- Preservation of composition requires the Segal hypothesis. #def functors-pres-comp ( A B : U ) ( AisSegal : is-segal A) ( BisSegal : is-segal B) ( F : A -> B) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : ( Segal-comp B BisSegal ( F x) (F y) (F z) ( ap-hom A B F x y f) ( ap-hom A B F y z g)) = ( ap-hom A B F x z (Segal-comp A AisSegal x y z f g)) := Segal-comp-uniqueness B BisSegal ( F x) (F y) (F z) ( ap-hom A B F x y f) ( ap-hom A B F y z g) ( ap-hom A B F x z (Segal-comp A AisSegal x y z f g)) ( ap-hom2 A B F x y z f g ( Segal-comp A AisSegal x y z f g) ( Segal-comp-witness A AisSegal x y z f g))","title":"Functors"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#natural-transformations","text":"This corresponds to Section 6.2 in [RS17]. Given two simplicial maps f g : (x : A) -> B x , a natural transformation from f to g is an arrow \u03b7 : hom ((x : A) -> B x) f g between them. #def nat-trans ( A : U ) ( B : A -> U ) ( f g : ( x : A) -> (B x)) : U := hom ( (x : A) -> (B x)) f g Equivalently, natural transformations can be determined by their components , i.e. as a family of arrows (x : A) \u2192 hom (B x) (f x) (g x) . #def nat-trans-components ( A : U ) ( B : A -> U ) ( f g : ( x : A) -> (B x)) : U := ( x : A) -> hom (B x) (f x) (g x) #def ev-components-nat-trans ( A : U ) ( B : A -> U ) ( f g : ( x : A) -> (B x)) ( \u03b7 : nat-trans A B f g) : nat-trans-components A B f g := \\ x t -> \u03b7 t x #def nat-trans-nat-trans-components ( A : U ) ( B : A -> U ) ( f g : ( x : A) -> (B x)) ( \u03b7 : nat-trans-components A B f g) : nat-trans A B f g := \\ t x -> \u03b7 x t","title":"Natural transformations"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#natural-transformation-extensionality","text":"-- [RS17, Proposition 6.3] #def is-equiv-ev-components-nat-trans ( A : U ) ( B : A -> U ) ( f g : ( x : A) -> (B x)) : is-equiv ( nat-trans A B f g) ( nat-trans-components A B f g) ( ev-components-nat-trans A B f g) := ( ( \\ \u03b7 t x -> \u03b7 x t , \\ _ -> refl ) , ( \\ \u03b7 t x -> \u03b7 x t , \\ _ -> refl )) #def equiv-components-nat-trans ( A : U ) ( B : A -> U ) ( f g : ( x : A) -> (B x)) : Equiv (nat-trans A B f g) (nat-trans-components A B f g) := ( ev-components-nat-trans A B f g , is-equiv-ev-components-nat-trans A B f g)","title":"Natural transformation extensionality"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#horizontal-composition","text":"Horizontal composition of natural transformations makes sense over any type. In particular, contrary to what is written in [RS17] we do not need C to be Segal. #def horizontal-comp-nat-trans ( A B C : U ) ( f g : A -> B) ( f' g' : B -> C) ( \u03b7 : nat-trans A ( \\ _ -> B) f g) ( \u03b7' : nat-trans B ( \\ _ -> C) f' g') : nat-trans A ( \\ _ -> C) ( \\ x -> f' (f x)) ( \\ x -> g' (g x)) := \\ t x -> \u03b7' t (\u03b7 t x) #def horizontal-comp-nat-trans-components ( A B C : U ) ( f g : A -> B) ( f' g' : B -> C) ( \u03b7 : nat-trans-components A ( \\ _ -> B) f g) ( \u03b7' : nat-trans-components B ( \\ _ -> C) f' g') : nat-trans-components A ( \\ _ -> C) ( \\ x -> f' (f x)) ( \\ x -> g' (g x)) := \\ x t -> \u03b7' (\u03b7 x t) t","title":"Horizontal composition"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#vertical-composition","text":"We can define vertical composition for natural transformations in families of Segal types. #def vertical-comp-nat-trans-components ( A : U ) ( B : A -> U ) ( BisSegal : ( x : A) -> is-segal (B x)) ( f g h : ( x : A) -> (B x)) ( \u03b7 : nat-trans-components A B f g) ( \u03b7' : nat-trans-components A B g h) : nat-trans-components A B f h := \\ x -> Segal-comp (B x) (BisSegal x) (f x) (g x) (h x) (\u03b7 x) (\u03b7' x) #def vertical-comp-nat-trans ( A : U ) ( B : A -> U ) ( BisSegal : ( x : A) -> is-segal (B x)) ( f g h : ( x : A) -> (B x)) ( \u03b7 : nat-trans A B f g) ( \u03b7' : nat-trans A B g h) : nat-trans A B f h := \\ t x -> vertical-comp-nat-trans-components A B BisSegal f g h ( \\ x' t' -> \u03b7 t' x') ( \\ x' t' -> \u03b7' t' x') ( x) ( t) The identity natural transformation is identity arrows on components -- [RS17, Proposition 6.5(ii)] #def id-arr-components-id-nat-trans ( A : U ) ( B : A -> U ) ( f : ( x : A) -> (B x)) ( a : A) : ( \\ t -> id-arr ((x : A) -> B x) f t a) =_{\u0394\u00b9 -> B a} id-arr (B a) (f a) := refl","title":"Vertical composition"},{"location":"simplicial-hott/07-discrete.rzk/","text":"Discrete types \u00b6 These formalisations correspond to Section 7 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 hott/1-paths.md - We require basic path algebra. hott/4-equivalences.md - We require the notion of equivalence between types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types. The definition \u00b6 Discrete types are types in which the hom-types are canonically equivalent to identity types. -- [RS17, Definition 7.1] #def arr-eq ( A : U ) -- A type. ( x y : A) -- Two points of type A. ( p : x = y) -- A path p from x to y in A. : hom A x y -- An arrow p from x to y in A. := idJ (A, x, \\ y' -> \\ p' -> hom A x y', (id-arr A x), y, p) #def is-discrete ( A : U ) -- A type. : U := ( x : A) -> ( y : A) -> is-equiv (x =_{A} y) (hom A x y) (arr-eq A x y) Families of discrete types \u00b6 By function extensionality, the dependent function type associated to a family of discrete types is discrete. #def equiv-discrete-family ( funext : FunExt) ( X : U ) ( A : X -> U ) ( Aisdiscrete : ( x : X) -> is-discrete (A x)) ( f g : ( x : X) -> A x) : Equiv (f = g) ( hom ((x : X) -> A x) f g) := triple-comp-equiv ( f = g) ( (x : X) -> f x = g x) ( (x : X) -> hom (A x) (f x) (g x)) ( hom ((x : X) -> A x) f g) ( FunExt-equiv funext X A f g) ( function-equiv-fibered-equiv funext X ( \\ x -> (f x = g x))( \\ x -> hom (A x) (f x) (g x)) ( \\ x -> (arr-eq (A x) (f x) (g x),(Aisdiscrete x (f x) (g x))))) (flip-ext-fun-inv 2 \u0394\u00b9 \u2202\u0394\u00b9 X ( \\ t x -> A x) ( \\ t x -> recOR (t === 0_2 |-> f x, t === 1_2 |-> g x))) #def equiv-discrete-family-map ( funext : FunExt) ( X : U ) ( A : X -> U ) ( Aisdiscrete : ( x : X) -> is-discrete (A x)) ( f g : ( x : X) -> A x) ( h : f = g) : arr-eq ( (x : X) -> A x) f g h = ( first (equiv-discrete-family funext X A Aisdiscrete f g)) h := idJ ( (x : X) -> A x, f, \\ g' h' -> arr-eq ( (x : X) -> A x) f g' h' = ( first (equiv-discrete-family funext X A Aisdiscrete f g')) h', refl , g, h) -- [RS17, Proposition 7.2] #def is-discrete-dependent-function-discrete-family ( funext : FunExt) ( X : U ) ( A : X -> U ) ( Aisdiscrete : ( x : X) -> is-discrete (A x)) : is-discrete ( (x : X) -> A x) := \\ f g -> is-equiv-homotopic-is-equiv ( f = g) ( hom ((x : X) -> A x) f g) ( arr-eq ((x : X) -> A x) f g) ( first (equiv-discrete-family funext X A Aisdiscrete f g)) ( equiv-discrete-family-map funext X A Aisdiscrete f g) ( second (equiv-discrete-family funext X A Aisdiscrete f g)) By extension extensionality, an extension type into a family of discrete types is discrete. Sinced fibered-Eq-extension-Equiv considers total extension types only, extending from BOT, that's all we prove here for now. #def Eq-discrete-extension ( extext : ExtExt) -- This proof uses extension extensionality. ( I : CUBE ) -- A cube. ( \u03c8 : I -> TOPE ) -- A tope. ( A : \u03c8 -> U ) -- A type family over the tope. ( Aisdiscrete : ( t : \u03c8) -> is-discrete (A t)) ( f g : ( t : \u03c8) -> A t) -- A pair of elements of the extension type : Equiv (f = g) ( hom ((t : \u03c8) -> A t) f g) := triple-comp-equiv ( f = g) ( (t : \u03c8) -> f t = g t) ( (t : \u03c8) -> hom (A t) (f t) (g t)) ( hom ((t : \u03c8) -> A t) f g) ( ExtExtEquiv extext I \u03c8 ( \\ t -> BOT ) A ( \\ u -> recBOT ) f g) ( fibered-Eq-extension-Equiv extext I \u03c8 ( \\ t -> f t = g t) ( \\ t -> hom (A t)(f t)(g t)) ( \\ t -> (arr-eq (A t) (f t) (g t), (Aisdiscrete t (f t)(g t))))) ( fubini I 2 \u03c8 ( \\ t -> BOT ) \u0394\u00b9 \u2202\u0394\u00b9 ( \\ t s -> A t) ( \\ (t, s) -> recOR (s === 0_2 |-> f t, s === 1_2 |-> g t))) #def Eq-discrete-extension-map ( extext : ExtExt) -- This proof uses extension extensionality. ( I : CUBE ) -- A cube. ( \u03c8 : ( t : I) -> TOPE ) -- A tope. ( A : \u03c8 -> U ) -- A type family over the tope. ( Aisdiscrete : ( t : \u03c8) -> is-discrete (A t)) ( f g : ( t : \u03c8) -> A t) -- A pair of elements of the extension type ( h : f = g) : arr-eq ( (t : \u03c8) -> A t) f g h = ( first (Eq-discrete-extension extext I \u03c8 A Aisdiscrete f g)) h := idJ ( (t : \u03c8) -> A t, f, \\ g' h' -> arr-eq ( (t : \u03c8) -> A t) f g' h' = ( first (Eq-discrete-extension extext I \u03c8 A Aisdiscrete f g')) h', refl , g, h) -- [RS17, Proposition 7.2, for extension types] #def is-discrete-extension-family ( extext : ExtExt) -- This proof uses extension extensionality. ( I : CUBE ) -- A cube. ( \u03c8 : ( t : I) -> TOPE ) -- A tope. ( A : \u03c8 -> U ) -- A type family over the tope. ( Aisdiscrete : ( t : \u03c8) -> is-discrete (A t)) : is-discrete ( (t : \u03c8) -> A t) := \\ f g -> is-equiv-homotopic-is-equiv ( f = g) ( hom ((t : \u03c8) -> A t) f g) ( arr-eq ((t : \u03c8) -> A t) f g) ( first (Eq-discrete-extension extext I \u03c8 A Aisdiscrete f g)) ( Eq-discrete-extension-map extext I \u03c8 A Aisdiscrete f g) ( second (Eq-discrete-extension extext I \u03c8 A Aisdiscrete f g)) For instance, the arrow type of a discrete type is discrete. #def is-discrete-arr-is-discrete ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( Aisdiscrete : is-discrete A) : is-discrete (arr A) := is-discrete-extension-family extext 2 \u0394\u00b9 ( \\ t -> A)( \\ t -> Aisdiscrete) Discrete types are Segal types \u00b6 Discrete types are automatically Segal types. #section discrete-arr-equivalences #variable extext : ExtExt #variable A : U #variable Aisdiscrete : is-discrete A #variables x y z w : A #variable f : hom A x y #variable g : hom A z w #def is-equiv-arr-eq-discrete uses ( x y z w ) : is-equiv (f =_{\u0394\u00b9 -> A} g)(hom (arr A) f g)(arr-eq (arr A) f g) := (is-discrete-arr-is-discrete extext A Aisdiscrete) f g #def equiv-arr-eq-discrete uses ( x y z w ) : Equiv (f =_{\u0394\u00b9 -> A} g)(hom (arr A) f g) := (arr-eq (arr A) f g, (is-discrete-arr-is-discrete extext A Aisdiscrete) f g) #def equiv-square-hom-arr : Equiv (hom (arr A) f g) ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) := ( \\ \u03b1 -> ( \\ t -> \u03b1 t 0_2 , ( \\ t -> \u03b1 t 1_2 , \\(t, s) -> \u03b1 t s)), ( ( \\ \u03c3 -> \\ t -> \\ s -> ( second ( second \u03c3)) (t, s), \\ \u03b1 -> refl ), ( \\ \u03c3 -> \\ t -> \\ s -> ( second ( second \u03c3)) (t, s), \\ \u03c3 -> refl ))) -- The equivalence underlying Eq-arr. #def fibered-arr-free-arr : (arr A) -> ( \u2211 (x : A), ( \u2211 (y : A), hom A x y)) := \\ k -> (k 0_2 , (k 1_2 , k)) #def id-equiv-Eq-arr uses ( w x y z ) : is-equiv ( f =_{\u0394\u00b9 -> A} g) ( fibered-arr-free-arr f = fibered-arr-free-arr g) ( ap (arr A) ( \u2211 (u : A), ( \u2211 (v : A), hom A u v)) f g fibered-arr-free-arr) := is-equiv-ap-is-equiv ( arr A) ( \u2211 (u : A), ( \u2211 (v : A), hom A u v)) fibered-arr-free-arr ( second (Eq-arr A)) f g #def id-Eq-Eq-arr uses ( w x y z ) : Equiv (f =_{\u0394\u00b9 -> A} g) (fibered-arr-free-arr f = fibered-arr-free-arr g) := Eq-ap-is-equiv ( arr A) ( \u2211 (u : A), ( \u2211 (v : A), hom A u v)) fibered-arr-free-arr ( second (Eq-arr A)) f g #def equiv-sigma-over-prod-arr-eq : Equiv (fibered-arr-free-arr f = fibered-arr-free-arr g) ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g))) := Eq-sigma-over-prod-equiv A A ( \\ u v -> hom A u v) ( fibered-arr-free-arr f) ( fibered-arr-free-arr g) #def equiv-square-sigma-over-prod uses ( extext Aisdiscrete ) : Equiv ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g))) ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) := left-cancel-equiv ( f =_{\u0394\u00b9 -> A} g) ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g))) ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) ( comp-equiv ( f =_{\u0394\u00b9 -> A} g) ( fibered-arr-free-arr f = fibered-arr-free-arr g) ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g))) id-Eq-Eq-arr equiv-sigma-over-prod-arr-eq) ( comp-equiv ( f =_{\u0394\u00b9 -> A} g) ( hom (arr A) f g) ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) equiv-arr-eq-discrete equiv-square-hom-arr) #end discrete-arr-equivalences -- closing the section so I can use path induction #def fibered-map-square-sigma-over-prod ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y z w : A) ( f : hom A x y) ( p : x = z) ( q : y = w) : ( g : hom A z w) -> (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g) -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> (arr-eq A x z p) t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> (arr-eq A y w q) t ]>) := idJ ( A, x, \\ z' p' -> (g : hom A z' w) -> (prod-transport A A ( \\ a b -> hom A a b) x z' y w p' q f = g) -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> (arr-eq A x z' p') t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> (arr-eq A y w q) t ]>), idJ ( A, y, \\ w' q' -> (g : hom A x w') -> (prod-transport A A ( \\ a b -> hom A a b) x x y w' refl q' f = g) -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> (arr-eq A y w' q') t ]>), \\ g \u03c4 -> idJ ( hom A x y, f, \\ g' \u03c4' -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g' s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>), \\ (t , s) -> f s, g, \u03c4), w, q), z, p) #def square-sigma-over-prod ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y z w : A) ( f : hom A x y) ( g : hom A z w) ((p, (q, \u03c4)) : ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g)))) : ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) := ( arr-eq A x z p, ( arr-eq A y w q, fibered-map-square-sigma-over-prod extext A Aisdiscrete x y z w f p q g \u03c4)) #def refl-refl-map-equiv-square-sigma-over-prod ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y : A) ( f g : hom A x y) ( \u03c4 : prod-transport A A ( \\ a b -> hom A a b) x x y y refl refl f = g) : ( first (equiv-square-sigma-over-prod extext A Aisdiscrete x y x y f g)) ( refl , ( refl , \u03c4)) = (square-sigma-over-prod extext A Aisdiscrete x y x y f g) ( refl , ( refl , \u03c4)) := idJ ( hom A x y, f, \\ g' \u03c4' -> ( first (equiv-square-sigma-over-prod extext A Aisdiscrete x y x y f g')) ( refl , ( refl , \u03c4')) = (square-sigma-over-prod extext A Aisdiscrete x y x y f g') ( refl , ( refl , \u03c4')), refl , g, \u03c4) #def map-equiv-square-sigma-over-prod ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y z w : A) ( f : hom A x y) ( p : x = z) ( q : y = w) : ( g : hom A z w) -> ( \u03c4 : prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g) -> ( first (equiv-square-sigma-over-prod extext A Aisdiscrete x y z w f g)) (p, (q, \u03c4)) = (square-sigma-over-prod extext A Aisdiscrete x y z w f g) (p, (q, \u03c4)) := idJ ( A, y, \\ w' q' -> (g : hom A z w') -> ( \u03c4 : prod-transport A A ( \\ a b -> hom A a b) x z y w' p q' f = g) -> ( first (equiv-square-sigma-over-prod extext A Aisdiscrete x y z w' f g)) (p, (q', \u03c4)) = (square-sigma-over-prod extext A Aisdiscrete x y z w' f g) (p, (q', \u03c4)), idJ ( A, x, \\ z' p' -> (g : hom A z' y) -> ( \u03c4 : prod-transport A A ( \\ a b -> hom A a b) x z' y y p' refl f = g) -> ( first (equiv-square-sigma-over-prod extext A Aisdiscrete x y z' y f g)) (p', ( refl , \u03c4)) = (square-sigma-over-prod extext A Aisdiscrete x y z' y f g) (p', ( refl , \u03c4)), \\ g \u03c4 -> refl-refl-map-equiv-square-sigma-over-prod extext A Aisdiscrete x y f g \u03c4, z, p), w, q) #def is-equiv-square-sigma-over-prod ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y z w : A) ( f : hom A x y) ( g : hom A z w) : is-equiv ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g))) ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) (square-sigma-over-prod extext A Aisdiscrete x y z w f g) := is-equiv-rev-homotopic-is-equiv ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g))) ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) ( first (equiv-square-sigma-over-prod extext A Aisdiscrete x y z w f g)) ( square-sigma-over-prod extext A Aisdiscrete x y z w f g) ( \\ (p, (q, \u03c4)) -> map-equiv-square-sigma-over-prod extext A Aisdiscrete x y z w f p q g \u03c4) ( second (equiv-square-sigma-over-prod extext A Aisdiscrete x y z w f g)) #def is-equiv-fibered-map-square-sigma-over-prod ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y z w : A) ( f : hom A x y) ( g : hom A z w) ( p : x = z) ( q : y = w) : is-equiv (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> (arr-eq A x z p) t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> (arr-eq A y w q) t ]>) (fibered-map-square-sigma-over-prod extext A Aisdiscrete x y z w f p q g) := fibered-map-is-equiv-bases-are-equiv-total-map-is-equiv ( x = z) ( hom A x z) ( y = w) ( hom A y w) ( \\ p' q' -> (prod-transport A A ( \\ a b -> hom A a b) x z y w p' q' f = g)) ( \\ h' k' -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h' t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k' t ]>)) ( arr-eq A x z) ( arr-eq A y w) ( \\ p' q' -> (fibered-map-square-sigma-over-prod extext A Aisdiscrete x y z w f p' q' g)) ( is-equiv-square-sigma-over-prod extext A Aisdiscrete x y z w f g) ( Aisdiscrete x z) ( Aisdiscrete y w) p q #def is-equiv-fibered-map-square-sigma-over-prod-refl-refl ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y : A) ( f : hom A x y) ( g : hom A x y) : is-equiv (f = g) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) (fibered-map-square-sigma-over-prod extext A Aisdiscrete x y x y f refl refl g) := is-equiv-fibered-map-square-sigma-over-prod extext A Aisdiscrete x y x y f g refl refl The previous calculations allow us to establish a family of equivalences: #def is-equiv-sum-fibered-map-square-sigma-over-prod-refl-refl ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y : A) ( f : hom A x y) : is-equiv ( \u2211 (g : hom A x y), f = g) ( \u2211 (g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) ( total-map-family-of-maps ( hom A x y) ( \\ g -> f = g) ( \\ g -> <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) ( \\ g -> (fibered-map-square-sigma-over-prod extext A Aisdiscrete x y x y f refl refl g))) := family-of-equiv-total-equiv ( hom A x y) ( \\ g -> f = g) ( \\ g -> <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) ( \\ g -> (fibered-map-square-sigma-over-prod extext A Aisdiscrete x y x y f refl refl g)) ( \\ g -> is-equiv-fibered-map-square-sigma-over-prod-refl-refl extext A Aisdiscrete x y f g) #def equiv-sum-fibered-map-square-sigma-over-prod-refl-refl ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y : A) ( f : hom A x y) : Equiv ( \u2211 (g : hom A x y), f = g) ( \u2211 (g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) := ( ( total-map-family-of-maps ( hom A x y) ( \\ g -> f = g) ( \\ g -> <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) ( \\ g -> (fibered-map-square-sigma-over-prod extext A Aisdiscrete x y x y f refl refl g))), is-equiv-sum-fibered-map-square-sigma-over-prod-refl-refl extext A Aisdiscrete x y f) Now using the equivalence on total spaces and the contractibility of based path spaces, we conclude that the codomain extension type is contractible. #def is-contr-horn-refl-refl-extension-type ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y : A) ( f : hom A x y) : is-contr ( \u2211 (g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) := is-contr-is-equiv-from-contr ( \u2211 (g : hom A x y), f = g) ( \u2211 (g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) ( equiv-sum-fibered-map-square-sigma-over-prod-refl-refl extext A Aisdiscrete x y f) ( is-contr-based-paths (hom A x y) f) The extension types that appear in the Segal condition are retracts of this type --- at least when the second arrow in the composable pair is an identity. #def triangle-to-square-section ( A : U ) ( x y : A) ( f g : hom A x y) ( \u03b1 : hom2 A x y y f (id-arr A y) g) : <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]> := \\ (t, s) -> recOR (t <= s |-> \u03b1 (s, t), s <= t |-> g s) #def sigma-triangle-to-sigma-square-section ( A : U ) ( x y : A) ( f : hom A x y) ((d, \u03b1) : \u2211 ( d : hom A x y), hom2 A x y y f (id-arr A y) d) : \u2211 ( g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]> := (d, triangle-to-square-section A x y f d \u03b1) #def sigma-square-to-sigma-triangle-retraction ( A : U ) ( x y : A) ( f : hom A x y) ((g, \u03c3) : \u2211 ( g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) : \u2211 ( d : hom A x y), hom2 A x y y f (id-arr A y) d := ( \\ t -> \u03c3 (t, t), \\ (t, s) -> \u03c3 (s, t)) #def sigma-triangle-to-sigma-square-retract ( A : U ) ( x y : A) ( f : hom A x y) : is-retract-of ( \u2211 (d : hom A x y), hom2 A x y y f (id-arr A y) d) ( \u2211 (g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) := ( sigma-triangle-to-sigma-square-section A x y f, ( sigma-square-to-sigma-triangle-retraction A x y f , \\ d\u03b1 -> refl )) We can now verify the Segal condition in the case of composable pairs in which the second arrow is an identity. #def is-contr-hom2-with-id-is-discrete ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y : A) ( f : hom A x y) : is-contr ( \u2211 (d : hom A x y), hom2 A x y y f (id-arr A y) d) := is-retract-of-is-contr-is-contr ( \u2211 (d : hom A x y), hom2 A x y y f (id-arr A y) d) ( \u2211 (g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) ( sigma-triangle-to-sigma-square-retract A x y f) ( is-contr-horn-refl-refl-extension-type extext A Aisdiscrete x y f) But since A is discrete, its hom type family is equivalent to its identity type family, and we can use \"path induction\" over arrows to reduce the general case to the one just proven: #def is-contr-hom2-is-discrete ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : is-contr ( \u2211 (h : hom A x z), hom2 A x y z f g h) := ind-based-path A y ( \\ w -> hom A y w) ( \\ w -> arr-eq A y w) ( Aisdiscrete y) ( \\ w d -> is-contr ( \u2211 (h : hom A x w), hom2 A x y w f d h)) ( is-contr-hom2-with-id-is-discrete extext A Aisdiscrete x y f) ( z) ( g) Finally, we conclude: -- [RS, Proposition 7.3] #def is-segal-is-discrete ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) : is-segal A := \\ x y z f g -> is-contr-hom2-is-discrete extext A Aisdiscrete x y z f g","title":"Discrete Types"},{"location":"simplicial-hott/07-discrete.rzk/#discrete-types","text":"These formalisations correspond to Section 7 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Discrete types"},{"location":"simplicial-hott/07-discrete.rzk/#prerequisites","text":"hott/1-paths.md - We require basic path algebra. hott/4-equivalences.md - We require the notion of equivalence between types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types.","title":"Prerequisites"},{"location":"simplicial-hott/07-discrete.rzk/#the-definition","text":"Discrete types are types in which the hom-types are canonically equivalent to identity types. -- [RS17, Definition 7.1] #def arr-eq ( A : U ) -- A type. ( x y : A) -- Two points of type A. ( p : x = y) -- A path p from x to y in A. : hom A x y -- An arrow p from x to y in A. := idJ (A, x, \\ y' -> \\ p' -> hom A x y', (id-arr A x), y, p) #def is-discrete ( A : U ) -- A type. : U := ( x : A) -> ( y : A) -> is-equiv (x =_{A} y) (hom A x y) (arr-eq A x y)","title":"The definition"},{"location":"simplicial-hott/07-discrete.rzk/#families-of-discrete-types","text":"By function extensionality, the dependent function type associated to a family of discrete types is discrete. #def equiv-discrete-family ( funext : FunExt) ( X : U ) ( A : X -> U ) ( Aisdiscrete : ( x : X) -> is-discrete (A x)) ( f g : ( x : X) -> A x) : Equiv (f = g) ( hom ((x : X) -> A x) f g) := triple-comp-equiv ( f = g) ( (x : X) -> f x = g x) ( (x : X) -> hom (A x) (f x) (g x)) ( hom ((x : X) -> A x) f g) ( FunExt-equiv funext X A f g) ( function-equiv-fibered-equiv funext X ( \\ x -> (f x = g x))( \\ x -> hom (A x) (f x) (g x)) ( \\ x -> (arr-eq (A x) (f x) (g x),(Aisdiscrete x (f x) (g x))))) (flip-ext-fun-inv 2 \u0394\u00b9 \u2202\u0394\u00b9 X ( \\ t x -> A x) ( \\ t x -> recOR (t === 0_2 |-> f x, t === 1_2 |-> g x))) #def equiv-discrete-family-map ( funext : FunExt) ( X : U ) ( A : X -> U ) ( Aisdiscrete : ( x : X) -> is-discrete (A x)) ( f g : ( x : X) -> A x) ( h : f = g) : arr-eq ( (x : X) -> A x) f g h = ( first (equiv-discrete-family funext X A Aisdiscrete f g)) h := idJ ( (x : X) -> A x, f, \\ g' h' -> arr-eq ( (x : X) -> A x) f g' h' = ( first (equiv-discrete-family funext X A Aisdiscrete f g')) h', refl , g, h) -- [RS17, Proposition 7.2] #def is-discrete-dependent-function-discrete-family ( funext : FunExt) ( X : U ) ( A : X -> U ) ( Aisdiscrete : ( x : X) -> is-discrete (A x)) : is-discrete ( (x : X) -> A x) := \\ f g -> is-equiv-homotopic-is-equiv ( f = g) ( hom ((x : X) -> A x) f g) ( arr-eq ((x : X) -> A x) f g) ( first (equiv-discrete-family funext X A Aisdiscrete f g)) ( equiv-discrete-family-map funext X A Aisdiscrete f g) ( second (equiv-discrete-family funext X A Aisdiscrete f g)) By extension extensionality, an extension type into a family of discrete types is discrete. Sinced fibered-Eq-extension-Equiv considers total extension types only, extending from BOT, that's all we prove here for now. #def Eq-discrete-extension ( extext : ExtExt) -- This proof uses extension extensionality. ( I : CUBE ) -- A cube. ( \u03c8 : I -> TOPE ) -- A tope. ( A : \u03c8 -> U ) -- A type family over the tope. ( Aisdiscrete : ( t : \u03c8) -> is-discrete (A t)) ( f g : ( t : \u03c8) -> A t) -- A pair of elements of the extension type : Equiv (f = g) ( hom ((t : \u03c8) -> A t) f g) := triple-comp-equiv ( f = g) ( (t : \u03c8) -> f t = g t) ( (t : \u03c8) -> hom (A t) (f t) (g t)) ( hom ((t : \u03c8) -> A t) f g) ( ExtExtEquiv extext I \u03c8 ( \\ t -> BOT ) A ( \\ u -> recBOT ) f g) ( fibered-Eq-extension-Equiv extext I \u03c8 ( \\ t -> f t = g t) ( \\ t -> hom (A t)(f t)(g t)) ( \\ t -> (arr-eq (A t) (f t) (g t), (Aisdiscrete t (f t)(g t))))) ( fubini I 2 \u03c8 ( \\ t -> BOT ) \u0394\u00b9 \u2202\u0394\u00b9 ( \\ t s -> A t) ( \\ (t, s) -> recOR (s === 0_2 |-> f t, s === 1_2 |-> g t))) #def Eq-discrete-extension-map ( extext : ExtExt) -- This proof uses extension extensionality. ( I : CUBE ) -- A cube. ( \u03c8 : ( t : I) -> TOPE ) -- A tope. ( A : \u03c8 -> U ) -- A type family over the tope. ( Aisdiscrete : ( t : \u03c8) -> is-discrete (A t)) ( f g : ( t : \u03c8) -> A t) -- A pair of elements of the extension type ( h : f = g) : arr-eq ( (t : \u03c8) -> A t) f g h = ( first (Eq-discrete-extension extext I \u03c8 A Aisdiscrete f g)) h := idJ ( (t : \u03c8) -> A t, f, \\ g' h' -> arr-eq ( (t : \u03c8) -> A t) f g' h' = ( first (Eq-discrete-extension extext I \u03c8 A Aisdiscrete f g')) h', refl , g, h) -- [RS17, Proposition 7.2, for extension types] #def is-discrete-extension-family ( extext : ExtExt) -- This proof uses extension extensionality. ( I : CUBE ) -- A cube. ( \u03c8 : ( t : I) -> TOPE ) -- A tope. ( A : \u03c8 -> U ) -- A type family over the tope. ( Aisdiscrete : ( t : \u03c8) -> is-discrete (A t)) : is-discrete ( (t : \u03c8) -> A t) := \\ f g -> is-equiv-homotopic-is-equiv ( f = g) ( hom ((t : \u03c8) -> A t) f g) ( arr-eq ((t : \u03c8) -> A t) f g) ( first (Eq-discrete-extension extext I \u03c8 A Aisdiscrete f g)) ( Eq-discrete-extension-map extext I \u03c8 A Aisdiscrete f g) ( second (Eq-discrete-extension extext I \u03c8 A Aisdiscrete f g)) For instance, the arrow type of a discrete type is discrete. #def is-discrete-arr-is-discrete ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( Aisdiscrete : is-discrete A) : is-discrete (arr A) := is-discrete-extension-family extext 2 \u0394\u00b9 ( \\ t -> A)( \\ t -> Aisdiscrete)","title":"Families of discrete types"},{"location":"simplicial-hott/07-discrete.rzk/#discrete-types-are-segal-types","text":"Discrete types are automatically Segal types. #section discrete-arr-equivalences #variable extext : ExtExt #variable A : U #variable Aisdiscrete : is-discrete A #variables x y z w : A #variable f : hom A x y #variable g : hom A z w #def is-equiv-arr-eq-discrete uses ( x y z w ) : is-equiv (f =_{\u0394\u00b9 -> A} g)(hom (arr A) f g)(arr-eq (arr A) f g) := (is-discrete-arr-is-discrete extext A Aisdiscrete) f g #def equiv-arr-eq-discrete uses ( x y z w ) : Equiv (f =_{\u0394\u00b9 -> A} g)(hom (arr A) f g) := (arr-eq (arr A) f g, (is-discrete-arr-is-discrete extext A Aisdiscrete) f g) #def equiv-square-hom-arr : Equiv (hom (arr A) f g) ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) := ( \\ \u03b1 -> ( \\ t -> \u03b1 t 0_2 , ( \\ t -> \u03b1 t 1_2 , \\(t, s) -> \u03b1 t s)), ( ( \\ \u03c3 -> \\ t -> \\ s -> ( second ( second \u03c3)) (t, s), \\ \u03b1 -> refl ), ( \\ \u03c3 -> \\ t -> \\ s -> ( second ( second \u03c3)) (t, s), \\ \u03c3 -> refl ))) -- The equivalence underlying Eq-arr. #def fibered-arr-free-arr : (arr A) -> ( \u2211 (x : A), ( \u2211 (y : A), hom A x y)) := \\ k -> (k 0_2 , (k 1_2 , k)) #def id-equiv-Eq-arr uses ( w x y z ) : is-equiv ( f =_{\u0394\u00b9 -> A} g) ( fibered-arr-free-arr f = fibered-arr-free-arr g) ( ap (arr A) ( \u2211 (u : A), ( \u2211 (v : A), hom A u v)) f g fibered-arr-free-arr) := is-equiv-ap-is-equiv ( arr A) ( \u2211 (u : A), ( \u2211 (v : A), hom A u v)) fibered-arr-free-arr ( second (Eq-arr A)) f g #def id-Eq-Eq-arr uses ( w x y z ) : Equiv (f =_{\u0394\u00b9 -> A} g) (fibered-arr-free-arr f = fibered-arr-free-arr g) := Eq-ap-is-equiv ( arr A) ( \u2211 (u : A), ( \u2211 (v : A), hom A u v)) fibered-arr-free-arr ( second (Eq-arr A)) f g #def equiv-sigma-over-prod-arr-eq : Equiv (fibered-arr-free-arr f = fibered-arr-free-arr g) ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g))) := Eq-sigma-over-prod-equiv A A ( \\ u v -> hom A u v) ( fibered-arr-free-arr f) ( fibered-arr-free-arr g) #def equiv-square-sigma-over-prod uses ( extext Aisdiscrete ) : Equiv ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g))) ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) := left-cancel-equiv ( f =_{\u0394\u00b9 -> A} g) ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g))) ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) ( comp-equiv ( f =_{\u0394\u00b9 -> A} g) ( fibered-arr-free-arr f = fibered-arr-free-arr g) ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g))) id-Eq-Eq-arr equiv-sigma-over-prod-arr-eq) ( comp-equiv ( f =_{\u0394\u00b9 -> A} g) ( hom (arr A) f g) ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) equiv-arr-eq-discrete equiv-square-hom-arr) #end discrete-arr-equivalences -- closing the section so I can use path induction #def fibered-map-square-sigma-over-prod ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y z w : A) ( f : hom A x y) ( p : x = z) ( q : y = w) : ( g : hom A z w) -> (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g) -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> (arr-eq A x z p) t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> (arr-eq A y w q) t ]>) := idJ ( A, x, \\ z' p' -> (g : hom A z' w) -> (prod-transport A A ( \\ a b -> hom A a b) x z' y w p' q f = g) -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> (arr-eq A x z' p') t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> (arr-eq A y w q) t ]>), idJ ( A, y, \\ w' q' -> (g : hom A x w') -> (prod-transport A A ( \\ a b -> hom A a b) x x y w' refl q' f = g) -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> (arr-eq A y w' q') t ]>), \\ g \u03c4 -> idJ ( hom A x y, f, \\ g' \u03c4' -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g' s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>), \\ (t , s) -> f s, g, \u03c4), w, q), z, p) #def square-sigma-over-prod ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y z w : A) ( f : hom A x y) ( g : hom A z w) ((p, (q, \u03c4)) : ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g)))) : ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) := ( arr-eq A x z p, ( arr-eq A y w q, fibered-map-square-sigma-over-prod extext A Aisdiscrete x y z w f p q g \u03c4)) #def refl-refl-map-equiv-square-sigma-over-prod ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y : A) ( f g : hom A x y) ( \u03c4 : prod-transport A A ( \\ a b -> hom A a b) x x y y refl refl f = g) : ( first (equiv-square-sigma-over-prod extext A Aisdiscrete x y x y f g)) ( refl , ( refl , \u03c4)) = (square-sigma-over-prod extext A Aisdiscrete x y x y f g) ( refl , ( refl , \u03c4)) := idJ ( hom A x y, f, \\ g' \u03c4' -> ( first (equiv-square-sigma-over-prod extext A Aisdiscrete x y x y f g')) ( refl , ( refl , \u03c4')) = (square-sigma-over-prod extext A Aisdiscrete x y x y f g') ( refl , ( refl , \u03c4')), refl , g, \u03c4) #def map-equiv-square-sigma-over-prod ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y z w : A) ( f : hom A x y) ( p : x = z) ( q : y = w) : ( g : hom A z w) -> ( \u03c4 : prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g) -> ( first (equiv-square-sigma-over-prod extext A Aisdiscrete x y z w f g)) (p, (q, \u03c4)) = (square-sigma-over-prod extext A Aisdiscrete x y z w f g) (p, (q, \u03c4)) := idJ ( A, y, \\ w' q' -> (g : hom A z w') -> ( \u03c4 : prod-transport A A ( \\ a b -> hom A a b) x z y w' p q' f = g) -> ( first (equiv-square-sigma-over-prod extext A Aisdiscrete x y z w' f g)) (p, (q', \u03c4)) = (square-sigma-over-prod extext A Aisdiscrete x y z w' f g) (p, (q', \u03c4)), idJ ( A, x, \\ z' p' -> (g : hom A z' y) -> ( \u03c4 : prod-transport A A ( \\ a b -> hom A a b) x z' y y p' refl f = g) -> ( first (equiv-square-sigma-over-prod extext A Aisdiscrete x y z' y f g)) (p', ( refl , \u03c4)) = (square-sigma-over-prod extext A Aisdiscrete x y z' y f g) (p', ( refl , \u03c4)), \\ g \u03c4 -> refl-refl-map-equiv-square-sigma-over-prod extext A Aisdiscrete x y f g \u03c4, z, p), w, q) #def is-equiv-square-sigma-over-prod ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y z w : A) ( f : hom A x y) ( g : hom A z w) : is-equiv ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g))) ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) (square-sigma-over-prod extext A Aisdiscrete x y z w f g) := is-equiv-rev-homotopic-is-equiv ( \u2211(p : x = z), ( \u2211(q : y = w), (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g))) ( \u2211(h : hom A x z), ( \u2211(k : hom A y w), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k t ]>))) ( first (equiv-square-sigma-over-prod extext A Aisdiscrete x y z w f g)) ( square-sigma-over-prod extext A Aisdiscrete x y z w f g) ( \\ (p, (q, \u03c4)) -> map-equiv-square-sigma-over-prod extext A Aisdiscrete x y z w f p q g \u03c4) ( second (equiv-square-sigma-over-prod extext A Aisdiscrete x y z w f g)) #def is-equiv-fibered-map-square-sigma-over-prod ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y z w : A) ( f : hom A x y) ( g : hom A z w) ( p : x = z) ( q : y = w) : is-equiv (prod-transport A A ( \\ a b -> hom A a b) x z y w p q f = g) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> (arr-eq A x z p) t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> (arr-eq A y w q) t ]>) (fibered-map-square-sigma-over-prod extext A Aisdiscrete x y z w f p q g) := fibered-map-is-equiv-bases-are-equiv-total-map-is-equiv ( x = z) ( hom A x z) ( y = w) ( hom A y w) ( \\ p' q' -> (prod-transport A A ( \\ a b -> hom A a b) x z y w p' q' f = g)) ( \\ h' k' -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> h' t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> k' t ]>)) ( arr-eq A x z) ( arr-eq A y w) ( \\ p' q' -> (fibered-map-square-sigma-over-prod extext A Aisdiscrete x y z w f p' q' g)) ( is-equiv-square-sigma-over-prod extext A Aisdiscrete x y z w f g) ( Aisdiscrete x z) ( Aisdiscrete y w) p q #def is-equiv-fibered-map-square-sigma-over-prod-refl-refl ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y : A) ( f : hom A x y) ( g : hom A x y) : is-equiv (f = g) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) (fibered-map-square-sigma-over-prod extext A Aisdiscrete x y x y f refl refl g) := is-equiv-fibered-map-square-sigma-over-prod extext A Aisdiscrete x y x y f g refl refl The previous calculations allow us to establish a family of equivalences: #def is-equiv-sum-fibered-map-square-sigma-over-prod-refl-refl ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y : A) ( f : hom A x y) : is-equiv ( \u2211 (g : hom A x y), f = g) ( \u2211 (g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) ( total-map-family-of-maps ( hom A x y) ( \\ g -> f = g) ( \\ g -> <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) ( \\ g -> (fibered-map-square-sigma-over-prod extext A Aisdiscrete x y x y f refl refl g))) := family-of-equiv-total-equiv ( hom A x y) ( \\ g -> f = g) ( \\ g -> <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) ( \\ g -> (fibered-map-square-sigma-over-prod extext A Aisdiscrete x y x y f refl refl g)) ( \\ g -> is-equiv-fibered-map-square-sigma-over-prod-refl-refl extext A Aisdiscrete x y f g) #def equiv-sum-fibered-map-square-sigma-over-prod-refl-refl ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y : A) ( f : hom A x y) : Equiv ( \u2211 (g : hom A x y), f = g) ( \u2211 (g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) := ( ( total-map-family-of-maps ( hom A x y) ( \\ g -> f = g) ( \\ g -> <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) ( \\ g -> (fibered-map-square-sigma-over-prod extext A Aisdiscrete x y x y f refl refl g))), is-equiv-sum-fibered-map-square-sigma-over-prod-refl-refl extext A Aisdiscrete x y f) Now using the equivalence on total spaces and the contractibility of based path spaces, we conclude that the codomain extension type is contractible. #def is-contr-horn-refl-refl-extension-type ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y : A) ( f : hom A x y) : is-contr ( \u2211 (g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) := is-contr-is-equiv-from-contr ( \u2211 (g : hom A x y), f = g) ( \u2211 (g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) ( equiv-sum-fibered-map-square-sigma-over-prod-refl-refl extext A Aisdiscrete x y f) ( is-contr-based-paths (hom A x y) f) The extension types that appear in the Segal condition are retracts of this type --- at least when the second arrow in the composable pair is an identity. #def triangle-to-square-section ( A : U ) ( x y : A) ( f g : hom A x y) ( \u03b1 : hom2 A x y y f (id-arr A y) g) : <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]> := \\ (t, s) -> recOR (t <= s |-> \u03b1 (s, t), s <= t |-> g s) #def sigma-triangle-to-sigma-square-section ( A : U ) ( x y : A) ( f : hom A x y) ((d, \u03b1) : \u2211 ( d : hom A x y), hom2 A x y y f (id-arr A y) d) : \u2211 ( g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]> := (d, triangle-to-square-section A x y f d \u03b1) #def sigma-square-to-sigma-triangle-retraction ( A : U ) ( x y : A) ( f : hom A x y) ((g, \u03c3) : \u2211 ( g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) : \u2211 ( d : hom A x y), hom2 A x y y f (id-arr A y) d := ( \\ t -> \u03c3 (t, t), \\ (t, s) -> \u03c3 (s, t)) #def sigma-triangle-to-sigma-square-retract ( A : U ) ( x y : A) ( f : hom A x y) : is-retract-of ( \u2211 (d : hom A x y), hom2 A x y y f (id-arr A y) d) ( \u2211 (g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) := ( sigma-triangle-to-sigma-square-section A x y f, ( sigma-square-to-sigma-triangle-retraction A x y f , \\ d\u03b1 -> refl )) We can now verify the Segal condition in the case of composable pairs in which the second arrow is an identity. #def is-contr-hom2-with-id-is-discrete ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y : A) ( f : hom A x y) : is-contr ( \u2211 (d : hom A x y), hom2 A x y y f (id-arr A y) d) := is-retract-of-is-contr-is-contr ( \u2211 (d : hom A x y), hom2 A x y y f (id-arr A y) d) ( \u2211 (g : hom A x y), <{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> f s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> g s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> x, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> y ]>) ( sigma-triangle-to-sigma-square-retract A x y f) ( is-contr-horn-refl-refl-extension-type extext A Aisdiscrete x y f) But since A is discrete, its hom type family is equivalent to its identity type family, and we can use \"path induction\" over arrows to reduce the general case to the one just proven: #def is-contr-hom2-is-discrete ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : is-contr ( \u2211 (h : hom A x z), hom2 A x y z f g h) := ind-based-path A y ( \\ w -> hom A y w) ( \\ w -> arr-eq A y w) ( Aisdiscrete y) ( \\ w d -> is-contr ( \u2211 (h : hom A x w), hom2 A x y w f d h)) ( is-contr-hom2-with-id-is-discrete extext A Aisdiscrete x y f) ( z) ( g) Finally, we conclude: -- [RS, Proposition 7.3] #def is-segal-is-discrete ( extext : ExtExt) ( A : U ) ( Aisdiscrete : is-discrete A) : is-segal A := \\ x y z f g -> is-contr-hom2-is-discrete extext A Aisdiscrete x y z f g","title":"Discrete types are Segal types"},{"location":"simplicial-hott/08-covariant.rzk/","text":"Covariantly functorial type families \u00b6 These formalisations correspond to Section 8 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 hott/* - We require various prerequisites from homotopy type theory, for instance the notion of contractible types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 5-segal-types.md - We make use of the notion of Segal types and their structures. Dependent hom types \u00b6 In a type family over a base type, there is a dependent hom type of arrows that live over a specified arrow in the base type. -- [RS17, Section 8 Prelim] -- The type of dependent arrows in C over f from u to v #def dhom ( A : U ) -- The base type. ( x y : A) -- Two points in the base. ( f : hom A x y) -- An arrow in the base. ( C : A -> U ) -- A type family. ( u : C x) -- A lift of the domain. ( v : C y) -- A lift of the codomain. : U := <{t : 2 | \u0394\u00b9 t } -> C (f t) [t === 0_2 |-> u, t === 1_2 |-> v ]> It will be convenient to collect together dependent hom types with fixed domain but varying codomain. #def dhomFrom ( A : U ) -- The base type. ( x y : A) -- Two points in the base. ( f : hom A x y) -- An arrow in the base. ( C : A -> U ) -- A type family. ( u : C x) -- A lift of the domain. : U := ( \u2211 (v : C y), dhom A x y f C u v) There is also a type of dependent commutative triangles over a base commutative triangle. #def dhom2 ( A : U ) -- The base type. ( x y z : A) -- Three points in the base. ( f : hom A x y) -- An arrow in the base. ( g : hom A y z) -- An arrow in the base. ( h : hom A x z) -- An arrow in the base. ( alpha : hom2 A x y z f g h) -- A composition witness in the base. ( C : A -> U ) -- A type family. ( u : C x) -- A lift of the initial point. ( v : C y) -- A lift of the second point. ( w : C z) -- A lift of the third point. ( ff : dhom A x y f C u v) -- A lift of the first arrow. ( gg : dhom A y z g C v w) -- A lift of the second arrow. ( hh : dhom A x z h C u w) -- A lift of the diagonal arrow. : U := <{(t1, t2) : 2 * 2 | \u0394\u00b2 (t1, t2)} -> C (alpha (t1, t2)) [t2 === 0_2 |-> ff t1, t1 === 1_2 |-> gg t2, t2 === t1 |-> hh t2 ]> Covariant families \u00b6 A family of types over a base type is covariant if every arrow in the base has a unique lift with specified domain. -- [RS17, Definition 8.2] #def isCovFam ( A : U ) ( C : A -> U ) : U := ( x : A) -> ( y : A) -> ( f : hom A x y) -> ( u : C x) -> is-contr (dhomFrom A x y f C u) -- Type of covariant families over a fixed type #def covFam ( A : U ) : U := ( \u2211 (C : ( (a : A) -> U )), isCovFam A C) Representable covariant families \u00b6 If A is a Segal type and a : A is any term, then hom A a defines a covariant family over A, and conversely if this family is covariant for every a : A, then A must be a Segal type. The proof involves a rather lengthy composition of equivalences. #def dhom-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. ( v : hom A a y) -- A lift of the codomain. : U := dhom A x y f ( \\ z -> hom A a z) u v -- By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhom-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. ( v : hom A a y) -- A lift of the codomain. : Equiv (dhom-representable A a x y f u v) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>) := curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 ( \\ t s -> A) (\\ (t, s) -> recOR (((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t )) #def dhomFrom-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : U := dhomFrom A x y f ( \\ z -> hom A a z) u -- By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhomFrom-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) ( \u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) := total-equiv-family-equiv (hom A a y) ( \\ v -> dhom-representable A a x y f u v) ( \\ v -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) ( \\ v -> uncurried-dhom-representable A a x y f u v) #def square-to-hom2-pushout ( A : U ) ( w x y z : A) ( u : hom A w x) ( f : hom A x z) ( g : hom A w y) ( v : hom A y z) : (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> g t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>) -> ( \u2211 (d : hom A w z), prod (hom2 A w x z u f d) (hom2 A w y z g v d)) := \\ sq -> (( \\ t -> sq (t, t)), (\\ (t, s) -> sq (s, t), \\ (t, s) -> sq (t, s))) #def hom2-pushout-to-square ( A : U ) ( w x y z : A) ( u : hom A w x) ( f : hom A x z) ( g : hom A w y) ( v : hom A y z) : ( \u2211 (d : hom A w z), prod (hom2 A w x z u f d) (hom2 A w y z g v d)) -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> g t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>) := \\ (d, (alpha1, alpha2)) (t, s) -> recOR (t <= s |-> alpha1 (s, t), s <= t |-> alpha2 (t, s)) #def Eq-square-hom2-pushout ( A : U ) ( w x y z : A) ( u : hom A w x) ( f : hom A x z) ( g : hom A w y) ( v : hom A y z) : Equiv (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> g t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>) ( \u2211 (d : hom A w z), prod (hom2 A w x z u f d) (hom2 A w y z g v d)) := (square-to-hom2-pushout A w x y z u f g v, ((hom2-pushout-to-square A w x y z u f g v, \\ sq -> refl ), (hom2-pushout-to-square A w x y z u f g v, \\ alphas -> refl ))) #def representable-dhomFrom-uncurry-hom2 ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv ( \u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) ( \u2211 (v : hom A a y), ( \u2211 (d : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) := total-equiv-family-equiv (hom A a y) ( \\ v -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) ( \\ v -> (\u2211 (d : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) ( \\ v -> Eq-square-hom2-pushout A a x a y u f (id-arr A a) v) #def representable-dhomFrom-hom2 ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), ( \u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) := triple-comp-equiv (dhomFrom-representable A a x y f u) ( \u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) ( \u2211 (v : hom A a y), ( \u2211 (d : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) ( \u2211 (d : hom A a y), ( \u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (uncurried-dhomFrom-representable A a x y f u) (representable-dhomFrom-uncurry-hom2 A a x y f u) (sigma-fubini (hom A a y) (hom A a y) ( \\ v d -> prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) #def representable-dhomFrom-hom2-dist ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) := right-cancel-equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) ( \u2211 (d : hom A a y), ( \u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (representable-dhomFrom-hom2 A a x y f u) (total-equiv-family-equiv (hom A a y) ( \\ d -> (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) ( \\ d -> (\u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) ( \\ d -> (prod-distribute-sigma (hom2 A a x y u f d) (hom A a y)( \\ v -> hom2 A a a y (id-arr A a) v d)))) Now we introduce the hypothesis that A is Segal type. #def Segal-representable-dhomFrom-path-space ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is a Segal type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), (v = d)))) := right-cancel-equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), (v = d)))) ( \u2211 (d : hom A a y), (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) (representable-dhomFrom-hom2-dist A a x y f u) (total-equiv-family-equiv (hom A a y) ( \\ d -> (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), (v = d)))) ( \\ d -> (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) ( \\ d -> (total-equiv-family-equiv (hom2 A a x y u f d) ( \\ alpha -> (\u2211 (v : hom A a y), (v = d))) ( \\ alpha -> (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d)) ( \\ alpha -> (total-equiv-family-equiv (hom A a y) ( \\ v -> (v = d)) ( \\ v -> hom2 A a a y (id-arr A a) v d) ( \\ v -> (Eq-Segal-homotopy-hom2 A AisSegal a y v d))))))) #def codomain-based-paths-contraction ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. ( d : hom A a y) : Equiv (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), (v = d))) (hom2 A a x y u f d) := equiv-projection-contractible-fibers (hom2 A a x y u f d) ( \\ alpha -> (\u2211 (v : hom A a y), (v = d))) ( \\ alpha -> is-contr-codomain-based-paths (hom A a y) d) #def is-segal-representable-dhomFrom-hom2 ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is a Segal type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (hom2 A a x y u f d)) := comp-equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), (v = d)))) ( \u2211 (d : hom A a y), (hom2 A a x y u f d)) (Segal-representable-dhomFrom-path-space A AisSegal a x y f u) (total-equiv-family-equiv (hom A a y) ( \\ d -> prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), (v = d))) ( \\ d -> hom2 A a x y u f d) ( \\ d -> codomain-based-paths-contraction A a x y f u d)) #def is-segal-representable-dhomFrom-contractible ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is a Segal type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : is-contr (dhomFrom-representable A a x y f u) := is-contr-is-equiv-to-contr (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (hom2 A a x y u f d)) (is-segal-representable-dhomFrom-hom2 A AisSegal a x y f u) (AisSegal a x y u f) Finally, we see that covariant hom families in a Segal type are covariant. -- [RS, Proposition 8.13(<-)] #def is-segal-representable-isCovFam ( A : U ) ( AisSegal : is-segal A) ( a : A) : isCovFam A ( \\ x -> hom A a x) := \\ x y f u -> is-segal-representable-dhomFrom-contractible A AisSegal a x y f u The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for Segal types - so instead we argue as follows: -- [RS, Proposition 8.13(->)] #def representable-isCovFam-is-segal ( A : U ) ( repiscovfam : ( a : A) -> isCovFam A ( \\ x -> hom A a x)) : is-segal A := \\ x y z f g -> first-is-contr-sigma ( \u2211 (h : hom A x z), hom2 A x y z f g h) ( \\ hk -> \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v ( first hk)) ( \\ hk -> ( first hk, \\ (t, s) -> first hk s)) ( is-contr-is-equiv-to-contr (\u2211 (hk : \u2211 ( h : hom A x z), hom2 A x y z f g h), \u2211 ( v : hom A x z), hom2 A x x z (id-arr A x) v ( first hk)) (dhomFrom-representable A x y z g f) (inv-equiv (dhomFrom-representable A x y z g f) ( \u2211 (hk : \u2211 ( h : hom A x z), hom2 A x y z f g h), \u2211 ( v : hom A x z), hom2 A x x z (id-arr A x) v ( first hk)) (comp-equiv (dhomFrom-representable A x y z g f) ( \u2211 (h : hom A x z), (prod (hom2 A x y z f g h) ( \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v h))) ( \u2211 (hk : \u2211 ( h : hom A x z), hom2 A x y z f g h), \u2211 ( v : hom A x z), hom2 A x x z (id-arr A x) v ( first hk)) (representable-dhomFrom-hom2-dist A x y z g f) (assoc-sigma (hom A x z) ( \\ h -> hom2 A x y z f g h) ( \\ h _ -> \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v h)))) (repiscovfam x y z g f)) While not needed to prove Proposition 8.13, it is interesting to observe that the dependent hom types in a representable family can be understood as extension types as follows. #def cofibration-union-test ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]> <{(t, s) : 2 * 2 | ((t === 1_2 ) /\\ (\u0394\u00b9 s))} -> A [ ((t === 1_2 ) /\\ (s === 0_2 )) |-> a, ((t === 1_2 ) /\\ (s === 1_2 )) |-> y ]> := cofibration_union ( 2 * 2 ) (\\ (t, s) -> (t === 1_2 ) /\\ \u0394\u00b9 s) (\\ (t, s) -> ((t === 0_2 ) /\\ \u0394\u00b9 s) \\/ (\u0394\u00b9 t /\\ (s === 0_2 )) \\/ (\u0394\u00b9 t /\\ (s === 1_2 ))) (\\ (t, s) -> A) (\\ (t, s) -> recOR (((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t )) #def base-hom-rewriting ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (<{(t, s) : 2 * 2 | ((t === 1_2 ) /\\ (\u0394\u00b9 s))} -> A [ ((t === 1_2 ) /\\ (s === 0_2 )) |-> a, ((t === 1_2 ) /\\ (s === 1_2 )) |-> y ]>) (hom A a y) := ( \\ v -> ( \\ r -> v (( 1_2 , r))), (( \\ v -> \\ (t, s) -> v s, \\ v -> refl ), ( \\ v -> \\ (t, s) -> v s, \\ v -> refl ))) #def base-hom-expansion ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]> (hom A a y) := comp-equiv (<{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]> ) (<{(t, s) : 2 * 2 | ((t === 1_2 ) /\\ (\u0394\u00b9 s))} -> A [ ((t === 1_2 ) /\\ (s === 0_2 )) |-> a, ((t === 1_2 ) /\\ (s === 1_2 )) |-> y ]>) (hom A a y) (cofibration-union-test A a x y f u) (base-hom-rewriting A a x y f u) #def representable-dhomFrom-expansion ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv ( \u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> (sq ( 1_2 , s)), (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) ( \u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) := total-equiv-pullback-is-equiv ( <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]> ) (hom A a y) ( first (base-hom-expansion A a x y f u)) ( second (base-hom-expansion A a x y f u)) ( \\ v -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) #def representable-dhomFrom-composite-expansion ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) ( \u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> (sq ( 1_2 , s)), (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) := right-cancel-equiv (dhomFrom-representable A a x y f u) ( \u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> (sq ( 1_2 , s)), (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) ( \u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) (uncurried-dhomFrom-representable A a x y f u) (representable-dhomFrom-expansion A a x y f u) #def representable-dhomFrom-cofibration-composition ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t]> ) ( \u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> (sq ( 1_2 , s)), (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) := cofibration-composition ( 2 * 2 ) \u0394\u00b9\u00d7\u0394\u00b9 \u2202\u25a1 (\\ (t, s) -> ((t === 0_2 ) /\\ \u0394\u00b9 s) \\/ (\u0394\u00b9 t /\\ (s === 0_2 )) \\/ (\u0394\u00b9 t /\\ (s === 1_2 ))) ( \\ ts -> A) (\\ (t, s) -> recOR ( ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t)) #def representable-dhomFrom-as-extension-type ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t]> ) := right-cancel-equiv (dhomFrom-representable A a x y f u) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t]> ) ( \u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> (sq ( 1_2 , s)), (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) (representable-dhomFrom-composite-expansion A a x y f u) (representable-dhomFrom-cofibration-composition A a x y f u) Covariant lifts, transport, and uniqueness \u00b6 In a covariant family C over a base type A, a term u : C x may be transported along an arrow f : hom A x y to give a term in C y. -- [RS17, covariant transport from beginning of Section 8.2] #def covTrans ( A : U ) ( x y : A) ( f : hom A x y) ( C : A -> U ) ( CisCov : isCovFam A C) ( u : C x) : C y := first (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, covariant lift from beginning of Section 8.2] #def covLift ( A : U ) ( x y : A) ( f : hom A x y) ( C : A -> U ) ( CisCov : isCovFam A C) ( u : C x) : (dhom A x y f C u (covTrans A x y f C CisCov u)) := second (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) #def covUniqueness ( A : U ) ( x y : A) ( f : hom A x y) ( C : A -> U ) ( CisCov : isCovFam A C) ( u : C x) ( lift : dhomFrom A x y f C u) : (covTrans A x y f C CisCov u) = ( first lift) := first-path-sigma (C y) ( \\ v -> dhom A x y f C u v) (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) lift (contracting-htpy (dhomFrom A x y f C u) (CisCov x y f u) lift) Covariant functoriality \u00b6 The covariant transport operation defines a covariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law. #def d-id-arr ( A : U ) ( x : A) ( C : A -> U ) ( u : C x) : dhom A x x (id-arr A x) C u u := \\ t -> u -- [RS17, Proposition 8.16, Part 2] -- Covariant families preserve identities #def covPresId ( A : U ) ( x : A) ( C : A -> U ) ( CisCov : isCovFam A C) ( u : C x) : (covTrans A x x (id-arr A x) C CisCov u) = u := covUniqueness A x x (id-arr A x) C CisCov u (u, d-id-arr A x C u) Natural transformations \u00b6 A fiberwise map between covariant families is automatically \"natural\" commuting with the covariant lifts. -- [RS17, Proposition 8.17] -- Covariant naturality #def covariant-fiberwise-transformation-application ( A : U ) ( x y : A) ( f : hom A x y) ( C D : A -> U ) ( CisCov : isCovFam A C) ( \u03d5 : ( z : A) -> C z -> D z) ( u : C x) : dhomFrom A x y f D (\u03d5 x u) := (\u03d5 y (covTrans A x y f C CisCov u), \\ t -> \u03d5 (f t) (covLift A x y f C CisCov u t)) #def naturality-covariant-fiberwise-transformation ( A : U ) ( x y : A) ( f : hom A x y) ( C D : A -> U ) ( CisCov : isCovFam A C) ( DisCov : isCovFam A D) ( \u03d5 : ( z : A) -> C z -> D z) ( u : C x) : (covTrans A x y f D DisCov (\u03d5 x u)) = (\u03d5 y (covTrans A x y f C CisCov u)) := covUniqueness A x y f D DisCov (\u03d5 x u) (covariant-fiberwise-transformation-application A x y f C D CisCov \u03d5 u) Contravariant families \u00b6 A family of types over a base type is contravariant if every arrow in the base has a unique lift with specified codomain. #def dhomTo ( A : U ) -- The base type. ( x y : A) -- Two points in the base. ( f : hom A x y) -- An arrow in the base. ( C : A -> U ) -- A type family. ( v : C y) -- A lift of the domain. : U := ( \u2211 (u : C x), dhom A x y f C u v) -- [RS17, Definition 8.2, dual form] #def isContraFam ( A : U ) ( C : A -> U ) : U := ( x : A) -> ( y : A) -> ( f : hom A x y) -> ( v : C y) -> is-contr (dhomTo A x y f C v) -- Type of contravariant families over a fixed type #def contraFam ( A : U ) : U := ( \u2211 (C : A -> U ), isContraFam A C) Representable contravariant families \u00b6 If A is a Segal type and a : A is any term, then the family \\x -> hom A x a defines a contravariant family over A, and conversely if this family is contravariant for every a : A, then A must be a Segal type. The proof involves a rather lengthy composition of equivalences. #def dhom-contra-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A x a) -- A lift of the domain. ( v : hom A y a) -- A lift of the codomain. : U := dhom A x y f ( \\ z -> hom A z a) u v -- By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhom-contra-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A x a) -- A lift of the domain. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhom-contra-representable A a x y f u v) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a ]>) := curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 ( \\ t s -> A) (\\ (t, s) -> recOR (((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a )) #def dhomTo-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : U := dhomTo A x y f ( \\ z -> hom A z a) v -- By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhomTo-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhomTo-representable A a x y f v) ( \u2211 (u : hom A x a), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a ]>)) := total-equiv-family-equiv (hom A x a) ( \\ u -> dhom-contra-representable A a x y f u v) ( \\ u -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a ]>)) ( \\ u -> uncurried-dhom-contra-representable A a x y f u v) #def representable-dhomTo-uncurry-hom2 ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv ( \u2211 (u : hom A x a), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a ]>)) ( \u2211 (u : hom A x a), ( \u2211 (d : hom A x a), prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d) )) := total-equiv-family-equiv (hom A x a) ( \\ u -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a ]>)) ( \\ u -> (\u2211 (d : hom A x a), prod (hom2 A x a a u (id-arr A a) d)(hom2 A x y a f v d) )) ( \\ u -> Eq-square-hom2-pushout A x a y a u (id-arr A a) f v) #def representable-dhomTo-hom2 ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), ( \u2211 (u : hom A x a), prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d) )) := triple-comp-equiv (dhomTo-representable A a x y f v) ( \u2211 (u : hom A x a), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a ]>)) ( \u2211 (u : hom A x a ), ( \u2211 (d : hom A x a), prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d))) ( \u2211 (d : hom A x a ), ( \u2211 (u : hom A x a), prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d))) (uncurried-dhomTo-representable A a x y f v) (representable-dhomTo-uncurry-hom2 A a x y f v) (sigma-fubini (hom A x a) (hom A x a) ( \\ u d -> prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d))) #def representable-dhomTo-hom2-swap ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), ( \u2211 (u : hom A x a), prod (hom2 A x y a f v d)(hom2 A x a a u (id-arr A a) d) )) := comp-equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), ( \u2211 (u : hom A x a), prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d) )) ( \u2211 (d : hom A x a), ( \u2211 (u : hom A x a), prod (hom2 A x y a f v d)(hom2 A x a a u (id-arr A a) d) )) (representable-dhomTo-hom2 A a x y f v) (total-equiv-family-equiv (hom A x a) ( \\ d -> (\u2211 (u : hom A x a), prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d) )) ( \\ d -> (\u2211 (u : hom A x a), prod (hom2 A x y a f v d)(hom2 A x a a u (id-arr A a) d) )) ( \\ d -> total-equiv-family-equiv (hom A x a) ( \\ u -> prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d)) ( \\ u -> prod (hom2 A x y a f v d)(hom2 A x a a u (id-arr A a) d)) ( \\ u -> sym-prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d)))) #def representable-dhomTo-hom2-dist ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a ), (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a ), hom2 A x a a u (id-arr A a) d))) := right-cancel-equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a ), (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a ), hom2 A x a a u (id-arr A a) d))) ( \u2211 (d : hom A x a), ( \u2211 (u : hom A x a), prod (hom2 A x y a f v d) (hom2 A x a a u (id-arr A a) d))) (representable-dhomTo-hom2-swap A a x y f v) (total-equiv-family-equiv (hom A x a) ( \\ d -> (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a ), hom2 A x a a u (id-arr A a) d))) ( \\ d -> (\u2211 (u : hom A x a), prod (hom2 A x y a f v d) (hom2 A x a a u (id-arr A a) d) )) ( \\ d -> (prod-distribute-sigma (hom2 A x y a f v d) (hom A x a)( \\ u -> hom2 A x a a u (id-arr A a) d)))) Now we introduce the hypothesis that A is Segal type. #def Segal-representable-dhomTo-path-space ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is a Segal type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), (u = d)))) := right-cancel-equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), (u = d)))) ( \u2211 (d : hom A x a), (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), (hom2 A x a a u (id-arr A a) d)))) (representable-dhomTo-hom2-dist A a x y f v) (total-equiv-family-equiv (hom A x a) ( \\ d -> (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), (u = d)))) ( \\ d -> (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), hom2 A x a a u (id-arr A a) d))) ( \\ d -> (total-equiv-family-equiv (hom2 A x y a f v d) ( \\ \u03b1 -> (\u2211 (u : hom A x a), (u = d))) ( \\ \u03b1 -> (\u2211 (u : hom A x a), hom2 A x a a u (id-arr A a) d)) ( \\ \u03b1 -> (total-equiv-family-equiv (hom A x a) ( \\ u -> (u = d)) ( \\ u -> hom2 A x a a u (id-arr A a) d) ( \\ u -> (Eq-Segal-homotopy-hom2' A AisSegal x a u d))))))) #def is-segal-representable-dhomTo-hom2 ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is a Segal type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), (hom2 A x y a f v d)) := comp-equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), (u = d)))) ( \u2211 (d : hom A x a), (hom2 A x y a f v d)) (Segal-representable-dhomTo-path-space A AisSegal a x y f v) (total-equiv-family-equiv (hom A x a) ( \\ d -> prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), (u = d))) ( \\ d -> hom2 A x y a f v d) ( \\ d -> codomain-based-paths-contraction A x y a v f d)) #def is-segal-representable-dhomTo-contractible ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is a Segal type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : is-contr (dhomTo-representable A a x y f v) := is-contr-is-equiv-to-contr (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), (hom2 A x y a f v d)) (is-segal-representable-dhomTo-hom2 A AisSegal a x y f v) (AisSegal x y a f v) Finally, we see that contravariant hom families in a Segal type are contravariant. -- [RS, Proposition 8.13(<-), dual] #def is-segal-representable-isContraFam ( A : U ) ( AisSegal : is-segal A) ( a : A) : isContraFam A ( \\ x -> hom A x a) := \\ x y f v -> is-segal-representable-dhomTo-contractible A AisSegal a x y f v The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for Segal types - so instead we argue as follows: -- [RS, Proposition 8.13(->), dual] #def representable-isContraFam-is-segal ( A : U ) ( repiscontrafam : ( a : A) -> isContraFam A ( \\ x -> hom A x a)) : is-segal A := \\ x y z f g -> first-is-contr-sigma ( \u2211 (h : hom A x z), hom2 A x y z f g h) ( \\ hk -> \u2211 (u : hom A x z), hom2 A x z z u (id-arr A z) ( first hk)) ( \\ hk -> ( first hk, \\ (t, s) -> first hk t)) ( is-contr-is-equiv-to-contr (\u2211 (hk : \u2211 ( h : hom A x z), hom2 A x y z f g h), \u2211 ( u : hom A x z), hom2 A x z z u (id-arr A z) ( first hk)) (dhomTo-representable A z x y f g) (inv-equiv (dhomTo-representable A z x y f g) ( \u2211 (hk : \u2211 ( h : hom A x z), hom2 A x y z f g h), \u2211 ( u : hom A x z), hom2 A x z z u (id-arr A z) ( first hk)) (comp-equiv (dhomTo-representable A z x y f g) ( \u2211 (h : hom A x z), (prod (hom2 A x y z f g h) ( \u2211 (u : hom A x z), hom2 A x z z u (id-arr A z) h))) ( \u2211 (hk : \u2211 ( h : hom A x z), hom2 A x y z f g h), \u2211 ( u : hom A x z), hom2 A x z z u (id-arr A z) ( first hk)) (representable-dhomTo-hom2-dist A z x y f g) (assoc-sigma (hom A x z) ( \\ h -> hom2 A x y z f g h) ( \\ h _ -> \u2211 (u : hom A x z), hom2 A x z z u (id-arr A z) h)))) (repiscontrafam z x y f g)) Contravariant lifts, transport, and uniqueness \u00b6 In a contravariant family C over a base type A, a term v : C y may be transported along an arrow f : hom A x y to give a term in C x. -- [RS17, contravariant transport from beginning of Section 8.2] #def contraTrans ( A : U ) ( x y : A) ( f : hom A x y) ( C : A -> U ) ( CisContra : isContraFam A C) ( v : C y) : C x := first (contraction-center (dhomTo A x y f C v) (CisContra x y f v)) -- [RS17, contravariant lift from beginning of Section 8.2] #def contraLift ( A : U ) ( x y : A) ( f : hom A x y) ( C : A -> U ) ( CisContra : isContraFam A C) ( v : C y) : (dhom A x y f C (contraTrans A x y f C CisContra v) v) := second (contraction-center (dhomTo A x y f C v) (CisContra x y f v)) #def contraUniqueness ( A : U ) ( x y : A) ( f : hom A x y) ( C : A -> U ) ( CisContra : isContraFam A C) ( v : C y) ( lift : dhomTo A x y f C v) : (contraTrans A x y f C CisContra v) = ( first lift) := first-path-sigma (C x) ( \\ u -> dhom A x y f C u v) (contraction-center (dhomTo A x y f C v) (CisContra x y f v)) lift (contracting-htpy (dhomTo A x y f C v) (CisContra x y f v) lift) Contravariant functoriality \u00b6 The contravariant transport operation defines a comtravariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law. -- [RS17, Proposition 8.16, Part 2, dual] -- Comtravariant families preserve identities #def contraPresId ( A : U ) ( x : A) ( C : A -> U ) ( CisContra : isContraFam A C) ( u : C x) : (contraTrans A x x (id-arr A x) C CisContra u) = u := contraUniqueness A x x (id-arr A x) C CisContra u (u, d-id-arr A x C u) Contravariant natural transformations \u00b6 A fiberwise map between contrvariant families is automatically \"natural\" commuting with the contravariant lifts. -- [RS17, Proposition 8.17, dual] -- Contravariant naturality #def contravariant-fiberwise-transformation-application ( A : U ) ( x y : A) ( f : hom A x y) ( C D : A -> U ) ( CisContra : isContraFam A C) ( \u03d5 : ( z : A) -> C z -> D z) ( v : C y) : dhomTo A x y f D (\u03d5 y v) := (\u03d5 x (contraTrans A x y f C CisContra v), \\ t -> \u03d5 (f t) (contraLift A x y f C CisContra v t)) #def naturality-contravariant-fiberwise-transformation ( A : U ) ( x y : A) ( f : hom A x y) ( C D : A -> U ) ( CisContra : isContraFam A C) ( DisContra : isContraFam A D) ( \u03d5 : ( z : A) -> C z -> D z) ( v : C y) : (contraTrans A x y f D DisContra (\u03d5 y v)) = (\u03d5 x (contraTrans A x y f C CisContra v)) := contraUniqueness A x y f D DisContra (\u03d5 y v) (contravariant-fiberwise-transformation-application A x y f C D CisContra \u03d5 v)","title":"Covariantly Functorial Type Families"},{"location":"simplicial-hott/08-covariant.rzk/#covariantly-functorial-type-families","text":"These formalisations correspond to Section 8 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Covariantly functorial type families"},{"location":"simplicial-hott/08-covariant.rzk/#prerequisites","text":"hott/* - We require various prerequisites from homotopy type theory, for instance the notion of contractible types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 5-segal-types.md - We make use of the notion of Segal types and their structures.","title":"Prerequisites"},{"location":"simplicial-hott/08-covariant.rzk/#dependent-hom-types","text":"In a type family over a base type, there is a dependent hom type of arrows that live over a specified arrow in the base type. -- [RS17, Section 8 Prelim] -- The type of dependent arrows in C over f from u to v #def dhom ( A : U ) -- The base type. ( x y : A) -- Two points in the base. ( f : hom A x y) -- An arrow in the base. ( C : A -> U ) -- A type family. ( u : C x) -- A lift of the domain. ( v : C y) -- A lift of the codomain. : U := <{t : 2 | \u0394\u00b9 t } -> C (f t) [t === 0_2 |-> u, t === 1_2 |-> v ]> It will be convenient to collect together dependent hom types with fixed domain but varying codomain. #def dhomFrom ( A : U ) -- The base type. ( x y : A) -- Two points in the base. ( f : hom A x y) -- An arrow in the base. ( C : A -> U ) -- A type family. ( u : C x) -- A lift of the domain. : U := ( \u2211 (v : C y), dhom A x y f C u v) There is also a type of dependent commutative triangles over a base commutative triangle. #def dhom2 ( A : U ) -- The base type. ( x y z : A) -- Three points in the base. ( f : hom A x y) -- An arrow in the base. ( g : hom A y z) -- An arrow in the base. ( h : hom A x z) -- An arrow in the base. ( alpha : hom2 A x y z f g h) -- A composition witness in the base. ( C : A -> U ) -- A type family. ( u : C x) -- A lift of the initial point. ( v : C y) -- A lift of the second point. ( w : C z) -- A lift of the third point. ( ff : dhom A x y f C u v) -- A lift of the first arrow. ( gg : dhom A y z g C v w) -- A lift of the second arrow. ( hh : dhom A x z h C u w) -- A lift of the diagonal arrow. : U := <{(t1, t2) : 2 * 2 | \u0394\u00b2 (t1, t2)} -> C (alpha (t1, t2)) [t2 === 0_2 |-> ff t1, t1 === 1_2 |-> gg t2, t2 === t1 |-> hh t2 ]>","title":"Dependent hom types"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-families","text":"A family of types over a base type is covariant if every arrow in the base has a unique lift with specified domain. -- [RS17, Definition 8.2] #def isCovFam ( A : U ) ( C : A -> U ) : U := ( x : A) -> ( y : A) -> ( f : hom A x y) -> ( u : C x) -> is-contr (dhomFrom A x y f C u) -- Type of covariant families over a fixed type #def covFam ( A : U ) : U := ( \u2211 (C : ( (a : A) -> U )), isCovFam A C)","title":"Covariant families"},{"location":"simplicial-hott/08-covariant.rzk/#representable-covariant-families","text":"If A is a Segal type and a : A is any term, then hom A a defines a covariant family over A, and conversely if this family is covariant for every a : A, then A must be a Segal type. The proof involves a rather lengthy composition of equivalences. #def dhom-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. ( v : hom A a y) -- A lift of the codomain. : U := dhom A x y f ( \\ z -> hom A a z) u v -- By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhom-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. ( v : hom A a y) -- A lift of the codomain. : Equiv (dhom-representable A a x y f u v) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>) := curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 ( \\ t s -> A) (\\ (t, s) -> recOR (((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t )) #def dhomFrom-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : U := dhomFrom A x y f ( \\ z -> hom A a z) u -- By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhomFrom-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) ( \u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) := total-equiv-family-equiv (hom A a y) ( \\ v -> dhom-representable A a x y f u v) ( \\ v -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) ( \\ v -> uncurried-dhom-representable A a x y f u v) #def square-to-hom2-pushout ( A : U ) ( w x y z : A) ( u : hom A w x) ( f : hom A x z) ( g : hom A w y) ( v : hom A y z) : (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> g t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>) -> ( \u2211 (d : hom A w z), prod (hom2 A w x z u f d) (hom2 A w y z g v d)) := \\ sq -> (( \\ t -> sq (t, t)), (\\ (t, s) -> sq (s, t), \\ (t, s) -> sq (t, s))) #def hom2-pushout-to-square ( A : U ) ( w x y z : A) ( u : hom A w x) ( f : hom A x z) ( g : hom A w y) ( v : hom A y z) : ( \u2211 (d : hom A w z), prod (hom2 A w x z u f d) (hom2 A w y z g v d)) -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> g t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>) := \\ (d, (alpha1, alpha2)) (t, s) -> recOR (t <= s |-> alpha1 (s, t), s <= t |-> alpha2 (t, s)) #def Eq-square-hom2-pushout ( A : U ) ( w x y z : A) ( u : hom A w x) ( f : hom A x z) ( g : hom A w y) ( v : hom A y z) : Equiv (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> g t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>) ( \u2211 (d : hom A w z), prod (hom2 A w x z u f d) (hom2 A w y z g v d)) := (square-to-hom2-pushout A w x y z u f g v, ((hom2-pushout-to-square A w x y z u f g v, \\ sq -> refl ), (hom2-pushout-to-square A w x y z u f g v, \\ alphas -> refl ))) #def representable-dhomFrom-uncurry-hom2 ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv ( \u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) ( \u2211 (v : hom A a y), ( \u2211 (d : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) := total-equiv-family-equiv (hom A a y) ( \\ v -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) ( \\ v -> (\u2211 (d : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) ( \\ v -> Eq-square-hom2-pushout A a x a y u f (id-arr A a) v) #def representable-dhomFrom-hom2 ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), ( \u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) := triple-comp-equiv (dhomFrom-representable A a x y f u) ( \u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) ( \u2211 (v : hom A a y), ( \u2211 (d : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) ( \u2211 (d : hom A a y), ( \u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (uncurried-dhomFrom-representable A a x y f u) (representable-dhomFrom-uncurry-hom2 A a x y f u) (sigma-fubini (hom A a y) (hom A a y) ( \\ v d -> prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) #def representable-dhomFrom-hom2-dist ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) := right-cancel-equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) ( \u2211 (d : hom A a y), ( \u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (representable-dhomFrom-hom2 A a x y f u) (total-equiv-family-equiv (hom A a y) ( \\ d -> (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) ( \\ d -> (\u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) ( \\ d -> (prod-distribute-sigma (hom2 A a x y u f d) (hom A a y)( \\ v -> hom2 A a a y (id-arr A a) v d)))) Now we introduce the hypothesis that A is Segal type. #def Segal-representable-dhomFrom-path-space ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is a Segal type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), (v = d)))) := right-cancel-equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), (v = d)))) ( \u2211 (d : hom A a y), (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) (representable-dhomFrom-hom2-dist A a x y f u) (total-equiv-family-equiv (hom A a y) ( \\ d -> (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), (v = d)))) ( \\ d -> (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) ( \\ d -> (total-equiv-family-equiv (hom2 A a x y u f d) ( \\ alpha -> (\u2211 (v : hom A a y), (v = d))) ( \\ alpha -> (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d)) ( \\ alpha -> (total-equiv-family-equiv (hom A a y) ( \\ v -> (v = d)) ( \\ v -> hom2 A a a y (id-arr A a) v d) ( \\ v -> (Eq-Segal-homotopy-hom2 A AisSegal a y v d))))))) #def codomain-based-paths-contraction ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. ( d : hom A a y) : Equiv (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), (v = d))) (hom2 A a x y u f d) := equiv-projection-contractible-fibers (hom2 A a x y u f d) ( \\ alpha -> (\u2211 (v : hom A a y), (v = d))) ( \\ alpha -> is-contr-codomain-based-paths (hom A a y) d) #def is-segal-representable-dhomFrom-hom2 ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is a Segal type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (hom2 A a x y u f d)) := comp-equiv (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), (v = d)))) ( \u2211 (d : hom A a y), (hom2 A a x y u f d)) (Segal-representable-dhomFrom-path-space A AisSegal a x y f u) (total-equiv-family-equiv (hom A a y) ( \\ d -> prod (hom2 A a x y u f d) ( \u2211 (v : hom A a y), (v = d))) ( \\ d -> hom2 A a x y u f d) ( \\ d -> codomain-based-paths-contraction A a x y f u d)) #def is-segal-representable-dhomFrom-contractible ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is a Segal type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : is-contr (dhomFrom-representable A a x y f u) := is-contr-is-equiv-to-contr (dhomFrom-representable A a x y f u) ( \u2211 (d : hom A a y), (hom2 A a x y u f d)) (is-segal-representable-dhomFrom-hom2 A AisSegal a x y f u) (AisSegal a x y u f) Finally, we see that covariant hom families in a Segal type are covariant. -- [RS, Proposition 8.13(<-)] #def is-segal-representable-isCovFam ( A : U ) ( AisSegal : is-segal A) ( a : A) : isCovFam A ( \\ x -> hom A a x) := \\ x y f u -> is-segal-representable-dhomFrom-contractible A AisSegal a x y f u The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for Segal types - so instead we argue as follows: -- [RS, Proposition 8.13(->)] #def representable-isCovFam-is-segal ( A : U ) ( repiscovfam : ( a : A) -> isCovFam A ( \\ x -> hom A a x)) : is-segal A := \\ x y z f g -> first-is-contr-sigma ( \u2211 (h : hom A x z), hom2 A x y z f g h) ( \\ hk -> \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v ( first hk)) ( \\ hk -> ( first hk, \\ (t, s) -> first hk s)) ( is-contr-is-equiv-to-contr (\u2211 (hk : \u2211 ( h : hom A x z), hom2 A x y z f g h), \u2211 ( v : hom A x z), hom2 A x x z (id-arr A x) v ( first hk)) (dhomFrom-representable A x y z g f) (inv-equiv (dhomFrom-representable A x y z g f) ( \u2211 (hk : \u2211 ( h : hom A x z), hom2 A x y z f g h), \u2211 ( v : hom A x z), hom2 A x x z (id-arr A x) v ( first hk)) (comp-equiv (dhomFrom-representable A x y z g f) ( \u2211 (h : hom A x z), (prod (hom2 A x y z f g h) ( \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v h))) ( \u2211 (hk : \u2211 ( h : hom A x z), hom2 A x y z f g h), \u2211 ( v : hom A x z), hom2 A x x z (id-arr A x) v ( first hk)) (representable-dhomFrom-hom2-dist A x y z g f) (assoc-sigma (hom A x z) ( \\ h -> hom2 A x y z f g h) ( \\ h _ -> \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v h)))) (repiscovfam x y z g f)) While not needed to prove Proposition 8.13, it is interesting to observe that the dependent hom types in a representable family can be understood as extension types as follows. #def cofibration-union-test ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]> <{(t, s) : 2 * 2 | ((t === 1_2 ) /\\ (\u0394\u00b9 s))} -> A [ ((t === 1_2 ) /\\ (s === 0_2 )) |-> a, ((t === 1_2 ) /\\ (s === 1_2 )) |-> y ]> := cofibration_union ( 2 * 2 ) (\\ (t, s) -> (t === 1_2 ) /\\ \u0394\u00b9 s) (\\ (t, s) -> ((t === 0_2 ) /\\ \u0394\u00b9 s) \\/ (\u0394\u00b9 t /\\ (s === 0_2 )) \\/ (\u0394\u00b9 t /\\ (s === 1_2 ))) (\\ (t, s) -> A) (\\ (t, s) -> recOR (((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t )) #def base-hom-rewriting ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (<{(t, s) : 2 * 2 | ((t === 1_2 ) /\\ (\u0394\u00b9 s))} -> A [ ((t === 1_2 ) /\\ (s === 0_2 )) |-> a, ((t === 1_2 ) /\\ (s === 1_2 )) |-> y ]>) (hom A a y) := ( \\ v -> ( \\ r -> v (( 1_2 , r))), (( \\ v -> \\ (t, s) -> v s, \\ v -> refl ), ( \\ v -> \\ (t, s) -> v s, \\ v -> refl ))) #def base-hom-expansion ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]> (hom A a y) := comp-equiv (<{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]> ) (<{(t, s) : 2 * 2 | ((t === 1_2 ) /\\ (\u0394\u00b9 s))} -> A [ ((t === 1_2 ) /\\ (s === 0_2 )) |-> a, ((t === 1_2 ) /\\ (s === 1_2 )) |-> y ]>) (hom A a y) (cofibration-union-test A a x y f u) (base-hom-rewriting A a x y f u) #def representable-dhomFrom-expansion ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv ( \u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> (sq ( 1_2 , s)), (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) ( \u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) := total-equiv-pullback-is-equiv ( <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]> ) (hom A a y) ( first (base-hom-expansion A a x y f u)) ( second (base-hom-expansion A a x y f u)) ( \\ v -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) #def representable-dhomFrom-composite-expansion ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) ( \u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> (sq ( 1_2 , s)), (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) := right-cancel-equiv (dhomFrom-representable A a x y f u) ( \u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> (sq ( 1_2 , s)), (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) ( \u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) (uncurried-dhomFrom-representable A a x y f u) (representable-dhomFrom-expansion A a x y f u) #def representable-dhomFrom-cofibration-composition ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t]> ) ( \u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> (sq ( 1_2 , s)), (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) := cofibration-composition ( 2 * 2 ) \u0394\u00b9\u00d7\u0394\u00b9 \u2202\u25a1 (\\ (t, s) -> ((t === 0_2 ) /\\ \u0394\u00b9 s) \\/ (\u0394\u00b9 t /\\ (s === 0_2 )) \\/ (\u0394\u00b9 t /\\ (s === 1_2 ))) ( \\ ts -> A) (\\ (t, s) -> recOR ( ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t)) #def representable-dhomFrom-as-extension-type ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A a x) -- A lift of the domain. : Equiv (dhomFrom-representable A a x y f u) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t]> ) := right-cancel-equiv (dhomFrom-representable A a x y f u) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t]> ) ( \u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> (sq ( 1_2 , s)), (\u0394\u00b9 t /\\ (s === 0_2 )) |-> a, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> f t ]>)) (representable-dhomFrom-composite-expansion A a x y f u) (representable-dhomFrom-cofibration-composition A a x y f u)","title":"Representable covariant families"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-lifts-transport-and-uniqueness","text":"In a covariant family C over a base type A, a term u : C x may be transported along an arrow f : hom A x y to give a term in C y. -- [RS17, covariant transport from beginning of Section 8.2] #def covTrans ( A : U ) ( x y : A) ( f : hom A x y) ( C : A -> U ) ( CisCov : isCovFam A C) ( u : C x) : C y := first (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, covariant lift from beginning of Section 8.2] #def covLift ( A : U ) ( x y : A) ( f : hom A x y) ( C : A -> U ) ( CisCov : isCovFam A C) ( u : C x) : (dhom A x y f C u (covTrans A x y f C CisCov u)) := second (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) #def covUniqueness ( A : U ) ( x y : A) ( f : hom A x y) ( C : A -> U ) ( CisCov : isCovFam A C) ( u : C x) ( lift : dhomFrom A x y f C u) : (covTrans A x y f C CisCov u) = ( first lift) := first-path-sigma (C y) ( \\ v -> dhom A x y f C u v) (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) lift (contracting-htpy (dhomFrom A x y f C u) (CisCov x y f u) lift)","title":"Covariant lifts, transport, and uniqueness"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-functoriality","text":"The covariant transport operation defines a covariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law. #def d-id-arr ( A : U ) ( x : A) ( C : A -> U ) ( u : C x) : dhom A x x (id-arr A x) C u u := \\ t -> u -- [RS17, Proposition 8.16, Part 2] -- Covariant families preserve identities #def covPresId ( A : U ) ( x : A) ( C : A -> U ) ( CisCov : isCovFam A C) ( u : C x) : (covTrans A x x (id-arr A x) C CisCov u) = u := covUniqueness A x x (id-arr A x) C CisCov u (u, d-id-arr A x C u)","title":"Covariant functoriality"},{"location":"simplicial-hott/08-covariant.rzk/#natural-transformations","text":"A fiberwise map between covariant families is automatically \"natural\" commuting with the covariant lifts. -- [RS17, Proposition 8.17] -- Covariant naturality #def covariant-fiberwise-transformation-application ( A : U ) ( x y : A) ( f : hom A x y) ( C D : A -> U ) ( CisCov : isCovFam A C) ( \u03d5 : ( z : A) -> C z -> D z) ( u : C x) : dhomFrom A x y f D (\u03d5 x u) := (\u03d5 y (covTrans A x y f C CisCov u), \\ t -> \u03d5 (f t) (covLift A x y f C CisCov u t)) #def naturality-covariant-fiberwise-transformation ( A : U ) ( x y : A) ( f : hom A x y) ( C D : A -> U ) ( CisCov : isCovFam A C) ( DisCov : isCovFam A D) ( \u03d5 : ( z : A) -> C z -> D z) ( u : C x) : (covTrans A x y f D DisCov (\u03d5 x u)) = (\u03d5 y (covTrans A x y f C CisCov u)) := covUniqueness A x y f D DisCov (\u03d5 x u) (covariant-fiberwise-transformation-application A x y f C D CisCov \u03d5 u)","title":"Natural transformations"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-families","text":"A family of types over a base type is contravariant if every arrow in the base has a unique lift with specified codomain. #def dhomTo ( A : U ) -- The base type. ( x y : A) -- Two points in the base. ( f : hom A x y) -- An arrow in the base. ( C : A -> U ) -- A type family. ( v : C y) -- A lift of the domain. : U := ( \u2211 (u : C x), dhom A x y f C u v) -- [RS17, Definition 8.2, dual form] #def isContraFam ( A : U ) ( C : A -> U ) : U := ( x : A) -> ( y : A) -> ( f : hom A x y) -> ( v : C y) -> is-contr (dhomTo A x y f C v) -- Type of contravariant families over a fixed type #def contraFam ( A : U ) : U := ( \u2211 (C : A -> U ), isContraFam A C)","title":"Contravariant families"},{"location":"simplicial-hott/08-covariant.rzk/#representable-contravariant-families","text":"If A is a Segal type and a : A is any term, then the family \\x -> hom A x a defines a contravariant family over A, and conversely if this family is contravariant for every a : A, then A must be a Segal type. The proof involves a rather lengthy composition of equivalences. #def dhom-contra-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A x a) -- A lift of the domain. ( v : hom A y a) -- A lift of the codomain. : U := dhom A x y f ( \\ z -> hom A z a) u v -- By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhom-contra-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( u : hom A x a) -- A lift of the domain. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhom-contra-representable A a x y f u v) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a ]>) := curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 ( \\ t s -> A) (\\ (t, s) -> recOR (((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a )) #def dhomTo-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : U := dhomTo A x y f ( \\ z -> hom A z a) v -- By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhomTo-representable ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhomTo-representable A a x y f v) ( \u2211 (u : hom A x a), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a ]>)) := total-equiv-family-equiv (hom A x a) ( \\ u -> dhom-contra-representable A a x y f u v) ( \\ u -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a ]>)) ( \\ u -> uncurried-dhom-contra-representable A a x y f u v) #def representable-dhomTo-uncurry-hom2 ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv ( \u2211 (u : hom A x a), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a ]>)) ( \u2211 (u : hom A x a), ( \u2211 (d : hom A x a), prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d) )) := total-equiv-family-equiv (hom A x a) ( \\ u -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a ]>)) ( \\ u -> (\u2211 (d : hom A x a), prod (hom2 A x a a u (id-arr A a) d)(hom2 A x y a f v d) )) ( \\ u -> Eq-square-hom2-pushout A x a y a u (id-arr A a) f v) #def representable-dhomTo-hom2 ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), ( \u2211 (u : hom A x a), prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d) )) := triple-comp-equiv (dhomTo-representable A a x y f v) ( \u2211 (u : hom A x a), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2 ) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2 ) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2 )) |-> f t, (\u0394\u00b9 t /\\ (s === 1_2 )) |-> a ]>)) ( \u2211 (u : hom A x a ), ( \u2211 (d : hom A x a), prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d))) ( \u2211 (d : hom A x a ), ( \u2211 (u : hom A x a), prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d))) (uncurried-dhomTo-representable A a x y f v) (representable-dhomTo-uncurry-hom2 A a x y f v) (sigma-fubini (hom A x a) (hom A x a) ( \\ u d -> prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d))) #def representable-dhomTo-hom2-swap ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), ( \u2211 (u : hom A x a), prod (hom2 A x y a f v d)(hom2 A x a a u (id-arr A a) d) )) := comp-equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), ( \u2211 (u : hom A x a), prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d) )) ( \u2211 (d : hom A x a), ( \u2211 (u : hom A x a), prod (hom2 A x y a f v d)(hom2 A x a a u (id-arr A a) d) )) (representable-dhomTo-hom2 A a x y f v) (total-equiv-family-equiv (hom A x a) ( \\ d -> (\u2211 (u : hom A x a), prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d) )) ( \\ d -> (\u2211 (u : hom A x a), prod (hom2 A x y a f v d)(hom2 A x a a u (id-arr A a) d) )) ( \\ d -> total-equiv-family-equiv (hom A x a) ( \\ u -> prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d)) ( \\ u -> prod (hom2 A x y a f v d)(hom2 A x a a u (id-arr A a) d)) ( \\ u -> sym-prod (hom2 A x a a u (id-arr A a) d) (hom2 A x y a f v d)))) #def representable-dhomTo-hom2-dist ( A : U ) -- The ambient type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a ), (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a ), hom2 A x a a u (id-arr A a) d))) := right-cancel-equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a ), (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a ), hom2 A x a a u (id-arr A a) d))) ( \u2211 (d : hom A x a), ( \u2211 (u : hom A x a), prod (hom2 A x y a f v d) (hom2 A x a a u (id-arr A a) d))) (representable-dhomTo-hom2-swap A a x y f v) (total-equiv-family-equiv (hom A x a) ( \\ d -> (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a ), hom2 A x a a u (id-arr A a) d))) ( \\ d -> (\u2211 (u : hom A x a), prod (hom2 A x y a f v d) (hom2 A x a a u (id-arr A a) d) )) ( \\ d -> (prod-distribute-sigma (hom2 A x y a f v d) (hom A x a)( \\ u -> hom2 A x a a u (id-arr A a) d)))) Now we introduce the hypothesis that A is Segal type. #def Segal-representable-dhomTo-path-space ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is a Segal type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), (u = d)))) := right-cancel-equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), (u = d)))) ( \u2211 (d : hom A x a), (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), (hom2 A x a a u (id-arr A a) d)))) (representable-dhomTo-hom2-dist A a x y f v) (total-equiv-family-equiv (hom A x a) ( \\ d -> (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), (u = d)))) ( \\ d -> (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), hom2 A x a a u (id-arr A a) d))) ( \\ d -> (total-equiv-family-equiv (hom2 A x y a f v d) ( \\ \u03b1 -> (\u2211 (u : hom A x a), (u = d))) ( \\ \u03b1 -> (\u2211 (u : hom A x a), hom2 A x a a u (id-arr A a) d)) ( \\ \u03b1 -> (total-equiv-family-equiv (hom A x a) ( \\ u -> (u = d)) ( \\ u -> hom2 A x a a u (id-arr A a) d) ( \\ u -> (Eq-Segal-homotopy-hom2' A AisSegal x a u d))))))) #def is-segal-representable-dhomTo-hom2 ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is a Segal type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : Equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), (hom2 A x y a f v d)) := comp-equiv (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), (prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), (u = d)))) ( \u2211 (d : hom A x a), (hom2 A x y a f v d)) (Segal-representable-dhomTo-path-space A AisSegal a x y f v) (total-equiv-family-equiv (hom A x a) ( \\ d -> prod (hom2 A x y a f v d) ( \u2211 (u : hom A x a), (u = d))) ( \\ d -> hom2 A x y a f v d) ( \\ d -> codomain-based-paths-contraction A x y a v f d)) #def is-segal-representable-dhomTo-contractible ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is a Segal type. ( a x y : A) -- The representing object and two points in the base. ( f : hom A x y) -- An arrow in the base. ( v : hom A y a) -- A lift of the codomain. : is-contr (dhomTo-representable A a x y f v) := is-contr-is-equiv-to-contr (dhomTo-representable A a x y f v) ( \u2211 (d : hom A x a), (hom2 A x y a f v d)) (is-segal-representable-dhomTo-hom2 A AisSegal a x y f v) (AisSegal x y a f v) Finally, we see that contravariant hom families in a Segal type are contravariant. -- [RS, Proposition 8.13(<-), dual] #def is-segal-representable-isContraFam ( A : U ) ( AisSegal : is-segal A) ( a : A) : isContraFam A ( \\ x -> hom A x a) := \\ x y f v -> is-segal-representable-dhomTo-contractible A AisSegal a x y f v The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for Segal types - so instead we argue as follows: -- [RS, Proposition 8.13(->), dual] #def representable-isContraFam-is-segal ( A : U ) ( repiscontrafam : ( a : A) -> isContraFam A ( \\ x -> hom A x a)) : is-segal A := \\ x y z f g -> first-is-contr-sigma ( \u2211 (h : hom A x z), hom2 A x y z f g h) ( \\ hk -> \u2211 (u : hom A x z), hom2 A x z z u (id-arr A z) ( first hk)) ( \\ hk -> ( first hk, \\ (t, s) -> first hk t)) ( is-contr-is-equiv-to-contr (\u2211 (hk : \u2211 ( h : hom A x z), hom2 A x y z f g h), \u2211 ( u : hom A x z), hom2 A x z z u (id-arr A z) ( first hk)) (dhomTo-representable A z x y f g) (inv-equiv (dhomTo-representable A z x y f g) ( \u2211 (hk : \u2211 ( h : hom A x z), hom2 A x y z f g h), \u2211 ( u : hom A x z), hom2 A x z z u (id-arr A z) ( first hk)) (comp-equiv (dhomTo-representable A z x y f g) ( \u2211 (h : hom A x z), (prod (hom2 A x y z f g h) ( \u2211 (u : hom A x z), hom2 A x z z u (id-arr A z) h))) ( \u2211 (hk : \u2211 ( h : hom A x z), hom2 A x y z f g h), \u2211 ( u : hom A x z), hom2 A x z z u (id-arr A z) ( first hk)) (representable-dhomTo-hom2-dist A z x y f g) (assoc-sigma (hom A x z) ( \\ h -> hom2 A x y z f g h) ( \\ h _ -> \u2211 (u : hom A x z), hom2 A x z z u (id-arr A z) h)))) (repiscontrafam z x y f g))","title":"Representable contravariant families"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-lifts-transport-and-uniqueness","text":"In a contravariant family C over a base type A, a term v : C y may be transported along an arrow f : hom A x y to give a term in C x. -- [RS17, contravariant transport from beginning of Section 8.2] #def contraTrans ( A : U ) ( x y : A) ( f : hom A x y) ( C : A -> U ) ( CisContra : isContraFam A C) ( v : C y) : C x := first (contraction-center (dhomTo A x y f C v) (CisContra x y f v)) -- [RS17, contravariant lift from beginning of Section 8.2] #def contraLift ( A : U ) ( x y : A) ( f : hom A x y) ( C : A -> U ) ( CisContra : isContraFam A C) ( v : C y) : (dhom A x y f C (contraTrans A x y f C CisContra v) v) := second (contraction-center (dhomTo A x y f C v) (CisContra x y f v)) #def contraUniqueness ( A : U ) ( x y : A) ( f : hom A x y) ( C : A -> U ) ( CisContra : isContraFam A C) ( v : C y) ( lift : dhomTo A x y f C v) : (contraTrans A x y f C CisContra v) = ( first lift) := first-path-sigma (C x) ( \\ u -> dhom A x y f C u v) (contraction-center (dhomTo A x y f C v) (CisContra x y f v)) lift (contracting-htpy (dhomTo A x y f C v) (CisContra x y f v) lift)","title":"Contravariant lifts, transport, and uniqueness"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-functoriality","text":"The contravariant transport operation defines a comtravariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law. -- [RS17, Proposition 8.16, Part 2, dual] -- Comtravariant families preserve identities #def contraPresId ( A : U ) ( x : A) ( C : A -> U ) ( CisContra : isContraFam A C) ( u : C x) : (contraTrans A x x (id-arr A x) C CisContra u) = u := contraUniqueness A x x (id-arr A x) C CisContra u (u, d-id-arr A x C u)","title":"Contravariant functoriality"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-natural-transformations","text":"A fiberwise map between contrvariant families is automatically \"natural\" commuting with the contravariant lifts. -- [RS17, Proposition 8.17, dual] -- Contravariant naturality #def contravariant-fiberwise-transformation-application ( A : U ) ( x y : A) ( f : hom A x y) ( C D : A -> U ) ( CisContra : isContraFam A C) ( \u03d5 : ( z : A) -> C z -> D z) ( v : C y) : dhomTo A x y f D (\u03d5 y v) := (\u03d5 x (contraTrans A x y f C CisContra v), \\ t -> \u03d5 (f t) (contraLift A x y f C CisContra v t)) #def naturality-contravariant-fiberwise-transformation ( A : U ) ( x y : A) ( f : hom A x y) ( C D : A -> U ) ( CisContra : isContraFam A C) ( DisContra : isContraFam A D) ( \u03d5 : ( z : A) -> C z -> D z) ( v : C y) : (contraTrans A x y f D DisContra (\u03d5 y v)) = (\u03d5 x (contraTrans A x y f C CisContra v)) := contraUniqueness A x y f D DisContra (\u03d5 y v) (contravariant-fiberwise-transformation-application A x y f C D CisContra \u03d5 v)","title":"Contravariant natural transformations"},{"location":"simplicial-hott/09-yoneda.rzk/","text":"The Yoneda lemma \u00b6 These formalisations correspond to Section 9 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 8-covariant.md - We use covariant type families. Natural transformations involving a representable functor \u00b6 Fix a Segal type A and a term a : A. The Yoneda lemma characterizes natural transformations from the representable type family hom A a : A -> U to a covariant type family C : A -> U. Ordinary, such a natural transformation would involve a family of maps \u03d5 : (z : A) -> hom A a z -> C z together with a proof of naturality of these components, but by naturality-covariant-fiberwise-transformation naturality is automatic. #def naturality-covariant-fiberwise-representable-transformation ( A : U ) ( AisSegal : is-segal A) ( a x y : A) ( f : hom A a x) ( g : hom A x y) ( C : A -> U ) ( CisCov : isCovFam A C) ( \u03d5 : ( z : A) -> hom A a z -> C z) : (covTrans A x y g C CisCov (\u03d5 x f)) = (\u03d5 y (Segal-comp A AisSegal a x y f g)) := naturality-covariant-fiberwise-transformation A x y g ( \\ z -> hom A a z) C (is-segal-representable-isCovFam A AisSegal a) CisCov \u03d5 f The Yoneda maps \u00b6 For any Segal type A and term a : A, the Yoneda lemma provides an equivalence between the type (z : A) -> hom A a z -> C z of natural transformations out of the functor (hom A a) and valued in an arbitrary covariant family C and the type (C a). One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the covariant transport operation. -- The map evid evaluates a natural transformation -- out of a representable functor at the identity arrow. #def evid ( A : U ) -- The ambient type. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. : ( (z : A) -> hom A a z -> C z) -> C a := \\ \u03d5 -> \u03d5 a (id-arr A a) -- The inverse map only exists for Segal types. #def yon ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. ( CisCov : isCovFam A C) -- A covariant family. : C a -> ( (z : A) -> hom A a z -> C z) := \\ u z f -> covTrans A a z f C CisCov u The Yoneda composites \u00b6 It remains to show that the Yoneda maps are inverses. -- One retraction is straightforward: #def evid-yon ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. ( CisCov : isCovFam A C) -- A covariant family. ( u : C a) : (evid A a C) ((yon A AisSegal a C CisCov) u) = u := covPresId A a C CisCov u The other composite carries \u03d5 to an a priori distinct natural transformation. We first show that these are pointwise equal at all x : A and f : hom A a x in two steps. #section yon-evid #variable A : U -- The ambient type. #variable AisSegal : is-segal A -- A proof that A is Segal. #variable a : A -- The representing object. #variable C : A -> U -- A type family. #variable CisCov : isCovFam A C -- A covariant family. -- The composite yon-evid of \u03d5 equals \u03d5 at all x : A and f : hom A a x. #def yon-evid-twice-pointwise ( \u03d5 : ( z : A) -> hom A a z -> C z) -- A natural transformation. ( x : A) ( f : hom A a x) : ((yon A AisSegal a C CisCov)((evid A a C) \u03d5 )) x f = \u03d5 x f := concat (C x) (((yon A AisSegal a C CisCov)((evid A a C) \u03d5 )) x f) (\u03d5 x (Segal-comp A AisSegal a a x (id-arr A a) f)) (\u03d5 x f) (naturality-covariant-fiberwise-representable-transformation A AisSegal a a x (id-arr A a) f C CisCov \u03d5 ) (ap (hom A a x) (C x) (Segal-comp A AisSegal a a x (id-arr A a) f) f (\u03d5 x) (Segal-id-comp A AisSegal a x f)) -- By funext, these are equals as functions of f pointwise in x. #def yon-evid-once-pointwise ( funext : FunExt) ( \u03d5 : ( z : A) -> hom A a z -> C z) -- A natural transformation. ( x : A) : ((yon A AisSegal a C CisCov)((evid A a C) \u03d5 )) x = \u03d5 x := eq-htpy funext (hom A a x) ( \\ f -> C x) ( \\ f -> ((yon A AisSegal a C CisCov)((evid A a C) \u03d5 )) x f) ( \\ f -> (\u03d5 x f)) ( \\ f -> yon-evid-twice-pointwise \u03d5 x f) -- By funext again, these are equal as functions of x and f. #def yon-evid ( funext : FunExt) ( \u03d5 : ( z : A) -> hom A a z -> C z) -- A natural transformation. : ((yon A AisSegal a C CisCov)((evid A a C) \u03d5 )) = \u03d5 := eq-htpy funext A ( \\ x -> (hom A a x -> C x)) ( \\ x -> ((yon A AisSegal a C CisCov)((evid A a C) \u03d5 )) x) ( \\ x -> (\u03d5 x)) ( \\ x -> yon-evid-once-pointwise funext \u03d5 x) #end yon-evid The Yoneda lemma \u00b6 The Yoneda lemma says that evaluation at the identity defines an equivalence. #def Yoneda-lemma ( funext : FunExt) ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. ( CisCov : isCovFam A C) -- A covariant family. : is-equiv ( (z : A) -> hom A a z -> C z) (C a) (evid A a C) := ((yon A AisSegal a C CisCov, yon-evid A AisSegal a C CisCov funext), (yon A AisSegal a C CisCov, evid-yon A AisSegal a C CisCov)) Yoneda for contravariant families \u00b6 Dually, the Yoneda lemma for contravariant type families characterizes natural transformations from the contravariant family represented by a term a : A in a Segal type to a contravariant type family C : A -> U. By naturality-contravariant-fiberwise-transformation naturality is again automatic. #def naturality-contravariant-fiberwise-representable-transformation ( A : U ) ( AisSegal : is-segal A) ( a x y : A) ( f : hom A y a) ( g : hom A x y) ( C : A -> U ) ( CisContra : isContraFam A C) ( \u03d5 : ( z : A) -> hom A z a -> C z) : (contraTrans A x y g C CisContra (\u03d5 y f)) = (\u03d5 x (Segal-comp A AisSegal x y a g f)) := naturality-contravariant-fiberwise-transformation A x y g ( \\ z -> hom A z a) C (is-segal-representable-isContraFam A AisSegal a) CisContra \u03d5 f For any Segal type A and term a : A, the contravariant Yoneda lemma provides an equivalence between the type (z : A) -> hom A z a -> C z of natural transformations out of the functor (\\ x -> hom A x a) and valued in an arbitrary contravariant family C and the type (C a). One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the contravariant transport operation. -- The map evid evaluates a natural transformation -- out of a representable functor at the identity arrow. #def contra-evid ( A : U ) -- The ambient type. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. : ( (z : A) -> hom A z a -> C z) -> C a := \\ \u03d5 -> \u03d5 a (id-arr A a) -- The inverse map only exists for Segal types and contravariant families. #def contra-yon ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. ( CisContra : isContraFam A C) -- A contrariant family. : C a -> ( (z : A) -> hom A z a -> C z) := \\ v z f -> contraTrans A z a f C CisContra v It remains to show that the Yoneda maps are inverses. -- One retraction is straightforward: #def contra-evid-yon ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. ( CisContra : isContraFam A C) -- A contravariant family. ( v : C a) : (contra-evid A a C) ((contra-yon A AisSegal a C CisContra) v) = v := contraPresId A a C CisContra v The other composite carries \u03d5 to an a priori distinct natural transformation. We first show that these are pointwise equal at all x : A and f : hom A x a in two steps. #section contra-yon-evid #variable A : U -- The ambient type. #variable AisSegal : is-segal A -- A proof that A is Segal. #variable a : A -- The representing object. #variable C : A -> U -- A type family. #variable CisContra : isContraFam A C -- A contravariant family. -- The composite yon-evid of \u03d5 equals \u03d5 at all x : A and f : hom A x a. #def contra-yon-evid-twice-pointwise ( \u03d5 : ( z : A) -> hom A z a -> C z) -- A natural transformation. ( x : A) ( f : hom A x a) : ((contra-yon A AisSegal a C CisContra)((contra-evid A a C) \u03d5 )) x f = \u03d5 x f := concat (C x) (((contra-yon A AisSegal a C CisContra)((contra-evid A a C) \u03d5 )) x f) (\u03d5 x (Segal-comp A AisSegal x a a f (id-arr A a))) (\u03d5 x f) (naturality-contravariant-fiberwise-representable-transformation A AisSegal a x a (id-arr A a) f C CisContra \u03d5 ) (ap (hom A x a) (C x) (Segal-comp A AisSegal x a a f (id-arr A a)) f (\u03d5 x) (Segal-comp-id A AisSegal x a f)) -- By funext, these are equals as functions of f pointwise in x. #def contra-yon-evid-once-pointwise ( funext : FunExt) ( \u03d5 : ( z : A) -> hom A z a -> C z) -- A natural transformation. ( x : A) : ((contra-yon A AisSegal a C CisContra)((contra-evid A a C) \u03d5 )) x = \u03d5 x := eq-htpy funext (hom A x a) ( \\ f -> C x) ( \\ f -> ((contra-yon A AisSegal a C CisContra)((contra-evid A a C) \u03d5 )) x f) ( \\ f -> (\u03d5 x f)) ( \\ f -> contra-yon-evid-twice-pointwise \u03d5 x f) -- By funext again, these are equal as functions of x and f. #def contra-yon-evid ( funext : FunExt) ( \u03d5 : ( z : A) -> hom A z a -> C z) -- A natural transformation. : ((contra-yon A AisSegal a C CisContra)((contra-evid A a C) \u03d5 )) = \u03d5 := eq-htpy funext A ( \\ x -> (hom A x a -> C x)) ( \\ x -> ((contra-yon A AisSegal a C CisContra)((contra-evid A a C) \u03d5 )) x) ( \\ x -> (\u03d5 x)) ( \\ x -> contra-yon-evid-once-pointwise funext \u03d5 x) #end contra-yon-evid The contravariant Yoneda lemma says that evaluation at the identity defines an equivalence. #def contra-Yoneda-lemma ( funext : FunExt) ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. ( CisContra : isContraFam A C) -- A contravariant family. : is-equiv ( (z : A) -> hom A z a -> C z) (C a) (contra-evid A a C) := ((contra-yon A AisSegal a C CisContra, contra-yon-evid A AisSegal a C CisContra funext), (contra-yon A AisSegal a C CisContra, contra-evid-yon A AisSegal a C CisContra))","title":"The Yoneda Lemma"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-lemma","text":"These formalisations correspond to Section 9 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"The Yoneda lemma"},{"location":"simplicial-hott/09-yoneda.rzk/#prerequisites","text":"hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 8-covariant.md - We use covariant type families.","title":"Prerequisites"},{"location":"simplicial-hott/09-yoneda.rzk/#natural-transformations-involving-a-representable-functor","text":"Fix a Segal type A and a term a : A. The Yoneda lemma characterizes natural transformations from the representable type family hom A a : A -> U to a covariant type family C : A -> U. Ordinary, such a natural transformation would involve a family of maps \u03d5 : (z : A) -> hom A a z -> C z together with a proof of naturality of these components, but by naturality-covariant-fiberwise-transformation naturality is automatic. #def naturality-covariant-fiberwise-representable-transformation ( A : U ) ( AisSegal : is-segal A) ( a x y : A) ( f : hom A a x) ( g : hom A x y) ( C : A -> U ) ( CisCov : isCovFam A C) ( \u03d5 : ( z : A) -> hom A a z -> C z) : (covTrans A x y g C CisCov (\u03d5 x f)) = (\u03d5 y (Segal-comp A AisSegal a x y f g)) := naturality-covariant-fiberwise-transformation A x y g ( \\ z -> hom A a z) C (is-segal-representable-isCovFam A AisSegal a) CisCov \u03d5 f","title":"Natural transformations involving a representable functor"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-maps","text":"For any Segal type A and term a : A, the Yoneda lemma provides an equivalence between the type (z : A) -> hom A a z -> C z of natural transformations out of the functor (hom A a) and valued in an arbitrary covariant family C and the type (C a). One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the covariant transport operation. -- The map evid evaluates a natural transformation -- out of a representable functor at the identity arrow. #def evid ( A : U ) -- The ambient type. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. : ( (z : A) -> hom A a z -> C z) -> C a := \\ \u03d5 -> \u03d5 a (id-arr A a) -- The inverse map only exists for Segal types. #def yon ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. ( CisCov : isCovFam A C) -- A covariant family. : C a -> ( (z : A) -> hom A a z -> C z) := \\ u z f -> covTrans A a z f C CisCov u","title":"The Yoneda maps"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-composites","text":"It remains to show that the Yoneda maps are inverses. -- One retraction is straightforward: #def evid-yon ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. ( CisCov : isCovFam A C) -- A covariant family. ( u : C a) : (evid A a C) ((yon A AisSegal a C CisCov) u) = u := covPresId A a C CisCov u The other composite carries \u03d5 to an a priori distinct natural transformation. We first show that these are pointwise equal at all x : A and f : hom A a x in two steps. #section yon-evid #variable A : U -- The ambient type. #variable AisSegal : is-segal A -- A proof that A is Segal. #variable a : A -- The representing object. #variable C : A -> U -- A type family. #variable CisCov : isCovFam A C -- A covariant family. -- The composite yon-evid of \u03d5 equals \u03d5 at all x : A and f : hom A a x. #def yon-evid-twice-pointwise ( \u03d5 : ( z : A) -> hom A a z -> C z) -- A natural transformation. ( x : A) ( f : hom A a x) : ((yon A AisSegal a C CisCov)((evid A a C) \u03d5 )) x f = \u03d5 x f := concat (C x) (((yon A AisSegal a C CisCov)((evid A a C) \u03d5 )) x f) (\u03d5 x (Segal-comp A AisSegal a a x (id-arr A a) f)) (\u03d5 x f) (naturality-covariant-fiberwise-representable-transformation A AisSegal a a x (id-arr A a) f C CisCov \u03d5 ) (ap (hom A a x) (C x) (Segal-comp A AisSegal a a x (id-arr A a) f) f (\u03d5 x) (Segal-id-comp A AisSegal a x f)) -- By funext, these are equals as functions of f pointwise in x. #def yon-evid-once-pointwise ( funext : FunExt) ( \u03d5 : ( z : A) -> hom A a z -> C z) -- A natural transformation. ( x : A) : ((yon A AisSegal a C CisCov)((evid A a C) \u03d5 )) x = \u03d5 x := eq-htpy funext (hom A a x) ( \\ f -> C x) ( \\ f -> ((yon A AisSegal a C CisCov)((evid A a C) \u03d5 )) x f) ( \\ f -> (\u03d5 x f)) ( \\ f -> yon-evid-twice-pointwise \u03d5 x f) -- By funext again, these are equal as functions of x and f. #def yon-evid ( funext : FunExt) ( \u03d5 : ( z : A) -> hom A a z -> C z) -- A natural transformation. : ((yon A AisSegal a C CisCov)((evid A a C) \u03d5 )) = \u03d5 := eq-htpy funext A ( \\ x -> (hom A a x -> C x)) ( \\ x -> ((yon A AisSegal a C CisCov)((evid A a C) \u03d5 )) x) ( \\ x -> (\u03d5 x)) ( \\ x -> yon-evid-once-pointwise funext \u03d5 x) #end yon-evid","title":"The Yoneda composites"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-lemma_1","text":"The Yoneda lemma says that evaluation at the identity defines an equivalence. #def Yoneda-lemma ( funext : FunExt) ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. ( CisCov : isCovFam A C) -- A covariant family. : is-equiv ( (z : A) -> hom A a z -> C z) (C a) (evid A a C) := ((yon A AisSegal a C CisCov, yon-evid A AisSegal a C CisCov funext), (yon A AisSegal a C CisCov, evid-yon A AisSegal a C CisCov))","title":"The Yoneda lemma"},{"location":"simplicial-hott/09-yoneda.rzk/#yoneda-for-contravariant-families","text":"Dually, the Yoneda lemma for contravariant type families characterizes natural transformations from the contravariant family represented by a term a : A in a Segal type to a contravariant type family C : A -> U. By naturality-contravariant-fiberwise-transformation naturality is again automatic. #def naturality-contravariant-fiberwise-representable-transformation ( A : U ) ( AisSegal : is-segal A) ( a x y : A) ( f : hom A y a) ( g : hom A x y) ( C : A -> U ) ( CisContra : isContraFam A C) ( \u03d5 : ( z : A) -> hom A z a -> C z) : (contraTrans A x y g C CisContra (\u03d5 y f)) = (\u03d5 x (Segal-comp A AisSegal x y a g f)) := naturality-contravariant-fiberwise-transformation A x y g ( \\ z -> hom A z a) C (is-segal-representable-isContraFam A AisSegal a) CisContra \u03d5 f For any Segal type A and term a : A, the contravariant Yoneda lemma provides an equivalence between the type (z : A) -> hom A z a -> C z of natural transformations out of the functor (\\ x -> hom A x a) and valued in an arbitrary contravariant family C and the type (C a). One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the contravariant transport operation. -- The map evid evaluates a natural transformation -- out of a representable functor at the identity arrow. #def contra-evid ( A : U ) -- The ambient type. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. : ( (z : A) -> hom A z a -> C z) -> C a := \\ \u03d5 -> \u03d5 a (id-arr A a) -- The inverse map only exists for Segal types and contravariant families. #def contra-yon ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. ( CisContra : isContraFam A C) -- A contrariant family. : C a -> ( (z : A) -> hom A z a -> C z) := \\ v z f -> contraTrans A z a f C CisContra v It remains to show that the Yoneda maps are inverses. -- One retraction is straightforward: #def contra-evid-yon ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. ( CisContra : isContraFam A C) -- A contravariant family. ( v : C a) : (contra-evid A a C) ((contra-yon A AisSegal a C CisContra) v) = v := contraPresId A a C CisContra v The other composite carries \u03d5 to an a priori distinct natural transformation. We first show that these are pointwise equal at all x : A and f : hom A x a in two steps. #section contra-yon-evid #variable A : U -- The ambient type. #variable AisSegal : is-segal A -- A proof that A is Segal. #variable a : A -- The representing object. #variable C : A -> U -- A type family. #variable CisContra : isContraFam A C -- A contravariant family. -- The composite yon-evid of \u03d5 equals \u03d5 at all x : A and f : hom A x a. #def contra-yon-evid-twice-pointwise ( \u03d5 : ( z : A) -> hom A z a -> C z) -- A natural transformation. ( x : A) ( f : hom A x a) : ((contra-yon A AisSegal a C CisContra)((contra-evid A a C) \u03d5 )) x f = \u03d5 x f := concat (C x) (((contra-yon A AisSegal a C CisContra)((contra-evid A a C) \u03d5 )) x f) (\u03d5 x (Segal-comp A AisSegal x a a f (id-arr A a))) (\u03d5 x f) (naturality-contravariant-fiberwise-representable-transformation A AisSegal a x a (id-arr A a) f C CisContra \u03d5 ) (ap (hom A x a) (C x) (Segal-comp A AisSegal x a a f (id-arr A a)) f (\u03d5 x) (Segal-comp-id A AisSegal x a f)) -- By funext, these are equals as functions of f pointwise in x. #def contra-yon-evid-once-pointwise ( funext : FunExt) ( \u03d5 : ( z : A) -> hom A z a -> C z) -- A natural transformation. ( x : A) : ((contra-yon A AisSegal a C CisContra)((contra-evid A a C) \u03d5 )) x = \u03d5 x := eq-htpy funext (hom A x a) ( \\ f -> C x) ( \\ f -> ((contra-yon A AisSegal a C CisContra)((contra-evid A a C) \u03d5 )) x f) ( \\ f -> (\u03d5 x f)) ( \\ f -> contra-yon-evid-twice-pointwise \u03d5 x f) -- By funext again, these are equal as functions of x and f. #def contra-yon-evid ( funext : FunExt) ( \u03d5 : ( z : A) -> hom A z a -> C z) -- A natural transformation. : ((contra-yon A AisSegal a C CisContra)((contra-evid A a C) \u03d5 )) = \u03d5 := eq-htpy funext A ( \\ x -> (hom A x a -> C x)) ( \\ x -> ((contra-yon A AisSegal a C CisContra)((contra-evid A a C) \u03d5 )) x) ( \\ x -> (\u03d5 x)) ( \\ x -> contra-yon-evid-once-pointwise funext \u03d5 x) #end contra-yon-evid The contravariant Yoneda lemma says that evaluation at the identity defines an equivalence. #def contra-Yoneda-lemma ( funext : FunExt) ( A : U ) -- The ambient type. ( AisSegal : is-segal A) -- A proof that A is Segal. ( a : A) -- The representing object. ( C : A -> U ) -- A type family. ( CisContra : isContraFam A C) -- A contravariant family. : is-equiv ( (z : A) -> hom A z a -> C z) (C a) (contra-evid A a C) := ((contra-yon A AisSegal a C CisContra, contra-yon-evid A AisSegal a C CisContra funext), (contra-yon A AisSegal a C CisContra, contra-evid-yon A AisSegal a C CisContra))","title":"Yoneda for contravariant families"},{"location":"simplicial-hott/10-rezk-types.rzk/","text":"Rezk types \u00b6 This is a literate rzk file: #lang rzk-1 #section isomorphisms #def arrow-has-retraction ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) : U := (Segal-comp A AisSegal x y x f g) =_{hom A x x} (id-arr A x) #def arrow-Retraction ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : U := \u2211 ( g : hom A y x), (arrow-has-retraction A AisSegal x y f g) #def arrow-has-section ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( h : hom A y x) : U := (Segal-comp A AisSegal y x y h f) =_{hom A y y} (id-arr A y) #def arrow-Section ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : U := \u2211 ( h : hom A y x), (arrow-has-section A AisSegal x y f h) #def arrow-is-iso ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : U := prod (arrow-Retraction A AisSegal x y f) (arrow-Section A AisSegal x y f) #def Iso ( A : U ) ( AisSegal : is-segal A) ( x y : A) : U := \u2211 ( f : hom A x y), arrow-is-iso A AisSegal x y f #def arrow-has-inverse ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : U := \u2211 ( g : hom A y x), prod (arrow-has-retraction A AisSegal x y f g) (arrow-has-section A AisSegal x y f g) #def arrow-inverse-to-iso ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : (arrow-has-inverse A AisSegal x y f) -> (arrow-is-iso A AisSegal x y f) := (\\(g, (p, q)) -> ((g, p), (g, q))) #def arrow-iso-to-inverse ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : (arrow-is-iso A AisSegal x y f) -> (arrow-has-inverse A AisSegal x y f) := (\\((g, p), (h, q)) -> (g, (p, (concat (hom A y y) (Segal-comp A AisSegal y x y g f) (Segal-comp A AisSegal y x y h f) (id-arr A y) (Segal-homotopy-postwhisker A AisSegal y x y g h f (quintuple-concat-alternating (hom A y x) g (Segal-comp A AisSegal y y x (id-arr A y) g) -- a0 = g and a1 = g o id_y (rev (hom A y x) (Segal-comp A AisSegal y y x (id-arr A y) g) g (Segal-id-comp A AisSegal y x g)) -- p1 = identity law (Segal-comp A AisSegal y y x (Segal-comp A AisSegal y x y h f) g) -- a2 = g o (f o h) (Segal-homotopy-postwhisker A AisSegal y y x -- p2 = postwhiskering (id-arr A y) (Segal-comp A AisSegal y x y h f) g (rev (hom A y y) (Segal-comp A AisSegal y x y h f) (id-arr A y) q) ) (Segal-comp A AisSegal y x x h (Segal-comp A AisSegal x y x f g)) -- a3 = (g o f) o h (Segal-associativity extext A AisSegal y x y x h f g) -- p3 = associativity (Segal-comp A AisSegal y x x h (id-arr A x)) -- a4 = id_x o h (Segal-homotopy-prewhisker A AisSegal y x x h -- p4 = prewhiskering (Segal-comp A AisSegal x y x f g) (id-arr A x) p) h -- a5 = h (Segal-comp-id A AisSegal y x h) -- p5 = connect through identity law ) ) q ) ) ) ) #def arrow-inverse-iff-iso ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : iff (arrow-has-inverse A AisSegal x y f) (arrow-is-iso A AisSegal x y f) := (arrow-inverse-to-iso A AisSegal x y f, arrow-iso-to-inverse extext A AisSegal x y f) #def if-iso-then-postcomp-has-retraction ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) : ( z : A) -> has-retraction (hom A z x) (hom A z y) (Segal-postcomp A AisSegal x y f z) := \\ z -> ( (Segal-postcomp A AisSegal y x g z), \\ k -> (triple-concat (hom A z x) -- k is an arrow z -> x (Segal-comp A AisSegal z y x (Segal-comp A AisSegal z x y k f) g) -- g(fk) (Segal-comp A AisSegal z x x k (Segal-comp A AisSegal x y x f g)) -- (gf)k (Segal-comp A AisSegal z x x k (id-arr A x)) -- id_x k k --k (Segal-associativity extext A AisSegal z x y x k f g) -- g(fk) = (gf)k (Segal-homotopy-prewhisker A AisSegal z x x k (Segal-comp A AisSegal x y x f g) (id-arr A x) gg) -- (gf)k = id_x k from (gf) = id_x (Segal-comp-id A AisSegal z x k) -- id_x k = k ) ) #def if-iso-then-postcomp-has-section ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : ( z : A) -> has-section (hom A z x) (hom A z y) (Segal-postcomp A AisSegal x y f z) := \\ z -> ( (Segal-postcomp A AisSegal y x h z), \\ k -> (triple-concat (hom A z y) -- k is an arrow z to y (Segal-comp A AisSegal z x y (Segal-comp A AisSegal z y x k h) f) -- f(hk) (Segal-comp A AisSegal z y y k (Segal-comp A AisSegal y x y h f)) -- (fh)k (Segal-comp A AisSegal z y y k (id-arr A y)) -- id_y k k --k (Segal-associativity extext A AisSegal z y x y k h f) -- f(hk) = (fh)k (Segal-homotopy-prewhisker A AisSegal z y y k (Segal-comp A AisSegal y x y h f) (id-arr A y) hh) -- (fh)k = id_y k from (fh) = id_y (Segal-comp-id A AisSegal z y k) -- id_y k = k ) ) #def if-iso-then-postcomp-is-equiv ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : ( z : A) -> is-equiv (hom A z x) (hom A z y) (Segal-postcomp A AisSegal x y f z) := \\ z -> ( (if-iso-then-postcomp-has-retraction extext A AisSegal x y f g gg z), (if-iso-then-postcomp-has-section extext A AisSegal x y f h hh z) ) #def if-iso-then-precomp-has-retraction ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : ( z : A) -> has-retraction (hom A y z) (hom A x z) (Segal-precomp A AisSegal x y f z) := \\ z -> ( (Segal-precomp A AisSegal y x h z), \\ k -> (triple-concat (hom A y z) -- k is an arrow y -> z (Segal-comp A AisSegal y x z h (Segal-comp A AisSegal x y z f k)) -- (kf)h (Segal-comp A AisSegal y y z (Segal-comp A AisSegal y x y h f) k) -- k(fh) (Segal-comp A AisSegal y y z (id-arr A y) k) -- k id_y k --k (rev (hom A y z) (Segal-comp A AisSegal y y z (Segal-comp A AisSegal y x y h f) k) (Segal-comp A AisSegal y x z h (Segal-comp A AisSegal x y z f k)) (Segal-associativity extext A AisSegal y x y z h f k) ) -- (kf)h = k(fh) (Segal-homotopy-postwhisker A AisSegal y y z (Segal-comp A AisSegal y x y h f) (id-arr A y) k hh) -- k(fh) = k id_y from (fh) = id_y (Segal-id-comp A AisSegal y z k) -- k id_y = k ) ) #def if-iso-then-precomp-has-section ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) : ( z : A) -> has-section (hom A y z) (hom A x z) (Segal-precomp A AisSegal x y f z) := \\ z -> ( (Segal-precomp A AisSegal y x g z), \\ k -> (triple-concat (hom A x z) -- k is an arrow x -> z (Segal-comp A AisSegal x y z f (Segal-comp A AisSegal y x z g k)) -- (kg)f (Segal-comp A AisSegal x x z (Segal-comp A AisSegal x y x f g) k) -- k(gf) (Segal-comp A AisSegal x x z (id-arr A x) k) -- k id_x k --k (rev (hom A x z) (Segal-comp A AisSegal x x z (Segal-comp A AisSegal x y x f g) k) (Segal-comp A AisSegal x y z f (Segal-comp A AisSegal y x z g k)) (Segal-associativity extext A AisSegal x y x z f g k) ) -- (kg)f = k(gf) (Segal-homotopy-postwhisker A AisSegal x x z (Segal-comp A AisSegal x y x f g) (id-arr A x) k gg) -- k(gf) = k id_x from (gf) = id_x (Segal-id-comp A AisSegal x z k) -- k id_x = k ) ) #def if-iso-then-precomp-is-equiv ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : ( z : A) -> is-equiv (hom A y z) (hom A x z) (Segal-precomp A AisSegal x y f z) := \\ z -> ( (if-iso-then-precomp-has-retraction extext A AisSegal x y f h hh z), (if-iso-then-precomp-has-section extext A AisSegal x y f g gg z) ) #def iso-inhabited-implies-hasRetr-contr ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : is-contr (arrow-Retraction A AisSegal x y f) := (is-contr-map-is-equiv (hom A y x) (hom A x x) (Segal-precomp A AisSegal x y f x) (if-iso-then-precomp-is-equiv extext A AisSegal x y f g gg h hh x)) (id-arr A x) #def iso-inhabited-implies-hasSec-contr ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : is-contr (arrow-Section A AisSegal x y f) := (is-contr-map-is-equiv (hom A y x) (hom A y y) (Segal-postcomp A AisSegal x y f y) (if-iso-then-postcomp-is-equiv extext A AisSegal x y f g gg h hh y)) (id-arr A y) #def iso-inhabited-implies-iso-contr ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : is-contr (arrow-is-iso A AisSegal x y f) := (is-contr-product (arrow-Retraction A AisSegal x y f) (arrow-Section A AisSegal x y f) (iso-inhabited-implies-hasRetr-contr extext A AisSegal x y f g gg h hh) (iso-inhabited-implies-hasSec-contr extext A AisSegal x y f g gg h hh) ) #def iso-is-prop ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : (is-prop (arrow-is-iso A AisSegal x y f)) := (is-prop-is-contr-is-inhabited (arrow-is-iso A AisSegal x y f) ( \\ is-isof -> (iso-inhabited-implies-iso-contr extext A AisSegal x y f ( first ( first is-isof)) ( second ( first is-isof)) ( first ( second is-isof)) ( second ( second is-isof)))) ) #def id-iso ( A : U ) ( AisSegal : is-segal A) : ( x : A) -> Iso A AisSegal x x := \\ x -> ( (id-arr A x), ( ( (id-arr A x), (Segal-id-comp A AisSegal x x (id-arr A x)) ), ( (id-arr A x), (Segal-id-comp A AisSegal x x (id-arr A x)) ) ) ) #def idtoiso ( A : U ) ( AisSegal : is-segal A) ( x y : A) : (x = y) -> Iso A AisSegal x y := \\ p -> idJ (A, x, \\ y' p' -> Iso A AisSegal x y', (id-iso A AisSegal x), y, p) #def is-rezk ( A : U ) : U := \u2211 ( AisSegal : is-segal A), ( x : A) -> ( y : A) -> is-equiv (x = y) (Iso A AisSegal x y) (idtoiso A AisSegal x y) #end isomorphisms def cocomma (B : U) (b : B) : U := (\u2211(x : B), (hom B b x)) \u00b6 def comma (B : U) (b : B) : U := (\u2211(x : B), (hom B x b)) \u00b6 def hom-cocomma (B : U) (b : B) : U := axiom-choice 2 \u0394\u00b9 \u2202\u0394\u00b9 (\\t -> \u00b6 def axiom-choice (I : CUBE) (\u03c8 : I -> TOPE) (\u03d5 : \u03c8 -> TOPE) (X : \u03c8 -> U) (Y : \u00b6 (t : \u03c8) -> (x : X t) -> U) (a : (t : \u03d5) -> X t) (b : (t : \u03d5) -> Y t (a t)) : Eq (<{t : I | \u03c8 t} -> (\u2211 (x : X t), Y t x) [ \u03d5 t |-> (a t , b t) ]>) (\u2211 (f : (<{t : I | \u03c8 t} -> X t [\u03d5 t |-> a t ]>)), (<{t : I | \u03c8 t} -> Y t (f t) [ \u03d5 t |-> b t ]>))","title":"Rezk Types"},{"location":"simplicial-hott/10-rezk-types.rzk/#rezk-types","text":"This is a literate rzk file: #lang rzk-1 #section isomorphisms #def arrow-has-retraction ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) : U := (Segal-comp A AisSegal x y x f g) =_{hom A x x} (id-arr A x) #def arrow-Retraction ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : U := \u2211 ( g : hom A y x), (arrow-has-retraction A AisSegal x y f g) #def arrow-has-section ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( h : hom A y x) : U := (Segal-comp A AisSegal y x y h f) =_{hom A y y} (id-arr A y) #def arrow-Section ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : U := \u2211 ( h : hom A y x), (arrow-has-section A AisSegal x y f h) #def arrow-is-iso ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : U := prod (arrow-Retraction A AisSegal x y f) (arrow-Section A AisSegal x y f) #def Iso ( A : U ) ( AisSegal : is-segal A) ( x y : A) : U := \u2211 ( f : hom A x y), arrow-is-iso A AisSegal x y f #def arrow-has-inverse ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : U := \u2211 ( g : hom A y x), prod (arrow-has-retraction A AisSegal x y f g) (arrow-has-section A AisSegal x y f g) #def arrow-inverse-to-iso ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : (arrow-has-inverse A AisSegal x y f) -> (arrow-is-iso A AisSegal x y f) := (\\(g, (p, q)) -> ((g, p), (g, q))) #def arrow-iso-to-inverse ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : (arrow-is-iso A AisSegal x y f) -> (arrow-has-inverse A AisSegal x y f) := (\\((g, p), (h, q)) -> (g, (p, (concat (hom A y y) (Segal-comp A AisSegal y x y g f) (Segal-comp A AisSegal y x y h f) (id-arr A y) (Segal-homotopy-postwhisker A AisSegal y x y g h f (quintuple-concat-alternating (hom A y x) g (Segal-comp A AisSegal y y x (id-arr A y) g) -- a0 = g and a1 = g o id_y (rev (hom A y x) (Segal-comp A AisSegal y y x (id-arr A y) g) g (Segal-id-comp A AisSegal y x g)) -- p1 = identity law (Segal-comp A AisSegal y y x (Segal-comp A AisSegal y x y h f) g) -- a2 = g o (f o h) (Segal-homotopy-postwhisker A AisSegal y y x -- p2 = postwhiskering (id-arr A y) (Segal-comp A AisSegal y x y h f) g (rev (hom A y y) (Segal-comp A AisSegal y x y h f) (id-arr A y) q) ) (Segal-comp A AisSegal y x x h (Segal-comp A AisSegal x y x f g)) -- a3 = (g o f) o h (Segal-associativity extext A AisSegal y x y x h f g) -- p3 = associativity (Segal-comp A AisSegal y x x h (id-arr A x)) -- a4 = id_x o h (Segal-homotopy-prewhisker A AisSegal y x x h -- p4 = prewhiskering (Segal-comp A AisSegal x y x f g) (id-arr A x) p) h -- a5 = h (Segal-comp-id A AisSegal y x h) -- p5 = connect through identity law ) ) q ) ) ) ) #def arrow-inverse-iff-iso ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : iff (arrow-has-inverse A AisSegal x y f) (arrow-is-iso A AisSegal x y f) := (arrow-inverse-to-iso A AisSegal x y f, arrow-iso-to-inverse extext A AisSegal x y f) #def if-iso-then-postcomp-has-retraction ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) : ( z : A) -> has-retraction (hom A z x) (hom A z y) (Segal-postcomp A AisSegal x y f z) := \\ z -> ( (Segal-postcomp A AisSegal y x g z), \\ k -> (triple-concat (hom A z x) -- k is an arrow z -> x (Segal-comp A AisSegal z y x (Segal-comp A AisSegal z x y k f) g) -- g(fk) (Segal-comp A AisSegal z x x k (Segal-comp A AisSegal x y x f g)) -- (gf)k (Segal-comp A AisSegal z x x k (id-arr A x)) -- id_x k k --k (Segal-associativity extext A AisSegal z x y x k f g) -- g(fk) = (gf)k (Segal-homotopy-prewhisker A AisSegal z x x k (Segal-comp A AisSegal x y x f g) (id-arr A x) gg) -- (gf)k = id_x k from (gf) = id_x (Segal-comp-id A AisSegal z x k) -- id_x k = k ) ) #def if-iso-then-postcomp-has-section ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : ( z : A) -> has-section (hom A z x) (hom A z y) (Segal-postcomp A AisSegal x y f z) := \\ z -> ( (Segal-postcomp A AisSegal y x h z), \\ k -> (triple-concat (hom A z y) -- k is an arrow z to y (Segal-comp A AisSegal z x y (Segal-comp A AisSegal z y x k h) f) -- f(hk) (Segal-comp A AisSegal z y y k (Segal-comp A AisSegal y x y h f)) -- (fh)k (Segal-comp A AisSegal z y y k (id-arr A y)) -- id_y k k --k (Segal-associativity extext A AisSegal z y x y k h f) -- f(hk) = (fh)k (Segal-homotopy-prewhisker A AisSegal z y y k (Segal-comp A AisSegal y x y h f) (id-arr A y) hh) -- (fh)k = id_y k from (fh) = id_y (Segal-comp-id A AisSegal z y k) -- id_y k = k ) ) #def if-iso-then-postcomp-is-equiv ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : ( z : A) -> is-equiv (hom A z x) (hom A z y) (Segal-postcomp A AisSegal x y f z) := \\ z -> ( (if-iso-then-postcomp-has-retraction extext A AisSegal x y f g gg z), (if-iso-then-postcomp-has-section extext A AisSegal x y f h hh z) ) #def if-iso-then-precomp-has-retraction ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : ( z : A) -> has-retraction (hom A y z) (hom A x z) (Segal-precomp A AisSegal x y f z) := \\ z -> ( (Segal-precomp A AisSegal y x h z), \\ k -> (triple-concat (hom A y z) -- k is an arrow y -> z (Segal-comp A AisSegal y x z h (Segal-comp A AisSegal x y z f k)) -- (kf)h (Segal-comp A AisSegal y y z (Segal-comp A AisSegal y x y h f) k) -- k(fh) (Segal-comp A AisSegal y y z (id-arr A y) k) -- k id_y k --k (rev (hom A y z) (Segal-comp A AisSegal y y z (Segal-comp A AisSegal y x y h f) k) (Segal-comp A AisSegal y x z h (Segal-comp A AisSegal x y z f k)) (Segal-associativity extext A AisSegal y x y z h f k) ) -- (kf)h = k(fh) (Segal-homotopy-postwhisker A AisSegal y y z (Segal-comp A AisSegal y x y h f) (id-arr A y) k hh) -- k(fh) = k id_y from (fh) = id_y (Segal-id-comp A AisSegal y z k) -- k id_y = k ) ) #def if-iso-then-precomp-has-section ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) : ( z : A) -> has-section (hom A y z) (hom A x z) (Segal-precomp A AisSegal x y f z) := \\ z -> ( (Segal-precomp A AisSegal y x g z), \\ k -> (triple-concat (hom A x z) -- k is an arrow x -> z (Segal-comp A AisSegal x y z f (Segal-comp A AisSegal y x z g k)) -- (kg)f (Segal-comp A AisSegal x x z (Segal-comp A AisSegal x y x f g) k) -- k(gf) (Segal-comp A AisSegal x x z (id-arr A x) k) -- k id_x k --k (rev (hom A x z) (Segal-comp A AisSegal x x z (Segal-comp A AisSegal x y x f g) k) (Segal-comp A AisSegal x y z f (Segal-comp A AisSegal y x z g k)) (Segal-associativity extext A AisSegal x y x z f g k) ) -- (kg)f = k(gf) (Segal-homotopy-postwhisker A AisSegal x x z (Segal-comp A AisSegal x y x f g) (id-arr A x) k gg) -- k(gf) = k id_x from (gf) = id_x (Segal-id-comp A AisSegal x z k) -- k id_x = k ) ) #def if-iso-then-precomp-is-equiv ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : ( z : A) -> is-equiv (hom A y z) (hom A x z) (Segal-precomp A AisSegal x y f z) := \\ z -> ( (if-iso-then-precomp-has-retraction extext A AisSegal x y f h hh z), (if-iso-then-precomp-has-section extext A AisSegal x y f g gg z) ) #def iso-inhabited-implies-hasRetr-contr ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : is-contr (arrow-Retraction A AisSegal x y f) := (is-contr-map-is-equiv (hom A y x) (hom A x x) (Segal-precomp A AisSegal x y f x) (if-iso-then-precomp-is-equiv extext A AisSegal x y f g gg h hh x)) (id-arr A x) #def iso-inhabited-implies-hasSec-contr ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : is-contr (arrow-Section A AisSegal x y f) := (is-contr-map-is-equiv (hom A y x) (hom A y y) (Segal-postcomp A AisSegal x y f y) (if-iso-then-postcomp-is-equiv extext A AisSegal x y f g gg h hh y)) (id-arr A y) #def iso-inhabited-implies-iso-contr ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : arrow-has-retraction A AisSegal x y f g) ( h : hom A y x) ( hh : arrow-has-section A AisSegal x y f h) : is-contr (arrow-is-iso A AisSegal x y f) := (is-contr-product (arrow-Retraction A AisSegal x y f) (arrow-Section A AisSegal x y f) (iso-inhabited-implies-hasRetr-contr extext A AisSegal x y f g gg h hh) (iso-inhabited-implies-hasSec-contr extext A AisSegal x y f g gg h hh) ) #def iso-is-prop ( extext : ExtExt) -- This proof uses extension extensionality. ( A : U ) ( AisSegal : is-segal A) ( x y : A) ( f : hom A x y) : (is-prop (arrow-is-iso A AisSegal x y f)) := (is-prop-is-contr-is-inhabited (arrow-is-iso A AisSegal x y f) ( \\ is-isof -> (iso-inhabited-implies-iso-contr extext A AisSegal x y f ( first ( first is-isof)) ( second ( first is-isof)) ( first ( second is-isof)) ( second ( second is-isof)))) ) #def id-iso ( A : U ) ( AisSegal : is-segal A) : ( x : A) -> Iso A AisSegal x x := \\ x -> ( (id-arr A x), ( ( (id-arr A x), (Segal-id-comp A AisSegal x x (id-arr A x)) ), ( (id-arr A x), (Segal-id-comp A AisSegal x x (id-arr A x)) ) ) ) #def idtoiso ( A : U ) ( AisSegal : is-segal A) ( x y : A) : (x = y) -> Iso A AisSegal x y := \\ p -> idJ (A, x, \\ y' p' -> Iso A AisSegal x y', (id-iso A AisSegal x), y, p) #def is-rezk ( A : U ) : U := \u2211 ( AisSegal : is-segal A), ( x : A) -> ( y : A) -> is-equiv (x = y) (Iso A AisSegal x y) (idtoiso A AisSegal x y) #end isomorphisms","title":"Rezk types"},{"location":"simplicial-hott/10-rezk-types.rzk/#def-cocomma-b-u-b-b-u-x-b-hom-b-b-x","text":"","title":"def cocomma (B : U) (b : B) : U := (\u2211(x : B), (hom B b x))"},{"location":"simplicial-hott/10-rezk-types.rzk/#def-comma-b-u-b-b-u-x-b-hom-b-x-b","text":"","title":"def comma (B : U) (b : B) : U := (\u2211(x : B), (hom B x b))"},{"location":"simplicial-hott/10-rezk-types.rzk/#def-hom-cocomma-b-u-b-b-u-axiom-choice-2-1-1-t-","text":"","title":"def hom-cocomma (B : U) (b : B) : U := axiom-choice 2 \u0394\u00b9 \u2202\u0394\u00b9 (\\t -&gt;"},{"location":"simplicial-hott/10-rezk-types.rzk/#def-axiom-choice-i-cube-i-tope-tope-x-u-y","text":"(t : \u03c8) -> (x : X t) -> U) (a : (t : \u03d5) -> X t) (b : (t : \u03d5) -> Y t (a t)) : Eq (<{t : I | \u03c8 t} -> (\u2211 (x : X t), Y t x) [ \u03d5 t |-> (a t , b t) ]>) (\u2211 (f : (<{t : I | \u03c8 t} -> X t [\u03d5 t |-> a t ]>)), (<{t : I | \u03c8 t} -> Y t (f t) [ \u03d5 t |-> b t ]>))","title":"def axiom-choice (I : CUBE) (\u03c8 : I -&gt; TOPE) (\u03d5 : \u03c8 -&gt; TOPE) (X : \u03c8 -&gt; U) (Y :"},{"location":"simplicial-hott/12-cocartesian.rzk/","text":"Cocartesian families \u00b6 These formalizations capture cocartesian families as treated in BW23. The goal, for now, is not to give a general structural account as in the paper but rather to provide the definitions and results that are necessary to prove the cocartesian Yoneda Lemma. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 8-covariant.md - We use covariant type families. 10-rezk-types.md - We use Rezk types. (Iso-)Inner families \u00b6 This is a (tentative and redundant) definition of (iso-)inner families. In the future, hopefully, these can be replaced by instances of orthogonal and LARI families. #def totalType ( B : U ) ( P : B -> U ) : U := \u2211 ( b : B), P b #def isInnerFam ( B : U ) ( P : B -> U ) : U := prod (prod (is-segal B) (is-segal (totalType B P))) ( (b : B) -> (is-segal (P b))) #def is-isoInnerFam ( B : U ) ( P : B -> U ) : U := prod (prod (is-rezk B) (is-rezk (totalType B P))) ( (b : B) -> (is-segal (P b))) Cocartesian arrows \u00b6 Here we define the proposition that a dependent arrow in a family is cocartesian. This is an alternative version using unpacked extension types, as this is preferred for usage. -- [BW23, Definition 5.1.1] #def isCocartArr ( B : U ) ( b b' : B) ( u : hom B b b') ( P : B -> U ) ( e : P b) ( e' : P b') ( f : dhom B b b' u P e e') : U := ( b'' : B) -> ( v : hom B b' b'') -> ( w : hom B b b'') -> ( sigma : hom2 B b b' b'' u v w) -> ( e'' : P b'') -> ( h : dhom B b b'' w P e e'') -> is-contr ( \u2211 ( g : dhom B b' b'' v P e' e'') , ( dhom2 B b b' b'' u v w sigma P e e' e'' f g h)) Cocartesian lifts \u00b6 The following is the type of cocartesian lifts of a fixed arrow in the base with a given starting point in the fiber. -- [BW23, Definition 5.1.2] #def CocartLift ( B : U ) ( b b' : B) ( u : hom B b b') ( P : B -> U ) ( e : P b) : U := \u2211 ( e' : P b'), \u2211 ( f : dhom B b b' u P e e'), isCocartArr B b b' u P e e' f def cocart-is-prop (B : U) (Bis-rezk : is-rezk B) (b b' : B) (u : hom B b b') (P \u00b6 : B -> U) (TPis-rezk : is-rezk (totalType B P)) (PisfibRezk : (b : B) -> is-rezk (P b)) (e : P b) (e' : P b') (f : dhom B b b' u P e e') (fiscocart : isCocartArr B b b' u P e e' f) : is-contr(CocartLift B b b' u P e) := ( (e', f, fiscocart), \\d -> \\g -> Initial objects \u00b6 #def is-initial ( A : U ) ( a : A) : U := ( x : A) -> is-contr(hom A a x) In a Segal type, initial objects are isomorphic. #def initial-iso ( A : U ) ( AisSegal : is-segal A) ( a b : A) ( ainitial : is-initial A a) ( binitial : is-initial A b) : Iso A AisSegal a b := ( first (ainitial b) , ( ( first (binitial a) , contractible-connecting-htpy ( hom A a a) ( ainitial a) ( Segal-comp A AisSegal a b a ( first (ainitial b)) ( first (binitial a))) ( id-arr A a)) , ( first (binitial a) , contractible-connecting-htpy ( hom A b b) ( binitial b) ( Segal-comp A AisSegal b a b ( first (binitial a)) ( first (ainitial b))) ( id-arr A b)))) Final objects \u00b6 #def is-final ( A : U ) ( a : A) : U := ( x : A) -> is-contr(hom A x a) In a Segal type, final objects are isomorphic. #def final-iso ( A : U ) ( AisSegal : is-segal A) ( a b : A) ( afinal : is-final A a) ( bfinal : is-final A b) ( iso : Iso A AisSegal a b) : Iso A AisSegal a b := ( first (bfinal a) , ( ( first (afinal b) , contractible-connecting-htpy ( hom A a a) ( afinal a) ( Segal-comp A AisSegal a b a ( first (bfinal a)) ( first (afinal b))) ( id-arr A a)) , ( first (afinal b) , contractible-connecting-htpy ( hom A b b) ( bfinal b) ( Segal-comp A AisSegal b a b ( first (afinal b)) ( first (bfinal a))) ( id-arr A b))))","title":"Cocartesian Families"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-families","text":"These formalizations capture cocartesian families as treated in BW23. The goal, for now, is not to give a general structural account as in the paper but rather to provide the definitions and results that are necessary to prove the cocartesian Yoneda Lemma. This is a literate rzk file: #lang rzk-1","title":"Cocartesian families"},{"location":"simplicial-hott/12-cocartesian.rzk/#prerequisites","text":"hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 8-covariant.md - We use covariant type families. 10-rezk-types.md - We use Rezk types.","title":"Prerequisites"},{"location":"simplicial-hott/12-cocartesian.rzk/#iso-inner-families","text":"This is a (tentative and redundant) definition of (iso-)inner families. In the future, hopefully, these can be replaced by instances of orthogonal and LARI families. #def totalType ( B : U ) ( P : B -> U ) : U := \u2211 ( b : B), P b #def isInnerFam ( B : U ) ( P : B -> U ) : U := prod (prod (is-segal B) (is-segal (totalType B P))) ( (b : B) -> (is-segal (P b))) #def is-isoInnerFam ( B : U ) ( P : B -> U ) : U := prod (prod (is-rezk B) (is-rezk (totalType B P))) ( (b : B) -> (is-segal (P b)))","title":"(Iso-)Inner families"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-arrows","text":"Here we define the proposition that a dependent arrow in a family is cocartesian. This is an alternative version using unpacked extension types, as this is preferred for usage. -- [BW23, Definition 5.1.1] #def isCocartArr ( B : U ) ( b b' : B) ( u : hom B b b') ( P : B -> U ) ( e : P b) ( e' : P b') ( f : dhom B b b' u P e e') : U := ( b'' : B) -> ( v : hom B b' b'') -> ( w : hom B b b'') -> ( sigma : hom2 B b b' b'' u v w) -> ( e'' : P b'') -> ( h : dhom B b b'' w P e e'') -> is-contr ( \u2211 ( g : dhom B b' b'' v P e' e'') , ( dhom2 B b b' b'' u v w sigma P e e' e'' f g h))","title":"Cocartesian arrows"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-lifts","text":"The following is the type of cocartesian lifts of a fixed arrow in the base with a given starting point in the fiber. -- [BW23, Definition 5.1.2] #def CocartLift ( B : U ) ( b b' : B) ( u : hom B b b') ( P : B -> U ) ( e : P b) : U := \u2211 ( e' : P b'), \u2211 ( f : dhom B b b' u P e e'), isCocartArr B b b' u P e e' f","title":"Cocartesian lifts"},{"location":"simplicial-hott/12-cocartesian.rzk/#def-cocart-is-prop-b-u-bis-rezk-is-rezk-b-b-b-b-u-hom-b-b-b-p","text":": B -> U) (TPis-rezk : is-rezk (totalType B P)) (PisfibRezk : (b : B) -> is-rezk (P b)) (e : P b) (e' : P b') (f : dhom B b b' u P e e') (fiscocart : isCocartArr B b b' u P e e' f) : is-contr(CocartLift B b b' u P e) := ( (e', f, fiscocart), \\d -> \\g ->","title":"def cocart-is-prop (B : U) (Bis-rezk : is-rezk B) (b b' : B) (u : hom B b b') (P"},{"location":"simplicial-hott/12-cocartesian.rzk/#initial-objects","text":"#def is-initial ( A : U ) ( a : A) : U := ( x : A) -> is-contr(hom A a x) In a Segal type, initial objects are isomorphic. #def initial-iso ( A : U ) ( AisSegal : is-segal A) ( a b : A) ( ainitial : is-initial A a) ( binitial : is-initial A b) : Iso A AisSegal a b := ( first (ainitial b) , ( ( first (binitial a) , contractible-connecting-htpy ( hom A a a) ( ainitial a) ( Segal-comp A AisSegal a b a ( first (ainitial b)) ( first (binitial a))) ( id-arr A a)) , ( first (binitial a) , contractible-connecting-htpy ( hom A b b) ( binitial b) ( Segal-comp A AisSegal b a b ( first (binitial a)) ( first (ainitial b))) ( id-arr A b))))","title":"Initial objects"},{"location":"simplicial-hott/12-cocartesian.rzk/#final-objects","text":"#def is-final ( A : U ) ( a : A) : U := ( x : A) -> is-contr(hom A x a) In a Segal type, final objects are isomorphic. #def final-iso ( A : U ) ( AisSegal : is-segal A) ( a b : A) ( afinal : is-final A a) ( bfinal : is-final A b) ( iso : Iso A AisSegal a b) : Iso A AisSegal a b := ( first (bfinal a) , ( ( first (afinal b) , contractible-connecting-htpy ( hom A a a) ( afinal a) ( Segal-comp A AisSegal a b a ( first (bfinal a)) ( first (afinal b))) ( id-arr A a)) , ( first (afinal b) , contractible-connecting-htpy ( hom A b b) ( bfinal b) ( Segal-comp A AisSegal b a b ( first (afinal b)) ( first (bfinal a))) ( id-arr A b))))","title":"Final objects"}]}