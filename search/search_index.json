{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yoneda for \u221e-categories This is a formalization library for simplicial Homotopy Type Theory (sHoTT) with the aim of proving the Yoneda lemma for \u221e-categories following the paper \" A type theory for synthetic \u221e-categories \" [1]. This formalization project could be regarded as a companion to the article \" Could \u221e-category theory be taught to undergraduates? \" [2]. The formalizations are implemented using rzk , an experimental proof assistant for a variant of type theory with shapes developed by Nikolai Kudasov . Formalizations were contributed by Nikolai Kudasov, Emily Riehl , and Jonathan Weinberger . Another aim of this project is to compare the proof of the Yoneda lemma for \u221e-categories in simplicial HoTT with proofs of the Yoneda lemma for 1-categories in other proof assistants. To that end Sina Hazratpour has contributed a formalization in Lean3 extracted from materials he prepared to teach Introduction to Proofs at Johns Hopkins, which can be found here . References Emily Riehl & Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 Emily Riehl. Could \u221e-category theory be taught to undergraduates? Notices of the AMS. May 2023. https://www.ams.org/journals/notices/202305/noti2692/noti2692.html","title":"About"},{"location":"#yoneda-for-categories","text":"This is a formalization library for simplicial Homotopy Type Theory (sHoTT) with the aim of proving the Yoneda lemma for \u221e-categories following the paper \" A type theory for synthetic \u221e-categories \" [1]. This formalization project could be regarded as a companion to the article \" Could \u221e-category theory be taught to undergraduates? \" [2]. The formalizations are implemented using rzk , an experimental proof assistant for a variant of type theory with shapes developed by Nikolai Kudasov . Formalizations were contributed by Nikolai Kudasov, Emily Riehl , and Jonathan Weinberger . Another aim of this project is to compare the proof of the Yoneda lemma for \u221e-categories in simplicial HoTT with proofs of the Yoneda lemma for 1-categories in other proof assistants. To that end Sina Hazratpour has contributed a formalization in Lean3 extracted from materials he prepared to teach Introduction to Proofs at Johns Hopkins, which can be found here .","title":"Yoneda for \u221e-categories"},{"location":"#references","text":"Emily Riehl & Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 Emily Riehl. Could \u221e-category theory be taught to undergraduates? Notices of the AMS. May 2023. https://www.ams.org/journals/notices/202305/noti2692/noti2692.html","title":"References"},{"location":"hott/00-common/","text":"0. Common This is a literate rzk file: #lang rzk-1 Products of types #def prod (A B : U) : U := \u2211 (x : A), B -- defined to illustrate the syntax for terms in sigma types #def diagonal (A : U) (a : A) : prod A A := (a , a) The type of logical equivalences between types #def iff (A B : U) : U := prod (A -> B) (B -> A) Basic function definitions #section basic-functions #variables A B C D : U #def composition (g : B -> C) -- The second function. (f : A -> B) -- The first function. : A -> C -- The composite function. := \\z -> g (f z) #def triple-composition (h : C -> D) (g : B -> C) (f : A -> B) : A -> D := \\z -> h (g (f z)) #def identity : A -> A := \\a -> a #def constant (b : B) -- The constant output value. : A -> B := \\a -> b #end basic-functions Substitution -- Reindexing a type family along a function into the base type. #def reindex (A B : U) (f : B -> A) (C : A -> U) : (B -> U) := \\b -> C (f b)","title":"Common"},{"location":"hott/00-common/#0-common","text":"This is a literate rzk file: #lang rzk-1","title":"0. Common"},{"location":"hott/00-common/#products-of-types","text":"#def prod (A B : U) : U := \u2211 (x : A), B -- defined to illustrate the syntax for terms in sigma types #def diagonal (A : U) (a : A) : prod A A := (a , a)","title":"Products of types"},{"location":"hott/00-common/#the-type-of-logical-equivalences-between-types","text":"#def iff (A B : U) : U := prod (A -> B) (B -> A)","title":"The type of logical equivalences between types"},{"location":"hott/00-common/#basic-function-definitions","text":"#section basic-functions #variables A B C D : U #def composition (g : B -> C) -- The second function. (f : A -> B) -- The first function. : A -> C -- The composite function. := \\z -> g (f z) #def triple-composition (h : C -> D) (g : B -> C) (f : A -> B) : A -> D := \\z -> h (g (f z)) #def identity : A -> A := \\a -> a #def constant (b : B) -- The constant output value. : A -> B := \\a -> b #end basic-functions","title":"Basic function definitions"},{"location":"hott/00-common/#substitution","text":"-- Reindexing a type family along a function into the base type. #def reindex (A B : U) (f : B -> A) (C : A -> U) : (B -> U) := \\b -> C (f b)","title":"Substitution"},{"location":"hott/01-paths/","text":"1. Paths This is a literate rzk file: #lang rzk-1 Some basic path algebra #section path-algebra #variable A : U #variables x y z : A -- path reversal #def rev (p : x = y) -- A path from x to y in A. : y = x -- The reversal will be defined by path induction on p. := idJ(A, x, \\y' p' -> y' = x, refl, y, p) -- path composition by induction on the second path #def concat (p : x = y) -- A path from x to y in A. (q : y = z) -- A path from y to z in A. : (x = z) := idJ(A, y, \\z' q' -> (x = z'), p, z, q) -- an alternative construction of path composition by induction on the first path -- this is useful in situations where it's easier to induction on the first path #def altconcat (p : x = y) -- A path from x to y in A. : (y = z) -> (x = z) := idJ(A, x, \\y' p' -> (y' = z) -> (x = z), \\q' -> q', y, p) #end path-algebra Some basic coherences in path algebra #section basic-path-coherence #variable A : U #variables w x y z : A #def rev-involution (p : x = y) -- A path from x to y in A. : (rev A y x (rev A x y p)) = p := idJ(A, x, \\y' p' -> (rev A y' x (rev A x y' p')) = p', refl, y, p) -- the coherence we don't have definitionally #def refl-concat (p : x = y) : (concat A x x y refl p) = p := idJ(A, x, \\y' p' -> (concat A x x y' refl p') = p', refl, y, p) -- associativity #def concat-assoc (p : w = x) -- A path from w to x in A. (q : x = y) -- A path from x to y in A. (r : y = z) -- A path from y to z in A. : concat A w y z (concat A w x y p q) r = concat A w x z p (concat A x y z q r) := idJ(A, y, \\z' r' -> concat A w y z' (concat A w x y p q) r' = concat A w x z' p (concat A x y z' q r'), refl, z, r) #def assoc-concat (p : w = x) -- A path from w to x in A. (q : x = y) -- A path from x to y in A. (r : y = z) -- A path from y to z in A. : concat A w x z p (concat A x y z q r) = concat A w y z (concat A w x y p q) r := idJ(A, y, \\z' r' -> concat A w x z' p (concat A x y z' q r') = concat A w y z' (concat A w x y p q) r', refl, z, r) #def rev-right-inverse (p : x = y) : concat A x y x p (rev A x y p) = refl := idJ(A, x, \\y' p' -> concat A x y' x p' (rev A x y' p') = refl, refl, y, p) #def rev-left-inverse (p : x = y) : concat A y x y (rev A x y p) p = refl := idJ(A, x, \\y' p' -> concat A y' x y' (rev A x y' p') p' = refl, refl, y, p) -- concatenation of two paths with common codomain; defined using concat and rev #def zig-zag-concat (p : x = y) -- A path from x to y in A. (q : z = y) -- A path from z to y in A. : (x = z) := concat A x y z p (rev A z y q) -- concatenation of two paths with common domain; defined using concat and rev #def zag-zig-concat (p : y = x) -- A path from y to x in A. (q : y = z) -- A path from y to z in A. : (x = z) := concat A x y z (rev A y x p) q #def concat-right-cancel (p q : x = y) -- Two paths from x to y in A. (r : y = z) -- A path from y to z in A. : ((concat A x y z p r) = (concat A x y z q r)) -> (p = q) := idJ(A, y, \\z' r' -> (H : (concat A x y z' p r') = (concat A x y z' q r')) -> (p = q), \\H -> H, z, r) #end basic-path-coherence Some derived coherences in path algebra The statements or proofs of the following path algebra coherences reference one of the path algebra coherences defined above. #section derived-path-coherence #variable A : U #variables x y z : A #def rev-concat (p : x = y) -- A path from x to y in A. (q : y = z) -- A path from y to z in A. : (rev A x z (concat A x y z p q)) = (concat A z y x (rev A y z q) (rev A x y p)) := idJ(A, y, \\z' q' -> (rev A x z' (concat A x y z' p q')) = (concat A z' y x (rev A y z' q') (rev A x y p)), rev (y = x) (concat A y y x refl (rev A x y p)) (rev A x y p) (refl-concat A y x (rev A x y p)), z, q) -- postwhiskering paths of paths #def homotopy-concat (p q : x = y) -- Two paths from x to y in A. (H : p = q) (r : y = z) : (concat A x y z p r) = (concat A x y z q r) := idJ(A, y, \\z' r' -> (concat A x y z' p r') = (concat A x y z' q r'), H, z, r) -- prewhiskering paths of paths is much harder #def concat-homotopy (p : x = y) : (z : A) -> (q : y = z) -> (r : y = z) -> (H : q = r) -> (concat A x y z p q) = (concat A x y z p r) := idJ(A, x, \\y' p' -> (z : A) -> (q : y' = z) -> (r : y' = z) -> (H : q = r) -> (concat A x y' z p' q) = (concat A x y' z p' r), \\z q r H -> concat (x = z) (concat A x x z refl q) r (concat A x x z refl r) (concat (x = z) (concat A x x z refl q) q r (refl-concat A x z q) H) (rev (x = z) (concat A x x z refl r) r (refl-concat A x z r)), y, p) -- a higher path comparing the two compositions #def concat-altconcat (p : x = y) -- A path from x to y in A. : (q : y = z) -> (concat A x y z p q) = (altconcat A x y z p q) := idJ(A, x, \\y' -> \\p' -> (q' : y' =_{A} z) -> (concat A x y' z p' q') =_{x =_{A} z} altconcat A x y' z p' q', \\q' -> refl-concat A x z q', y, p) -- a higher path comparing the two compositions in the other order #def altconcat-concat (p : x = y) -- A path from x to y in A. (q : y = z) -- A path from y to z in A. : (altconcat A x y z p q) = concat A x y z p q := rev (x = z) (concat A x y z p q) (altconcat A x y z p q) (concat-altconcat p q) -- this is easier to prove for altconcat then for concat #def alt-triangle-rotation (p : x = z) (q : x = y) : (r : y = z) -> (H : p = altconcat A x y z q r) -> (altconcat A y x z (rev A x y q) p) = r := idJ(A, x, \\y' q' -> (r' : y' =_{A} z) -> (H' : p = altconcat A x y' z q' r') -> (altconcat A y' x z (rev A x y' q') p) = r', \\r' H' -> H', y, q) #end derived-path-coherence -- This needs to be outside the previous section because of the usage of concat-altconcat A y x #def triangle-rotation (A : U) (x y z : A) (p : x = z) (q : x = y) (r : y = z) (H : p = concat A x y z q r) : (concat A y x z (rev A x y q) p) = r := concat (y = z) (concat A y x z (rev A x y q) p) (altconcat A y x z (rev A x y q) p) r (concat-altconcat A y x z (rev A x y q) p) (alt-triangle-rotation A x y z p q r (concat (x = z) p (concat A x y z q r) (altconcat A x y z q r) H (concat-altconcat A x y z q r))) Application of functions to paths #def ap (A B : U) (x y : A) (f : A -> B) (p : x = y) : (f x = f y) := idJ(A, x, \\y' -> \\p' -> (f x = f y'), refl, y, p) #def ap-concat (A B : U) (x y z : A) (f : A -> B) (p : x = y) (q : y = z) : (ap A B x z f (concat A x y z p q)) = (concat B (f x) (f y) (f z) (ap A B x y f p) (ap A B y z f q)) := idJ(A, y, \\z' q' -> (ap A B x z' f (concat A x y z' p q')) = (concat B (f x) (f y) (f z') (ap A B x y f p) (ap A B y z' f q')), refl, z, q) #def rev-ap-rev (A B : U) (x y : A) (f : A -> B) (p : x = y) : (rev B (f y) (f x) (ap A B y x f (rev A x y p))) = (ap A B x y f p) := idJ(A, x, \\y' p' -> (rev B (f y') (f x) (ap A B y' x f (rev A x y' p'))) = (ap A B x y' f p'), refl, y, p) -- For specific use #def concat-ap-rev-ap-id (A B : U) (x y : A) (f : A -> B) (p : x = y) : (concat B (f y) (f x) (f y) (ap A B y x f (rev A x y p)) (ap A B x y f p)) = refl := idJ(A, x, \\y' p' -> (concat B (f y') (f x) (f y') (ap A B y' x f (rev A x y' p')) (ap A B x y' f p')) = refl, refl, y, p) #def ap-id (A : U) (x y : A) (p : x = y) : (ap A A x y (identity A) p) = p := idJ(A, x, \\y' -> \\p' -> (ap A A x y' (\\z -> z) p') = p', refl, y, p) -- application of a function to homotopic paths yields homotopic paths #def ap-htpy (A B : U) (x y : A) (f : A -> B) (p q : x = y) (H : p = q) : (ap A B x y f p) = (ap A B x y f q) := idJ(x = y, p, \\q' H' -> (ap A B x y f p) = (ap A B x y f q'), refl, q, H) #def ap-comp (A B C : U) (x y : A) (f : A -> B) (g : B -> C) (p : x = y) : (ap A C x y (composition A B C g f) p) = (ap B C (f x) (f y) g (ap A B x y f p)) := idJ(A, x, \\y' p' -> (ap A C x y' (\\z -> g (f z)) p') = (ap B C (f x) (f y') g (ap A B x y' f p')), refl, y, p) #def rev-ap-comp (A B C : U) (x y : A) (f : A -> B) (g : B -> C) (p : x = y) : (ap B C (f x) (f y) g (ap A B x y f p)) = (ap A C x y (composition A B C g f) p) := rev (g (f x) = g (f y)) (ap A C x y (\\z -> g (f z)) p) (ap B C (f x) (f y) g (ap A B x y f p)) (ap-comp A B C x y f g p) Transport #section transport #variable A : U #variable B : A -> U -- transport in a type family along a path in the base #def transport (x y : A) (p : x = y) (u : B x) : B y := idJ(A, x, \\y' p' -> B y', u, y, p) -- The lift of a base path to a path from a term in the total space to its transport. #def transport-lift (x y : A) (p : x = y) (u : B x) : (x, u) =_{\u2211 (z : A), B z} (y, transport x y p u) := idJ(A, x, \\y' p' -> (x, u) =_{\u2211 (z : A), B z} (y', transport x y' p' u), refl, y, p) -- transport along concatenated paths #def transport-concat (x y z : A) (p : x = y) (q : y = z) (u : B x) : (transport x z (concat A x y z p q) u) = (transport y z q (transport x y p u)) := idJ(A, y, \\z' q' -> (transport x z' (concat A x y z' p q') u) = (transport y z' q' (transport x y p u)), refl, z, q) #def transport-concat-rev (x y z : A) (p : x = y) (q : y = z) (u : B x) : (transport y z q (transport x y p u)) = (transport x z (concat A x y z p q) u) := idJ(A, y, \\z' q' -> (transport y z' q' (transport x y p u)) = (transport x z' (concat A x y z' p q') u), refl, z, q) -- A path between transportation along homotopic paths #def transport2 (x y : A) (p q : x = y) (H : p = q) (u : B x) : (transport x y p u) = (transport x y q u) := idJ(x = y, p, \\q' H' -> (transport x y p u) = (transport x y q' u), refl, q, H) #end transport Dependent application -- Application of dependent functions on paths #def apd (A : U) (B : A -> U) (x y : A) (f : (z : A) -> B z) (p : x = y) : ((transport A B x y p (f x)) = f y) := idJ(A, x, \\y' -> \\p' -> ((transport A B x y' p' (f x)) = f y'), refl, y, p) Higher-order concatenation #section higher-concatenation #variable A : U -- triple concatenation #def triple-concat (a0 a1 a2 a3 : A) (p1 : a0 = a1) (p2 : a1 = a2) (p3 : a2 = a3) : a0 = a3 := concat A a0 a1 a3 p1 (concat A a1 a2 a3 p2 p3) #def quadruple-concat (a0 a1 a2 a3 a4 : A) (p1 : a0 = a1) (p2 : a1 = a2) (p3 : a2 = a3) (p4 : a3 = a4) : a0 = a4 := triple-concat a0 a1 a2 a4 p1 p2 (concat A a2 a3 a4 p3 p4) #def quintuple-concat (a0 a1 a2 a3 a4 a5 : A) (p1 : a0 = a1) (p2 : a1 = a2) (p3 : a2 = a3) (p4 : a3 = a4) (p5 : a4 = a5) : a0 = a5 := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5) #def sextuple-concat (A : U) (a0 a1 a2 a3 a4 a5 a6 : A) (p1 : a0 = a1) (p2 : a1 = a2) (p3 : a2 = a3) (p4 : a3 = a4) (p5 : a4 = a5) (p6 : a5 = a6) : a0 = a6 := quintuple-concat A a0 a1 a2 a3 a4 a6 p1 p2 p3 p4 (concat A a4 a5 a6 p5 p6) #def sextuple-concat-alternating (A : U) (a0 a1 : A) (p1 : a0 = a1) (a2 : A) (p2 : a1 = a2) (a3 : A) (p3 : a2 = a3) (a4 : A) (p4 : a3 = a4) (a5 : A) (p5 : a4 = a5) (a6 : A) (p6 : a5 = a6) : a0 = a6 := quintuple-concat A a0 a1 a2 a3 a4 a6 p1 p2 p3 p4 (concat A a4 a5 a6 p5 p6) #def 12ary-concat (a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 : A) (p1 : a0 = a1) (p2 : a1 = a2) (p3 : a2 = a3) (p4 : a3 = a4) (p5 : a4 = a5) (p6 : a5 = a6) (p7 : a6 = a7) (p8 : a7 = a8) (p9 : a8 = a9) (p10 : a9 = a10) (p11 : a10 = a11) (p12 : a11 = a12) : a0 = a12 := quintuple-concat a0 a1 a2 a3 a4 a12 p1 p2 p3 p4 (quintuple-concat a4 a5 a6 a7 a8 a12 p5 p6 p7 p8 (quadruple-concat a8 a9 a10 a11 a12 p9 p10 p11 p12)) -- Same as above but with alternating arguments #def 12ary-concat-alternating (a0 a1 : A) (p1 : a0 = a1) (a2 : A) (p2 : a1 = a2) (a3 : A) (p3 : a2 = a3) (a4 : A) (p4 : a3 = a4) (a5 : A) (p5 : a4 = a5) (a6 : A) (p6 : a5 = a6) (a7 : A) (p7 : a6 = a7) (a8 : A) (p8 : a7 = a8) (a9 : A) (p9 : a8 = a9) (a10 : A) (p10 : a9 = a10) (a11 : A) (p11 : a10 = a11) (a12 : A) (p12 : a11 = a12) : a0 = a12 := 12ary-concat a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 #end higher-concatenation Paths involving products #section paths-in-products #variables A B : U #def path-product (a a' : A) (b b' : B) (e_A : a = a') (e_B : b = b') : (a, b) =_{prod A B} (a', b') := transport A (\\x -> (a, b) =_{prod A B} (x, b')) a a' e_A (transport B (\\y -> (a, b) =_{prod A B} (a, y)) b b' e_B refl) #def first-path-product (x y : prod A B) (e : x =_{prod A B} y) : first x = first y := ap (prod A B) A x y (\\z -> first z) e #def second-path-product (x y : prod A B) (e : x =_{prod A B} y) : second x = second y := ap (prod A B) B x y (\\z -> second z) e #end paths-in-products Paths involving dependent sums #section paths-in-sigma #variable A : U #variable B : A -> U #def first-path-sigma (x y : \u2211 (a : A), B a) (e : x = y) : first x = first y := ap (\u2211 (a : A), B a) A x y (\\z -> first z) e #def second-path-sigma (x y : \u2211 (a : A), B a) (e : x = y) : (transport A B (first x) (first y) (first-path-sigma x y e) (second x)) = (second y) := idJ((\u2211 (a : A), B a), x, \\y' e' -> (transport A B (first x) (first y') (first-path-sigma x y' e') (second x)) = (second y'), refl, y, e) #end paths-in-sigma","title":"Paths"},{"location":"hott/01-paths/#1-paths","text":"This is a literate rzk file: #lang rzk-1","title":"1. Paths"},{"location":"hott/01-paths/#some-basic-path-algebra","text":"#section path-algebra #variable A : U #variables x y z : A -- path reversal #def rev (p : x = y) -- A path from x to y in A. : y = x -- The reversal will be defined by path induction on p. := idJ(A, x, \\y' p' -> y' = x, refl, y, p) -- path composition by induction on the second path #def concat (p : x = y) -- A path from x to y in A. (q : y = z) -- A path from y to z in A. : (x = z) := idJ(A, y, \\z' q' -> (x = z'), p, z, q) -- an alternative construction of path composition by induction on the first path -- this is useful in situations where it's easier to induction on the first path #def altconcat (p : x = y) -- A path from x to y in A. : (y = z) -> (x = z) := idJ(A, x, \\y' p' -> (y' = z) -> (x = z), \\q' -> q', y, p) #end path-algebra","title":"Some basic path algebra"},{"location":"hott/01-paths/#some-basic-coherences-in-path-algebra","text":"#section basic-path-coherence #variable A : U #variables w x y z : A #def rev-involution (p : x = y) -- A path from x to y in A. : (rev A y x (rev A x y p)) = p := idJ(A, x, \\y' p' -> (rev A y' x (rev A x y' p')) = p', refl, y, p) -- the coherence we don't have definitionally #def refl-concat (p : x = y) : (concat A x x y refl p) = p := idJ(A, x, \\y' p' -> (concat A x x y' refl p') = p', refl, y, p) -- associativity #def concat-assoc (p : w = x) -- A path from w to x in A. (q : x = y) -- A path from x to y in A. (r : y = z) -- A path from y to z in A. : concat A w y z (concat A w x y p q) r = concat A w x z p (concat A x y z q r) := idJ(A, y, \\z' r' -> concat A w y z' (concat A w x y p q) r' = concat A w x z' p (concat A x y z' q r'), refl, z, r) #def assoc-concat (p : w = x) -- A path from w to x in A. (q : x = y) -- A path from x to y in A. (r : y = z) -- A path from y to z in A. : concat A w x z p (concat A x y z q r) = concat A w y z (concat A w x y p q) r := idJ(A, y, \\z' r' -> concat A w x z' p (concat A x y z' q r') = concat A w y z' (concat A w x y p q) r', refl, z, r) #def rev-right-inverse (p : x = y) : concat A x y x p (rev A x y p) = refl := idJ(A, x, \\y' p' -> concat A x y' x p' (rev A x y' p') = refl, refl, y, p) #def rev-left-inverse (p : x = y) : concat A y x y (rev A x y p) p = refl := idJ(A, x, \\y' p' -> concat A y' x y' (rev A x y' p') p' = refl, refl, y, p) -- concatenation of two paths with common codomain; defined using concat and rev #def zig-zag-concat (p : x = y) -- A path from x to y in A. (q : z = y) -- A path from z to y in A. : (x = z) := concat A x y z p (rev A z y q) -- concatenation of two paths with common domain; defined using concat and rev #def zag-zig-concat (p : y = x) -- A path from y to x in A. (q : y = z) -- A path from y to z in A. : (x = z) := concat A x y z (rev A y x p) q #def concat-right-cancel (p q : x = y) -- Two paths from x to y in A. (r : y = z) -- A path from y to z in A. : ((concat A x y z p r) = (concat A x y z q r)) -> (p = q) := idJ(A, y, \\z' r' -> (H : (concat A x y z' p r') = (concat A x y z' q r')) -> (p = q), \\H -> H, z, r) #end basic-path-coherence","title":"Some basic coherences in path algebra"},{"location":"hott/01-paths/#some-derived-coherences-in-path-algebra","text":"The statements or proofs of the following path algebra coherences reference one of the path algebra coherences defined above. #section derived-path-coherence #variable A : U #variables x y z : A #def rev-concat (p : x = y) -- A path from x to y in A. (q : y = z) -- A path from y to z in A. : (rev A x z (concat A x y z p q)) = (concat A z y x (rev A y z q) (rev A x y p)) := idJ(A, y, \\z' q' -> (rev A x z' (concat A x y z' p q')) = (concat A z' y x (rev A y z' q') (rev A x y p)), rev (y = x) (concat A y y x refl (rev A x y p)) (rev A x y p) (refl-concat A y x (rev A x y p)), z, q) -- postwhiskering paths of paths #def homotopy-concat (p q : x = y) -- Two paths from x to y in A. (H : p = q) (r : y = z) : (concat A x y z p r) = (concat A x y z q r) := idJ(A, y, \\z' r' -> (concat A x y z' p r') = (concat A x y z' q r'), H, z, r) -- prewhiskering paths of paths is much harder #def concat-homotopy (p : x = y) : (z : A) -> (q : y = z) -> (r : y = z) -> (H : q = r) -> (concat A x y z p q) = (concat A x y z p r) := idJ(A, x, \\y' p' -> (z : A) -> (q : y' = z) -> (r : y' = z) -> (H : q = r) -> (concat A x y' z p' q) = (concat A x y' z p' r), \\z q r H -> concat (x = z) (concat A x x z refl q) r (concat A x x z refl r) (concat (x = z) (concat A x x z refl q) q r (refl-concat A x z q) H) (rev (x = z) (concat A x x z refl r) r (refl-concat A x z r)), y, p) -- a higher path comparing the two compositions #def concat-altconcat (p : x = y) -- A path from x to y in A. : (q : y = z) -> (concat A x y z p q) = (altconcat A x y z p q) := idJ(A, x, \\y' -> \\p' -> (q' : y' =_{A} z) -> (concat A x y' z p' q') =_{x =_{A} z} altconcat A x y' z p' q', \\q' -> refl-concat A x z q', y, p) -- a higher path comparing the two compositions in the other order #def altconcat-concat (p : x = y) -- A path from x to y in A. (q : y = z) -- A path from y to z in A. : (altconcat A x y z p q) = concat A x y z p q := rev (x = z) (concat A x y z p q) (altconcat A x y z p q) (concat-altconcat p q) -- this is easier to prove for altconcat then for concat #def alt-triangle-rotation (p : x = z) (q : x = y) : (r : y = z) -> (H : p = altconcat A x y z q r) -> (altconcat A y x z (rev A x y q) p) = r := idJ(A, x, \\y' q' -> (r' : y' =_{A} z) -> (H' : p = altconcat A x y' z q' r') -> (altconcat A y' x z (rev A x y' q') p) = r', \\r' H' -> H', y, q) #end derived-path-coherence -- This needs to be outside the previous section because of the usage of concat-altconcat A y x #def triangle-rotation (A : U) (x y z : A) (p : x = z) (q : x = y) (r : y = z) (H : p = concat A x y z q r) : (concat A y x z (rev A x y q) p) = r := concat (y = z) (concat A y x z (rev A x y q) p) (altconcat A y x z (rev A x y q) p) r (concat-altconcat A y x z (rev A x y q) p) (alt-triangle-rotation A x y z p q r (concat (x = z) p (concat A x y z q r) (altconcat A x y z q r) H (concat-altconcat A x y z q r)))","title":"Some derived coherences in path algebra"},{"location":"hott/01-paths/#application-of-functions-to-paths","text":"#def ap (A B : U) (x y : A) (f : A -> B) (p : x = y) : (f x = f y) := idJ(A, x, \\y' -> \\p' -> (f x = f y'), refl, y, p) #def ap-concat (A B : U) (x y z : A) (f : A -> B) (p : x = y) (q : y = z) : (ap A B x z f (concat A x y z p q)) = (concat B (f x) (f y) (f z) (ap A B x y f p) (ap A B y z f q)) := idJ(A, y, \\z' q' -> (ap A B x z' f (concat A x y z' p q')) = (concat B (f x) (f y) (f z') (ap A B x y f p) (ap A B y z' f q')), refl, z, q) #def rev-ap-rev (A B : U) (x y : A) (f : A -> B) (p : x = y) : (rev B (f y) (f x) (ap A B y x f (rev A x y p))) = (ap A B x y f p) := idJ(A, x, \\y' p' -> (rev B (f y') (f x) (ap A B y' x f (rev A x y' p'))) = (ap A B x y' f p'), refl, y, p) -- For specific use #def concat-ap-rev-ap-id (A B : U) (x y : A) (f : A -> B) (p : x = y) : (concat B (f y) (f x) (f y) (ap A B y x f (rev A x y p)) (ap A B x y f p)) = refl := idJ(A, x, \\y' p' -> (concat B (f y') (f x) (f y') (ap A B y' x f (rev A x y' p')) (ap A B x y' f p')) = refl, refl, y, p) #def ap-id (A : U) (x y : A) (p : x = y) : (ap A A x y (identity A) p) = p := idJ(A, x, \\y' -> \\p' -> (ap A A x y' (\\z -> z) p') = p', refl, y, p) -- application of a function to homotopic paths yields homotopic paths #def ap-htpy (A B : U) (x y : A) (f : A -> B) (p q : x = y) (H : p = q) : (ap A B x y f p) = (ap A B x y f q) := idJ(x = y, p, \\q' H' -> (ap A B x y f p) = (ap A B x y f q'), refl, q, H) #def ap-comp (A B C : U) (x y : A) (f : A -> B) (g : B -> C) (p : x = y) : (ap A C x y (composition A B C g f) p) = (ap B C (f x) (f y) g (ap A B x y f p)) := idJ(A, x, \\y' p' -> (ap A C x y' (\\z -> g (f z)) p') = (ap B C (f x) (f y') g (ap A B x y' f p')), refl, y, p) #def rev-ap-comp (A B C : U) (x y : A) (f : A -> B) (g : B -> C) (p : x = y) : (ap B C (f x) (f y) g (ap A B x y f p)) = (ap A C x y (composition A B C g f) p) := rev (g (f x) = g (f y)) (ap A C x y (\\z -> g (f z)) p) (ap B C (f x) (f y) g (ap A B x y f p)) (ap-comp A B C x y f g p)","title":"Application of functions to paths"},{"location":"hott/01-paths/#transport","text":"#section transport #variable A : U #variable B : A -> U -- transport in a type family along a path in the base #def transport (x y : A) (p : x = y) (u : B x) : B y := idJ(A, x, \\y' p' -> B y', u, y, p) -- The lift of a base path to a path from a term in the total space to its transport. #def transport-lift (x y : A) (p : x = y) (u : B x) : (x, u) =_{\u2211 (z : A), B z} (y, transport x y p u) := idJ(A, x, \\y' p' -> (x, u) =_{\u2211 (z : A), B z} (y', transport x y' p' u), refl, y, p) -- transport along concatenated paths #def transport-concat (x y z : A) (p : x = y) (q : y = z) (u : B x) : (transport x z (concat A x y z p q) u) = (transport y z q (transport x y p u)) := idJ(A, y, \\z' q' -> (transport x z' (concat A x y z' p q') u) = (transport y z' q' (transport x y p u)), refl, z, q) #def transport-concat-rev (x y z : A) (p : x = y) (q : y = z) (u : B x) : (transport y z q (transport x y p u)) = (transport x z (concat A x y z p q) u) := idJ(A, y, \\z' q' -> (transport y z' q' (transport x y p u)) = (transport x z' (concat A x y z' p q') u), refl, z, q) -- A path between transportation along homotopic paths #def transport2 (x y : A) (p q : x = y) (H : p = q) (u : B x) : (transport x y p u) = (transport x y q u) := idJ(x = y, p, \\q' H' -> (transport x y p u) = (transport x y q' u), refl, q, H) #end transport","title":"Transport"},{"location":"hott/01-paths/#dependent-application","text":"-- Application of dependent functions on paths #def apd (A : U) (B : A -> U) (x y : A) (f : (z : A) -> B z) (p : x = y) : ((transport A B x y p (f x)) = f y) := idJ(A, x, \\y' -> \\p' -> ((transport A B x y' p' (f x)) = f y'), refl, y, p)","title":"Dependent application"},{"location":"hott/01-paths/#higher-order-concatenation","text":"#section higher-concatenation #variable A : U -- triple concatenation #def triple-concat (a0 a1 a2 a3 : A) (p1 : a0 = a1) (p2 : a1 = a2) (p3 : a2 = a3) : a0 = a3 := concat A a0 a1 a3 p1 (concat A a1 a2 a3 p2 p3) #def quadruple-concat (a0 a1 a2 a3 a4 : A) (p1 : a0 = a1) (p2 : a1 = a2) (p3 : a2 = a3) (p4 : a3 = a4) : a0 = a4 := triple-concat a0 a1 a2 a4 p1 p2 (concat A a2 a3 a4 p3 p4) #def quintuple-concat (a0 a1 a2 a3 a4 a5 : A) (p1 : a0 = a1) (p2 : a1 = a2) (p3 : a2 = a3) (p4 : a3 = a4) (p5 : a4 = a5) : a0 = a5 := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5) #def sextuple-concat (A : U) (a0 a1 a2 a3 a4 a5 a6 : A) (p1 : a0 = a1) (p2 : a1 = a2) (p3 : a2 = a3) (p4 : a3 = a4) (p5 : a4 = a5) (p6 : a5 = a6) : a0 = a6 := quintuple-concat A a0 a1 a2 a3 a4 a6 p1 p2 p3 p4 (concat A a4 a5 a6 p5 p6) #def sextuple-concat-alternating (A : U) (a0 a1 : A) (p1 : a0 = a1) (a2 : A) (p2 : a1 = a2) (a3 : A) (p3 : a2 = a3) (a4 : A) (p4 : a3 = a4) (a5 : A) (p5 : a4 = a5) (a6 : A) (p6 : a5 = a6) : a0 = a6 := quintuple-concat A a0 a1 a2 a3 a4 a6 p1 p2 p3 p4 (concat A a4 a5 a6 p5 p6) #def 12ary-concat (a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 : A) (p1 : a0 = a1) (p2 : a1 = a2) (p3 : a2 = a3) (p4 : a3 = a4) (p5 : a4 = a5) (p6 : a5 = a6) (p7 : a6 = a7) (p8 : a7 = a8) (p9 : a8 = a9) (p10 : a9 = a10) (p11 : a10 = a11) (p12 : a11 = a12) : a0 = a12 := quintuple-concat a0 a1 a2 a3 a4 a12 p1 p2 p3 p4 (quintuple-concat a4 a5 a6 a7 a8 a12 p5 p6 p7 p8 (quadruple-concat a8 a9 a10 a11 a12 p9 p10 p11 p12)) -- Same as above but with alternating arguments #def 12ary-concat-alternating (a0 a1 : A) (p1 : a0 = a1) (a2 : A) (p2 : a1 = a2) (a3 : A) (p3 : a2 = a3) (a4 : A) (p4 : a3 = a4) (a5 : A) (p5 : a4 = a5) (a6 : A) (p6 : a5 = a6) (a7 : A) (p7 : a6 = a7) (a8 : A) (p8 : a7 = a8) (a9 : A) (p9 : a8 = a9) (a10 : A) (p10 : a9 = a10) (a11 : A) (p11 : a10 = a11) (a12 : A) (p12 : a11 = a12) : a0 = a12 := 12ary-concat a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 #end higher-concatenation","title":"Higher-order concatenation"},{"location":"hott/01-paths/#paths-involving-products","text":"#section paths-in-products #variables A B : U #def path-product (a a' : A) (b b' : B) (e_A : a = a') (e_B : b = b') : (a, b) =_{prod A B} (a', b') := transport A (\\x -> (a, b) =_{prod A B} (x, b')) a a' e_A (transport B (\\y -> (a, b) =_{prod A B} (a, y)) b b' e_B refl) #def first-path-product (x y : prod A B) (e : x =_{prod A B} y) : first x = first y := ap (prod A B) A x y (\\z -> first z) e #def second-path-product (x y : prod A B) (e : x =_{prod A B} y) : second x = second y := ap (prod A B) B x y (\\z -> second z) e #end paths-in-products","title":"Paths involving products"},{"location":"hott/01-paths/#paths-involving-dependent-sums","text":"#section paths-in-sigma #variable A : U #variable B : A -> U #def first-path-sigma (x y : \u2211 (a : A), B a) (e : x = y) : first x = first y := ap (\u2211 (a : A), B a) A x y (\\z -> first z) e #def second-path-sigma (x y : \u2211 (a : A), B a) (e : x = y) : (transport A B (first x) (first y) (first-path-sigma x y e) (second x)) = (second y) := idJ((\u2211 (a : A), B a), x, \\y' e' -> (transport A B (first x) (first y') (first-path-sigma x y' e') (second x)) = (second y'), refl, y, e) #end paths-in-sigma","title":"Paths involving dependent sums"},{"location":"hott/02-homotopies/","text":"2. Homotopies This is a literate rzk file: #lang rzk-1 Homotopies and their algebra #section homotopies #variables A B : U -- The type of homotopies between parallel functions. #def homotopy (f g : A -> B) -- Two parallel functions. : U := (a : A) -> (f a = g a) -- The reversal of a homotopy #def homotopy-rev (f g : A -> B) -- Two parallel functions. (H : homotopy f g) -- A homotopy from f to g. : homotopy g f := \\a -> rev B (f a) (g a) (H a) -- Homotopy composition is defined in diagrammatic order like concat but unlike composition. #def homotopy-composition (f g h : A -> B) -- Three parallel functions. (H : homotopy f g) (K : homotopy g h) : homotopy f h := \\a -> concat B (f a) (g a) (h a) (H a) (K a) #end homotopies Whiskering homotopies #section homotopy-whiskering #variables A B C : U #def homotopy-postwhisker (f g : A -> B) -- Two parallel functions. (H : homotopy A B f g) -- A homotopy from f to g. (h : B -> C) : homotopy A C (composition A B C h f) (composition A B C h g) := \\a -> ap B C (f a) (g a) h (H a) #def homotopy-prewhisker (f g : B -> C) -- Two parallel functions (H : homotopy B C f g) (h : A -> B) : homotopy A C (composition A B C f h) (composition A B C g h) := \\a -> H (h a) #end homotopy-whiskering Naturality -- The naturality square associated to a homotopy and a path. #def nat-htpy (A B : U) -- Two types. (f g : A -> B) -- Two parallel functions. (H : homotopy A B f g) -- A homotopy from f to g. (x y : A) (p : x = y) : (concat B (f x) (f y) (g y) (ap A B x y f p) (H y)) = (concat B (f x) (g x) (g y) (H x) (ap A B x y g p)) := idJ(A, x, \\y' p' -> (concat B (f x) (f y') (g y') (ap A B x y' f p') (H y')) = (concat B (f x) (g x) (g y') (H x) (ap A B x y' g p')), refl-concat B (f x) (g x) (H x), y, p) An application #section cocone-naturality #variable A : U #variable f : A -> A #variable H : homotopy A A f (identity A) #variable a : A -- In the case of a homotopy H from f to the identity the previous square applies to the path H a to produce the following naturality square. #def cocone-naturality : (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = (concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a))) := nat-htpy A A f (identity A) H (f a) a (H a) -- After composing with ap-id, this naturality square transforms to the following: #def reduced-cocone-naturality : (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = (concat A (f (f a)) (f a) (a) (H (f a)) (H a)) := concat ((f (f a)) = a) (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) (concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a))) (concat A (f (f a)) (f a) (a) (H (f a)) (H a)) (cocone-naturality) (concat-homotopy A (f (f a)) (f a) (H (f a)) a (ap A A (f a) a (identity A) (H a)) (H a) (ap-id A (f a) a (H a))) -- Cancelling the path (H a) on the right and reversing yields a path we need: #def cocone-naturality-coherence : (H (f a)) =(ap A A (f a) a f (H a)) := rev (f (f a) = f a) (ap A A (f a) a f (H a)) (H (f a)) (concat-right-cancel A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H (f a)) (H a) (reduced-cocone-naturality)) #end cocone-naturality","title":"Homotopies"},{"location":"hott/02-homotopies/#2-homotopies","text":"This is a literate rzk file: #lang rzk-1","title":"2. Homotopies"},{"location":"hott/02-homotopies/#homotopies-and-their-algebra","text":"#section homotopies #variables A B : U -- The type of homotopies between parallel functions. #def homotopy (f g : A -> B) -- Two parallel functions. : U := (a : A) -> (f a = g a) -- The reversal of a homotopy #def homotopy-rev (f g : A -> B) -- Two parallel functions. (H : homotopy f g) -- A homotopy from f to g. : homotopy g f := \\a -> rev B (f a) (g a) (H a) -- Homotopy composition is defined in diagrammatic order like concat but unlike composition. #def homotopy-composition (f g h : A -> B) -- Three parallel functions. (H : homotopy f g) (K : homotopy g h) : homotopy f h := \\a -> concat B (f a) (g a) (h a) (H a) (K a) #end homotopies","title":"Homotopies and their algebra"},{"location":"hott/02-homotopies/#whiskering-homotopies","text":"#section homotopy-whiskering #variables A B C : U #def homotopy-postwhisker (f g : A -> B) -- Two parallel functions. (H : homotopy A B f g) -- A homotopy from f to g. (h : B -> C) : homotopy A C (composition A B C h f) (composition A B C h g) := \\a -> ap B C (f a) (g a) h (H a) #def homotopy-prewhisker (f g : B -> C) -- Two parallel functions (H : homotopy B C f g) (h : A -> B) : homotopy A C (composition A B C f h) (composition A B C g h) := \\a -> H (h a) #end homotopy-whiskering","title":"Whiskering homotopies"},{"location":"hott/02-homotopies/#naturality","text":"-- The naturality square associated to a homotopy and a path. #def nat-htpy (A B : U) -- Two types. (f g : A -> B) -- Two parallel functions. (H : homotopy A B f g) -- A homotopy from f to g. (x y : A) (p : x = y) : (concat B (f x) (f y) (g y) (ap A B x y f p) (H y)) = (concat B (f x) (g x) (g y) (H x) (ap A B x y g p)) := idJ(A, x, \\y' p' -> (concat B (f x) (f y') (g y') (ap A B x y' f p') (H y')) = (concat B (f x) (g x) (g y') (H x) (ap A B x y' g p')), refl-concat B (f x) (g x) (H x), y, p)","title":"Naturality"},{"location":"hott/02-homotopies/#an-application","text":"#section cocone-naturality #variable A : U #variable f : A -> A #variable H : homotopy A A f (identity A) #variable a : A -- In the case of a homotopy H from f to the identity the previous square applies to the path H a to produce the following naturality square. #def cocone-naturality : (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = (concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a))) := nat-htpy A A f (identity A) H (f a) a (H a) -- After composing with ap-id, this naturality square transforms to the following: #def reduced-cocone-naturality : (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = (concat A (f (f a)) (f a) (a) (H (f a)) (H a)) := concat ((f (f a)) = a) (concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) (concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a))) (concat A (f (f a)) (f a) (a) (H (f a)) (H a)) (cocone-naturality) (concat-homotopy A (f (f a)) (f a) (H (f a)) a (ap A A (f a) a (identity A) (H a)) (H a) (ap-id A (f a) a (H a))) -- Cancelling the path (H a) on the right and reversing yields a path we need: #def cocone-naturality-coherence : (H (f a)) =(ap A A (f a) a f (H a)) := rev (f (f a) = f a) (ap A A (f a) a f (H a)) (H (f a)) (concat-right-cancel A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H (f a)) (H a) (reduced-cocone-naturality)) #end cocone-naturality","title":"An application"},{"location":"hott/03-equivalences/","text":"3. Equivalences This is a literate rzk file: #lang rzk-1 Sections, retractions, and equivalences #section is-equiv #variables A B : U #def hasSection (f : A -> B) : U := \u2211 (s : B -> A), homotopy B B (composition B A B f s)(identity B) #def hasRetraction (f : A -> B) : U := \u2211 (r : B -> A), homotopy A A (composition A B A r f)(identity A) -- equivalences are bi-invertible maps #def isEquiv (f : A -> B) : U := prod (hasRetraction f) (hasSection f) #end is-equiv Equivalence data #section equivalence-data #variables A B : U #variable f : A -> B #variable fisequiv : isEquiv A B f #def isEquiv-section uses (f) : B -> A := (first (second fisequiv)) #def isEquiv-retraction uses (f) : B -> A := (first (first fisequiv)) -- the homotopy between the section and retraction of an equivalence #def isEquiv-htpic-inverses uses (f) : homotopy B A isEquiv-section isEquiv-retraction := homotopy-composition B A (isEquiv-section) (triple-composition B A B A isEquiv-retraction f isEquiv-section) (isEquiv-retraction) (homotopy-rev B A (triple-composition B A B A isEquiv-retraction f isEquiv-section) isEquiv-section (homotopy-prewhisker B A A (composition A B A isEquiv-retraction f) (identity A) (second (first fisequiv)) isEquiv-section)) (homotopy-postwhisker B B A (composition B A B f isEquiv-section) (identity B) (second (second fisequiv)) isEquiv-retraction) #end equivalence-data Invertible maps -- the following type of more coherent equivalences is not a proposition #def hasInverse (A B : U) (f : A -> B) : U := \u2211 (g : B -> A), -- A two-sided inverse (prod (homotopy A A (composition A B A g f)(identity A)) -- The retracting homotopy (homotopy B B (composition B A B f g)(identity B))) -- The section homotopy Equivalences are invertible maps -- invertible maps are equivalences #def hasInverse-isEquiv (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : isEquiv A B f := ((first fhasinverse, first (second fhasinverse)), (first fhasinverse, second (second fhasinverse))) -- equivalences are invertible #def isEquiv-hasInverse (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : hasInverse A B f := (isEquiv-section A B f fisequiv, (homotopy-composition A A (composition A B A (isEquiv-section A B f fisequiv) f) (composition A B A (isEquiv-retraction A B f fisequiv) f) (identity A) (homotopy-prewhisker A B A (isEquiv-section A B f fisequiv) (isEquiv-retraction A B f fisequiv) (isEquiv-htpic-inverses A B f fisequiv) f) (second (first fisequiv)) , second (second fisequiv))) Invertible map data #section has-inverse-data #variables A B : U #variable f : A -> B #variable fhasinverse : hasInverse A B f -- The inverse of a map with an inverse #def hasInverse-inverse uses (f) : B -> A := first (fhasinverse) -- Some iterated composites associated to a pair of invertible maps. #def hasInverse-retraction-composite uses (B fhasinverse) : A -> A := composition A B A hasInverse-inverse f #def hasInverse-section-composite uses (A fhasinverse) : B -> B := composition B A B f hasInverse-inverse -- This composite is parallel to f; we won't need the dual notion. #def hasInverse-triple-composite uses (fhasinverse) : A -> B := triple-composition A B A B f hasInverse-inverse f -- This composite is also parallel to f; again we won't need the dual notion. #def hasInverse-quintuple-composite uses (fhasinverse) : A -> B := \\a -> f (hasInverse-inverse (f (hasInverse-inverse (f a)))) #end has-inverse-data Half adjoint equivalences -- We'll require a more coherent notion of equivalence #def isHalfAdjointEquiv (A B : U) (f : A -> B) : U := \u2211 (fhasinverse : (hasInverse A B f)), (a : A) -> (((second (second fhasinverse))) (f a)) = (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (((first (second fhasinverse))) a)) -- By function extensionality, the previous definition coincides with the following one: #def ALTisHalfAdjointEquiv (A B : U) (f : A -> B) : U := \u2211 (fhasinverse : (hasInverse A B f)), ((homotopy-prewhisker A B B (hasInverse-section-composite A B f fhasinverse) (identity B) (second (second fhasinverse)) f) = ((homotopy-postwhisker A A B (hasInverse-retraction-composite A B f fhasinverse) (identity A) (first (second fhasinverse)) f))) Coherence data from an invertible map -- To promote an invertible map to a half adjoint equivalence we keep one homotopy and discard the other #def hasInverse-kept-htpy (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : homotopy A A (hasInverse-retraction-composite A B f fhasinverse) (identity A) := (first (second fhasinverse)) #def hasInverse-discarded-htpy (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : homotopy B B (hasInverse-section-composite A B f fhasinverse) (identity B) := (second (second fhasinverse)) #section has-inverse-coherence #variables A B : U #variable f : A -> B #variable fhasinverse : hasInverse A B f #variable a : A -- the required coherence will be built by transforming an instance of this naturality square #def hasInverse-discarded-naturality-square : concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse)(hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-discarded-htpy A B f fhasinverse (f a)) = concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) := nat-htpy A B (hasInverse-triple-composite A B f fhasinverse) f (\\x -> hasInverse-discarded-htpy A B f fhasinverse (f x)) (hasInverse-retraction-composite A B f fhasinverse a) (a) (hasInverse-kept-htpy A B f fhasinverse a) -- building a path that will be whiskered into the naturality square above #def hasInverse-cocone-homotopy-coherence : (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) = ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a) := cocone-naturality-coherence A (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse) a #def hasInverse-ap-cocone-homotopy-coherence : ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) = ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) := ap-htpy A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) hasInverse-cocone-homotopy-coherence #def hasInverse-cocone-coherence : ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) = (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) := concat ((hasInverse-quintuple-composite A B f fhasinverse a) = (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a))) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) hasInverse-ap-cocone-homotopy-coherence (rev-ap-comp A A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) f (hasInverse-kept-htpy A B f fhasinverse a)) -- this morally gives the half adjoint inverse coherence; it just requires rotation #def hasInverse-replaced-naturality-square : concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (hasInverse-discarded-htpy A B f fhasinverse (f a)) = concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) := concat ((hasInverse-quintuple-composite A B f fhasinverse a) =_{B} (f a)) (concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (hasInverse-discarded-htpy A B f fhasinverse (f a))) (concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-discarded-htpy A B f fhasinverse (f a))) (concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a))) (homotopy-concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) hasInverse-cocone-coherence (hasInverse-discarded-htpy A B f fhasinverse (f a))) hasInverse-discarded-naturality-square -- This will replace the discarded homotopy #def hasInverse-corrected-htpy : homotopy B B (hasInverse-section-composite A B f fhasinverse) (\\b -> b) := \\b -> concat B ((hasInverse-section-composite A B f fhasinverse) b) ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) b)) b (rev B ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) b)) ((hasInverse-section-composite A B f fhasinverse) b) (hasInverse-discarded-htpy A B f fhasinverse ((hasInverse-section-composite A B f fhasinverse) b))) (concat B ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) b)) ((hasInverse-section-composite A B f fhasinverse) b) b (ap A B ((hasInverse-retraction-composite A B f fhasinverse) (hasInverse-inverse A B f fhasinverse b)) (hasInverse-inverse A B f fhasinverse b) f ((first (second fhasinverse)) (hasInverse-inverse A B f fhasinverse b))) ((hasInverse-discarded-htpy A B f fhasinverse b))) -- this is the half adjoint coherence #def hasInverse-coherence : (hasInverse-corrected-htpy (f a)) = (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) := triangle-rotation B (hasInverse-quintuple-composite A B f fhasinverse a)(hasInverse-triple-composite A B f fhasinverse a) (f a) (concat B ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) (f a))) ((hasInverse-section-composite A B f fhasinverse) (f a)) (f a) (ap A B ((hasInverse-retraction-composite A B f fhasinverse) (hasInverse-inverse A B f fhasinverse (f a))) (hasInverse-inverse A B f fhasinverse (f a)) f ((first (second fhasinverse)) (hasInverse-inverse A B f fhasinverse (f a)))) ((hasInverse-discarded-htpy A B f fhasinverse (f a)))) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) hasInverse-replaced-naturality-square #end has-inverse-coherence Invertible maps are half adjoint equivalences -- to promote an invertible map to a half adjoint equivalence we change the data of the invertible map by replacing the discarded homotopy with the corrected one. #def hasInverse-correctedhasInverse (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : hasInverse A B f := (hasInverse-inverse A B f fhasinverse, (hasInverse-kept-htpy A B f fhasinverse, hasInverse-corrected-htpy A B f fhasinverse)) -- Invertible maps are half adjoint equivalences! #def hasInverse-isHalfAdjointEquiv (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : isHalfAdjointEquiv A B f := (hasInverse-correctedhasInverse A B f fhasinverse, hasInverse-coherence A B f fhasinverse) -- Equivalences are half adjoint equivalences! #def isEquiv-isHalfAdjointEquiv (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : isHalfAdjointEquiv A B f := hasInverse-isHalfAdjointEquiv A B f (isEquiv-hasInverse A B f fisequiv) Composing equivalences -- The type of equivalences between types uses the propositional notion isEquiv rather than the incoherent hasInverse. #def Eq (A B : U) : U := \u2211 (f : A -> B), ((isEquiv A) B) f -- The data of an equivalence is not symmetric so we promote an equivalence to an invertible map to prove symmetry #def sym_Eq (A B : U) (e : Eq A B) : Eq B A := (first (isEquiv-hasInverse A B (first e) (second e)) , (( first e , second (second (isEquiv-hasInverse A B (first e) (second e))) ) , ( first e , first (second (isEquiv-hasInverse A B (first e) (second e))) ) )) -- Composition of equivalences in diagrammatic order. #def compose_Eq (A B C : U) (A=B : Eq A B) (B=C : Eq B C) : Eq A C := (\\a -> (first B=C) ((first A=B) a), -- the composite equivalence ((\\c -> (first (first (second A=B))) ((first (first (second (B=C)))) c), (\\a -> concat A ((first (first (second A=B))) ((first (first (second B=C))) ((first B=C) ((first A=B) a)))) ((first (first (second A=B))) ((first A=B) a)) a (ap B A ((first (first (second B=C))) ((first B=C) ((first A=B) a))) -- should be inferred ((first A=B) a) -- should be inferred (first (first (second A=B))) ((second (first (second B=C))) ((first A=B) a))) ((second (first (second A=B))) a))), (\\c -> (first (second (second A=B))) ((first (second (second (B=C)))) c), (\\c -> concat C ((first B=C) ((first A=B) ((first (second (second A=B))) ((first (second (second B=C))) c)))) ((first B=C) ((first (second (second B=C))) c)) c (ap B C ((first A=B) ((first (second (second A=B))) ((first (second (second B=C))) c))) -- should be inferred ((first (second (second B=C))) c) -- should be inferred (first B=C) ((second (second (second A=B))) ((first (second (second B=C))) c))) ((second (second (second B=C))) c))))) -- now we compose the functions that are equivalences #def compose_isEquiv (A B C : U) (f : A -> B) (fisequiv : isEquiv A B f) (g : B -> C) (gisequiv : isEquiv B C g) : isEquiv A C (composition A B C g f) := ((composition C B A (isEquiv-retraction A B f fisequiv) (isEquiv-retraction B C g gisequiv), \\a -> concat A ((isEquiv-retraction A B f fisequiv) ((isEquiv-retraction B C g gisequiv) (g (f a)))) ((isEquiv-retraction A B f fisequiv) (f a)) a (ap B A ((isEquiv-retraction B C g gisequiv) (g (f a))) -- should be inferred (f a) -- should be inferred (isEquiv-retraction A B f fisequiv) ((second (first gisequiv)) (f a))) ((second (first fisequiv)) a)), (composition C B A (isEquiv-section A B f fisequiv) (isEquiv-section B C g gisequiv), \\c -> concat C (g (f ((first (second fisequiv)) ((first (second gisequiv)) c)))) (g ((first (second gisequiv)) c)) c (ap B C (f ((first (second fisequiv)) ((first (second gisequiv)) c))) -- should be inferred ((first (second gisequiv)) c) -- should be inferred g ((second (second fisequiv)) ((first (second gisequiv)) c))) ((second (second gisequiv)) c))) -- Right cancellation of equivalences in diagrammatic order. #def RightCancel_Eq (A B C : U) (A=C : Eq A C) (B=C : Eq B C) : Eq A B := compose_Eq A C B (A=C) (sym_Eq B C B=C) -- Left cancellation of equivalences in diagrammatic order. #def LeftCancel_Eq (A B C : U) (A=B : Eq A B) (A=C : Eq A C) : Eq B C := compose_Eq B A C (sym_Eq A B A=B) (A=C) -- a composition of three equivalences #def triple_compose_Eq (A B C D : U) (A=B : Eq A B) (B=C : Eq B C) (C=D : Eq C D) : Eq A D := compose_Eq A B D (A=B) (compose_Eq B C D B=C C=D) #def triple_compose_isEquiv (A B C D : U) (f : A -> B) (fisequiv : isEquiv A B f) (g : B -> C) (gisequiv : isEquiv B C g) (h : C -> D) (hisequiv : isEquiv C D h) : isEquiv A D (triple-composition A B C D h g f) := compose_isEquiv A B D f fisequiv (composition B C D h g) (compose_isEquiv B C D g gisequiv h hisequiv) Function extensionality -- The type that encodes the function extensionality axiom. #def FunExt : U := (X : U) -> (A : X -> U) -> (f : (x : X) -> A x) -> (g : (x : X) -> A x) -> (px : (x : X) -> f x = g x) -> f = g -- Using function extensionality, a fiberwise equivalence defines an equivalence of dependent function types #def fibered-equiv-function-equiv (funext : FunExt) (X : U) (A B : X -> U) (fibequiv : (x : X) -> Eq (A x) (B x)) : Eq ((x : X) -> A x) ((x : X) -> B x) := ((\\a -> \\x -> (first (fibequiv x)) (a x)), (((\\b -> \\x -> (first (first (second (fibequiv x)))) (b x)), \\a -> funext X A (\\x -> (first (first (second (fibequiv x)))) ((first (fibequiv x)) (a x))) a (\\x -> (second (first (second (fibequiv x)))) (a x))), ((\\b -> \\x -> (first (second (second (fibequiv x)))) (b x)), (\\b -> funext X B (\\x -> (first (fibequiv x)) ((first (second (second (fibequiv x)))) (b x))) b (\\x -> (second (second (second (fibequiv x)))) (b x))))))","title":"Equivalences"},{"location":"hott/03-equivalences/#3-equivalences","text":"This is a literate rzk file: #lang rzk-1","title":"3. Equivalences"},{"location":"hott/03-equivalences/#sections-retractions-and-equivalences","text":"#section is-equiv #variables A B : U #def hasSection (f : A -> B) : U := \u2211 (s : B -> A), homotopy B B (composition B A B f s)(identity B) #def hasRetraction (f : A -> B) : U := \u2211 (r : B -> A), homotopy A A (composition A B A r f)(identity A) -- equivalences are bi-invertible maps #def isEquiv (f : A -> B) : U := prod (hasRetraction f) (hasSection f) #end is-equiv","title":"Sections, retractions, and equivalences"},{"location":"hott/03-equivalences/#equivalence-data","text":"#section equivalence-data #variables A B : U #variable f : A -> B #variable fisequiv : isEquiv A B f #def isEquiv-section uses (f) : B -> A := (first (second fisequiv)) #def isEquiv-retraction uses (f) : B -> A := (first (first fisequiv)) -- the homotopy between the section and retraction of an equivalence #def isEquiv-htpic-inverses uses (f) : homotopy B A isEquiv-section isEquiv-retraction := homotopy-composition B A (isEquiv-section) (triple-composition B A B A isEquiv-retraction f isEquiv-section) (isEquiv-retraction) (homotopy-rev B A (triple-composition B A B A isEquiv-retraction f isEquiv-section) isEquiv-section (homotopy-prewhisker B A A (composition A B A isEquiv-retraction f) (identity A) (second (first fisequiv)) isEquiv-section)) (homotopy-postwhisker B B A (composition B A B f isEquiv-section) (identity B) (second (second fisequiv)) isEquiv-retraction) #end equivalence-data","title":"Equivalence data"},{"location":"hott/03-equivalences/#invertible-maps","text":"-- the following type of more coherent equivalences is not a proposition #def hasInverse (A B : U) (f : A -> B) : U := \u2211 (g : B -> A), -- A two-sided inverse (prod (homotopy A A (composition A B A g f)(identity A)) -- The retracting homotopy (homotopy B B (composition B A B f g)(identity B))) -- The section homotopy","title":"Invertible maps"},{"location":"hott/03-equivalences/#equivalences-are-invertible-maps","text":"-- invertible maps are equivalences #def hasInverse-isEquiv (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : isEquiv A B f := ((first fhasinverse, first (second fhasinverse)), (first fhasinverse, second (second fhasinverse))) -- equivalences are invertible #def isEquiv-hasInverse (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : hasInverse A B f := (isEquiv-section A B f fisequiv, (homotopy-composition A A (composition A B A (isEquiv-section A B f fisequiv) f) (composition A B A (isEquiv-retraction A B f fisequiv) f) (identity A) (homotopy-prewhisker A B A (isEquiv-section A B f fisequiv) (isEquiv-retraction A B f fisequiv) (isEquiv-htpic-inverses A B f fisequiv) f) (second (first fisequiv)) , second (second fisequiv)))","title":"Equivalences are invertible maps"},{"location":"hott/03-equivalences/#invertible-map-data","text":"#section has-inverse-data #variables A B : U #variable f : A -> B #variable fhasinverse : hasInverse A B f -- The inverse of a map with an inverse #def hasInverse-inverse uses (f) : B -> A := first (fhasinverse) -- Some iterated composites associated to a pair of invertible maps. #def hasInverse-retraction-composite uses (B fhasinverse) : A -> A := composition A B A hasInverse-inverse f #def hasInverse-section-composite uses (A fhasinverse) : B -> B := composition B A B f hasInverse-inverse -- This composite is parallel to f; we won't need the dual notion. #def hasInverse-triple-composite uses (fhasinverse) : A -> B := triple-composition A B A B f hasInverse-inverse f -- This composite is also parallel to f; again we won't need the dual notion. #def hasInverse-quintuple-composite uses (fhasinverse) : A -> B := \\a -> f (hasInverse-inverse (f (hasInverse-inverse (f a)))) #end has-inverse-data","title":"Invertible map data"},{"location":"hott/03-equivalences/#half-adjoint-equivalences","text":"-- We'll require a more coherent notion of equivalence #def isHalfAdjointEquiv (A B : U) (f : A -> B) : U := \u2211 (fhasinverse : (hasInverse A B f)), (a : A) -> (((second (second fhasinverse))) (f a)) = (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (((first (second fhasinverse))) a)) -- By function extensionality, the previous definition coincides with the following one: #def ALTisHalfAdjointEquiv (A B : U) (f : A -> B) : U := \u2211 (fhasinverse : (hasInverse A B f)), ((homotopy-prewhisker A B B (hasInverse-section-composite A B f fhasinverse) (identity B) (second (second fhasinverse)) f) = ((homotopy-postwhisker A A B (hasInverse-retraction-composite A B f fhasinverse) (identity A) (first (second fhasinverse)) f)))","title":"Half adjoint equivalences"},{"location":"hott/03-equivalences/#coherence-data-from-an-invertible-map","text":"-- To promote an invertible map to a half adjoint equivalence we keep one homotopy and discard the other #def hasInverse-kept-htpy (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : homotopy A A (hasInverse-retraction-composite A B f fhasinverse) (identity A) := (first (second fhasinverse)) #def hasInverse-discarded-htpy (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : homotopy B B (hasInverse-section-composite A B f fhasinverse) (identity B) := (second (second fhasinverse)) #section has-inverse-coherence #variables A B : U #variable f : A -> B #variable fhasinverse : hasInverse A B f #variable a : A -- the required coherence will be built by transforming an instance of this naturality square #def hasInverse-discarded-naturality-square : concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse)(hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-discarded-htpy A B f fhasinverse (f a)) = concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) := nat-htpy A B (hasInverse-triple-composite A B f fhasinverse) f (\\x -> hasInverse-discarded-htpy A B f fhasinverse (f x)) (hasInverse-retraction-composite A B f fhasinverse a) (a) (hasInverse-kept-htpy A B f fhasinverse a) -- building a path that will be whiskered into the naturality square above #def hasInverse-cocone-homotopy-coherence : (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) = ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a) := cocone-naturality-coherence A (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse) a #def hasInverse-ap-cocone-homotopy-coherence : ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) = ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) := ap-htpy A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) hasInverse-cocone-homotopy-coherence #def hasInverse-cocone-coherence : ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) = (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) := concat ((hasInverse-quintuple-composite A B f fhasinverse a) = (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (ap A A (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a))) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) hasInverse-ap-cocone-homotopy-coherence (rev-ap-comp A A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-retraction-composite A B f fhasinverse) f (hasInverse-kept-htpy A B f fhasinverse a)) -- this morally gives the half adjoint inverse coherence; it just requires rotation #def hasInverse-replaced-naturality-square : concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (hasInverse-discarded-htpy A B f fhasinverse (f a)) = concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) := concat ((hasInverse-quintuple-composite A B f fhasinverse a) =_{B} (f a)) (concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (hasInverse-discarded-htpy A B f fhasinverse (f a))) (concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) (hasInverse-discarded-htpy A B f fhasinverse (f a))) (concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a))) (homotopy-concat B (hasInverse-quintuple-composite A B f fhasinverse a) (hasInverse-triple-composite A B f fhasinverse a) (f a) (ap A B (hasInverse-retraction-composite A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a)) (hasInverse-retraction-composite A B f fhasinverse a) f (hasInverse-kept-htpy A B f fhasinverse (hasInverse-retraction-composite A B f fhasinverse a))) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a (hasInverse-triple-composite A B f fhasinverse) (hasInverse-kept-htpy A B f fhasinverse a)) hasInverse-cocone-coherence (hasInverse-discarded-htpy A B f fhasinverse (f a))) hasInverse-discarded-naturality-square -- This will replace the discarded homotopy #def hasInverse-corrected-htpy : homotopy B B (hasInverse-section-composite A B f fhasinverse) (\\b -> b) := \\b -> concat B ((hasInverse-section-composite A B f fhasinverse) b) ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) b)) b (rev B ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) b)) ((hasInverse-section-composite A B f fhasinverse) b) (hasInverse-discarded-htpy A B f fhasinverse ((hasInverse-section-composite A B f fhasinverse) b))) (concat B ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) b)) ((hasInverse-section-composite A B f fhasinverse) b) b (ap A B ((hasInverse-retraction-composite A B f fhasinverse) (hasInverse-inverse A B f fhasinverse b)) (hasInverse-inverse A B f fhasinverse b) f ((first (second fhasinverse)) (hasInverse-inverse A B f fhasinverse b))) ((hasInverse-discarded-htpy A B f fhasinverse b))) -- this is the half adjoint coherence #def hasInverse-coherence : (hasInverse-corrected-htpy (f a)) = (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) := triangle-rotation B (hasInverse-quintuple-composite A B f fhasinverse a)(hasInverse-triple-composite A B f fhasinverse a) (f a) (concat B ((hasInverse-section-composite A B f fhasinverse) ((hasInverse-section-composite A B f fhasinverse) (f a))) ((hasInverse-section-composite A B f fhasinverse) (f a)) (f a) (ap A B ((hasInverse-retraction-composite A B f fhasinverse) (hasInverse-inverse A B f fhasinverse (f a))) (hasInverse-inverse A B f fhasinverse (f a)) f ((first (second fhasinverse)) (hasInverse-inverse A B f fhasinverse (f a)))) ((hasInverse-discarded-htpy A B f fhasinverse (f a)))) (hasInverse-discarded-htpy A B f fhasinverse (hasInverse-triple-composite A B f fhasinverse a)) (ap A B (hasInverse-retraction-composite A B f fhasinverse a) a f (hasInverse-kept-htpy A B f fhasinverse a)) hasInverse-replaced-naturality-square #end has-inverse-coherence","title":"Coherence data from an invertible map"},{"location":"hott/03-equivalences/#invertible-maps-are-half-adjoint-equivalences","text":"-- to promote an invertible map to a half adjoint equivalence we change the data of the invertible map by replacing the discarded homotopy with the corrected one. #def hasInverse-correctedhasInverse (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : hasInverse A B f := (hasInverse-inverse A B f fhasinverse, (hasInverse-kept-htpy A B f fhasinverse, hasInverse-corrected-htpy A B f fhasinverse)) -- Invertible maps are half adjoint equivalences! #def hasInverse-isHalfAdjointEquiv (A B : U) (f : A -> B) (fhasinverse : hasInverse A B f) : isHalfAdjointEquiv A B f := (hasInverse-correctedhasInverse A B f fhasinverse, hasInverse-coherence A B f fhasinverse) -- Equivalences are half adjoint equivalences! #def isEquiv-isHalfAdjointEquiv (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : isHalfAdjointEquiv A B f := hasInverse-isHalfAdjointEquiv A B f (isEquiv-hasInverse A B f fisequiv)","title":"Invertible maps are half adjoint equivalences"},{"location":"hott/03-equivalences/#composing-equivalences","text":"-- The type of equivalences between types uses the propositional notion isEquiv rather than the incoherent hasInverse. #def Eq (A B : U) : U := \u2211 (f : A -> B), ((isEquiv A) B) f -- The data of an equivalence is not symmetric so we promote an equivalence to an invertible map to prove symmetry #def sym_Eq (A B : U) (e : Eq A B) : Eq B A := (first (isEquiv-hasInverse A B (first e) (second e)) , (( first e , second (second (isEquiv-hasInverse A B (first e) (second e))) ) , ( first e , first (second (isEquiv-hasInverse A B (first e) (second e))) ) )) -- Composition of equivalences in diagrammatic order. #def compose_Eq (A B C : U) (A=B : Eq A B) (B=C : Eq B C) : Eq A C := (\\a -> (first B=C) ((first A=B) a), -- the composite equivalence ((\\c -> (first (first (second A=B))) ((first (first (second (B=C)))) c), (\\a -> concat A ((first (first (second A=B))) ((first (first (second B=C))) ((first B=C) ((first A=B) a)))) ((first (first (second A=B))) ((first A=B) a)) a (ap B A ((first (first (second B=C))) ((first B=C) ((first A=B) a))) -- should be inferred ((first A=B) a) -- should be inferred (first (first (second A=B))) ((second (first (second B=C))) ((first A=B) a))) ((second (first (second A=B))) a))), (\\c -> (first (second (second A=B))) ((first (second (second (B=C)))) c), (\\c -> concat C ((first B=C) ((first A=B) ((first (second (second A=B))) ((first (second (second B=C))) c)))) ((first B=C) ((first (second (second B=C))) c)) c (ap B C ((first A=B) ((first (second (second A=B))) ((first (second (second B=C))) c))) -- should be inferred ((first (second (second B=C))) c) -- should be inferred (first B=C) ((second (second (second A=B))) ((first (second (second B=C))) c))) ((second (second (second B=C))) c))))) -- now we compose the functions that are equivalences #def compose_isEquiv (A B C : U) (f : A -> B) (fisequiv : isEquiv A B f) (g : B -> C) (gisequiv : isEquiv B C g) : isEquiv A C (composition A B C g f) := ((composition C B A (isEquiv-retraction A B f fisequiv) (isEquiv-retraction B C g gisequiv), \\a -> concat A ((isEquiv-retraction A B f fisequiv) ((isEquiv-retraction B C g gisequiv) (g (f a)))) ((isEquiv-retraction A B f fisequiv) (f a)) a (ap B A ((isEquiv-retraction B C g gisequiv) (g (f a))) -- should be inferred (f a) -- should be inferred (isEquiv-retraction A B f fisequiv) ((second (first gisequiv)) (f a))) ((second (first fisequiv)) a)), (composition C B A (isEquiv-section A B f fisequiv) (isEquiv-section B C g gisequiv), \\c -> concat C (g (f ((first (second fisequiv)) ((first (second gisequiv)) c)))) (g ((first (second gisequiv)) c)) c (ap B C (f ((first (second fisequiv)) ((first (second gisequiv)) c))) -- should be inferred ((first (second gisequiv)) c) -- should be inferred g ((second (second fisequiv)) ((first (second gisequiv)) c))) ((second (second gisequiv)) c))) -- Right cancellation of equivalences in diagrammatic order. #def RightCancel_Eq (A B C : U) (A=C : Eq A C) (B=C : Eq B C) : Eq A B := compose_Eq A C B (A=C) (sym_Eq B C B=C) -- Left cancellation of equivalences in diagrammatic order. #def LeftCancel_Eq (A B C : U) (A=B : Eq A B) (A=C : Eq A C) : Eq B C := compose_Eq B A C (sym_Eq A B A=B) (A=C) -- a composition of three equivalences #def triple_compose_Eq (A B C D : U) (A=B : Eq A B) (B=C : Eq B C) (C=D : Eq C D) : Eq A D := compose_Eq A B D (A=B) (compose_Eq B C D B=C C=D) #def triple_compose_isEquiv (A B C D : U) (f : A -> B) (fisequiv : isEquiv A B f) (g : B -> C) (gisequiv : isEquiv B C g) (h : C -> D) (hisequiv : isEquiv C D h) : isEquiv A D (triple-composition A B C D h g f) := compose_isEquiv A B D f fisequiv (composition B C D h g) (compose_isEquiv B C D g gisequiv h hisequiv)","title":"Composing equivalences"},{"location":"hott/03-equivalences/#function-extensionality","text":"-- The type that encodes the function extensionality axiom. #def FunExt : U := (X : U) -> (A : X -> U) -> (f : (x : X) -> A x) -> (g : (x : X) -> A x) -> (px : (x : X) -> f x = g x) -> f = g -- Using function extensionality, a fiberwise equivalence defines an equivalence of dependent function types #def fibered-equiv-function-equiv (funext : FunExt) (X : U) (A B : X -> U) (fibequiv : (x : X) -> Eq (A x) (B x)) : Eq ((x : X) -> A x) ((x : X) -> B x) := ((\\a -> \\x -> (first (fibequiv x)) (a x)), (((\\b -> \\x -> (first (first (second (fibequiv x)))) (b x)), \\a -> funext X A (\\x -> (first (first (second (fibequiv x)))) ((first (fibequiv x)) (a x))) a (\\x -> (second (first (second (fibequiv x)))) (a x))), ((\\b -> \\x -> (first (second (second (fibequiv x)))) (b x)), (\\b -> funext X B (\\x -> (first (fibequiv x)) ((first (second (second (fibequiv x)))) (b x))) b (\\x -> (second (second (second (fibequiv x)))) (b x))))))","title":"Function extensionality"},{"location":"hott/04-contractible/","text":"4. Contractible This is a literate rzk file: #lang rzk-1 Contractible types -- contractible types #def isContr (A : U) : U := \u2211 (x : A), (y : A) -> x = y Contractible type data #section contractible-data #variable A : U #variable Aiscontr : isContr A #def contraction-center : A := (first Aiscontr) -- The path from the contraction center to any point. #def contracting-htpy : (z : A) -> contraction-center = z := second Aiscontr -- A path between an arbitrary pair of types in a contractible type. #def contractible-connecting-htpy uses (Aiscontr) (x y : A) : x = y := zag-zig-concat A x contraction-center y (contracting-htpy x) (contracting-htpy y) #end contractible-data Retracts of contractible types A retract of contractible types is contractible. -- A type that records a proof that A is a retract of B. -- Very similar to hasRetraction. #def isRetract (A B : U) : U := \u2211 (s : A -> B), hasRetraction A B s #section retraction-data #variables A B : U #variable AretractB : isRetract A B #def isRetract-section : A -> B := first AretractB #def isRetract-retraction : B -> A := first (second AretractB) #def isRetract-homotopy : homotopy A A (composition A B A isRetract-retraction isRetract-section)(identity A) := second (second AretractB) -- If A is a retract of a contractible type it has a term. #def isRetract-ofContr-isInhabited uses (AretractB) (Biscontr : isContr B) : A := isRetract-retraction (contraction-center B Biscontr) -- If A is a retract of a contractible type it has a contracting homotopy. #def isRetract-ofContr-hasHtpy uses (AretractB) (Biscontr : isContr B) (a : A) : (isRetract-ofContr-isInhabited Biscontr) = a := concat A (isRetract-ofContr-isInhabited Biscontr) ((composition A B A isRetract-retraction isRetract-section) a) a (ap B A (contraction-center B Biscontr) (isRetract-section a) isRetract-retraction (contracting-htpy B Biscontr (isRetract-section a))) (isRetract-homotopy a) -- If A is a retract of a contractible type it is contractible. #def isRetract-ofContr-isContr uses (AretractB) (Biscontr : isContr B) : isContr A := (isRetract-ofContr-isInhabited Biscontr, isRetract-ofContr-hasHtpy Biscontr) #end retraction-data Functions between contractible types A function between contractible types is an equivalence #def areContr-isEquiv (A B : U) (Aiscontr : isContr A) (Biscontr : isContr B) (f : A -> B) : isEquiv A B f := ((\\b -> contraction-center A Aiscontr, \\a -> contracting-htpy A Aiscontr a), (\\b -> contraction-center A Aiscontr, \\b -> contractible-connecting-htpy B Biscontr (f (contraction-center A Aiscontr)) b)) A type equivalent to a contractible type is contractible. #def isEquiv-toContr-isContr (A B : U) (e : Eq A B) (Biscontr : isContr B) : isContr A := isRetract-ofContr-isContr A B (first e, first (second e)) Biscontr Contractible products #def isContr-product (A B : U) (AisContr : isContr A) (BisContr : isContr B) : isContr (prod A B) := ((first AisContr, first BisContr), \\p -> path-product A B (first AisContr) (first p) (first BisContr) (second p) (second AisContr (first p)) (second BisContr (second p)) ) #def first-isContr-product (A B : U) (AxBisContr : isContr (prod A B)) : isContr A := (first (first AxBisContr), \\a -> first-path-product A B (first AxBisContr) (a, second (first AxBisContr)) (second AxBisContr (a, second (first AxBisContr)))) #def first-isContr-sigma (A : U) (B : A -> U) (b : (a : A) -> B a) (ABisContr : isContr (\u2211 (a : A), B a)) : isContr A := (first (first ABisContr), \\a -> first-path-sigma A B (first ABisContr) (a, b a) (second ABisContr (a, b a))) #def isProp (A : U) : U := (a : A) -> (b : A) -> isContr(a = b)","title":"Contractible"},{"location":"hott/04-contractible/#4-contractible","text":"This is a literate rzk file: #lang rzk-1","title":"4. Contractible"},{"location":"hott/04-contractible/#contractible-types","text":"-- contractible types #def isContr (A : U) : U := \u2211 (x : A), (y : A) -> x = y","title":"Contractible types"},{"location":"hott/04-contractible/#contractible-type-data","text":"#section contractible-data #variable A : U #variable Aiscontr : isContr A #def contraction-center : A := (first Aiscontr) -- The path from the contraction center to any point. #def contracting-htpy : (z : A) -> contraction-center = z := second Aiscontr -- A path between an arbitrary pair of types in a contractible type. #def contractible-connecting-htpy uses (Aiscontr) (x y : A) : x = y := zag-zig-concat A x contraction-center y (contracting-htpy x) (contracting-htpy y) #end contractible-data","title":"Contractible type data"},{"location":"hott/04-contractible/#retracts-of-contractible-types","text":"A retract of contractible types is contractible. -- A type that records a proof that A is a retract of B. -- Very similar to hasRetraction. #def isRetract (A B : U) : U := \u2211 (s : A -> B), hasRetraction A B s #section retraction-data #variables A B : U #variable AretractB : isRetract A B #def isRetract-section : A -> B := first AretractB #def isRetract-retraction : B -> A := first (second AretractB) #def isRetract-homotopy : homotopy A A (composition A B A isRetract-retraction isRetract-section)(identity A) := second (second AretractB) -- If A is a retract of a contractible type it has a term. #def isRetract-ofContr-isInhabited uses (AretractB) (Biscontr : isContr B) : A := isRetract-retraction (contraction-center B Biscontr) -- If A is a retract of a contractible type it has a contracting homotopy. #def isRetract-ofContr-hasHtpy uses (AretractB) (Biscontr : isContr B) (a : A) : (isRetract-ofContr-isInhabited Biscontr) = a := concat A (isRetract-ofContr-isInhabited Biscontr) ((composition A B A isRetract-retraction isRetract-section) a) a (ap B A (contraction-center B Biscontr) (isRetract-section a) isRetract-retraction (contracting-htpy B Biscontr (isRetract-section a))) (isRetract-homotopy a) -- If A is a retract of a contractible type it is contractible. #def isRetract-ofContr-isContr uses (AretractB) (Biscontr : isContr B) : isContr A := (isRetract-ofContr-isInhabited Biscontr, isRetract-ofContr-hasHtpy Biscontr) #end retraction-data","title":"Retracts of contractible types"},{"location":"hott/04-contractible/#functions-between-contractible-types","text":"A function between contractible types is an equivalence #def areContr-isEquiv (A B : U) (Aiscontr : isContr A) (Biscontr : isContr B) (f : A -> B) : isEquiv A B f := ((\\b -> contraction-center A Aiscontr, \\a -> contracting-htpy A Aiscontr a), (\\b -> contraction-center A Aiscontr, \\b -> contractible-connecting-htpy B Biscontr (f (contraction-center A Aiscontr)) b)) A type equivalent to a contractible type is contractible. #def isEquiv-toContr-isContr (A B : U) (e : Eq A B) (Biscontr : isContr B) : isContr A := isRetract-ofContr-isContr A B (first e, first (second e)) Biscontr","title":"Functions between contractible types"},{"location":"hott/04-contractible/#contractible-products","text":"#def isContr-product (A B : U) (AisContr : isContr A) (BisContr : isContr B) : isContr (prod A B) := ((first AisContr, first BisContr), \\p -> path-product A B (first AisContr) (first p) (first BisContr) (second p) (second AisContr (first p)) (second BisContr (second p)) ) #def first-isContr-product (A B : U) (AxBisContr : isContr (prod A B)) : isContr A := (first (first AxBisContr), \\a -> first-path-product A B (first AxBisContr) (a, second (first AxBisContr)) (second AxBisContr (a, second (first AxBisContr)))) #def first-isContr-sigma (A : U) (B : A -> U) (b : (a : A) -> B a) (ABisContr : isContr (\u2211 (a : A), B a)) : isContr A := (first (first ABisContr), \\a -> first-path-sigma A B (first ABisContr) (a, b a) (second ABisContr (a, b a))) #def isProp (A : U) : U := (a : A) -> (b : A) -> isContr(a = b)","title":"Contractible products"},{"location":"hott/05-sigma/","text":"5. Sigma types This is a literate rzk file: #lang rzk-1 Identity types of sigma types -- Sigma-induction #def ind-Sigma (A : U) (B : A -> U) (C : (\u2211(a : A), B a) -> U) (s : \u2211(a : A), B a) (f : (a : A) -> (b : B a) -> C (a, b)) : C s := (f (first s)) (second s) -- [Rijke 22, Definition 9.3.1] #def Eq-Sigma (A : U) (B : A -> U) (s t : \u2211(a : A), B a) : U := \u2211(p : (first s) = (first t)), (transport A B (first s) (first t) p (second s)) = (second t) -- [Rijke 22, used in Lemma 9.3.2] #def refl-in-Sigma (A : U) (B : A -> U) (x : A) (y : B x) : \u2211(p : (x = x)), ((transport A B x x refl_{x} y) = y) := (refl_{x}, refl_{y}) -- [Rijke 22, Lemma 9.3.2] -- Eq-sigma is reflexive #def reflexive-Eq-Sigma (A : U) (B : A -> U) (s : \u2211(a : A), B a) : (Eq-Sigma A B s s) := (ind-Sigma A B (\\k -> (Eq-Sigma A B k k)) s (\\u v -> (refl_{u}, refl_{v})) ) -- [Rijke 22, Definition 9.3.3] #def pair-eq (A : U) (B : A -> U) (s t : \u2211(a : A), B a) (p : s = t) : (Eq-Sigma A B s t) := idJ(\u2211(a : A), B a, s, \\t' p' -> (Eq-Sigma A B s t'), (reflexive-Eq-Sigma A B s), t, p) -- A path through the total space projects to a path in the base. -- Morally but not definitionally the first component of pair-eq. -- Literally the same as first-path-sigma. #def total-path-to-base-path (A : U) (B : A -> U) (z w : \u2211 (a : A), B a) (p : z = w) : ((first z) = first w) := ap (\u2211 (a : A), B a) A z w (\\u -> first u) p -- A path through the total space gives a path in a fiber using transport along the path in the base. -- Morally, but not definitionally, the second component of pair-eq. -- Literally the same as second-path-sigma. #def total-path-to-fibered-path (A : U) (B : A -> U) (z w : \u2211 (a : A), B a) (p : z = w) : (transport A B (first z) (first w) (total-path-to-base-path A B z w p) (second z)) = (second w) := idJ((\u2211 (a : A), B a), z, \\w' p' -> (transport A B (first z) (first w') (total-path-to-base-path A B z w' p') (second z)) = (second w'), refl, w, p) -- A path in a fiber defines a path in the total space #def fibered-path-to-sigma-path (A : U) (B : A -> U) (x : A) (u v : B x) (p : u = v) : (x , u) =_{\u2211 (a : A), B a} (x , v) := idJ(B x, u, \\v' p' -> (x , u) = (x , v'), refl, v, p) -- Essentially eq-pair but with explicit arguments. #def pair-of-paths-to-path-of-pairs (A : U) (B : A -> U) (x y : A) (p : x = y) : (u : B x) -> (v : B y) -> ((transport A B x y p u) = v) -> (x, u) =_{\u2211 (z : A), B z} (y, v) := idJ(A, x, \\y' p' -> (u' : B x) -> (v' : B y') -> ((transport A B x y' p' u') = v') -> (x, u') =_{\u2211 (z : A), B z} (y', v'), \\(u' : B x) -> \\(v' : B x) -> \\(q' : (transport A B x x refl u') = v') -> (fibered-path-to-sigma-path A B x u' v' q'), y, p) -- The inverse to pair-eq. #def eq-pair (A : U) (B : A -> U) (s t : \u2211(a : A), B a) (e : Eq-Sigma A B s t) : (s = t) := pair-of-paths-to-path-of-pairs A B (first s) (first t) (first e) (second s) (second t) (second e) Based path spaces As an application, we prove that based path spaces are contractible. -- Transport in the space of paths starting at a is concatenation. #def based-transport-is-concat (A : U) -- The ambient type. (a x y : A) -- The basepoint and two other points. (p : a = x) -- An element of the based path space. (q : x = y) -- A path in the base. : (transport A (\\z -> (a = z)) x y q p) = (concat A a x y p q) := idJ(A, x, \\y' q' -> (transport A (\\z -> (a = z)) x y' q' p) = (concat A a x y' p q'), refl, y, q) -- The center of contraction in the based path space is (a, refl) #def based-paths-center (A : U) -- The ambient type. (a : A) -- The basepoint. : \u2211 (x : A), a = x := (a, refl) -- The contracting homotopy. #def based-paths-contracting-homotopy (A : U) -- The ambient type. (a : A) -- The basepoint. (p : \u2211 (x : A), a = x) -- Another based path. : (based-paths-center A a) =_{\u2211 (x : A), a = x} p := pair-of-paths-to-path-of-pairs A (\\z -> a = z) a (first p) (second p) (refl) (second p) (concat (a = (first p)) (transport A (\\z -> (a = z)) a (first p) (second p) (refl)) (concat A a a (first p) (refl) (second p)) (second p) (based-transport-is-concat A a a (first p) (refl) (second p)) (refl-concat A a (first p) (second p))) -- Based path spaces are contractible #def based-paths-contractible (A : U) -- The ambient type. (a : A) -- The basepoint. : isContr (\u2211 (x : A), a = x) := (based-paths-center A a, based-paths-contracting-homotopy A a) Fubini Given a family over a pair of independent types, the order of summation is unimportant. #def sigma-fubini (A B : U) (C : A -> B -> U) : Eq (\u2211 (x : A), \u2211 (y : B), C x y) (\u2211 (y : B), \u2211 (x : A), C x y) := (\\t -> (first (second t), (first t, second (second t))), ((\\t -> (first (second t), (first t, second (second t))), \\t -> refl), (\\t -> (first (second t), (first t, second (second t))), \\t -> refl))) Products distribute inside a Sigma type: #def prod-distribute-sigma (A B : U) (C : B -> U) : Eq (prod A (\u2211 (b : B), C b)) (\u2211 (b : B), prod A (C b)) := (\\(a, (b, c)) -> (b, (a, c)), ((\\(b, (a, c)) -> (a, (b, c)), \\z -> refl), (\\(b, (a, c)) -> (a, (b, c)), \\z -> refl))) Associativity #def assoc (A : U) (B : A -> U) (C : (a : A) -> B a -> U) : Eq (\u2211 (a : A), \u2211 (b : B a), C a b) (\u2211 (ab : \u2211 (a : A), B a), C (first ab) (second ab)) := (\\(a, (b, c)) -> ((a, b), c), ((\\((a, b), c) -> (a, (b, c)), \\_ -> refl), (\\((a, b), c) -> (a, (b, c)), \\_ -> refl)))","title":"Sigma types"},{"location":"hott/05-sigma/#5-sigma-types","text":"This is a literate rzk file: #lang rzk-1","title":"5. Sigma types"},{"location":"hott/05-sigma/#identity-types-of-sigma-types","text":"-- Sigma-induction #def ind-Sigma (A : U) (B : A -> U) (C : (\u2211(a : A), B a) -> U) (s : \u2211(a : A), B a) (f : (a : A) -> (b : B a) -> C (a, b)) : C s := (f (first s)) (second s) -- [Rijke 22, Definition 9.3.1] #def Eq-Sigma (A : U) (B : A -> U) (s t : \u2211(a : A), B a) : U := \u2211(p : (first s) = (first t)), (transport A B (first s) (first t) p (second s)) = (second t) -- [Rijke 22, used in Lemma 9.3.2] #def refl-in-Sigma (A : U) (B : A -> U) (x : A) (y : B x) : \u2211(p : (x = x)), ((transport A B x x refl_{x} y) = y) := (refl_{x}, refl_{y}) -- [Rijke 22, Lemma 9.3.2] -- Eq-sigma is reflexive #def reflexive-Eq-Sigma (A : U) (B : A -> U) (s : \u2211(a : A), B a) : (Eq-Sigma A B s s) := (ind-Sigma A B (\\k -> (Eq-Sigma A B k k)) s (\\u v -> (refl_{u}, refl_{v})) ) -- [Rijke 22, Definition 9.3.3] #def pair-eq (A : U) (B : A -> U) (s t : \u2211(a : A), B a) (p : s = t) : (Eq-Sigma A B s t) := idJ(\u2211(a : A), B a, s, \\t' p' -> (Eq-Sigma A B s t'), (reflexive-Eq-Sigma A B s), t, p) -- A path through the total space projects to a path in the base. -- Morally but not definitionally the first component of pair-eq. -- Literally the same as first-path-sigma. #def total-path-to-base-path (A : U) (B : A -> U) (z w : \u2211 (a : A), B a) (p : z = w) : ((first z) = first w) := ap (\u2211 (a : A), B a) A z w (\\u -> first u) p -- A path through the total space gives a path in a fiber using transport along the path in the base. -- Morally, but not definitionally, the second component of pair-eq. -- Literally the same as second-path-sigma. #def total-path-to-fibered-path (A : U) (B : A -> U) (z w : \u2211 (a : A), B a) (p : z = w) : (transport A B (first z) (first w) (total-path-to-base-path A B z w p) (second z)) = (second w) := idJ((\u2211 (a : A), B a), z, \\w' p' -> (transport A B (first z) (first w') (total-path-to-base-path A B z w' p') (second z)) = (second w'), refl, w, p) -- A path in a fiber defines a path in the total space #def fibered-path-to-sigma-path (A : U) (B : A -> U) (x : A) (u v : B x) (p : u = v) : (x , u) =_{\u2211 (a : A), B a} (x , v) := idJ(B x, u, \\v' p' -> (x , u) = (x , v'), refl, v, p) -- Essentially eq-pair but with explicit arguments. #def pair-of-paths-to-path-of-pairs (A : U) (B : A -> U) (x y : A) (p : x = y) : (u : B x) -> (v : B y) -> ((transport A B x y p u) = v) -> (x, u) =_{\u2211 (z : A), B z} (y, v) := idJ(A, x, \\y' p' -> (u' : B x) -> (v' : B y') -> ((transport A B x y' p' u') = v') -> (x, u') =_{\u2211 (z : A), B z} (y', v'), \\(u' : B x) -> \\(v' : B x) -> \\(q' : (transport A B x x refl u') = v') -> (fibered-path-to-sigma-path A B x u' v' q'), y, p) -- The inverse to pair-eq. #def eq-pair (A : U) (B : A -> U) (s t : \u2211(a : A), B a) (e : Eq-Sigma A B s t) : (s = t) := pair-of-paths-to-path-of-pairs A B (first s) (first t) (first e) (second s) (second t) (second e)","title":"Identity types of sigma types"},{"location":"hott/05-sigma/#based-path-spaces","text":"As an application, we prove that based path spaces are contractible. -- Transport in the space of paths starting at a is concatenation. #def based-transport-is-concat (A : U) -- The ambient type. (a x y : A) -- The basepoint and two other points. (p : a = x) -- An element of the based path space. (q : x = y) -- A path in the base. : (transport A (\\z -> (a = z)) x y q p) = (concat A a x y p q) := idJ(A, x, \\y' q' -> (transport A (\\z -> (a = z)) x y' q' p) = (concat A a x y' p q'), refl, y, q) -- The center of contraction in the based path space is (a, refl) #def based-paths-center (A : U) -- The ambient type. (a : A) -- The basepoint. : \u2211 (x : A), a = x := (a, refl) -- The contracting homotopy. #def based-paths-contracting-homotopy (A : U) -- The ambient type. (a : A) -- The basepoint. (p : \u2211 (x : A), a = x) -- Another based path. : (based-paths-center A a) =_{\u2211 (x : A), a = x} p := pair-of-paths-to-path-of-pairs A (\\z -> a = z) a (first p) (second p) (refl) (second p) (concat (a = (first p)) (transport A (\\z -> (a = z)) a (first p) (second p) (refl)) (concat A a a (first p) (refl) (second p)) (second p) (based-transport-is-concat A a a (first p) (refl) (second p)) (refl-concat A a (first p) (second p))) -- Based path spaces are contractible #def based-paths-contractible (A : U) -- The ambient type. (a : A) -- The basepoint. : isContr (\u2211 (x : A), a = x) := (based-paths-center A a, based-paths-contracting-homotopy A a)","title":"Based path spaces"},{"location":"hott/05-sigma/#fubini","text":"Given a family over a pair of independent types, the order of summation is unimportant. #def sigma-fubini (A B : U) (C : A -> B -> U) : Eq (\u2211 (x : A), \u2211 (y : B), C x y) (\u2211 (y : B), \u2211 (x : A), C x y) := (\\t -> (first (second t), (first t, second (second t))), ((\\t -> (first (second t), (first t, second (second t))), \\t -> refl), (\\t -> (first (second t), (first t, second (second t))), \\t -> refl))) Products distribute inside a Sigma type: #def prod-distribute-sigma (A B : U) (C : B -> U) : Eq (prod A (\u2211 (b : B), C b)) (\u2211 (b : B), prod A (C b)) := (\\(a, (b, c)) -> (b, (a, c)), ((\\(b, (a, c)) -> (a, (b, c)), \\z -> refl), (\\(b, (a, c)) -> (a, (b, c)), \\z -> refl)))","title":"Fubini"},{"location":"hott/05-sigma/#associativity","text":"#def assoc (A : U) (B : A -> U) (C : (a : A) -> B a -> U) : Eq (\u2211 (a : A), \u2211 (b : B a), C a b) (\u2211 (ab : \u2211 (a : A), B a), C (first ab) (second ab)) := (\\(a, (b, c)) -> ((a, b), c), ((\\((a, b), c) -> (a, (b, c)), \\_ -> refl), (\\((a, b), c) -> (a, (b, c)), \\_ -> refl)))","title":"Associativity"},{"location":"hott/06-fibers/","text":"7. Fibers This is a literate rzk file: #lang rzk-1 Fibers The homotopy fiber of a map is the following type: -- The fiber of a map #def fib (A B : U) (f : A -> B) (b : B) : U := \u2211 (a : A), (f a) = b -- We calculate the transport of (a, q) : fib b along p : a = a' #def transport-in-fiber (A B : U) (f : A -> B) (b : B) (a a' : A) (u : (f a) = b) (p : a = a') : (transport A (\\x -> (f x) = b) a a' p u) = (concat B (f a') (f a) b (ap A B a' a f (rev A a a' p)) u) := idJ(A, a, \\a'' p' -> (transport A (\\x -> (f x) = b) a a'' p' u) = (concat B (f a'') (f a) b (ap A B a'' a f (rev A a a'' p')) u), (rev ((f a) = b) (concat B (f a) (f a) b refl u) u (refl-concat B (f a) b u)), a', p) Contractible maps A map is contractible just when its fibers are contractible. -- Contractible maps #def isContr-map (A B : U) (f : A -> B) : U := (b : B) -> isContr (fib A B f b) Contractible maps are equivalences: #section isEquiv-isContr-map #variables A B : U #variable f : A -> B #variable fiscontr : isContr-map A B f -- The inverse to a contractible map #def isContr-map-inverse : B -> A := \\b -> first(contraction-center (fib A B f b) (fiscontr b)) #def isContr-map-hasSection : hasSection A B f := (isContr-map-inverse, \\b -> second(contraction-center (fib A B f b) (fiscontr b))) #def isContr-map-data-in-fiber uses (fiscontr) (a : A) : fib A B f (f a) := (isContr-map-inverse (f a), (second isContr-map-hasSection) (f a)) #def isContr-map-path-in-fiber (a : A) : (isContr-map-data-in-fiber a) =_{fib A B f (f a)} (a, refl) := contractible-connecting-htpy (fib A B f (f a)) (fiscontr (f a)) (isContr-map-data-in-fiber a) (a, refl) #def isContr-map-hasRetraction uses (fiscontr) : hasRetraction A B f := (isContr-map-inverse, \\a -> (ap (fib A B f (f a)) A (isContr-map-data-in-fiber a) ((a, refl)) (\\u -> first u) (isContr-map-path-in-fiber a))) #def isContr-map-isEquiv uses (fiscontr) : isEquiv A B f := (isContr-map-hasRetraction, isContr-map-hasSection) #end isEquiv-isContr-map Half adjoint equivalences are contractible. We now show that half adjoint equivalences are contractible maps. -- If f is a half adjoint equivalence, its fibers are inhabited. #def isHAE-isSurj (A B : U) (f : A -> B) (fisHAE : isHalfAdjointEquiv A B f) -- first fisHAE : hasInverse A B f (b : B) : fib A B f b := ((hasInverse-inverse A B f (first fisHAE)) b, (second (second (first fisHAE))) b) It takes much more work to construct the contracting homotopy. The bath path of this homotopy is straightforward. #section half-adjoint-equivalence-fiber-data #variables A B : U #variable f : A -> B #variable fisHAE : isHalfAdjointEquiv A B f #variable b : B #variable z : fib A B f b #def isHAE-fib-base-path : ((hasInverse-inverse A B f (first fisHAE)) b) = (first z) := concat A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z))) ((first (second (first fisHAE))) (first z)) -- Specializing the above to isHAE-fib-base-path #def isHAE-fib-base-path-transport : (transport A (\\x -> (f x) = b) ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ) ((second (second (first fisHAE))) b)) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ))) ((second (second (first fisHAE))) b)) := transport-in-fiber A B f b ((hasInverse-inverse A B f (first fisHAE)) b) (first z) ((second (second (first fisHAE))) b) (isHAE-fib-base-path ) #def isHAE-fib-base-path-rev-coherence : rev A ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ) = concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))) := rev-concat A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z))) ((first (second (first fisHAE))) (first z)) #def isHAE-fib-base-path-transport-rev-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ))) ((second (second (first fisHAE))) b)) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) ((second (second (first fisHAE))) b)) := homotopy-concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ))) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) (ap-htpy A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path )) (concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z))))) (isHAE-fib-base-path-rev-coherence )) ((second (second (first fisHAE))) b) #def isHAE-fib-base-path-transport-ap-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) ((second (second (first fisHAE))) b)) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) ((second (second (first fisHAE))) b)) := homotopy-concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) (ap-concat A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z))))) ((second (second (first fisHAE))) b) #def isHAE-fib-base-path-transport-rev-ap-rev-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) ((second (second (first fisHAE))) b)) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) )) ((second (second (first fisHAE))) b)) := homotopy-concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) )) (concat-homotopy B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z))))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z))) (ap-htpy A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))) (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) (rev-ap-rev B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z))) ) ((second (second (first fisHAE))) b) #def isHAE-fib-base-path-transport-ap-ap-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) )) ((second (second (first fisHAE))) b)) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z))) ((second (second (first fisHAE))) b)) := homotopy-concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) )) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z))) (concat-homotopy B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) ) (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z)) (rev-ap-comp B A B (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) f (second z))) ((second (second (first fisHAE))) b) #def isHAE-fib-base-path-transport-assoc-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z))) ((second (second (first fisHAE))) b)) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z)) ((second (second (first fisHAE))) b))) := concat-assoc B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z)) ((second (second (first fisHAE))) b) #def isHAE-fib-base-path-transport-nat-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z)) ((second (second (first fisHAE))) b))) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (ap B B (f (first z)) b (identity B) (second z)))) := concat-homotopy B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) b (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z)) ((second (second (first fisHAE))) b)) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (ap B B (f (first z)) b (identity B) (second z))) (nat-htpy B B (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (identity B) (second (second (first fisHAE))) (f (first z)) b (second z)) #def isHAE-fib-base-path-transport-ap-id-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (ap B B (f (first z)) b (identity B) (second z)))) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (second z))) := concat-homotopy B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) b (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (ap B B (f (first z)) b (identity B) (second z))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (second z)) (concat-homotopy B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) ((second (second (first fisHAE))) (f (first z))) b (ap B B (f (first z)) b (identity B) (second z)) (second z) (ap-id B (f (first z)) b (second z))) #def isHAE-fib-base-path-transport-reassoc-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (second z))) = (concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) ((second (second (first fisHAE))) (f (first z)))) (second z)) := assoc-concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) ((second (second (first fisHAE))) (f (first z))) (second z) #def isHAE-fib-base-path-transport-HAE-calculation : (concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) ((second (second (first fisHAE))) (f (first z)))) (second z)) = (concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z)))) (second z)) := homotopy-concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) ((second (second (first fisHAE))) (f (first z)))) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z)))) (concat-homotopy B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (f (first z)) (((second (second (first fisHAE)))) (f (first z))) (ap A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z))) ((second fisHAE) (first z))) (second z) #def isHAE-fib-base-path-transport-HAE-reduction : (concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z)))) (second z)) = (concat B (f (first z)) (f (first z)) b (refl) (second z)) := homotopy-concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z)))) (refl) (concat-ap-rev-ap-id A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z))) (second z) #def isHAE-fib-base-path-transport-HAE-final-reduction uses (A) : (concat B (f (first z)) (f (first z)) b (refl) (second z)) = (second z) := refl-concat B (f (first z)) b (second z) #def isHAE-fib-base-path-transport-path : (transport A (\\x -> (f x) = b) ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ) ((second (second (first fisHAE))) b)) = (second z) := 12ary-concat-alternating ((f (first z)) = b) (transport A (\\x -> (f x) = b) ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ) ((second (second (first fisHAE))) b)) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ))) ((second (second (first fisHAE))) b)) (isHAE-fib-base-path-transport ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) ((second (second (first fisHAE))) b)) (isHAE-fib-base-path-transport-rev-calculation ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) ((second (second (first fisHAE))) b)) (isHAE-fib-base-path-transport-ap-calculation ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) )) ((second (second (first fisHAE))) b)) (isHAE-fib-base-path-transport-rev-ap-rev-calculation ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z))) ((second (second (first fisHAE))) b)) (isHAE-fib-base-path-transport-ap-ap-calculation ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z)) ((second (second (first fisHAE))) b))) (isHAE-fib-base-path-transport-assoc-calculation ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (ap B B (f (first z)) b (identity B) (second z)))) (isHAE-fib-base-path-transport-nat-calculation ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (second z))) (isHAE-fib-base-path-transport-ap-id-calculation ) (concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) ((second (second (first fisHAE))) (f (first z)))) (second z)) (isHAE-fib-base-path-transport-reassoc-calculation ) (concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z)))) (second z)) (isHAE-fib-base-path-transport-HAE-calculation ) (concat B (f (first z)) (f (first z)) b (refl) (second z)) (isHAE-fib-base-path-transport-HAE-reduction ) (second z) (isHAE-fib-base-path-transport-HAE-final-reduction ) Finally, we may define the contracting homotopy: #def isHAE-fib-contracting-homotopy : (isHAE-isSurj A B f fisHAE b) = z := pair-of-paths-to-path-of-pairs A (\\x -> (f x) = b) ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ) ((second (second (first fisHAE))) b) (second z) (isHAE-fib-base-path-transport-path ) #end half-adjoint-equivalence-fiber-data Half adjoint equivalences define contractible maps: #def isHAE-isContr-map (A B : U) (f : A -> B) (fisHAE : isHalfAdjointEquiv A B f) : isContr-map A B f := \\b -> (isHAE-isSurj A B f fisHAE b, \\z -> isHAE-fib-contracting-homotopy A B f fisHAE b z) Equivalences are contractible maps #def isEquiv-isContr-map (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : isContr-map A B f := \\b -> (isHAE-isSurj A B f (isEquiv-isHalfAdjointEquiv A B f fisequiv) b, \\z -> isHAE-fib-contracting-homotopy A B f (isEquiv-isHalfAdjointEquiv A B f fisequiv) b z) #def isContr-map-iff-isEquiv (A B : U) (f : A -> B) : iff (isContr-map A B f) (isEquiv A B f) := (isContr-map-isEquiv A B f, isEquiv-isContr-map A B f) Fiber of total map We now calculate the fiber of the map on total spaces associated to a family of maps. #def family-of-maps-total-map (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps : (\u2211 (x : A), B x) -> (\u2211 (x : A), C x) -- the induced map on total spaces := \\z -> (first z, f (first z) (second z)) #def total-map-to-fiber (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (w : (\u2211 (x : A), C x)) : fib (B (first w)) (C (first w)) (f (first w)) (second w) -> (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w) := \\(b, p) -> ((first w, b), fibered-path-to-sigma-path A C (first w) (f (first w) b) (second w) p) #def total-map-from-fiber (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (w : (\u2211 (x : A), C x)) : (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w) -> fib (B (first w)) (C (first w)) (f (first w)) (second w) := \\(z, p) -> idJ((\u2211 (x : A), C x), ((family-of-maps-total-map A B C f) z), \\w' p' -> fib (B (first w')) (C (first w')) (f (first w')) (second w'), (((second z), refl)), w, p) #def total-map-to-fiber-retraction (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (w : (\u2211 (x : A), C x)) : hasRetraction (fib (B (first w)) (C (first w)) (f (first w)) (second w)) (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w) (total-map-to-fiber A B C f w) := (total-map-from-fiber A B C f w, \\(b, p) -> idJ((C (first w)), (f (first w) b), \\w1 p' -> ((total-map-from-fiber A B C f ((first w, w1))) ((total-map-to-fiber A B C f (first w, w1)) (b, p'))) =_{(fib (B (first w)) (C (first w)) (f (first w)) (w1))} (b, p'), refl, (second w), p)) #def total-map-to-fiber-section (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (w : (\u2211 (x : A), C x)) : hasSection (fib (B (first w)) (C (first w)) (f (first w)) (second w)) (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w) (total-map-to-fiber A B C f w) := (total-map-from-fiber A B C f w, \\(z, p) -> idJ((\u2211 (x : A), C x), ((first z, f (first z) (second z))), \\w' p' -> ((total-map-to-fiber A B C f w') ((total-map-from-fiber A B C f w') (z, p'))) =_{(fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w')} (z, p'), refl, w, p)) #def total-map-to-fiber-isEquiv (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (w : (\u2211 (x : A), C x)) : isEquiv (fib (B (first w)) (C (first w)) (f (first w)) (second w)) (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w) (total-map-to-fiber A B C f w) := (total-map-to-fiber-retraction A B C f w, total-map-to-fiber-section A B C f w) #def total-map-fiber-equiv (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (w : (\u2211 (x : A), C x)) : Eq (fib (B (first w)) (C (first w)) (f (first w)) (second w)) (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w) := (total-map-to-fiber A B C f w, total-map-to-fiber-isEquiv A B C f w) Families of equivalences A family of equivalences induces an equivalence on total spaces and conversely. It will be easiest to work with the incoherent notion of two-sided-inverses. #def invertible-family-total-inverse (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (invfamily : (a : A) -> hasInverse (B a) (C a) (f a)) -- an invertible family of maps : (\u2211 (x : A), C x) -> (\u2211 (x : A), B x) -- the inverse map on total spaces := \\(a, c) -> (a, (hasInverse-inverse (B a) (C a) (f a) (invfamily a)) c) #def invertible-family-total-retraction (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (invfamily : (a : A) -> hasInverse (B a) (C a) (f a)) -- an invertible family of maps : hasRetraction (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) := (invertible-family-total-inverse A B C f invfamily, \\(a, b) -> (fibered-path-to-sigma-path A B a ((hasInverse-inverse (B a) (C a) (f a) (invfamily a)) (f a b)) b ((first (second (invfamily a))) b))) #def invertible-family-total-section (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (invfamily : (a : A) -> hasInverse (B a) (C a) (f a)) -- an invertible family of maps : hasSection (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) := (invertible-family-total-inverse A B C f invfamily, \\(a, c) -> (fibered-path-to-sigma-path A C a (f a ((hasInverse-inverse (B a) (C a) (f a) (invfamily a)) c)) c ((second (second (invfamily a))) c))) #def invertible-family-total-invertible (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (invfamily : (a : A) -> hasInverse (B a) (C a) (f a)) -- an invertible family of maps : hasInverse (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) := (invertible-family-total-inverse A B C f invfamily, (second (invertible-family-total-retraction A B C f invfamily), second (invertible-family-total-section A B C f invfamily) )) #def family-of-equiv-total-equiv (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (familyequiv : (a : A) -> isEquiv (B a) (C a) (f a)) -- a family of equivalences : isEquiv (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) := hasInverse-isEquiv (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) (invertible-family-total-invertible A B C f (\\a -> isEquiv-hasInverse (B a) (C a) (f a) (familyequiv a))) #def family-Eq-total-Eq (A : U) (B C : A -> U) (familyeq : (a : A) -> Eq (B a) (C a)) -- a family of equivalences : Eq (\u2211 (x : A), B x) (\u2211 (x : A), C x) := (family-of-maps-total-map A B C (\\a -> first (familyeq a)), family-of-equiv-total-equiv A B C (\\a -> first (familyeq a)) (\\a -> second (familyeq a))) The one-way result: that a family of equivalence gives an invertible map (and thus an equivalence) on total spaces. #def family-of-equiv-total-invertible (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (familyequiv : (a : A) -> isEquiv (B a) (C a) (f a)) -- a family of equivalences : hasInverse (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) := invertible-family-total-invertible A B C f (\\a -> isEquiv-hasInverse (B a) (C a) (f a) (familyequiv a)) For the converse, we make use of our calculation on fibers. The first implication could be proven similarly. #def total-contr-map-family-of-contr-maps (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (totalcontrmap : isContr-map (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f)) (a : A) : isContr-map (B a) (C a) (f a) := \\c -> isEquiv-toContr-isContr (fib (B a) (C a) (f a) c) (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) ((a, c))) (total-map-fiber-equiv A B C f ((a, c))) (totalcontrmap ((a, c))) #def total-equiv-family-of-equiv (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (totalequiv : isEquiv (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f)) (a : A) : isEquiv (B a) (C a) (f a) := isContr-map-isEquiv (B a) (C a) (f a) (total-contr-map-family-of-contr-maps A B C f (isEquiv-isContr-map (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) totalequiv) a) In summary, a family of maps is an equivalence iff the map on total spaces is an equivalence. #def total-equiv-iff-family-of-equiv (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps : iff ((a : A) -> isEquiv (B a) (C a) (f a)) (isEquiv (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f)) := (family-of-equiv-total-equiv A B C f, total-equiv-family-of-equiv A B C f) Codomain based path spaces #def rev-is-eq (A : U) (x y : A) : Eq (x = y) (y = x) := (rev A x y, ((rev A y x, rev-involution A x y),(rev A y x, rev-involution A y x))) -- An equivalence between the based path spaces. #def based-paths-Eq (A : U) (a : A) : Eq (\u2211 (x : A), x = a) (\u2211 (x : A), a = x) := family-Eq-total-Eq A (\\x -> x = a) (\\x -> a = x)(\\x -> rev-is-eq A x a) -- Codomain based path spaces are contractible #def codomain-based-paths-contractible (A : U) -- The ambient type. (a : A) -- The basepoint. : isContr (\u2211 (x : A), x = a) := isEquiv-toContr-isContr (\u2211 (x : A), x = a) (\u2211 (x : A), a = x) (based-paths-Eq A a) (based-paths-contractible A a) Pullback of a type family A family of types over B pulls back along any function f : A -> B to define a family of types over A. #def pullback (A B : U) (f : A -> B) (C : B -> U) : A -> U := \\a -> C (f a) The pullback of a family along homotopic maps is equivalent. #def pullback-homotopy (A B : U) (f g : A -> B) (alpha : homotopy A B f g) (C : B -> U) (a : A) : (pullback A B f C a) -> (pullback A B g C a) := \\c -> transport B C (f a) (g a) (alpha a) c #def pullback-homotopy-inverse (A B : U) (f g : A -> B) (alpha : homotopy A B f g) (C : B -> U) (a : A) : (pullback A B g C a) -> (pullback A B f C a) := \\c -> transport B C (g a) (f a) (rev B (f a) (g a) (alpha a)) c #def pullback-homotopy-has-retraction (A B : U) (f g : A -> B) (alpha : homotopy A B f g) (C : B -> U) (a : A) : hasRetraction (pullback A B f C a) (pullback A B g C a) (pullback-homotopy A B f g alpha C a) := (pullback-homotopy-inverse A B f g alpha C a, \\c -> concat (pullback A B f C a) (transport B C (g a) (f a) (rev B (f a) (g a) (alpha a)) (transport B C (f a) (g a) (alpha a) c)) (transport B C (f a) (f a) (concat B (f a) (g a) (f a) (alpha a) (rev B (f a) (g a) (alpha a))) c) c (transport-concat-rev B C (f a) (g a) (f a) (alpha a) (rev B (f a) (g a) (alpha a)) c) (transport2 B C (f a) (f a) (concat B (f a) (g a) (f a) (alpha a) (rev B (f a) (g a) (alpha a))) refl (rev-right-inverse B (f a) (g a) (alpha a)) c)) #def pullback-homotopy-has-section (A B : U) (f g : A -> B) (alpha : homotopy A B f g) (C : B -> U) (a : A) : hasSection (pullback A B f C a) (pullback A B g C a) (pullback-homotopy A B f g alpha C a) := (pullback-homotopy-inverse A B f g alpha C a, \\c -> concat (pullback A B g C a) (transport B C (f a) (g a) (alpha a) (transport B C (g a) (f a) (rev B (f a) (g a) (alpha a)) c)) (transport B C (g a) (g a) (concat B (g a) (f a) (g a) (rev B (f a) (g a) (alpha a)) (alpha a)) c) c (transport-concat-rev B C (g a) (f a) (g a) (rev B (f a) (g a) (alpha a)) (alpha a) c) (transport2 B C (g a) (g a) (concat B (g a) (f a) (g a) (rev B (f a) (g a) (alpha a)) (alpha a)) refl (rev-left-inverse B (f a) (g a) (alpha a)) c)) #def pullback-homotopy-isEquiv (A B : U) (f g : A -> B) (alpha : homotopy A B f g) (C : B -> U) (a : A) : isEquiv (pullback A B f C a) (pullback A B g C a) (pullback-homotopy A B f g alpha C a) := (pullback-homotopy-has-retraction A B f g alpha C a, pullback-homotopy-has-section A B f g alpha C a) The total space of a pulled back family of types maps to the original total space. #def pullback-comparison-map (A B : U) (f : A -> B) (C : B -> U) : (\u2211(a : A), (pullback A B f C) a) -> (\u2211(b : B), C b) := \\(a, c) -> (f a, c) Now we show that if a family is pulled back along an equivalence, the total spaces are equivalent by proving that the comparison is a contractible map. For this, we first prove that each fiber is equivalent to a fiber of the original map. #def pullback-comparison-fiber (A B : U) (f : A -> B) (C : B -> U) (z : \u2211(b : B), C b) : U := fib (\u2211(a : A), (pullback A B f C) a) (\u2211(b : B), C b) (pullback-comparison-map A B f C) z #def pullback-comparison-fiber-to-fiber (A B : U) (f : A -> B) (C : B -> U) (z : \u2211(b : B), C b) : (pullback-comparison-fiber A B f C z) -> (fib A B f (first z)) := \\(w, p) -> idJ((\u2211(b : B), C b), (pullback-comparison-map A B f C w), \\z' p' -> (fib A B f (first z')), (first w, refl), z, p) #def from-base-fiber-to-pullback-comparison-fiber (A B : U) (f : A -> B) (C : B -> U) (b : B) : (fib A B f b) -> (c : C b) -> (pullback-comparison-fiber A B f C (b, c)) := \\(a, p) -> idJ(B, f a, \\b' p' -> (c : C b') -> (pullback-comparison-fiber A B f C ((b', c))), \\c -> ((a, c), refl), b, p) #def pullback-comparison-fiber-to-fiber-inv (A B : U) (f : A -> B) (C : B -> U) (z : \u2211(b : B), C b) : (fib A B f (first z)) -> (pullback-comparison-fiber A B f C z) := \\(a, p) -> from-base-fiber-to-pullback-comparison-fiber A B f C (first z) (a, p) (second z) #def pullback-comparison-fiber-to-fiber-retracting-homotopy (A B : U) (f : A -> B) (C : B -> U) (z : \u2211(b : B), C b) ((w, p) : pullback-comparison-fiber A B f C z) : ((pullback-comparison-fiber-to-fiber-inv A B f C z) ((pullback-comparison-fiber-to-fiber A B f C z) (w, p))) =_{(pullback-comparison-fiber A B f C z)} (w, p) := idJ((\u2211(b : B), C b), (pullback-comparison-map A B f C w), \\z' p' -> ((pullback-comparison-fiber-to-fiber-inv A B f C z') ((pullback-comparison-fiber-to-fiber A B f C z') (w, p'))) =_{(pullback-comparison-fiber A B f C z')} (w, p'), refl, z, p) #def pullback-comparison-fiber-to-fiber-section-homotopy-map (A B : U) (f : A -> B) (C : B -> U) (b : B) ((a, p) : fib A B f b) : (c : C b) -> ((pullback-comparison-fiber-to-fiber A B f C (b, c)) ((pullback-comparison-fiber-to-fiber-inv A B f C (b, c)) (a, p))) =_{(fib A B f b)} (a, p) := idJ(B, f a, \\b' p' -> (c : C b') -> ((pullback-comparison-fiber-to-fiber A B f C (b', c)) ((pullback-comparison-fiber-to-fiber-inv A B f C (b', c)) (a, p'))) =_{(fib A B f b')} (a, p'), \\c -> refl, b, p) #def pullback-comparison-fiber-to-fiber-section-homotopy (A B : U) (f : A -> B) (C : B -> U) (z : \u2211(b : B), C b) ((a, p) : fib A B f (first z)) : ((pullback-comparison-fiber-to-fiber A B f C z) ((pullback-comparison-fiber-to-fiber-inv A B f C z) (a, p))) =_{(fib A B f (first z))} (a, p) := pullback-comparison-fiber-to-fiber-section-homotopy-map A B f C (first z) (a, p) (second z) #def pullback-comparison-fiber-Eq (A B : U) (f : A -> B) (C : B -> U) (z : \u2211(b : B), C b) : Eq (pullback-comparison-fiber A B f C z) (fib A B f (first z)) := (pullback-comparison-fiber-to-fiber A B f C z, ((pullback-comparison-fiber-to-fiber-inv A B f C z, pullback-comparison-fiber-to-fiber-retracting-homotopy A B f C z), (pullback-comparison-fiber-to-fiber-inv A B f C z, pullback-comparison-fiber-to-fiber-section-homotopy A B f C z))) As a corollary, we show that pullback along an equivalence induces an equivalence of total spaces. #def pullback-is-equiv-total-eq (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) (C : B -> U) : Eq (\u2211(a : A), (pullback A B f C) a) (\u2211(b : B), C b) := (pullback-comparison-map A B f C, isContr-map-isEquiv (\u2211(a : A), (pullback A B f C) a) (\u2211(b : B), C b) (pullback-comparison-map A B f C) (\\z -> (isEquiv-toContr-isContr (pullback-comparison-fiber A B f C z) (fib A B f (first z)) (pullback-comparison-fiber-Eq A B f C z) (isEquiv-isContr-map A B f fisequiv (first z)))))","title":"Fibers"},{"location":"hott/06-fibers/#7-fibers","text":"This is a literate rzk file: #lang rzk-1","title":"7. Fibers"},{"location":"hott/06-fibers/#fibers","text":"The homotopy fiber of a map is the following type: -- The fiber of a map #def fib (A B : U) (f : A -> B) (b : B) : U := \u2211 (a : A), (f a) = b -- We calculate the transport of (a, q) : fib b along p : a = a' #def transport-in-fiber (A B : U) (f : A -> B) (b : B) (a a' : A) (u : (f a) = b) (p : a = a') : (transport A (\\x -> (f x) = b) a a' p u) = (concat B (f a') (f a) b (ap A B a' a f (rev A a a' p)) u) := idJ(A, a, \\a'' p' -> (transport A (\\x -> (f x) = b) a a'' p' u) = (concat B (f a'') (f a) b (ap A B a'' a f (rev A a a'' p')) u), (rev ((f a) = b) (concat B (f a) (f a) b refl u) u (refl-concat B (f a) b u)), a', p)","title":"Fibers"},{"location":"hott/06-fibers/#contractible-maps","text":"A map is contractible just when its fibers are contractible. -- Contractible maps #def isContr-map (A B : U) (f : A -> B) : U := (b : B) -> isContr (fib A B f b) Contractible maps are equivalences: #section isEquiv-isContr-map #variables A B : U #variable f : A -> B #variable fiscontr : isContr-map A B f -- The inverse to a contractible map #def isContr-map-inverse : B -> A := \\b -> first(contraction-center (fib A B f b) (fiscontr b)) #def isContr-map-hasSection : hasSection A B f := (isContr-map-inverse, \\b -> second(contraction-center (fib A B f b) (fiscontr b))) #def isContr-map-data-in-fiber uses (fiscontr) (a : A) : fib A B f (f a) := (isContr-map-inverse (f a), (second isContr-map-hasSection) (f a)) #def isContr-map-path-in-fiber (a : A) : (isContr-map-data-in-fiber a) =_{fib A B f (f a)} (a, refl) := contractible-connecting-htpy (fib A B f (f a)) (fiscontr (f a)) (isContr-map-data-in-fiber a) (a, refl) #def isContr-map-hasRetraction uses (fiscontr) : hasRetraction A B f := (isContr-map-inverse, \\a -> (ap (fib A B f (f a)) A (isContr-map-data-in-fiber a) ((a, refl)) (\\u -> first u) (isContr-map-path-in-fiber a))) #def isContr-map-isEquiv uses (fiscontr) : isEquiv A B f := (isContr-map-hasRetraction, isContr-map-hasSection) #end isEquiv-isContr-map","title":"Contractible maps"},{"location":"hott/06-fibers/#half-adjoint-equivalences-are-contractible","text":"We now show that half adjoint equivalences are contractible maps. -- If f is a half adjoint equivalence, its fibers are inhabited. #def isHAE-isSurj (A B : U) (f : A -> B) (fisHAE : isHalfAdjointEquiv A B f) -- first fisHAE : hasInverse A B f (b : B) : fib A B f b := ((hasInverse-inverse A B f (first fisHAE)) b, (second (second (first fisHAE))) b) It takes much more work to construct the contracting homotopy. The bath path of this homotopy is straightforward. #section half-adjoint-equivalence-fiber-data #variables A B : U #variable f : A -> B #variable fisHAE : isHalfAdjointEquiv A B f #variable b : B #variable z : fib A B f b #def isHAE-fib-base-path : ((hasInverse-inverse A B f (first fisHAE)) b) = (first z) := concat A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z))) ((first (second (first fisHAE))) (first z)) -- Specializing the above to isHAE-fib-base-path #def isHAE-fib-base-path-transport : (transport A (\\x -> (f x) = b) ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ) ((second (second (first fisHAE))) b)) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ))) ((second (second (first fisHAE))) b)) := transport-in-fiber A B f b ((hasInverse-inverse A B f (first fisHAE)) b) (first z) ((second (second (first fisHAE))) b) (isHAE-fib-base-path ) #def isHAE-fib-base-path-rev-coherence : rev A ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ) = concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))) := rev-concat A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z))) ((first (second (first fisHAE))) (first z)) #def isHAE-fib-base-path-transport-rev-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ))) ((second (second (first fisHAE))) b)) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) ((second (second (first fisHAE))) b)) := homotopy-concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ))) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) (ap-htpy A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path )) (concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z))))) (isHAE-fib-base-path-rev-coherence )) ((second (second (first fisHAE))) b) #def isHAE-fib-base-path-transport-ap-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) ((second (second (first fisHAE))) b)) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) ((second (second (first fisHAE))) b)) := homotopy-concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) (ap-concat A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z))))) ((second (second (first fisHAE))) b) #def isHAE-fib-base-path-transport-rev-ap-rev-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) ((second (second (first fisHAE))) b)) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) )) ((second (second (first fisHAE))) b)) := homotopy-concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) )) (concat-homotopy B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z))))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z))) (ap-htpy A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))) (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) (rev-ap-rev B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z))) ) ((second (second (first fisHAE))) b) #def isHAE-fib-base-path-transport-ap-ap-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) )) ((second (second (first fisHAE))) b)) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z))) ((second (second (first fisHAE))) b)) := homotopy-concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) )) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z))) (concat-homotopy B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) ) (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z)) (rev-ap-comp B A B (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) f (second z))) ((second (second (first fisHAE))) b) #def isHAE-fib-base-path-transport-assoc-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z))) ((second (second (first fisHAE))) b)) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z)) ((second (second (first fisHAE))) b))) := concat-assoc B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z)) ((second (second (first fisHAE))) b) #def isHAE-fib-base-path-transport-nat-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z)) ((second (second (first fisHAE))) b))) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (ap B B (f (first z)) b (identity B) (second z)))) := concat-homotopy B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) b (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z)) ((second (second (first fisHAE))) b)) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (ap B B (f (first z)) b (identity B) (second z))) (nat-htpy B B (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (identity B) (second (second (first fisHAE))) (f (first z)) b (second z)) #def isHAE-fib-base-path-transport-ap-id-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (ap B B (f (first z)) b (identity B) (second z)))) = (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (second z))) := concat-homotopy B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) b (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (ap B B (f (first z)) b (identity B) (second z))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (second z)) (concat-homotopy B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) ((second (second (first fisHAE))) (f (first z))) b (ap B B (f (first z)) b (identity B) (second z)) (second z) (ap-id B (f (first z)) b (second z))) #def isHAE-fib-base-path-transport-reassoc-calculation : (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (second z))) = (concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) ((second (second (first fisHAE))) (f (first z)))) (second z)) := assoc-concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) ((second (second (first fisHAE))) (f (first z))) (second z) #def isHAE-fib-base-path-transport-HAE-calculation : (concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) ((second (second (first fisHAE))) (f (first z)))) (second z)) = (concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z)))) (second z)) := homotopy-concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) ((second (second (first fisHAE))) (f (first z)))) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z)))) (concat-homotopy B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (f (first z)) (((second (second (first fisHAE)))) (f (first z))) (ap A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z))) ((second fisHAE) (first z))) (second z) #def isHAE-fib-base-path-transport-HAE-reduction : (concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z)))) (second z)) = (concat B (f (first z)) (f (first z)) b (refl) (second z)) := homotopy-concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z)))) (refl) (concat-ap-rev-ap-id A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z))) (second z) #def isHAE-fib-base-path-transport-HAE-final-reduction uses (A) : (concat B (f (first z)) (f (first z)) b (refl) (second z)) = (second z) := refl-concat B (f (first z)) b (second z) #def isHAE-fib-base-path-transport-path : (transport A (\\x -> (f x) = b) ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ) ((second (second (first fisHAE))) b)) = (second z) := 12ary-concat-alternating ((f (first z)) = b) (transport A (\\x -> (f x) = b) ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ) ((second (second (first fisHAE))) b)) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ))) ((second (second (first fisHAE))) b)) (isHAE-fib-base-path-transport ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) b) f (concat A (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z))) (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) ((second (second (first fisHAE))) b)) (isHAE-fib-base-path-transport-rev-calculation ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (rev A ((hasInverse-inverse A B f (first fisHAE)) b) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (ap B A b (f (first z)) (hasInverse-inverse A B f (first fisHAE)) (rev B (f (first z)) b (second z)))))) ((second (second (first fisHAE))) b)) (isHAE-fib-base-path-transport-ap-calculation ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) ((hasInverse-inverse A B f (first fisHAE)) b) f (ap B A (f (first z)) b (hasInverse-inverse A B f (first fisHAE)) (second z)) )) ((second (second (first fisHAE))) b)) (isHAE-fib-base-path-transport-rev-ap-rev-calculation ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z))) ((second (second (first fisHAE))) b)) (isHAE-fib-base-path-transport-ap-ap-calculation ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f ((hasInverse-inverse A B f (first fisHAE)) b)) b (ap B B (f (first z)) b (composition B A B f (hasInverse-inverse A B f (first fisHAE))) (second z)) ((second (second (first fisHAE))) b))) (isHAE-fib-base-path-transport-assoc-calculation ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (ap B B (f (first z)) b (identity B) (second z)))) (isHAE-fib-base-path-transport-nat-calculation ) (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) b (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (concat B (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) b ((second (second (first fisHAE))) (f (first z))) (second z))) (isHAE-fib-base-path-transport-ap-id-calculation ) (concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) ((second (second (first fisHAE))) (f (first z)))) (second z)) (isHAE-fib-base-path-transport-reassoc-calculation ) (concat B (f (first z)) (f (first z)) b (concat B (f (first z)) (f ((hasInverse-inverse A B f (first fisHAE)) (f (first z)))) (f (first z)) (ap A B (first z) ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) f (rev A ((hasInverse-inverse A B f (first fisHAE)) (f (first z))) (first z) ((first (second (first fisHAE))) (first z)))) (ap A B (hasInverse-retraction-composite A B f (first fisHAE) (first z)) (first z) f (((first (second (first fisHAE)))) (first z)))) (second z)) (isHAE-fib-base-path-transport-HAE-calculation ) (concat B (f (first z)) (f (first z)) b (refl) (second z)) (isHAE-fib-base-path-transport-HAE-reduction ) (second z) (isHAE-fib-base-path-transport-HAE-final-reduction ) Finally, we may define the contracting homotopy: #def isHAE-fib-contracting-homotopy : (isHAE-isSurj A B f fisHAE b) = z := pair-of-paths-to-path-of-pairs A (\\x -> (f x) = b) ((hasInverse-inverse A B f (first fisHAE)) b) (first z) (isHAE-fib-base-path ) ((second (second (first fisHAE))) b) (second z) (isHAE-fib-base-path-transport-path ) #end half-adjoint-equivalence-fiber-data Half adjoint equivalences define contractible maps: #def isHAE-isContr-map (A B : U) (f : A -> B) (fisHAE : isHalfAdjointEquiv A B f) : isContr-map A B f := \\b -> (isHAE-isSurj A B f fisHAE b, \\z -> isHAE-fib-contracting-homotopy A B f fisHAE b z)","title":"Half adjoint equivalences are contractible."},{"location":"hott/06-fibers/#equivalences-are-contractible-maps","text":"#def isEquiv-isContr-map (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) : isContr-map A B f := \\b -> (isHAE-isSurj A B f (isEquiv-isHalfAdjointEquiv A B f fisequiv) b, \\z -> isHAE-fib-contracting-homotopy A B f (isEquiv-isHalfAdjointEquiv A B f fisequiv) b z) #def isContr-map-iff-isEquiv (A B : U) (f : A -> B) : iff (isContr-map A B f) (isEquiv A B f) := (isContr-map-isEquiv A B f, isEquiv-isContr-map A B f)","title":"Equivalences are contractible maps"},{"location":"hott/06-fibers/#fiber-of-total-map","text":"We now calculate the fiber of the map on total spaces associated to a family of maps. #def family-of-maps-total-map (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps : (\u2211 (x : A), B x) -> (\u2211 (x : A), C x) -- the induced map on total spaces := \\z -> (first z, f (first z) (second z)) #def total-map-to-fiber (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (w : (\u2211 (x : A), C x)) : fib (B (first w)) (C (first w)) (f (first w)) (second w) -> (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w) := \\(b, p) -> ((first w, b), fibered-path-to-sigma-path A C (first w) (f (first w) b) (second w) p) #def total-map-from-fiber (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (w : (\u2211 (x : A), C x)) : (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w) -> fib (B (first w)) (C (first w)) (f (first w)) (second w) := \\(z, p) -> idJ((\u2211 (x : A), C x), ((family-of-maps-total-map A B C f) z), \\w' p' -> fib (B (first w')) (C (first w')) (f (first w')) (second w'), (((second z), refl)), w, p) #def total-map-to-fiber-retraction (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (w : (\u2211 (x : A), C x)) : hasRetraction (fib (B (first w)) (C (first w)) (f (first w)) (second w)) (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w) (total-map-to-fiber A B C f w) := (total-map-from-fiber A B C f w, \\(b, p) -> idJ((C (first w)), (f (first w) b), \\w1 p' -> ((total-map-from-fiber A B C f ((first w, w1))) ((total-map-to-fiber A B C f (first w, w1)) (b, p'))) =_{(fib (B (first w)) (C (first w)) (f (first w)) (w1))} (b, p'), refl, (second w), p)) #def total-map-to-fiber-section (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (w : (\u2211 (x : A), C x)) : hasSection (fib (B (first w)) (C (first w)) (f (first w)) (second w)) (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w) (total-map-to-fiber A B C f w) := (total-map-from-fiber A B C f w, \\(z, p) -> idJ((\u2211 (x : A), C x), ((first z, f (first z) (second z))), \\w' p' -> ((total-map-to-fiber A B C f w') ((total-map-from-fiber A B C f w') (z, p'))) =_{(fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w')} (z, p'), refl, w, p)) #def total-map-to-fiber-isEquiv (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (w : (\u2211 (x : A), C x)) : isEquiv (fib (B (first w)) (C (first w)) (f (first w)) (second w)) (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w) (total-map-to-fiber A B C f w) := (total-map-to-fiber-retraction A B C f w, total-map-to-fiber-section A B C f w) #def total-map-fiber-equiv (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (w : (\u2211 (x : A), C x)) : Eq (fib (B (first w)) (C (first w)) (f (first w)) (second w)) (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) w) := (total-map-to-fiber A B C f w, total-map-to-fiber-isEquiv A B C f w)","title":"Fiber of total map"},{"location":"hott/06-fibers/#families-of-equivalences","text":"A family of equivalences induces an equivalence on total spaces and conversely. It will be easiest to work with the incoherent notion of two-sided-inverses. #def invertible-family-total-inverse (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (invfamily : (a : A) -> hasInverse (B a) (C a) (f a)) -- an invertible family of maps : (\u2211 (x : A), C x) -> (\u2211 (x : A), B x) -- the inverse map on total spaces := \\(a, c) -> (a, (hasInverse-inverse (B a) (C a) (f a) (invfamily a)) c) #def invertible-family-total-retraction (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (invfamily : (a : A) -> hasInverse (B a) (C a) (f a)) -- an invertible family of maps : hasRetraction (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) := (invertible-family-total-inverse A B C f invfamily, \\(a, b) -> (fibered-path-to-sigma-path A B a ((hasInverse-inverse (B a) (C a) (f a) (invfamily a)) (f a b)) b ((first (second (invfamily a))) b))) #def invertible-family-total-section (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (invfamily : (a : A) -> hasInverse (B a) (C a) (f a)) -- an invertible family of maps : hasSection (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) := (invertible-family-total-inverse A B C f invfamily, \\(a, c) -> (fibered-path-to-sigma-path A C a (f a ((hasInverse-inverse (B a) (C a) (f a) (invfamily a)) c)) c ((second (second (invfamily a))) c))) #def invertible-family-total-invertible (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (invfamily : (a : A) -> hasInverse (B a) (C a) (f a)) -- an invertible family of maps : hasInverse (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) := (invertible-family-total-inverse A B C f invfamily, (second (invertible-family-total-retraction A B C f invfamily), second (invertible-family-total-section A B C f invfamily) )) #def family-of-equiv-total-equiv (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (familyequiv : (a : A) -> isEquiv (B a) (C a) (f a)) -- a family of equivalences : isEquiv (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) := hasInverse-isEquiv (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) (invertible-family-total-invertible A B C f (\\a -> isEquiv-hasInverse (B a) (C a) (f a) (familyequiv a))) #def family-Eq-total-Eq (A : U) (B C : A -> U) (familyeq : (a : A) -> Eq (B a) (C a)) -- a family of equivalences : Eq (\u2211 (x : A), B x) (\u2211 (x : A), C x) := (family-of-maps-total-map A B C (\\a -> first (familyeq a)), family-of-equiv-total-equiv A B C (\\a -> first (familyeq a)) (\\a -> second (familyeq a))) The one-way result: that a family of equivalence gives an invertible map (and thus an equivalence) on total spaces. #def family-of-equiv-total-invertible (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (familyequiv : (a : A) -> isEquiv (B a) (C a) (f a)) -- a family of equivalences : hasInverse (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) := invertible-family-total-invertible A B C f (\\a -> isEquiv-hasInverse (B a) (C a) (f a) (familyequiv a)) For the converse, we make use of our calculation on fibers. The first implication could be proven similarly. #def total-contr-map-family-of-contr-maps (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (totalcontrmap : isContr-map (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f)) (a : A) : isContr-map (B a) (C a) (f a) := \\c -> isEquiv-toContr-isContr (fib (B a) (C a) (f a) c) (fib (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) ((a, c))) (total-map-fiber-equiv A B C f ((a, c))) (totalcontrmap ((a, c))) #def total-equiv-family-of-equiv (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps (totalequiv : isEquiv (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f)) (a : A) : isEquiv (B a) (C a) (f a) := isContr-map-isEquiv (B a) (C a) (f a) (total-contr-map-family-of-contr-maps A B C f (isEquiv-isContr-map (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f) totalequiv) a) In summary, a family of maps is an equivalence iff the map on total spaces is an equivalence. #def total-equiv-iff-family-of-equiv (A : U) (B C : A -> U) (f : (a : A) -> (B a) -> (C a)) -- a family of maps : iff ((a : A) -> isEquiv (B a) (C a) (f a)) (isEquiv (\u2211 (x : A), B x) (\u2211 (x : A), C x) (family-of-maps-total-map A B C f)) := (family-of-equiv-total-equiv A B C f, total-equiv-family-of-equiv A B C f)","title":"Families of equivalences"},{"location":"hott/06-fibers/#codomain-based-path-spaces","text":"#def rev-is-eq (A : U) (x y : A) : Eq (x = y) (y = x) := (rev A x y, ((rev A y x, rev-involution A x y),(rev A y x, rev-involution A y x))) -- An equivalence between the based path spaces. #def based-paths-Eq (A : U) (a : A) : Eq (\u2211 (x : A), x = a) (\u2211 (x : A), a = x) := family-Eq-total-Eq A (\\x -> x = a) (\\x -> a = x)(\\x -> rev-is-eq A x a) -- Codomain based path spaces are contractible #def codomain-based-paths-contractible (A : U) -- The ambient type. (a : A) -- The basepoint. : isContr (\u2211 (x : A), x = a) := isEquiv-toContr-isContr (\u2211 (x : A), x = a) (\u2211 (x : A), a = x) (based-paths-Eq A a) (based-paths-contractible A a)","title":"Codomain based path spaces"},{"location":"hott/06-fibers/#pullback-of-a-type-family","text":"A family of types over B pulls back along any function f : A -> B to define a family of types over A. #def pullback (A B : U) (f : A -> B) (C : B -> U) : A -> U := \\a -> C (f a) The pullback of a family along homotopic maps is equivalent. #def pullback-homotopy (A B : U) (f g : A -> B) (alpha : homotopy A B f g) (C : B -> U) (a : A) : (pullback A B f C a) -> (pullback A B g C a) := \\c -> transport B C (f a) (g a) (alpha a) c #def pullback-homotopy-inverse (A B : U) (f g : A -> B) (alpha : homotopy A B f g) (C : B -> U) (a : A) : (pullback A B g C a) -> (pullback A B f C a) := \\c -> transport B C (g a) (f a) (rev B (f a) (g a) (alpha a)) c #def pullback-homotopy-has-retraction (A B : U) (f g : A -> B) (alpha : homotopy A B f g) (C : B -> U) (a : A) : hasRetraction (pullback A B f C a) (pullback A B g C a) (pullback-homotopy A B f g alpha C a) := (pullback-homotopy-inverse A B f g alpha C a, \\c -> concat (pullback A B f C a) (transport B C (g a) (f a) (rev B (f a) (g a) (alpha a)) (transport B C (f a) (g a) (alpha a) c)) (transport B C (f a) (f a) (concat B (f a) (g a) (f a) (alpha a) (rev B (f a) (g a) (alpha a))) c) c (transport-concat-rev B C (f a) (g a) (f a) (alpha a) (rev B (f a) (g a) (alpha a)) c) (transport2 B C (f a) (f a) (concat B (f a) (g a) (f a) (alpha a) (rev B (f a) (g a) (alpha a))) refl (rev-right-inverse B (f a) (g a) (alpha a)) c)) #def pullback-homotopy-has-section (A B : U) (f g : A -> B) (alpha : homotopy A B f g) (C : B -> U) (a : A) : hasSection (pullback A B f C a) (pullback A B g C a) (pullback-homotopy A B f g alpha C a) := (pullback-homotopy-inverse A B f g alpha C a, \\c -> concat (pullback A B g C a) (transport B C (f a) (g a) (alpha a) (transport B C (g a) (f a) (rev B (f a) (g a) (alpha a)) c)) (transport B C (g a) (g a) (concat B (g a) (f a) (g a) (rev B (f a) (g a) (alpha a)) (alpha a)) c) c (transport-concat-rev B C (g a) (f a) (g a) (rev B (f a) (g a) (alpha a)) (alpha a) c) (transport2 B C (g a) (g a) (concat B (g a) (f a) (g a) (rev B (f a) (g a) (alpha a)) (alpha a)) refl (rev-left-inverse B (f a) (g a) (alpha a)) c)) #def pullback-homotopy-isEquiv (A B : U) (f g : A -> B) (alpha : homotopy A B f g) (C : B -> U) (a : A) : isEquiv (pullback A B f C a) (pullback A B g C a) (pullback-homotopy A B f g alpha C a) := (pullback-homotopy-has-retraction A B f g alpha C a, pullback-homotopy-has-section A B f g alpha C a) The total space of a pulled back family of types maps to the original total space. #def pullback-comparison-map (A B : U) (f : A -> B) (C : B -> U) : (\u2211(a : A), (pullback A B f C) a) -> (\u2211(b : B), C b) := \\(a, c) -> (f a, c) Now we show that if a family is pulled back along an equivalence, the total spaces are equivalent by proving that the comparison is a contractible map. For this, we first prove that each fiber is equivalent to a fiber of the original map. #def pullback-comparison-fiber (A B : U) (f : A -> B) (C : B -> U) (z : \u2211(b : B), C b) : U := fib (\u2211(a : A), (pullback A B f C) a) (\u2211(b : B), C b) (pullback-comparison-map A B f C) z #def pullback-comparison-fiber-to-fiber (A B : U) (f : A -> B) (C : B -> U) (z : \u2211(b : B), C b) : (pullback-comparison-fiber A B f C z) -> (fib A B f (first z)) := \\(w, p) -> idJ((\u2211(b : B), C b), (pullback-comparison-map A B f C w), \\z' p' -> (fib A B f (first z')), (first w, refl), z, p) #def from-base-fiber-to-pullback-comparison-fiber (A B : U) (f : A -> B) (C : B -> U) (b : B) : (fib A B f b) -> (c : C b) -> (pullback-comparison-fiber A B f C (b, c)) := \\(a, p) -> idJ(B, f a, \\b' p' -> (c : C b') -> (pullback-comparison-fiber A B f C ((b', c))), \\c -> ((a, c), refl), b, p) #def pullback-comparison-fiber-to-fiber-inv (A B : U) (f : A -> B) (C : B -> U) (z : \u2211(b : B), C b) : (fib A B f (first z)) -> (pullback-comparison-fiber A B f C z) := \\(a, p) -> from-base-fiber-to-pullback-comparison-fiber A B f C (first z) (a, p) (second z) #def pullback-comparison-fiber-to-fiber-retracting-homotopy (A B : U) (f : A -> B) (C : B -> U) (z : \u2211(b : B), C b) ((w, p) : pullback-comparison-fiber A B f C z) : ((pullback-comparison-fiber-to-fiber-inv A B f C z) ((pullback-comparison-fiber-to-fiber A B f C z) (w, p))) =_{(pullback-comparison-fiber A B f C z)} (w, p) := idJ((\u2211(b : B), C b), (pullback-comparison-map A B f C w), \\z' p' -> ((pullback-comparison-fiber-to-fiber-inv A B f C z') ((pullback-comparison-fiber-to-fiber A B f C z') (w, p'))) =_{(pullback-comparison-fiber A B f C z')} (w, p'), refl, z, p) #def pullback-comparison-fiber-to-fiber-section-homotopy-map (A B : U) (f : A -> B) (C : B -> U) (b : B) ((a, p) : fib A B f b) : (c : C b) -> ((pullback-comparison-fiber-to-fiber A B f C (b, c)) ((pullback-comparison-fiber-to-fiber-inv A B f C (b, c)) (a, p))) =_{(fib A B f b)} (a, p) := idJ(B, f a, \\b' p' -> (c : C b') -> ((pullback-comparison-fiber-to-fiber A B f C (b', c)) ((pullback-comparison-fiber-to-fiber-inv A B f C (b', c)) (a, p'))) =_{(fib A B f b')} (a, p'), \\c -> refl, b, p) #def pullback-comparison-fiber-to-fiber-section-homotopy (A B : U) (f : A -> B) (C : B -> U) (z : \u2211(b : B), C b) ((a, p) : fib A B f (first z)) : ((pullback-comparison-fiber-to-fiber A B f C z) ((pullback-comparison-fiber-to-fiber-inv A B f C z) (a, p))) =_{(fib A B f (first z))} (a, p) := pullback-comparison-fiber-to-fiber-section-homotopy-map A B f C (first z) (a, p) (second z) #def pullback-comparison-fiber-Eq (A B : U) (f : A -> B) (C : B -> U) (z : \u2211(b : B), C b) : Eq (pullback-comparison-fiber A B f C z) (fib A B f (first z)) := (pullback-comparison-fiber-to-fiber A B f C z, ((pullback-comparison-fiber-to-fiber-inv A B f C z, pullback-comparison-fiber-to-fiber-retracting-homotopy A B f C z), (pullback-comparison-fiber-to-fiber-inv A B f C z, pullback-comparison-fiber-to-fiber-section-homotopy A B f C z))) As a corollary, we show that pullback along an equivalence induces an equivalence of total spaces. #def pullback-is-equiv-total-eq (A B : U) (f : A -> B) (fisequiv : isEquiv A B f) (C : B -> U) : Eq (\u2211(a : A), (pullback A B f C) a) (\u2211(b : B), C b) := (pullback-comparison-map A B f C, isContr-map-isEquiv (\u2211(a : A), (pullback A B f C) a) (\u2211(b : B), C b) (pullback-comparison-map A B f C) (\\z -> (isEquiv-toContr-isContr (pullback-comparison-fiber A B f C z) (fib A B f (first z)) (pullback-comparison-fiber-Eq A B f C z) (isEquiv-isContr-map A B f fisequiv (first z)))))","title":"Pullback of a type family"},{"location":"hott/07-trivial-fibrations/","text":"6. Trivial Fibrations This is a literate rzk file: #lang rzk-1 Contractible fibers -- In what follows we apply show that the projection from the total space of a sigma type is an equivalence if and only if its fibers are contractible #def total-space-projection (A : U) (B : A -> U) : (\u2211 (x : A), B x) -> A := \\z -> first z -- The type that asserts that the fibers of a type family are contractible #def contractible-fibers (A : U) (B : A -> U) : U := ((x : A) -> isContr (B x)) #section contractible-fibers-data #variable A : U #variable B : A -> U #variable ABcontrfib : contractible-fibers A B -- The center of contraction in a contractible fibers #def contractible-fibers-section : (x : A) -> B x := \\x -> contraction-center (B x) (ABcontrfib x) -- The section of the total space projection built from the contraction centers #def contractible-fibers-actual-section uses (ABcontrfib) : (x : A) -> \u2211 (x : A), B x := \\x -> (x , contractible-fibers-section x) #def contractible-fibers-section-htpy uses (ABcontrfib) : homotopy A A (composition A (\u2211 (x : A), B x) A (total-space-projection A B) (contractible-fibers-actual-section)) (identity A) := \\x -> refl #def contractible-fibers-section-is-section uses (ABcontrfib) : hasSection (\u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-actual-section , contractible-fibers-section-htpy) -- This can be used to define the retraction homotopy for the total space projection, called \"first\" here #def contractible-fibers-retraction-htpy : (z : \u2211 (x : A), B x) -> ((contractible-fibers-actual-section) (first z)) = z := \\z -> fibered-path-to-sigma-path A B (first z) ((contractible-fibers-section) (first z)) (second z) (contracting-htpy (B (first z)) (ABcontrfib (first z)) (second z)) #def contractible-fibers-retraction uses (ABcontrfib) : hasRetraction (\u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-actual-section , contractible-fibers-retraction-htpy) -- The first half of our main result: #def contractible-fibers-projection-equiv uses (ABcontrfib) : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-retraction , contractible-fibers-section-is-section) #def contractible-fibers-projection-Eq uses (ABcontrfib) : Eq (\u2211 (x : A), B x) A := (total-space-projection A B, contractible-fibers-projection-equiv) #end contractible-fibers-data Projection equivalences -- From a projection equivalence, it's not hard to inhabit fibers #def projection-equiv-implies-inhabited-fibers (A : U) (B : A -> U) (ABprojequiv : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (a : A) : B a := transport A B (first ((first (second ABprojequiv)) a)) a ((second (second ABprojequiv)) a) (second ((first (second ABprojequiv)) a)) -- This is great but I'll need more coherence to show that the inhabited fibers are contractible; the following proof fails -- #def projection-equiv-implies-contractible-fibers -- (A : U) -- (B : A -> U) -- (ABprojequiv : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) -- : contractible-fibers A B -- := \\x -> (second ((first (first ABprojequiv)) x) , -- \\u -> total-path-to-fibered-path A B ((first (first ABprojequiv)) x) (x, u) ((second (first ABprojequiv)) (x, u)) ) #section projection-hae-data #variable A : U #variable B : A -> U #variable ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B) #variable w : (\u2211 (x : A), B x) -- We start over from a stronger hypothesis of a half adjoint equivalence #def projection-hae-inverse (a : A) : \u2211 (x : A), B x := (first (first ABprojHAE)) a #def projection-hae-base-htpy uses (B) (a : A) : (first (projection-hae-inverse a)) = a := (second (second (first ABprojHAE))) a #def projection-hae-section uses (ABprojHAE) (a : A) : B a := transport A B (first (projection-hae-inverse a)) a (projection-hae-base-htpy a) (second (projection-hae-inverse a)) #def projection-hae-total-htpy : (projection-hae-inverse (first w)) = w := (first (second (first ABprojHAE))) w #def projection-hae-fibered-htpy : (transport A B (first ((projection-hae-inverse (first w)))) (first w) (total-path-to-base-path A B (projection-hae-inverse (first w)) w (projection-hae-total-htpy)) (second (projection-hae-inverse (first w)))) = (second w) := total-path-to-fibered-path A B (projection-hae-inverse (first w)) w (projection-hae-total-htpy) #def projection-hae-base-coherence : (projection-hae-base-htpy (first w)) = (total-path-to-base-path A B (projection-hae-inverse (first w)) w (projection-hae-total-htpy)) := (second ABprojHAE) w #def projection-hae-transport-coherence : (projection-hae-section (first w)) = (transport A B (first ((projection-hae-inverse (first w)))) (first w) (total-path-to-base-path A B (projection-hae-inverse (first w)) w (projection-hae-total-htpy)) (second (projection-hae-inverse (first w)))) := transport2 A B (first (projection-hae-inverse (first w))) (first w) (projection-hae-base-htpy (first w)) (total-path-to-base-path A B (projection-hae-inverse (first w)) w (projection-hae-total-htpy)) (projection-hae-base-coherence) (second (projection-hae-inverse (first w))) #def projection-hae-fibered-contracting-htpy : (projection-hae-section (first w)) =_{B (first w)} (second w) := concat (B (first w)) (projection-hae-section (first w)) (transport A B (first ((projection-hae-inverse (first w)))) (first w) (total-path-to-base-path A B (projection-hae-inverse (first w)) w (projection-hae-total-htpy)) (second (projection-hae-inverse (first w)))) (second w) (projection-hae-transport-coherence) (projection-hae-fibered-htpy) #end projection-hae-data -- Finally we have #def projection-hae-contractible-fibers (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) : contractible-fibers A B := \\x -> ((projection-hae-section A B ABprojHAE x), \\u -> (projection-hae-fibered-contracting-htpy A B ABprojHAE (x, u))) -- The converse to our first result #def projection-equiv-contractible-fibers (A : U) (B : A -> U) (ABprojequiv : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) : contractible-fibers A B := projection-hae-contractible-fibers A B (isEquiv-isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B) ABprojequiv) -- The main theorem #def projection-theorem (A : U) (B : (a : A) -> U) : iff (isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (contractible-fibers A B) := (\\ABprojequiv -> projection-equiv-contractible-fibers A B ABprojequiv, \\ABcontrfib -> contractible-fibers-projection-equiv A B ABcontrfib)","title":"Trivial fibrations"},{"location":"hott/07-trivial-fibrations/#6-trivial-fibrations","text":"This is a literate rzk file: #lang rzk-1","title":"6. Trivial Fibrations"},{"location":"hott/07-trivial-fibrations/#contractible-fibers","text":"-- In what follows we apply show that the projection from the total space of a sigma type is an equivalence if and only if its fibers are contractible #def total-space-projection (A : U) (B : A -> U) : (\u2211 (x : A), B x) -> A := \\z -> first z -- The type that asserts that the fibers of a type family are contractible #def contractible-fibers (A : U) (B : A -> U) : U := ((x : A) -> isContr (B x)) #section contractible-fibers-data #variable A : U #variable B : A -> U #variable ABcontrfib : contractible-fibers A B -- The center of contraction in a contractible fibers #def contractible-fibers-section : (x : A) -> B x := \\x -> contraction-center (B x) (ABcontrfib x) -- The section of the total space projection built from the contraction centers #def contractible-fibers-actual-section uses (ABcontrfib) : (x : A) -> \u2211 (x : A), B x := \\x -> (x , contractible-fibers-section x) #def contractible-fibers-section-htpy uses (ABcontrfib) : homotopy A A (composition A (\u2211 (x : A), B x) A (total-space-projection A B) (contractible-fibers-actual-section)) (identity A) := \\x -> refl #def contractible-fibers-section-is-section uses (ABcontrfib) : hasSection (\u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-actual-section , contractible-fibers-section-htpy) -- This can be used to define the retraction homotopy for the total space projection, called \"first\" here #def contractible-fibers-retraction-htpy : (z : \u2211 (x : A), B x) -> ((contractible-fibers-actual-section) (first z)) = z := \\z -> fibered-path-to-sigma-path A B (first z) ((contractible-fibers-section) (first z)) (second z) (contracting-htpy (B (first z)) (ABcontrfib (first z)) (second z)) #def contractible-fibers-retraction uses (ABcontrfib) : hasRetraction (\u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-actual-section , contractible-fibers-retraction-htpy) -- The first half of our main result: #def contractible-fibers-projection-equiv uses (ABcontrfib) : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B) := (contractible-fibers-retraction , contractible-fibers-section-is-section) #def contractible-fibers-projection-Eq uses (ABcontrfib) : Eq (\u2211 (x : A), B x) A := (total-space-projection A B, contractible-fibers-projection-equiv) #end contractible-fibers-data","title":"Contractible fibers"},{"location":"hott/07-trivial-fibrations/#projection-equivalences","text":"-- From a projection equivalence, it's not hard to inhabit fibers #def projection-equiv-implies-inhabited-fibers (A : U) (B : A -> U) (ABprojequiv : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (a : A) : B a := transport A B (first ((first (second ABprojequiv)) a)) a ((second (second ABprojequiv)) a) (second ((first (second ABprojequiv)) a)) -- This is great but I'll need more coherence to show that the inhabited fibers are contractible; the following proof fails -- #def projection-equiv-implies-contractible-fibers -- (A : U) -- (B : A -> U) -- (ABprojequiv : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) -- : contractible-fibers A B -- := \\x -> (second ((first (first ABprojequiv)) x) , -- \\u -> total-path-to-fibered-path A B ((first (first ABprojequiv)) x) (x, u) ((second (first ABprojequiv)) (x, u)) ) #section projection-hae-data #variable A : U #variable B : A -> U #variable ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B) #variable w : (\u2211 (x : A), B x) -- We start over from a stronger hypothesis of a half adjoint equivalence #def projection-hae-inverse (a : A) : \u2211 (x : A), B x := (first (first ABprojHAE)) a #def projection-hae-base-htpy uses (B) (a : A) : (first (projection-hae-inverse a)) = a := (second (second (first ABprojHAE))) a #def projection-hae-section uses (ABprojHAE) (a : A) : B a := transport A B (first (projection-hae-inverse a)) a (projection-hae-base-htpy a) (second (projection-hae-inverse a)) #def projection-hae-total-htpy : (projection-hae-inverse (first w)) = w := (first (second (first ABprojHAE))) w #def projection-hae-fibered-htpy : (transport A B (first ((projection-hae-inverse (first w)))) (first w) (total-path-to-base-path A B (projection-hae-inverse (first w)) w (projection-hae-total-htpy)) (second (projection-hae-inverse (first w)))) = (second w) := total-path-to-fibered-path A B (projection-hae-inverse (first w)) w (projection-hae-total-htpy) #def projection-hae-base-coherence : (projection-hae-base-htpy (first w)) = (total-path-to-base-path A B (projection-hae-inverse (first w)) w (projection-hae-total-htpy)) := (second ABprojHAE) w #def projection-hae-transport-coherence : (projection-hae-section (first w)) = (transport A B (first ((projection-hae-inverse (first w)))) (first w) (total-path-to-base-path A B (projection-hae-inverse (first w)) w (projection-hae-total-htpy)) (second (projection-hae-inverse (first w)))) := transport2 A B (first (projection-hae-inverse (first w))) (first w) (projection-hae-base-htpy (first w)) (total-path-to-base-path A B (projection-hae-inverse (first w)) w (projection-hae-total-htpy)) (projection-hae-base-coherence) (second (projection-hae-inverse (first w))) #def projection-hae-fibered-contracting-htpy : (projection-hae-section (first w)) =_{B (first w)} (second w) := concat (B (first w)) (projection-hae-section (first w)) (transport A B (first ((projection-hae-inverse (first w)))) (first w) (total-path-to-base-path A B (projection-hae-inverse (first w)) w (projection-hae-total-htpy)) (second (projection-hae-inverse (first w)))) (second w) (projection-hae-transport-coherence) (projection-hae-fibered-htpy) #end projection-hae-data -- Finally we have #def projection-hae-contractible-fibers (A : U) (B : A -> U) (ABprojHAE : isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) : contractible-fibers A B := \\x -> ((projection-hae-section A B ABprojHAE x), \\u -> (projection-hae-fibered-contracting-htpy A B ABprojHAE (x, u))) -- The converse to our first result #def projection-equiv-contractible-fibers (A : U) (B : A -> U) (ABprojequiv : isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) : contractible-fibers A B := projection-hae-contractible-fibers A B (isEquiv-isHalfAdjointEquiv (\u2211 (x : A), B x) A (total-space-projection A B) ABprojequiv) -- The main theorem #def projection-theorem (A : U) (B : (a : A) -> U) : iff (isEquiv (\u2211 (x : A), B x) A (total-space-projection A B)) (contractible-fibers A B) := (\\ABprojequiv -> projection-equiv-contractible-fibers A B ABprojequiv, \\ABcontrfib -> contractible-fibers-projection-equiv A B ABcontrfib)","title":"Projection equivalences"},{"location":"simplicial-hott/03-simplicial-type-theory/","text":"3. Simplicial Type Theory These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1 Simplicies and their subshapes Simplicies: -- 1-simplex #def \u0394\u00b9 : 2 -> TOPE := \\t -> TOP -- 2-simplex #def \u0394\u00b2 : (2 * 2) -> TOPE := \\(t, s) -> s <= t -- 3-simplex #def \u0394\u00b3 : (2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 Boundaries of simplices: -- boundary of a 1-simplex #def \u2202\u0394\u00b9 : \u0394\u00b9 -> TOPE := \\t -> (t === 0_2 \\/ t === 1_2) -- boundary of a 2-simplex #def \u2202\u0394\u00b2 : \u0394\u00b2 -> TOPE := \\ts -> ((second ts) === 0_2 \\/ (first ts) === 1_2 \\/ (second ts) === (first ts)) Horns: -- the (2,1)-horn #def \u039b : (2 * 2) -> TOPE := \\(t, s) -> (s === 0_2 \\/ t === 1_2) Products: -- the product of topes defines the product of shapes #def shapeProd (I J : CUBE) (psi : I -> TOPE) (chi : J -> TOPE) : (I * J) -> TOPE := \\(t, s) -> psi t /\\ chi s -- the square as a product #def \u0394\u00b9\u00d7\u0394\u00b9 : (2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 -- the total boundary of the square #def \u2202\u25a1 : (2 * 2) -> TOPE := \\(t ,s) -> ((\u2202\u0394\u00b9 t) /\\ (\u0394\u00b9 s)) \\/ ((\u0394\u00b9 t) /\\ (\u2202\u0394\u00b9 s)) -- the vertical boundary of the square #def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : (2 * 2) -> TOPE := shapeProd 2 2 \u2202\u0394\u00b9 \u0394\u00b9 -- the prism from a 2-simplex in an arrow type #def \u0394\u00b2\u00d7\u0394\u00b9 : (2 * 2 * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9","title":"Simplicial Type Theory"},{"location":"simplicial-hott/03-simplicial-type-theory/#3-simplicial-type-theory","text":"These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"3. Simplicial Type Theory"},{"location":"simplicial-hott/03-simplicial-type-theory/#simplicies-and-their-subshapes","text":"Simplicies: -- 1-simplex #def \u0394\u00b9 : 2 -> TOPE := \\t -> TOP -- 2-simplex #def \u0394\u00b2 : (2 * 2) -> TOPE := \\(t, s) -> s <= t -- 3-simplex #def \u0394\u00b3 : (2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 Boundaries of simplices: -- boundary of a 1-simplex #def \u2202\u0394\u00b9 : \u0394\u00b9 -> TOPE := \\t -> (t === 0_2 \\/ t === 1_2) -- boundary of a 2-simplex #def \u2202\u0394\u00b2 : \u0394\u00b2 -> TOPE := \\ts -> ((second ts) === 0_2 \\/ (first ts) === 1_2 \\/ (second ts) === (first ts)) Horns: -- the (2,1)-horn #def \u039b : (2 * 2) -> TOPE := \\(t, s) -> (s === 0_2 \\/ t === 1_2) Products: -- the product of topes defines the product of shapes #def shapeProd (I J : CUBE) (psi : I -> TOPE) (chi : J -> TOPE) : (I * J) -> TOPE := \\(t, s) -> psi t /\\ chi s -- the square as a product #def \u0394\u00b9\u00d7\u0394\u00b9 : (2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 -- the total boundary of the square #def \u2202\u25a1 : (2 * 2) -> TOPE := \\(t ,s) -> ((\u2202\u0394\u00b9 t) /\\ (\u0394\u00b9 s)) \\/ ((\u0394\u00b9 t) /\\ (\u2202\u0394\u00b9 s)) -- the vertical boundary of the square #def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : (2 * 2) -> TOPE := shapeProd 2 2 \u2202\u0394\u00b9 \u0394\u00b9 -- the prism from a 2-simplex in an arrow type #def \u0394\u00b2\u00d7\u0394\u00b9 : (2 * 2 * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9","title":"Simplicies and their subshapes"},{"location":"simplicial-hott/04-extension-types/","text":"4. Equivalences involving extension types These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/4-equivalences.rzk \u2014 contains the definitions of Eq and compose_Eq the file hott/4-equivalences.rzk relies in turn on the previous files in hott/ Commutation of arguments and currying -- [RS17, Theorem 4.1] #def flip-ext-fun (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : U) (Y : psi -> X -> U) (f : (t : phi) -> (x : X) -> Y t x) : Eq (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) := (\\g x t -> g t x, -- the one-way map ((\\h t x -> (h x) t, -- the retraction \\g -> refl), -- the retracting homotopy (\\h t x -> (h x) t, -- the section \\h -> refl))) -- the section homotopy #def flip-ext-fun-inv (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : U) (Y : psi -> X -> U) (f : (t : phi) -> (x : X) -> Y t x) : Eq ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) := (\\h t x -> (h x) t, -- the one-way map ((\\g x t -> g t x, -- the retraction \\h -> refl), -- the retracting homotopy (\\g x t -> g t x, -- the section \\g -> refl))) -- [RS17, Theorem 4.2] #def curry-uncurry (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) := (\\g (t, s) -> (g t) s, -- the one way map ((\\h t s -> h (t , s) -- its retraction ,\\g -> refl), -- the retracting homotopy (\\h t s -> h (t , s) -- its section ,\\h -> refl))) -- the section homotopy #def uncurry-opcurry (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := (\\h s t -> h (t , s) , -- the one way map ((\\g (t, s) -> (g s) t -- its retraction ,\\h -> refl), -- the retracting homotopy (\\g (t, s) -> (g s) t -- its section ,\\g -> refl))) -- the section homotopy #def fubini (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := compose_Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) (curry-uncurry I J psi phi zeta chi X f) (uncurry-opcurry I J psi phi zeta chi X f) Extending into \u2211-types (the non-axiom of choice) -- [RS17, Theorem 4.3] #def axiom-choice (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : psi -> U) (Y : (t : psi) -> (x : X t) -> U) (a : (t : phi) -> X t) (b : (t : phi) -> Y t (a t)) : Eq (<{t : I | psi t} -> (\u2211 (x : X t), Y t x) [ phi t |-> (a t , b t) ]>) (\u2211 (f : (<{t : I | psi t} -> X t [phi t |-> a t ]>)), (<{t : I | psi t} -> Y t (f t) [ phi t |-> b t ]>)) := (\\g -> (\\t -> (first (g t)), \\t -> second (g t)) , -- the one way map ((\\h t -> ((first h) t, (second h) t) -- its retraction , \\g -> refl), -- the retracting homotopy (\\h t -> ((first h) t, (second h) t) -- its section , \\h -> refl))) -- the section homotopy Composites and unions of cofibrations -- [RS17, Theorem 4.4] -- Reformulated via tope disjunction instead of inclusion. -- See https://github.com/fizruk/rzk/issues/8 #def cofibration_composition' (I : CUBE) (chi psi phi : I -> TOPE) (X : chi -> U) (a : <{t : I | chi t /\\ psi t /\\ phi t} -> X t >) : Eq <{t : I | chi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]> (\u2211 (f : <{t : I | chi t /\\ psi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]>), <{t : I | chi t} -> X t [ chi t /\\ psi t |-> f t ]>) := (\\h -> (\\t -> h t, \\t -> h t), ((\\fg t -> (second fg) t, \\h -> refl), ((\\fg t -> (second fg) t, \\h -> refl)))) -- [RS17, Theorem 4.4] -- original form #def cofibration-composition (I : CUBE) (chi : I -> TOPE) (psi : chi -> TOPE) (phi : psi -> TOPE) (X : chi -> U) (a : (t : phi) -> X t) : Eq <{t : I | chi t} -> X t [ phi t |-> a t ]> (\u2211 (f : <{t : I | psi t} -> X t [ phi t |-> a t ]>), <{t : I | chi t} -> X t [ psi t |-> f t ]>) := (\\h -> (\\t -> h t, \\t -> h t), ((\\fg t -> (second fg) t, \\h -> refl), ((\\fg t -> (second fg) t, \\h -> refl)))) -- [RS17, Theorem 4.5] #def cofibration_union (I : CUBE) (phi psi : I -> TOPE) (X : <{t : I | phi t \\/ psi t} -> U >) (a : (t : psi) -> X t) : Eq <{t : I | phi t \\/ psi t} -> X t [ psi t |-> a t ]> <{t : I | phi t} -> X t [ phi t /\\ psi t |-> a t ]> := (\\h -> \\t -> h t, ((\\g -> \\t -> recOR(phi t |-> g t, psi t |-> a t), \\h -> refl), (\\g -> \\t -> recOR(phi t |-> g t, psi t |-> a t), \\h -> refl))) Relative function extensionality There are various equivalent forms of the relative function extensionality axiom. Here we state the one that will be most useful and derive an application. -- [RS17, Proposition 4.8(ii)] -- as suggested by footnote 8, we assert this as an \"extension extensionality\" axiom #def ExtExt : U := (I : CUBE) -> (psi : I -> TOPE) -> (phi : psi -> TOPE) -> (A : psi -> U) -> (a : (t : phi) -> A t) -> (f : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (g : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (_ : <{t : I | psi t} -> (f t = g t) [ phi t |-> refl ]>) -> (f = g) -- A fiberwise equivalence defines an equivalence of extension types, for simplicity extending from BOT #def fibered-equiv-extension-equiv (extext : ExtExt) (I : CUBE) (psi : I -> TOPE) (A B : psi -> U) (fibequiv : (t : psi) -> (Eq (A t) (B t)) ) : Eq (<{t : I | psi t } -> A t >) (<{t : I | psi t } -> B t >) := ((\\a t -> (first (fibequiv t)) (a t)), (((\\b t -> (first (first (second (fibequiv t)))) (b t)), \\a -> extext I psi (\\t -> BOT) A (\\u -> recBOT) (\\t -> (first (first (second (fibequiv t)))) ((first (fibequiv t)) (a t))) a (\\t -> (second (first (second (fibequiv t)))) (a t))), ((\\b t -> (first (second (second (fibequiv t)))) (b t)), (\\b -> extext I psi (\\t -> BOT) B (\\u -> recBOT) (\\t -> (first (fibequiv t)) ((first (second (second (fibequiv t)))) (b t))) b (\\t -> (second (second (second (fibequiv t)))) (b t))))))","title":"Extension Types"},{"location":"simplicial-hott/04-extension-types/#4-equivalences-involving-extension-types","text":"These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"4. Equivalences involving extension types"},{"location":"simplicial-hott/04-extension-types/#prerequisites","text":"hott/4-equivalences.rzk \u2014 contains the definitions of Eq and compose_Eq the file hott/4-equivalences.rzk relies in turn on the previous files in hott/","title":"Prerequisites"},{"location":"simplicial-hott/04-extension-types/#commutation-of-arguments-and-currying","text":"-- [RS17, Theorem 4.1] #def flip-ext-fun (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : U) (Y : psi -> X -> U) (f : (t : phi) -> (x : X) -> Y t x) : Eq (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) := (\\g x t -> g t x, -- the one-way map ((\\h t x -> (h x) t, -- the retraction \\g -> refl), -- the retracting homotopy (\\h t x -> (h x) t, -- the section \\h -> refl))) -- the section homotopy #def flip-ext-fun-inv (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : U) (Y : psi -> X -> U) (f : (t : phi) -> (x : X) -> Y t x) : Eq ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) := (\\h t x -> (h x) t, -- the one-way map ((\\g x t -> g t x, -- the retraction \\h -> refl), -- the retracting homotopy (\\g x t -> g t x, -- the section \\g -> refl))) -- [RS17, Theorem 4.2] #def curry-uncurry (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) := (\\g (t, s) -> (g t) s, -- the one way map ((\\h t s -> h (t , s) -- its retraction ,\\g -> refl), -- the retracting homotopy (\\h t s -> h (t , s) -- its section ,\\h -> refl))) -- the section homotopy #def uncurry-opcurry (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := (\\h s t -> h (t , s) , -- the one way map ((\\g (t, s) -> (g s) t -- its retraction ,\\h -> refl), -- the retracting homotopy (\\g (t, s) -> (g s) t -- its section ,\\g -> refl))) -- the section homotopy #def fubini (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := compose_Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) (curry-uncurry I J psi phi zeta chi X f) (uncurry-opcurry I J psi phi zeta chi X f)","title":"Commutation of arguments and currying"},{"location":"simplicial-hott/04-extension-types/#extending-into-types-the-non-axiom-of-choice","text":"-- [RS17, Theorem 4.3] #def axiom-choice (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : psi -> U) (Y : (t : psi) -> (x : X t) -> U) (a : (t : phi) -> X t) (b : (t : phi) -> Y t (a t)) : Eq (<{t : I | psi t} -> (\u2211 (x : X t), Y t x) [ phi t |-> (a t , b t) ]>) (\u2211 (f : (<{t : I | psi t} -> X t [phi t |-> a t ]>)), (<{t : I | psi t} -> Y t (f t) [ phi t |-> b t ]>)) := (\\g -> (\\t -> (first (g t)), \\t -> second (g t)) , -- the one way map ((\\h t -> ((first h) t, (second h) t) -- its retraction , \\g -> refl), -- the retracting homotopy (\\h t -> ((first h) t, (second h) t) -- its section , \\h -> refl))) -- the section homotopy","title":"Extending into \u2211-types (the non-axiom of choice)"},{"location":"simplicial-hott/04-extension-types/#composites-and-unions-of-cofibrations","text":"-- [RS17, Theorem 4.4] -- Reformulated via tope disjunction instead of inclusion. -- See https://github.com/fizruk/rzk/issues/8 #def cofibration_composition' (I : CUBE) (chi psi phi : I -> TOPE) (X : chi -> U) (a : <{t : I | chi t /\\ psi t /\\ phi t} -> X t >) : Eq <{t : I | chi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]> (\u2211 (f : <{t : I | chi t /\\ psi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]>), <{t : I | chi t} -> X t [ chi t /\\ psi t |-> f t ]>) := (\\h -> (\\t -> h t, \\t -> h t), ((\\fg t -> (second fg) t, \\h -> refl), ((\\fg t -> (second fg) t, \\h -> refl)))) -- [RS17, Theorem 4.4] -- original form #def cofibration-composition (I : CUBE) (chi : I -> TOPE) (psi : chi -> TOPE) (phi : psi -> TOPE) (X : chi -> U) (a : (t : phi) -> X t) : Eq <{t : I | chi t} -> X t [ phi t |-> a t ]> (\u2211 (f : <{t : I | psi t} -> X t [ phi t |-> a t ]>), <{t : I | chi t} -> X t [ psi t |-> f t ]>) := (\\h -> (\\t -> h t, \\t -> h t), ((\\fg t -> (second fg) t, \\h -> refl), ((\\fg t -> (second fg) t, \\h -> refl)))) -- [RS17, Theorem 4.5] #def cofibration_union (I : CUBE) (phi psi : I -> TOPE) (X : <{t : I | phi t \\/ psi t} -> U >) (a : (t : psi) -> X t) : Eq <{t : I | phi t \\/ psi t} -> X t [ psi t |-> a t ]> <{t : I | phi t} -> X t [ phi t /\\ psi t |-> a t ]> := (\\h -> \\t -> h t, ((\\g -> \\t -> recOR(phi t |-> g t, psi t |-> a t), \\h -> refl), (\\g -> \\t -> recOR(phi t |-> g t, psi t |-> a t), \\h -> refl)))","title":"Composites and unions of cofibrations"},{"location":"simplicial-hott/04-extension-types/#relative-function-extensionality","text":"There are various equivalent forms of the relative function extensionality axiom. Here we state the one that will be most useful and derive an application. -- [RS17, Proposition 4.8(ii)] -- as suggested by footnote 8, we assert this as an \"extension extensionality\" axiom #def ExtExt : U := (I : CUBE) -> (psi : I -> TOPE) -> (phi : psi -> TOPE) -> (A : psi -> U) -> (a : (t : phi) -> A t) -> (f : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (g : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (_ : <{t : I | psi t} -> (f t = g t) [ phi t |-> refl ]>) -> (f = g) -- A fiberwise equivalence defines an equivalence of extension types, for simplicity extending from BOT #def fibered-equiv-extension-equiv (extext : ExtExt) (I : CUBE) (psi : I -> TOPE) (A B : psi -> U) (fibequiv : (t : psi) -> (Eq (A t) (B t)) ) : Eq (<{t : I | psi t } -> A t >) (<{t : I | psi t } -> B t >) := ((\\a t -> (first (fibequiv t)) (a t)), (((\\b t -> (first (first (second (fibequiv t)))) (b t)), \\a -> extext I psi (\\t -> BOT) A (\\u -> recBOT) (\\t -> (first (first (second (fibequiv t)))) ((first (fibequiv t)) (a t))) a (\\t -> (second (first (second (fibequiv t)))) (a t))), ((\\b t -> (first (second (second (fibequiv t)))) (b t)), (\\b -> extext I psi (\\t -> BOT) B (\\u -> recBOT) (\\t -> (first (fibequiv t)) ((first (second (second (fibequiv t)))) (b t))) b (\\t -> (second (second (second (fibequiv t)))) (b t))))))","title":"Relative function extensionality"},{"location":"simplicial-hott/05-segal-types/","text":"Segal Types These formalisations correspond to Section 5 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/1-paths.md - We require basic path algebra. hott/2-contractible.md - We require the notion of contractible types and their data. hott/total-space.md \u2014 We rely on contractible-fibers-projection-equiv and total-space-projection in the proof of Theorem 5.5. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. Hom types Extension types are used \u2202to define the type of arrows between fixed terms: x y -- [RS17, Definition 5.1] -- The type of arrows in A from x to y. #def hom (A : U) -- A type. (x y : A) -- Two points in A. : U -- (hom A x y) is a 1-simplex (an arrow) := (t : \u0394\u00b9) -> A [ -- in A where t === 0_2 |-> x, -- * the left endpoint is exactly x t === 1_2 |-> y -- * the right endpoint is exactly y ] Extension types are also used to define the type of commutative triangles: x y z f g h -- [RS17, Definition 5.2] -- the type of commutative triangles in A #def hom2 (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. : U -- (hom2 A x y z f g h) is a 2-simplex (triangle) := { (t1, t2) : \u0394\u00b2 } -> A [ -- in A where t2 === 0_2 |-> f t1, -- * the top edge is exactly f, t1 === 1_2 |-> g t2, -- * the right edge is exactly g, and t2 === t1 |-> h t2 -- * the diagonal is exactly h ] The Segal condition A type is Segal if every composable pair of arrows has a unique composite. Note this is a considerable simplification of the usual Segal condition, which also requires homotopical uniqueness of higher-order composites. -- [RS17, Definition 5.3] #def isSegal (A : U) -- A type. : U := (x : A) -> (y : A) -> (z : A) -> (f : hom A x y) -> (g : hom A y z) -> isContr( \u2211 (h : hom A x z), hom2 A x y z f g h) Segal types have a composition functor and witnesses to the composition relation: -- Composition is written in diagrammatic order to match the order of arguments in isSegal. #def Segal-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom A x z := first (first (AisSegal x y z f g)) -- Segal types have composition witnesses #def Segal-comp-witness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom2 A x y z f g (Segal-comp A AisSegal x y z f g) := second (first (AisSegal x y z f g)) Composition in a Segal type is unique in the following sense. If there is a witness that an arrow h is a composite of f and g, then the specified composite equals h. x y z f g h \u03b1 = x y z f g Segal-comp Segal-comp-witness #def Segal-comp-uniqueness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. (alpha : hom2 A x y z f g h) -- A witness that h is a composite of f and g. : (Segal-comp A AisSegal x y z f g) = h := total-path-to-base-path (hom A x z) (\\k -> hom2 A x y z f g k) (Segal-comp A AisSegal x y z f g, Segal-comp-witness A AisSegal x y z f g) (h, alpha) (contracting-htpy (\u2211 (k : hom A x z), hom2 A x y z f g k) (AisSegal x y z f g) (h, alpha)) Characterizing Segal types Our aim is to prove that a type is Segal if and only if the horn-restriction map, defined below, is an equivalence. x y z f g -- A pair of composable arrows form a horn. #def horn (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u039b -> A := \\(t, s) -> recOR( s === 0_2 |-> f t, t === 1_2 |-> g s ) -- The underlying horn of a simplex #def horn-restriction (A : U) : (\u0394\u00b2 -> A) -> (\u039b -> A) := \\f t -> f t -- An alternate definition of Segal types. #def isSegal' (A : U) : U := isEquiv (\u0394\u00b2 -> A) (\u039b -> A) (horn-restriction A) Now we prove this definition is equivalent to the original one. -- Here, we prove the equivalence used in [RS17, Theorem 5.5]. -- However, we do this by constructing the equivalence directly, -- instead of using a composition of equivalences, as it is easier to write down -- and it computes better (we can use refl for the witnesses of the equivalence). #def compositions-are-horn-fillings (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : Eq (\u2211 (h : hom A x z), hom2 A x y z f g h) <{t : 2 * 2 | \u0394\u00b2 t } -> A [ \u039b t |-> horn A x y z f g t ]> := (\\hh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second hh) t, ((\\k -> (\\(t : 2) -> k (t, t), \\(t, s) -> k (t, s)), \\hh -> refl), (\\k -> (\\(t : 2) -> k (t, t), \\(t, s) -> k (t, s)), \\hh -> refl))) #def restriction-equiv (A : U) -- A type. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) := (\\k -> (\\{t : 2 * 2 | \u039b t} -> k t, (\\(t : 2) -> k (t, t), \\{t : 2 * 2 | \u0394\u00b2 t} -> k t)), ((\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}), (\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}))) -- [RS17, Theorem 5.5], the hard direction: #def Segal-restriction-equiv (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) -- (horn-restriction A) := compose_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u039b t} -> A >) (restriction-equiv A) (total-space-projection (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h), (contractible-fibers-projection-equiv (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (\\k -> AisSegal (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t))))) -- Verify that the mapping in (Segal-restriction-equiv A AisSegal) -- is exactly (horn-restriction A) #def Segal-restriction-equiv-test (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : (first (Segal-restriction-equiv A AisSegal)) = (horn-restriction A) := refl -- Segal types are Segal' types. #def isSegal-isSegal' (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal' A := second (Segal-restriction-equiv A AisSegal) -- Segal' types are Segal types. #def isSegal'-isSegal (A : U) -- A type. (AisSegal' : isSegal' A) -- A proof that A is Segal'. : isSegal A := \\x y z f g -> (projection-equiv-contractible-fibers (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (second (compose_Eq (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) (sym_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (restriction-equiv A)) (horn-restriction A, AisSegal') ))) (horn A x y z f g) -- [RS17, Theorem 5.5] proves that both notions of Segal types are logically equivalent. #def isSegal-iff-isSegal' (A : U) -- A type. : iff (isSegal A) (isSegal' A) := (isSegal-isSegal' A , isSegal'-isSegal A) Segal function and extension types Using the new characterization of Segal types, we can show that the type of functions or extensions into a family of Segal types is again a Segal type. -- [RS17, Corollary 5.6(i)] : if X is a type and A : X -> U is such that -- A(x) is a Segal type for all x then (x : X) -> A x is a Segal type #def Segal-function-types (funext : FunExt) -- This proof uses function extensionality. (X : U) -- A type. (A : (_ : X) -> U) -- A type family (fiberwiseAisSegal : (x : X) -> isSegal' (A x)) -- An assumption that the fibers are Segal types. : isSegal' ((x : X) -> A x) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> ((x : X) -> A x) >) ((x : X) -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) ((x : X) -> <{t : 2 * 2 | \u039b t} -> A x >) (<{t : 2 * 2 | \u039b t} -> ((x : X) -> A x) >) (\\g -> \\x -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t x) -- first equivalence (second (flip-ext-fun (2 * 2) \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) X (\\{t : 2 * 2 | \u0394\u00b2 t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) (\\h -> \\x -> \\{t : 2 * 2 | \u039b t} -> h x t) -- second equivalence (second (fibered-equiv-function-equiv funext X (\\x -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) (\\x -> <{t : 2 * 2 | \u039b t} -> A x >) (\\x -> (horn-restriction (A x) , fiberwiseAisSegal x)))) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\x -> (h x) t) -- third equivalence (second(flip-ext-fun-inv (2 * 2) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) X (\\{t : 2 * 2 | \u039b t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) -- [RS17, Corollary 5.6(ii)] : if X is a shape and A : X -> U is such that -- A(x) is a Segal type for all x then (x : X) -> A x is a Segal type #def Segal-extension-types (extext : ExtExt) -- This proof uses extension extensionality. (I : CUBE) -- A cube. (psi : (s : I) -> TOPE) -- A tope. (A : <{s : I | psi s} -> U >) -- An extension type. (fiberwiseAisSegal : <{s : I | psi s} -> isSegal' (A s) >) -- An assumption that the fibers are Segal types. : isSegal' (<{s : I | psi s} -> A s >) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> <{s : I | psi s} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s > >) (<{t : 2 * 2 | \u039b t} -> <{s : I | psi s} -> A s > >) (\\g -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t s) -- first equivalence (second(fubini (2 * 2) I \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) psi (\\{s : I | psi s} -> BOT) (\\{t : 2 * 2 | \u0394\u00b2 t} -> \\{s : I | psi s} -> A s) (\\{u : (2 * 2) * I | BOT} -> recBOT))) (\\h -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> h s t) -- second equivalence (second (fibered-equiv-extension-equiv extext I psi (\\{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s >) (\\{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s >) (\\{s : I | psi s} -> (horn-restriction (A s), fiberwiseAisSegal s)) )) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\{s : I | psi s} -> (h s) t) -- third equivalence (second(fubini I (2 * 2) psi (\\{s : I | psi s} -> BOT) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) (\\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> A s) (\\{u : I * (2 * 2) | BOT} -> recBOT))) In particular, the arrow type of a Segal type is Segal. -- The type of arrows in a type. #def arr -- A type (A : U) : U := (t : \u0394\u00b9) -> A -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal'. #def Segal'-arrow-types (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal' A) -- A proof that A isSegal'. : isSegal' (arr A) := Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> AisSegal) -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal. #def Segal-arrow-types (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal (arr A) := isSegal'-isSegal (arr A) (Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> (isSegal-isSegal' A AisSegal))) Identity All types have identity arrows and witnesses to the identity composition law. x x x -- [RS17, Definition 5.7] -- all types have identity arrows #def id-arr (A : U) -- A type. (x : A) -- A point in A. : hom A x x := \\{t : 2 | \u0394\u00b9 t} -> x Witness for the right identity law: x y y f y f f -- [RS17, Proposition 5.8a] -- the right unit law for identity #def comp-id-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x y y f (id-arr A y) f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f t Witness for the left identity law: x x y x f f f -- [RS17, Proposition 5.8b] -- the left unit law for identity #def id-comp-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x x y (id-arr A x) f f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f s In a Segal type, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. Thus, an identity axiom was not needed in the definition of Segal types. -- If A is Segal then the right unit law holds #def Segal-comp-id (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x y y f (id-arr A y)) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x y y f (id-arr A y) f (comp-id-witness A x y f) -- If A is Segal then the left unit law holds #def Segal-id-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x x y (id-arr A x) f) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x x y (id-arr A x) f f (id-comp-witness A x y f) Associativity We now prove that composition in a Segal type is associative, by using the fact that the type of arrows in a Segal type is itself a Segal type. \u2022 \u2022 \u2022 \u2022 #def unfolding-square (A : U) -- A type. (triangle : \u0394\u00b2 -> A) -- A triangle in A. : \u0394\u00b9\u00d7\u0394\u00b9 -> A -- A square in A, defined by gluing := \\(t, s) -> -- two copies of the triangle along the common diagonal edge. recOR(t <= s |-> triangle (s , t), s <= t |-> triangle (t , s)) For use in the proof of associativity: x y z y f g Segal-comp g f #def Segal-comp-witness-square (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u0394\u00b9\u00d7\u0394\u00b9 -> A := unfolding-square A (Segal-comp-witness A AisSegal x y z f g) The Segal-comp-witness-square as an arrow in the arrow type: x y z y f g #def Segal-arr-in-arr (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom (arr A) f g := \\t -> \\s -> (Segal-comp-witness-square A AisSegal x y z f g) (t, s) w x x y y z f g h #def Segal-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 (arr A) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h) (Segal-comp (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) := (Segal-comp-witness (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) w x y z g f h -- The Segal-associativity-witness curries to define a diagram \u0394\u00b2\u00d7\u0394\u00b9 -> A. -- The Segal-associativity-tetrahedron is extracted via the middle-simplex map \\((t, s), r) -> ((t, r), s) from \u0394\u00b3 to \u0394\u00b2\u00d7\u0394\u00b9 #def Segal-associativity-tetrahedron (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : \u0394\u00b3 -> A := \\((t, s), r) -> (Segal-associativity-witness extext A AisSegal w x y z f g h) (t, r) s w x y z g f h -- the diagonal composite of three arrows extracted from the Segal-associativity-tetrahedron #def Segal-triple-composite (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom A w z := \\t -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), t) w x y z g f h #def Segal-left-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), s) The front face: w x y z g f h #def Segal-right-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, s), s) #def Segal-left-associativity (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-left-associativity-witness extext A AisSegal w x y z f g h) #def Segal-right-associativity (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-right-associativity-witness extext A AisSegal w x y z f g h) #def Segal-associativity (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) := zig-zag-concat (hom A w z) (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) (Segal-left-associativity extext A AisSegal w x y z f g h) (Segal-right-associativity extext A AisSegal w x y z f g h) Homotopies We may define a \"homotopy\" to be a path between parallel arrows. In a Segal type, homotopies are equivalent to terms in hom2 types involving an identity arrow. #def homotopy-to-hom2 (A : U) (x y : A) (f g : hom A x y) (p : f = g) : (hom2 A x x y (id-arr A x) f g) := idJ(hom A x y, f, \\g' p' -> (hom2 A x x y (id-arr A x) f g'), (id-comp-witness A x y f), g, p) #def homotopy-to-hom2-total-map (A : U) (x y : A) (f : hom A x y) : (\u2211 (g : hom A x y), f = g) -> (\u2211 (g : hom A x y), (hom2 A x x y (id-arr A x) f g)) := \\(g, p) -> (g, homotopy-to-hom2 A x y f g p) #def Segal-homotopy-to-hom2-total-map-isEquiv (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) : isEquiv (\u2211 (g : hom A x y), f = g) (\u2211 (g : hom A x y), (hom2 A x x y (id-arr A x) f g)) (homotopy-to-hom2-total-map A x y f) := areContr-isEquiv (\u2211 (g : hom A x y), f = g) (\u2211 (g : hom A x y), (hom2 A x x y (id-arr A x) f g)) (based-paths-contractible (hom A x y) f) (AisSegal x x y (id-arr A x) f) (homotopy-to-hom2-total-map A x y f) -- [RS17, Proposition 5.10] #def Eq-Segal-homotopy-hom2 (A : U) (AisSegal : isSegal A) (x y : A) (f g : hom A x y) : Eq (f = g) (hom2 A x x y (id-arr A x) f g) := (homotopy-to-hom2 A x y f g, total-equiv-family-of-equiv (hom A x y) (\\g -> (f = g)) (\\g -> (hom2 A x x y (id-arr A x) f g)) (homotopy-to-hom2 A x y f) (Segal-homotopy-to-hom2-total-map-isEquiv A AisSegal x y f) g) More generally, a homotopy between a composite and another map is equivalent to the data provided by a commutative triangle with that boundary. #def Segal-eq-to-hom2 (A : U) (AisSegal : isSegal A) (x y z : A) (f : hom A x y) (g : hom A y z) (h : hom A x z) (p : (Segal-comp A AisSegal x y z f g) = h) : (hom2 A x y z f g h) := idJ(hom A x z, (Segal-comp A AisSegal x y z f g), \\h' p' -> (hom2 A x y z f g h'), Segal-comp-witness A AisSegal x y z f g, h, p) #def Segal-eq-to-hom2-total-map (A : U) (AisSegal : isSegal A) (x y z : A) (f : hom A x y) (g : hom A y z) : (\u2211 (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) -> (\u2211 (h : hom A x z), (hom2 A x y z f g h)) := \\(h, p) -> (h, Segal-eq-to-hom2 A AisSegal x y z f g h p) #def Segal-eq-to-hom2-total-map-isEquiv (A : U) (AisSegal : isSegal A) (x y z : A) (f : hom A x y) (g : hom A y z) : isEquiv (\u2211 (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) (\u2211 (h : hom A x z), (hom2 A x y z f g h)) (Segal-eq-to-hom2-total-map A AisSegal x y z f g) := areContr-isEquiv (\u2211 (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) (\u2211 (h : hom A x z), (hom2 A x y z f g h)) (based-paths-contractible (hom A x z) (Segal-comp A AisSegal x y z f g) ) (AisSegal x y z f g) (Segal-eq-to-hom2-total-map A AisSegal x y z f g) -- [RS17, Proposition 5.12] #def Eq-Segal-eq-hom2 (A : U) (AisSegal : isSegal A) (x y z : A) (f : hom A x y) (g : hom A y z) (h : hom A x z) : Eq ((Segal-comp A AisSegal x y z f g) = h) (hom2 A x y z f g h) := (Segal-eq-to-hom2 A AisSegal x y z f g h, total-equiv-family-of-equiv (hom A x z) (\\h -> (Segal-comp A AisSegal x y z f g) = h) (\\h -> hom2 A x y z f g h) (Segal-eq-to-hom2 A AisSegal x y z f g) (Segal-eq-to-hom2-total-map-isEquiv A AisSegal x y z f g) h) Homotopies form a congruence, meaning that homotopies are respected by composition: -- [RS17, Proposition 5.13] #def Segal-homotopy-congruence (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) (f g : hom A x y) (h k : hom A y z) (p : f = g) (q : h = k) : (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g k) := idJ(hom A y z, h, \\k' q' -> (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g k'), idJ(hom A x y, f, \\g' p' -> (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g' h), refl, g, p) , k, q) -- As a special case of the above: #def Segal-homotopy-postwhisker (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) (f g : hom A x y) (h : hom A y z) (p : f = g) : (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g h) := Segal-homotopy-congruence A AisSegal x y z f g h h p refl -- As a special case of the above: #def Segal-homotopy-prewhisker (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y : A) (k : hom A w x) (f g : hom A x y) (p : f = g) : (Segal-comp A AisSegal w x y k f) = (Segal-comp A AisSegal w x y k g) := Segal-homotopy-congruence A AisSegal w x y k k f g refl p -- [RS17, Proposition 5.14(a)] #def Segal-homotopy-postwhisker-is-ap (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) (f g : hom A x y) (h : hom A y z) (p : f = g) : (Segal-homotopy-postwhisker A AisSegal x y z f g h p) = ap (hom A x y) (hom A x z) f g (\\k -> Segal-comp A AisSegal x y z k h) p := idJ(hom A x y, f, \\g' p' -> (Segal-homotopy-postwhisker A AisSegal x y z f g' h p') = ap (hom A x y) (hom A x z) f g' (\\k -> Segal-comp A AisSegal x y z k h) p', refl, g, p) -- [RS17, Proposition 5.14(b)] #def Segal-homotopy-prewhisker-is-ap (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y : A) (k : hom A w x) (f g : hom A x y) (p : f = g) : (Segal-homotopy-prewhisker A AisSegal w x y k f g p) = ap (hom A x y) (hom A w y) f g (Segal-comp A AisSegal w x y k) p := idJ(hom A x y, f, \\g' p' -> (Segal-homotopy-prewhisker A AisSegal w x y k f g' p') = ap (hom A x y) (hom A w y) f g' (Segal-comp A AisSegal w x y k) p', refl, g, p) @import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap); text, textPath { font-family: Noto Serif; font-size: 20px; dominant-baseline: middle; text-anchor: middle; }","title":"Segal Types"},{"location":"simplicial-hott/05-segal-types/#segal-types","text":"These formalisations correspond to Section 5 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Segal Types"},{"location":"simplicial-hott/05-segal-types/#prerequisites","text":"hott/1-paths.md - We require basic path algebra. hott/2-contractible.md - We require the notion of contractible types and their data. hott/total-space.md \u2014 We rely on contractible-fibers-projection-equiv and total-space-projection in the proof of Theorem 5.5. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality.","title":"Prerequisites"},{"location":"simplicial-hott/05-segal-types/#hom-types","text":"Extension types are used \u2202to define the type of arrows between fixed terms: x y -- [RS17, Definition 5.1] -- The type of arrows in A from x to y. #def hom (A : U) -- A type. (x y : A) -- Two points in A. : U -- (hom A x y) is a 1-simplex (an arrow) := (t : \u0394\u00b9) -> A [ -- in A where t === 0_2 |-> x, -- * the left endpoint is exactly x t === 1_2 |-> y -- * the right endpoint is exactly y ] Extension types are also used to define the type of commutative triangles: x y z f g h -- [RS17, Definition 5.2] -- the type of commutative triangles in A #def hom2 (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. : U -- (hom2 A x y z f g h) is a 2-simplex (triangle) := { (t1, t2) : \u0394\u00b2 } -> A [ -- in A where t2 === 0_2 |-> f t1, -- * the top edge is exactly f, t1 === 1_2 |-> g t2, -- * the right edge is exactly g, and t2 === t1 |-> h t2 -- * the diagonal is exactly h ]","title":"Hom types"},{"location":"simplicial-hott/05-segal-types/#the-segal-condition","text":"A type is Segal if every composable pair of arrows has a unique composite. Note this is a considerable simplification of the usual Segal condition, which also requires homotopical uniqueness of higher-order composites. -- [RS17, Definition 5.3] #def isSegal (A : U) -- A type. : U := (x : A) -> (y : A) -> (z : A) -> (f : hom A x y) -> (g : hom A y z) -> isContr( \u2211 (h : hom A x z), hom2 A x y z f g h) Segal types have a composition functor and witnesses to the composition relation: -- Composition is written in diagrammatic order to match the order of arguments in isSegal. #def Segal-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom A x z := first (first (AisSegal x y z f g)) -- Segal types have composition witnesses #def Segal-comp-witness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom2 A x y z f g (Segal-comp A AisSegal x y z f g) := second (first (AisSegal x y z f g)) Composition in a Segal type is unique in the following sense. If there is a witness that an arrow h is a composite of f and g, then the specified composite equals h. x y z f g h \u03b1 = x y z f g Segal-comp Segal-comp-witness #def Segal-comp-uniqueness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. (alpha : hom2 A x y z f g h) -- A witness that h is a composite of f and g. : (Segal-comp A AisSegal x y z f g) = h := total-path-to-base-path (hom A x z) (\\k -> hom2 A x y z f g k) (Segal-comp A AisSegal x y z f g, Segal-comp-witness A AisSegal x y z f g) (h, alpha) (contracting-htpy (\u2211 (k : hom A x z), hom2 A x y z f g k) (AisSegal x y z f g) (h, alpha))","title":"The Segal condition"},{"location":"simplicial-hott/05-segal-types/#characterizing-segal-types","text":"Our aim is to prove that a type is Segal if and only if the horn-restriction map, defined below, is an equivalence. x y z f g -- A pair of composable arrows form a horn. #def horn (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u039b -> A := \\(t, s) -> recOR( s === 0_2 |-> f t, t === 1_2 |-> g s ) -- The underlying horn of a simplex #def horn-restriction (A : U) : (\u0394\u00b2 -> A) -> (\u039b -> A) := \\f t -> f t -- An alternate definition of Segal types. #def isSegal' (A : U) : U := isEquiv (\u0394\u00b2 -> A) (\u039b -> A) (horn-restriction A) Now we prove this definition is equivalent to the original one. -- Here, we prove the equivalence used in [RS17, Theorem 5.5]. -- However, we do this by constructing the equivalence directly, -- instead of using a composition of equivalences, as it is easier to write down -- and it computes better (we can use refl for the witnesses of the equivalence). #def compositions-are-horn-fillings (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : Eq (\u2211 (h : hom A x z), hom2 A x y z f g h) <{t : 2 * 2 | \u0394\u00b2 t } -> A [ \u039b t |-> horn A x y z f g t ]> := (\\hh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second hh) t, ((\\k -> (\\(t : 2) -> k (t, t), \\(t, s) -> k (t, s)), \\hh -> refl), (\\k -> (\\(t : 2) -> k (t, t), \\(t, s) -> k (t, s)), \\hh -> refl))) #def restriction-equiv (A : U) -- A type. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) := (\\k -> (\\{t : 2 * 2 | \u039b t} -> k t, (\\(t : 2) -> k (t, t), \\{t : 2 * 2 | \u0394\u00b2 t} -> k t)), ((\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}), (\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}))) -- [RS17, Theorem 5.5], the hard direction: #def Segal-restriction-equiv (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) -- (horn-restriction A) := compose_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u039b t} -> A >) (restriction-equiv A) (total-space-projection (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h), (contractible-fibers-projection-equiv (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (\\k -> AisSegal (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t))))) -- Verify that the mapping in (Segal-restriction-equiv A AisSegal) -- is exactly (horn-restriction A) #def Segal-restriction-equiv-test (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : (first (Segal-restriction-equiv A AisSegal)) = (horn-restriction A) := refl -- Segal types are Segal' types. #def isSegal-isSegal' (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal' A := second (Segal-restriction-equiv A AisSegal) -- Segal' types are Segal types. #def isSegal'-isSegal (A : U) -- A type. (AisSegal' : isSegal' A) -- A proof that A is Segal'. : isSegal A := \\x y z f g -> (projection-equiv-contractible-fibers (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (second (compose_Eq (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) (sym_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (restriction-equiv A)) (horn-restriction A, AisSegal') ))) (horn A x y z f g) -- [RS17, Theorem 5.5] proves that both notions of Segal types are logically equivalent. #def isSegal-iff-isSegal' (A : U) -- A type. : iff (isSegal A) (isSegal' A) := (isSegal-isSegal' A , isSegal'-isSegal A)","title":"Characterizing Segal types"},{"location":"simplicial-hott/05-segal-types/#segal-function-and-extension-types","text":"Using the new characterization of Segal types, we can show that the type of functions or extensions into a family of Segal types is again a Segal type. -- [RS17, Corollary 5.6(i)] : if X is a type and A : X -> U is such that -- A(x) is a Segal type for all x then (x : X) -> A x is a Segal type #def Segal-function-types (funext : FunExt) -- This proof uses function extensionality. (X : U) -- A type. (A : (_ : X) -> U) -- A type family (fiberwiseAisSegal : (x : X) -> isSegal' (A x)) -- An assumption that the fibers are Segal types. : isSegal' ((x : X) -> A x) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> ((x : X) -> A x) >) ((x : X) -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) ((x : X) -> <{t : 2 * 2 | \u039b t} -> A x >) (<{t : 2 * 2 | \u039b t} -> ((x : X) -> A x) >) (\\g -> \\x -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t x) -- first equivalence (second (flip-ext-fun (2 * 2) \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) X (\\{t : 2 * 2 | \u0394\u00b2 t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) (\\h -> \\x -> \\{t : 2 * 2 | \u039b t} -> h x t) -- second equivalence (second (fibered-equiv-function-equiv funext X (\\x -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) (\\x -> <{t : 2 * 2 | \u039b t} -> A x >) (\\x -> (horn-restriction (A x) , fiberwiseAisSegal x)))) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\x -> (h x) t) -- third equivalence (second(flip-ext-fun-inv (2 * 2) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) X (\\{t : 2 * 2 | \u039b t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) -- [RS17, Corollary 5.6(ii)] : if X is a shape and A : X -> U is such that -- A(x) is a Segal type for all x then (x : X) -> A x is a Segal type #def Segal-extension-types (extext : ExtExt) -- This proof uses extension extensionality. (I : CUBE) -- A cube. (psi : (s : I) -> TOPE) -- A tope. (A : <{s : I | psi s} -> U >) -- An extension type. (fiberwiseAisSegal : <{s : I | psi s} -> isSegal' (A s) >) -- An assumption that the fibers are Segal types. : isSegal' (<{s : I | psi s} -> A s >) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> <{s : I | psi s} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s > >) (<{t : 2 * 2 | \u039b t} -> <{s : I | psi s} -> A s > >) (\\g -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t s) -- first equivalence (second(fubini (2 * 2) I \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) psi (\\{s : I | psi s} -> BOT) (\\{t : 2 * 2 | \u0394\u00b2 t} -> \\{s : I | psi s} -> A s) (\\{u : (2 * 2) * I | BOT} -> recBOT))) (\\h -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> h s t) -- second equivalence (second (fibered-equiv-extension-equiv extext I psi (\\{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s >) (\\{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s >) (\\{s : I | psi s} -> (horn-restriction (A s), fiberwiseAisSegal s)) )) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\{s : I | psi s} -> (h s) t) -- third equivalence (second(fubini I (2 * 2) psi (\\{s : I | psi s} -> BOT) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) (\\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> A s) (\\{u : I * (2 * 2) | BOT} -> recBOT))) In particular, the arrow type of a Segal type is Segal. -- The type of arrows in a type. #def arr -- A type (A : U) : U := (t : \u0394\u00b9) -> A -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal'. #def Segal'-arrow-types (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal' A) -- A proof that A isSegal'. : isSegal' (arr A) := Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> AisSegal) -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal. #def Segal-arrow-types (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal (arr A) := isSegal'-isSegal (arr A) (Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> (isSegal-isSegal' A AisSegal)))","title":"Segal function and extension types"},{"location":"simplicial-hott/05-segal-types/#identity","text":"All types have identity arrows and witnesses to the identity composition law. x x x -- [RS17, Definition 5.7] -- all types have identity arrows #def id-arr (A : U) -- A type. (x : A) -- A point in A. : hom A x x := \\{t : 2 | \u0394\u00b9 t} -> x Witness for the right identity law: x y y f y f f -- [RS17, Proposition 5.8a] -- the right unit law for identity #def comp-id-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x y y f (id-arr A y) f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f t Witness for the left identity law: x x y x f f f -- [RS17, Proposition 5.8b] -- the left unit law for identity #def id-comp-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x x y (id-arr A x) f f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f s In a Segal type, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. Thus, an identity axiom was not needed in the definition of Segal types. -- If A is Segal then the right unit law holds #def Segal-comp-id (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x y y f (id-arr A y)) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x y y f (id-arr A y) f (comp-id-witness A x y f) -- If A is Segal then the left unit law holds #def Segal-id-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x x y (id-arr A x) f) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x x y (id-arr A x) f f (id-comp-witness A x y f)","title":"Identity"},{"location":"simplicial-hott/05-segal-types/#associativity","text":"We now prove that composition in a Segal type is associative, by using the fact that the type of arrows in a Segal type is itself a Segal type. \u2022 \u2022 \u2022 \u2022 #def unfolding-square (A : U) -- A type. (triangle : \u0394\u00b2 -> A) -- A triangle in A. : \u0394\u00b9\u00d7\u0394\u00b9 -> A -- A square in A, defined by gluing := \\(t, s) -> -- two copies of the triangle along the common diagonal edge. recOR(t <= s |-> triangle (s , t), s <= t |-> triangle (t , s)) For use in the proof of associativity: x y z y f g Segal-comp g f #def Segal-comp-witness-square (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u0394\u00b9\u00d7\u0394\u00b9 -> A := unfolding-square A (Segal-comp-witness A AisSegal x y z f g) The Segal-comp-witness-square as an arrow in the arrow type: x y z y f g #def Segal-arr-in-arr (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom (arr A) f g := \\t -> \\s -> (Segal-comp-witness-square A AisSegal x y z f g) (t, s) w x x y y z f g h #def Segal-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 (arr A) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h) (Segal-comp (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) := (Segal-comp-witness (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) w x y z g f h -- The Segal-associativity-witness curries to define a diagram \u0394\u00b2\u00d7\u0394\u00b9 -> A. -- The Segal-associativity-tetrahedron is extracted via the middle-simplex map \\((t, s), r) -> ((t, r), s) from \u0394\u00b3 to \u0394\u00b2\u00d7\u0394\u00b9 #def Segal-associativity-tetrahedron (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : \u0394\u00b3 -> A := \\((t, s), r) -> (Segal-associativity-witness extext A AisSegal w x y z f g h) (t, r) s w x y z g f h -- the diagonal composite of three arrows extracted from the Segal-associativity-tetrahedron #def Segal-triple-composite (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom A w z := \\t -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), t) w x y z g f h #def Segal-left-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), s) The front face: w x y z g f h #def Segal-right-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, s), s) #def Segal-left-associativity (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-left-associativity-witness extext A AisSegal w x y z f g h) #def Segal-right-associativity (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-right-associativity-witness extext A AisSegal w x y z f g h) #def Segal-associativity (extext : ExtExt) -- This proof uses extension extensionality. (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) := zig-zag-concat (hom A w z) (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) (Segal-left-associativity extext A AisSegal w x y z f g h) (Segal-right-associativity extext A AisSegal w x y z f g h)","title":"Associativity"},{"location":"simplicial-hott/05-segal-types/#homotopies","text":"We may define a \"homotopy\" to be a path between parallel arrows. In a Segal type, homotopies are equivalent to terms in hom2 types involving an identity arrow. #def homotopy-to-hom2 (A : U) (x y : A) (f g : hom A x y) (p : f = g) : (hom2 A x x y (id-arr A x) f g) := idJ(hom A x y, f, \\g' p' -> (hom2 A x x y (id-arr A x) f g'), (id-comp-witness A x y f), g, p) #def homotopy-to-hom2-total-map (A : U) (x y : A) (f : hom A x y) : (\u2211 (g : hom A x y), f = g) -> (\u2211 (g : hom A x y), (hom2 A x x y (id-arr A x) f g)) := \\(g, p) -> (g, homotopy-to-hom2 A x y f g p) #def Segal-homotopy-to-hom2-total-map-isEquiv (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) : isEquiv (\u2211 (g : hom A x y), f = g) (\u2211 (g : hom A x y), (hom2 A x x y (id-arr A x) f g)) (homotopy-to-hom2-total-map A x y f) := areContr-isEquiv (\u2211 (g : hom A x y), f = g) (\u2211 (g : hom A x y), (hom2 A x x y (id-arr A x) f g)) (based-paths-contractible (hom A x y) f) (AisSegal x x y (id-arr A x) f) (homotopy-to-hom2-total-map A x y f) -- [RS17, Proposition 5.10] #def Eq-Segal-homotopy-hom2 (A : U) (AisSegal : isSegal A) (x y : A) (f g : hom A x y) : Eq (f = g) (hom2 A x x y (id-arr A x) f g) := (homotopy-to-hom2 A x y f g, total-equiv-family-of-equiv (hom A x y) (\\g -> (f = g)) (\\g -> (hom2 A x x y (id-arr A x) f g)) (homotopy-to-hom2 A x y f) (Segal-homotopy-to-hom2-total-map-isEquiv A AisSegal x y f) g) More generally, a homotopy between a composite and another map is equivalent to the data provided by a commutative triangle with that boundary. #def Segal-eq-to-hom2 (A : U) (AisSegal : isSegal A) (x y z : A) (f : hom A x y) (g : hom A y z) (h : hom A x z) (p : (Segal-comp A AisSegal x y z f g) = h) : (hom2 A x y z f g h) := idJ(hom A x z, (Segal-comp A AisSegal x y z f g), \\h' p' -> (hom2 A x y z f g h'), Segal-comp-witness A AisSegal x y z f g, h, p) #def Segal-eq-to-hom2-total-map (A : U) (AisSegal : isSegal A) (x y z : A) (f : hom A x y) (g : hom A y z) : (\u2211 (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) -> (\u2211 (h : hom A x z), (hom2 A x y z f g h)) := \\(h, p) -> (h, Segal-eq-to-hom2 A AisSegal x y z f g h p) #def Segal-eq-to-hom2-total-map-isEquiv (A : U) (AisSegal : isSegal A) (x y z : A) (f : hom A x y) (g : hom A y z) : isEquiv (\u2211 (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) (\u2211 (h : hom A x z), (hom2 A x y z f g h)) (Segal-eq-to-hom2-total-map A AisSegal x y z f g) := areContr-isEquiv (\u2211 (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) (\u2211 (h : hom A x z), (hom2 A x y z f g h)) (based-paths-contractible (hom A x z) (Segal-comp A AisSegal x y z f g) ) (AisSegal x y z f g) (Segal-eq-to-hom2-total-map A AisSegal x y z f g) -- [RS17, Proposition 5.12] #def Eq-Segal-eq-hom2 (A : U) (AisSegal : isSegal A) (x y z : A) (f : hom A x y) (g : hom A y z) (h : hom A x z) : Eq ((Segal-comp A AisSegal x y z f g) = h) (hom2 A x y z f g h) := (Segal-eq-to-hom2 A AisSegal x y z f g h, total-equiv-family-of-equiv (hom A x z) (\\h -> (Segal-comp A AisSegal x y z f g) = h) (\\h -> hom2 A x y z f g h) (Segal-eq-to-hom2 A AisSegal x y z f g) (Segal-eq-to-hom2-total-map-isEquiv A AisSegal x y z f g) h) Homotopies form a congruence, meaning that homotopies are respected by composition: -- [RS17, Proposition 5.13] #def Segal-homotopy-congruence (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) (f g : hom A x y) (h k : hom A y z) (p : f = g) (q : h = k) : (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g k) := idJ(hom A y z, h, \\k' q' -> (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g k'), idJ(hom A x y, f, \\g' p' -> (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g' h), refl, g, p) , k, q) -- As a special case of the above: #def Segal-homotopy-postwhisker (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) (f g : hom A x y) (h : hom A y z) (p : f = g) : (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g h) := Segal-homotopy-congruence A AisSegal x y z f g h h p refl -- As a special case of the above: #def Segal-homotopy-prewhisker (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y : A) (k : hom A w x) (f g : hom A x y) (p : f = g) : (Segal-comp A AisSegal w x y k f) = (Segal-comp A AisSegal w x y k g) := Segal-homotopy-congruence A AisSegal w x y k k f g refl p -- [RS17, Proposition 5.14(a)] #def Segal-homotopy-postwhisker-is-ap (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) (f g : hom A x y) (h : hom A y z) (p : f = g) : (Segal-homotopy-postwhisker A AisSegal x y z f g h p) = ap (hom A x y) (hom A x z) f g (\\k -> Segal-comp A AisSegal x y z k h) p := idJ(hom A x y, f, \\g' p' -> (Segal-homotopy-postwhisker A AisSegal x y z f g' h p') = ap (hom A x y) (hom A x z) f g' (\\k -> Segal-comp A AisSegal x y z k h) p', refl, g, p) -- [RS17, Proposition 5.14(b)] #def Segal-homotopy-prewhisker-is-ap (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y : A) (k : hom A w x) (f g : hom A x y) (p : f = g) : (Segal-homotopy-prewhisker A AisSegal w x y k f g p) = ap (hom A x y) (hom A w y) f g (Segal-comp A AisSegal w x y k) p := idJ(hom A x y, f, \\g' p' -> (Segal-homotopy-prewhisker A AisSegal w x y k f g' p') = ap (hom A x y) (hom A w y) f g' (Segal-comp A AisSegal w x y k) p', refl, g, p) @import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap); text, textPath { font-family: Noto Serif; font-size: 20px; dominant-baseline: middle; text-anchor: middle; }","title":"Homotopies"},{"location":"simplicial-hott/06-2cat-of-segal-types/","text":"The 2-category of Segal types These formalisations correspond to Section 6 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types. Functors Functions between types induce an action on hom types, preserving sources and targets. -- [RS17, Section 6.1] -- Action of maps on homs. Called \"ap-hom\" to avoid conflicting with \"ap\". #def ap-hom (A B : U) (F : A -> B) (x y : A) (f : hom A x y) : hom B (F x) (F y) := \\t -> F (f t) #def ap-hom2 (A B : U) (F : A -> B) (x y z : A) (f : hom A x y) (g : hom A y z) (h : hom A x z) (alpha : hom2 A x y z f g h) : hom2 B (F x) (F y) (F z) (ap-hom A B F x y f) (ap-hom A B F y z g) (ap-hom A B F x z h) := \\t -> F (alpha t) Functions between types automatically preserve identity arrows. -- [RS17, Proposition 6.1.a] -- Preservation of identities follows from extension extensionality because these arrows are pointwise equal. #def functors-pres-id (extext : ExtExt) (A B : U) (F : A -> B) (x : A) : (ap-hom A B F x x (id-arr A x)) = (id-arr B (F x)) := extext 2 \u0394\u00b9 \u2202\u0394\u00b9 (\\t -> B) (\\t -> recOR( t === 0_2 |-> F x, t === 1_2 |-> F x)) (ap-hom A B F x x (id-arr A x)) (id-arr B (F x)) (\\t -> refl) -- [RS17, Proposition 6.1.b] -- Preservation of composition requires the Segal hypothesis. #def functors-pres-comp (A B : U) (AisSegal : isSegal A) (BisSegal : isSegal B) (F : A -> B) (x y z : A) (f : hom A x y) (g : hom A y z) : (Segal-comp B BisSegal (F x) (F y) (F z) (ap-hom A B F x y f) (ap-hom A B F y z g)) = (ap-hom A B F x z (Segal-comp A AisSegal x y z f g)) := Segal-comp-uniqueness B BisSegal (F x) (F y) (F z) (ap-hom A B F x y f) (ap-hom A B F y z g) (ap-hom A B F x z (Segal-comp A AisSegal x y z f g)) (ap-hom2 A B F x y z f g (Segal-comp A AisSegal x y z f g) (Segal-comp-witness A AisSegal x y z f g))","title":"2-Category of Segal Types"},{"location":"simplicial-hott/06-2cat-of-segal-types/#the-2-category-of-segal-types","text":"These formalisations correspond to Section 6 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"The 2-category of Segal types"},{"location":"simplicial-hott/06-2cat-of-segal-types/#prerequisites","text":"3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types.","title":"Prerequisites"},{"location":"simplicial-hott/06-2cat-of-segal-types/#functors","text":"Functions between types induce an action on hom types, preserving sources and targets. -- [RS17, Section 6.1] -- Action of maps on homs. Called \"ap-hom\" to avoid conflicting with \"ap\". #def ap-hom (A B : U) (F : A -> B) (x y : A) (f : hom A x y) : hom B (F x) (F y) := \\t -> F (f t) #def ap-hom2 (A B : U) (F : A -> B) (x y z : A) (f : hom A x y) (g : hom A y z) (h : hom A x z) (alpha : hom2 A x y z f g h) : hom2 B (F x) (F y) (F z) (ap-hom A B F x y f) (ap-hom A B F y z g) (ap-hom A B F x z h) := \\t -> F (alpha t) Functions between types automatically preserve identity arrows. -- [RS17, Proposition 6.1.a] -- Preservation of identities follows from extension extensionality because these arrows are pointwise equal. #def functors-pres-id (extext : ExtExt) (A B : U) (F : A -> B) (x : A) : (ap-hom A B F x x (id-arr A x)) = (id-arr B (F x)) := extext 2 \u0394\u00b9 \u2202\u0394\u00b9 (\\t -> B) (\\t -> recOR( t === 0_2 |-> F x, t === 1_2 |-> F x)) (ap-hom A B F x x (id-arr A x)) (id-arr B (F x)) (\\t -> refl) -- [RS17, Proposition 6.1.b] -- Preservation of composition requires the Segal hypothesis. #def functors-pres-comp (A B : U) (AisSegal : isSegal A) (BisSegal : isSegal B) (F : A -> B) (x y z : A) (f : hom A x y) (g : hom A y z) : (Segal-comp B BisSegal (F x) (F y) (F z) (ap-hom A B F x y f) (ap-hom A B F y z g)) = (ap-hom A B F x z (Segal-comp A AisSegal x y z f g)) := Segal-comp-uniqueness B BisSegal (F x) (F y) (F z) (ap-hom A B F x y f) (ap-hom A B F y z g) (ap-hom A B F x z (Segal-comp A AisSegal x y z f g)) (ap-hom2 A B F x y z f g (Segal-comp A AisSegal x y z f g) (Segal-comp-witness A AisSegal x y z f g))","title":"Functors"},{"location":"simplicial-hott/07-discrete/","text":"Discrete types These formalisations correspond to Section 7 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/1-paths.md - We require basic path algebra. hott/4-equivalences.md - We require the notion of equivalence between types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types. The definition Discrete types are types in which the hom-types are canonically equivalent to identity types. -- [RS17, Definition 7.1] #def id-to-arr (A : U) -- A type. (x y : A) -- Two points of type A. (p : x = y) -- A path p from x to y in A. : hom A x y -- An arrow p from x to y in A. := idJ(A, x, \\y' -> \\p' -> hom A x y', (id-arr A x), y, p) #def isDiscrete (A : U) -- A type. : U := (x : A) -> (y : A) -> isEquiv (x =_{A} y) (hom A x y) (id-to-arr A x y)","title":"Discrete Types"},{"location":"simplicial-hott/07-discrete/#discrete-types","text":"These formalisations correspond to Section 7 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Discrete types"},{"location":"simplicial-hott/07-discrete/#prerequisites","text":"hott/1-paths.md - We require basic path algebra. hott/4-equivalences.md - We require the notion of equivalence between types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types.","title":"Prerequisites"},{"location":"simplicial-hott/07-discrete/#the-definition","text":"Discrete types are types in which the hom-types are canonically equivalent to identity types. -- [RS17, Definition 7.1] #def id-to-arr (A : U) -- A type. (x y : A) -- Two points of type A. (p : x = y) -- A path p from x to y in A. : hom A x y -- An arrow p from x to y in A. := idJ(A, x, \\y' -> \\p' -> hom A x y', (id-arr A x), y, p) #def isDiscrete (A : U) -- A type. : U := (x : A) -> (y : A) -> isEquiv (x =_{A} y) (hom A x y) (id-to-arr A x y)","title":"The definition"},{"location":"simplicial-hott/08-covariant/","text":"Covariantly functorial type families These formalisations correspond to Section 8 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/* - We require various prerequisites from homotopy type theory, for instance the notion of contractible types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 5-segal-types.md - We make use of the notion of Segal types and their structures. Dependent hom types In a type family over a base type, there is a dependent hom type of arrows that live over a specified arrow in the base type. -- [RS17, Section 8 Prelim] -- The type of dependent arrows in C over f from u to v #def dhom (A : U) -- The base type. (x y : A) -- Two points in the base. (f : hom A x y) -- An arrow in the base. (C : A -> U) -- A type family. (u : C x) -- A lift of the domain. (v : C y) -- A lift of the codomain. : U := <{t : 2 | \u0394\u00b9 t } -> C (f t) [t === 0_2 |-> u, t === 1_2 |-> v ]> It will be convenient to collect together dependent hom types with fixed domain but varying codomain. #def dhomFrom (A : U) -- The base type. (x y : A) -- Two points in the base. (f : hom A x y) -- An arrow in the base. (C : A -> U) -- A type family. (u : C x) -- A lift of the domain. : U := (\u2211 (v : C y), dhom A x y f C u v) There is also a type of dependent commutative triangles over a base commutative triangle. #def dhom2 (A : U) -- The base type. (x y z : A) -- Three points in the base. (f : hom A x y) -- An arrow in the base. (g : hom A y z) -- An arrow in the base. (h : hom A x z) -- An arrow in the base. (alpha : hom2 A x y z f g h) -- A composition witness in the base. (C : A -> U) -- A type family. (u : C x) -- A lift of the initial point. (v : C y) -- A lift of the second point. (w : C z) -- A lift of the third point. (ff : dhom A x y f C u v) -- A lift of the first arrow. (gg : dhom A y z g C v w) -- A lift of the second arrow. (hh : dhom A x z h C u w) -- A lift of the diagonal arrow. : U := <{(t1, t2) : 2 * 2 | \u0394\u00b2 (t1, t2)} -> C (alpha (t1, t2)) [t2 === 0_2 |-> ff t1, t1 === 1_2 |-> gg t2, t2 === t1 |-> hh t2 ]> Covariant families A family of types over a base type is covariant if every arrow in the base has a unique lift with specified domain. -- [RS17, Definition 8.2] #def isCovFam (A : U) (C : A -> U) : U := (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -> isContr (dhomFrom A x y f C u) -- Type of covariant families over a fixed type #def covFam (A : U) : U := (\u2211 (C : ((a : A) -> U)), isCovFam A C) Representable covariant families If A is a Segal type and a : A is any term, then hom A a defines a covariant family over A, and conversely if this family is covariant for every a : A, then A must be a Segal type. The proof involves a rather lengthy composition of equivalences. #def representable-dhom (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. (v : hom A a y) -- A lift of the codomain. : U := dhom A x y f (\\z -> hom A a z) u v -- By uncurrying (RS 4.2) we have an equivalence: #def representable-dhom-uncurry (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. (v : hom A a y) -- A lift of the codomain. : Eq (representable-dhom A a x y f u v) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>) := curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 (\\t s -> A) (\\(t, s) -> recOR(((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t )) #def representable-dhomFrom (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : U := dhomFrom A x y f (\\z -> hom A a z) u -- By uncurrying (RS 4.2) we have an equivalence: #def representable-dhomFrom-uncurry (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (\u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) := family-Eq-total-Eq (hom A a y) (\\v -> representable-dhom A a x y f u v) (\\v -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (\\v -> representable-dhom-uncurry A a x y f u v) #def square-to-hom2-pushout (A : U) (w x y z : A) (u : hom A w x) (f : hom A x z) (g : hom A w y) (v : hom A y z) : (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> g t, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>) -> (\u2211 (d : hom A w z), prod (hom2 A w x z u f d) (hom2 A w y z g v d)) := \\sq -> ((\\t -> sq (t, t)), (\\(t, s) -> sq (s, t), \\(t, s) -> sq (t, s))) #def hom2-pushout-to-square (A : U) (w x y z : A) (u : hom A w x) (f : hom A x z) (g : hom A w y) (v : hom A y z) : (\u2211 (d : hom A w z), prod (hom2 A w x z u f d) (hom2 A w y z g v d)) -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> g t, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>) := \\(d, (alpha1, alpha2)) (t, s) -> recOR (t <= s |-> alpha1 (s, t), s <= t |-> alpha2 (t, s)) #def square-hom2-pushout-Eq (A : U) (w x y z : A) (u : hom A w x) (f : hom A x z) (g : hom A w y) (v : hom A y z) : Eq (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> g t, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>) (\u2211 (d : hom A w z), prod (hom2 A w x z u f d) (hom2 A w y z g v d)) := (square-to-hom2-pushout A w x y z u f g v, ((hom2-pushout-to-square A w x y z u f g v, \\sq -> refl), (hom2-pushout-to-square A w x y z u f g v, \\alphas -> refl))) #def representable-dhomFrom-uncurry-hom2 (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (\u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (\u2211 (v : hom A a y), (\u2211 (d : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) := family-Eq-total-Eq (hom A a y) (\\v -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (\\v -> (\u2211 (d : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (\\v -> square-hom2-pushout-Eq A a x a y u f (id-arr A a) v) #def representable-dhomFrom-hom2 (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (\u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) := triple_compose_Eq (representable-dhomFrom A a x y f u) (\u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (\u2211 (v : hom A a y), (\u2211 (d : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (\u2211 (d : hom A a y), (\u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (representable-dhomFrom-uncurry A a x y f u) (representable-dhomFrom-uncurry-hom2 A a x y f u) (sigma-fubini (hom A a y) (hom A a y) (\\v d -> prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) #def representable-dhomFrom-hom2-dist (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) := RightCancel_Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) (\u2211 (d : hom A a y), (\u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (representable-dhomFrom-hom2 A a x y f u) (family-Eq-total-Eq (hom A a y) (\\d -> (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) (\\d -> (\u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (\\d -> (prod-distribute-sigma (hom2 A a x y u f d) (hom A a y)(\\v -> hom2 A a a y (id-arr A a) v d)))) Now we introduce the hypothesis that A is Segal type. #def Segal-representable-dhomFrom-path-space (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is a Segal type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), (v = d)))) := RightCancel_Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), (v = d)))) (\u2211 (d : hom A a y), (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) (representable-dhomFrom-hom2-dist A a x y f u) (family-Eq-total-Eq (hom A a y) (\\d -> (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), (v = d)))) (\\d -> (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) (\\d -> (family-Eq-total-Eq (hom2 A a x y u f d) (\\alpha -> (\u2211 (v : hom A a y), (v = d))) (\\alpha -> (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d)) (\\alpha -> (family-Eq-total-Eq (hom A a y) (\\v -> (v = d)) (\\v -> hom2 A a a y (id-arr A a) v d) (\\v -> (Eq-Segal-homotopy-hom2 A AisSegal a y v d))))))) #def codomain-based-paths-contraction (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. (d : hom A a y) : Eq (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), (v = d))) (hom2 A a x y u f d) := contractible-fibers-projection-Eq (hom2 A a x y u f d) (\\alpha -> (\u2211 (v : hom A a y), (v = d))) (\\alpha -> codomain-based-paths-contractible (hom A a y) d) #def isSegal-representable-dhomFrom-hom2 (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is a Segal type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (hom2 A a x y u f d)) := compose_Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), (v = d)))) (\u2211 (d : hom A a y), (hom2 A a x y u f d)) (Segal-representable-dhomFrom-path-space A AisSegal a x y f u) (family-Eq-total-Eq (hom A a y) (\\d -> prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), (v = d))) (\\d -> hom2 A a x y u f d) (\\d -> codomain-based-paths-contraction A a x y f u d)) #def isSegal-representable-dhomFrom-contractible (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is a Segal type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : isContr (representable-dhomFrom A a x y f u) := isEquiv-toContr-isContr (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (hom2 A a x y u f d)) (isSegal-representable-dhomFrom-hom2 A AisSegal a x y f u) (AisSegal a x y u f) Finally, we see that covariantly hom families in a Segal type are covariant. -- [RS, Proposition 8.13(<-)] #def isSegal-representable-isCovFam (A : U) (AisSegal : isSegal A) (a : A) : isCovFam A (\\x -> hom A a x) := \\x y f u -> isSegal-representable-dhomFrom-contractible A AisSegal a x y f u The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for Segal types - so instead we argue as follows: -- [RS, Proposition 8.13(->)] #def representable-isCovFam-isSegal (A : U) (repiscovfam : (a : A) -> isCovFam A (\\x -> hom A a x)) : isSegal A := \\x y z f g -> first-isContr-sigma (\u2211 (h : hom A x z), hom2 A x y z f g h) (\\hk -> \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v (first hk)) (\\hk -> (first hk, \\(t, s) -> first hk s)) (isEquiv-toContr-isContr (\u2211 (hk : \u2211 (h : hom A x z), hom2 A x y z f g h), \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v (first hk)) (representable-dhomFrom A x y z g f) (sym_Eq (representable-dhomFrom A x y z g f) (\u2211 (hk : \u2211 (h : hom A x z), hom2 A x y z f g h), \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v (first hk)) (compose_Eq (representable-dhomFrom A x y z g f) (\u2211 (h : hom A x z), (prod (hom2 A x y z f g h) (\u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v h))) (\u2211 (hk : \u2211 (h : hom A x z), hom2 A x y z f g h), \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v (first hk)) (representable-dhomFrom-hom2-dist A x y z g f) (assoc (hom A x z) (\\h -> hom2 A x y z f g h) (\\h _ -> \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v h)))) (repiscovfam x y z g f)) While not needed to prove Proposition 8.13, it is interesting to observe that the dependent hom types in a representable family can be understood as extension types as follows. #def cofibration-union-test (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]> <{(t, s) : 2 * 2 | ((t === 1_2) /\\ (\u0394\u00b9 s))} -> A [ ((t === 1_2) /\\ (s === 0_2)) |-> a, ((t === 1_2) /\\ (s === 1_2)) |-> y ]> := cofibration_union (2 * 2) (\\(t, s) -> (t === 1_2) /\\ \u0394\u00b9 s) (\\(t, s) -> ((t === 0_2) /\\ \u0394\u00b9 s) \\/ (\u0394\u00b9 t /\\ (s === 0_2)) \\/ (\u0394\u00b9 t /\\ (s === 1_2))) (\\(t, s) -> A) (\\(t, s) -> recOR(((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t )) #def base-hom-rewriting (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (<{(t, s) : 2 * 2 | ((t === 1_2) /\\ (\u0394\u00b9 s))} -> A [ ((t === 1_2) /\\ (s === 0_2)) |-> a, ((t === 1_2) /\\ (s === 1_2)) |-> y ]>) (hom A a y) := (\\v -> (\\r -> v ((1_2, r))), ((\\v -> \\(t, s) -> v s, \\v -> refl), (\\v -> \\(t, s) -> v s, \\v -> refl))) #def base-hom-expansion (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]> (hom A a y) := compose_Eq (<{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]> ) (<{(t, s) : 2 * 2 | ((t === 1_2) /\\ (\u0394\u00b9 s))} -> A [ ((t === 1_2) /\\ (s === 0_2)) |-> a, ((t === 1_2) /\\ (s === 1_2)) |-> y ]>) (hom A a y) (cofibration-union-test A a x y f u) (base-hom-rewriting A a x y f u) #def representable-dhomFrom-expansion (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (\u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> (sq (1_2, s)), (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (\u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) := pullback-is-equiv-total-eq ( <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]> ) (hom A a y) (first (base-hom-expansion A a x y f u)) (second (base-hom-expansion A a x y f u)) (\\v -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) #def representable-dhomFrom-composite-expansion (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (\u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> (sq (1_2, s)), (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) := RightCancel_Eq (representable-dhomFrom A a x y f u) (\u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> (sq (1_2, s)), (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (\u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (representable-dhomFrom-uncurry A a x y f u) (representable-dhomFrom-expansion A a x y f u) #def representable-dhomFrom-cofibration-composition (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t]> ) (\u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> (sq (1_2, s)), (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) := cofibration-composition (2 * 2) \u0394\u00b9\u00d7\u0394\u00b9 \u2202\u25a1 (\\(t, s) -> ((t === 0_2) /\\ \u0394\u00b9 s) \\/ (\u0394\u00b9 t /\\ (s === 0_2)) \\/ (\u0394\u00b9 t /\\ (s === 1_2))) (\\ts -> A) (\\(t, s) -> recOR( ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t)) #def representable-dhomFrom-as-extension-type (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t]> ) := RightCancel_Eq (representable-dhomFrom A a x y f u) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t]> ) (\u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> (sq (1_2, s)), (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (representable-dhomFrom-composite-expansion A a x y f u) (representable-dhomFrom-cofibration-composition A a x y f u) Covariant lifts, transport, and uniqueness In a covariant family C over a base type A, a term u : C x may be transported along an arrow f : hom A x y to give a term in C y. -- [RS17, covariant transport from beginning of Section 8.2] #def covTrans (A : U) (x y : A) (f : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (u : C x) : C y := first (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, covariant lift from beginning of Section 8.2] #def covLift (A : U) (x y : A) (f : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (u : C x) : (dhom A x y f C u (covTrans A x y f C CisCov u)) := second (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) #def covUniqueness (A : U) (x y : A) (f : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (u : C x) (lift : dhomFrom A x y f C u) : (covTrans A x y f C CisCov u) = (first lift) := total-path-to-base-path (C y) (\\v -> dhom A x y f C u v) (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) lift (contracting-htpy (dhomFrom A x y f C u) (CisCov x y f u) lift) Covariant functoriality The covariant transport operation defines a covariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law. #def d-id-arr (A : U) (x : A) (C : A -> U) (u : C x) : dhom A x x (id-arr A x) C u u := \\t -> u -- [RS17, Proposition 8.16, Part 2] -- Covariant families preserve identities #def covPresId (A : U) (x : A) (C : A -> U) (CisCov : isCovFam A C) (u : C x) : (covTrans A x x (id-arr A x) C CisCov u) = u := covUniqueness A x x (id-arr A x) C CisCov u (u, d-id-arr A x C u) Natural transformations A fiberwise map between covariant families is automatically \"natural\" commuting with the covariant lifts. -- [RS17, Proposition 8.17] -- Covariant naturality #def covariant-transformation-application (A : U) (x y : A) (f : hom A x y) (C D : A -> U) (CisCov : isCovFam A C) (DisCov : isCovFam A D) (phi : (z : A) -> C z -> D z) (u : C x) : dhomFrom A x y f D (phi x u) := (phi y (covTrans A x y f C CisCov u), \\t -> phi (f t) (covLift A x y f C CisCov u t)) #def covariant-transformation-naturality (A : U) (x y : A) (f : hom A x y) (C D : A -> U) (CisCov : isCovFam A C) (DisCov : isCovFam A D) (phi : (z : A) -> C z -> D z) (u : C x) : (covTrans A x y f D DisCov (phi x u)) = (phi y (covTrans A x y f C CisCov u)) := covUniqueness A x y f D DisCov (phi x u) (covariant-transformation-application A x y f C D CisCov DisCov phi u)","title":"Covariantly Functorial Type Families"},{"location":"simplicial-hott/08-covariant/#covariantly-functorial-type-families","text":"These formalisations correspond to Section 8 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Covariantly functorial type families"},{"location":"simplicial-hott/08-covariant/#prerequisites","text":"hott/* - We require various prerequisites from homotopy type theory, for instance the notion of contractible types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 5-segal-types.md - We make use of the notion of Segal types and their structures.","title":"Prerequisites"},{"location":"simplicial-hott/08-covariant/#dependent-hom-types","text":"In a type family over a base type, there is a dependent hom type of arrows that live over a specified arrow in the base type. -- [RS17, Section 8 Prelim] -- The type of dependent arrows in C over f from u to v #def dhom (A : U) -- The base type. (x y : A) -- Two points in the base. (f : hom A x y) -- An arrow in the base. (C : A -> U) -- A type family. (u : C x) -- A lift of the domain. (v : C y) -- A lift of the codomain. : U := <{t : 2 | \u0394\u00b9 t } -> C (f t) [t === 0_2 |-> u, t === 1_2 |-> v ]> It will be convenient to collect together dependent hom types with fixed domain but varying codomain. #def dhomFrom (A : U) -- The base type. (x y : A) -- Two points in the base. (f : hom A x y) -- An arrow in the base. (C : A -> U) -- A type family. (u : C x) -- A lift of the domain. : U := (\u2211 (v : C y), dhom A x y f C u v) There is also a type of dependent commutative triangles over a base commutative triangle. #def dhom2 (A : U) -- The base type. (x y z : A) -- Three points in the base. (f : hom A x y) -- An arrow in the base. (g : hom A y z) -- An arrow in the base. (h : hom A x z) -- An arrow in the base. (alpha : hom2 A x y z f g h) -- A composition witness in the base. (C : A -> U) -- A type family. (u : C x) -- A lift of the initial point. (v : C y) -- A lift of the second point. (w : C z) -- A lift of the third point. (ff : dhom A x y f C u v) -- A lift of the first arrow. (gg : dhom A y z g C v w) -- A lift of the second arrow. (hh : dhom A x z h C u w) -- A lift of the diagonal arrow. : U := <{(t1, t2) : 2 * 2 | \u0394\u00b2 (t1, t2)} -> C (alpha (t1, t2)) [t2 === 0_2 |-> ff t1, t1 === 1_2 |-> gg t2, t2 === t1 |-> hh t2 ]>","title":"Dependent hom types"},{"location":"simplicial-hott/08-covariant/#covariant-families","text":"A family of types over a base type is covariant if every arrow in the base has a unique lift with specified domain. -- [RS17, Definition 8.2] #def isCovFam (A : U) (C : A -> U) : U := (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -> isContr (dhomFrom A x y f C u) -- Type of covariant families over a fixed type #def covFam (A : U) : U := (\u2211 (C : ((a : A) -> U)), isCovFam A C)","title":"Covariant families"},{"location":"simplicial-hott/08-covariant/#representable-covariant-families","text":"If A is a Segal type and a : A is any term, then hom A a defines a covariant family over A, and conversely if this family is covariant for every a : A, then A must be a Segal type. The proof involves a rather lengthy composition of equivalences. #def representable-dhom (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. (v : hom A a y) -- A lift of the codomain. : U := dhom A x y f (\\z -> hom A a z) u v -- By uncurrying (RS 4.2) we have an equivalence: #def representable-dhom-uncurry (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. (v : hom A a y) -- A lift of the codomain. : Eq (representable-dhom A a x y f u v) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>) := curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 (\\t s -> A) (\\(t, s) -> recOR(((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t )) #def representable-dhomFrom (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : U := dhomFrom A x y f (\\z -> hom A a z) u -- By uncurrying (RS 4.2) we have an equivalence: #def representable-dhomFrom-uncurry (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (\u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) := family-Eq-total-Eq (hom A a y) (\\v -> representable-dhom A a x y f u v) (\\v -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (\\v -> representable-dhom-uncurry A a x y f u v) #def square-to-hom2-pushout (A : U) (w x y z : A) (u : hom A w x) (f : hom A x z) (g : hom A w y) (v : hom A y z) : (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> g t, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>) -> (\u2211 (d : hom A w z), prod (hom2 A w x z u f d) (hom2 A w y z g v d)) := \\sq -> ((\\t -> sq (t, t)), (\\(t, s) -> sq (s, t), \\(t, s) -> sq (t, s))) #def hom2-pushout-to-square (A : U) (w x y z : A) (u : hom A w x) (f : hom A x z) (g : hom A w y) (v : hom A y z) : (\u2211 (d : hom A w z), prod (hom2 A w x z u f d) (hom2 A w y z g v d)) -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> g t, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>) := \\(d, (alpha1, alpha2)) (t, s) -> recOR (t <= s |-> alpha1 (s, t), s <= t |-> alpha2 (t, s)) #def square-hom2-pushout-Eq (A : U) (w x y z : A) (u : hom A w x) (f : hom A x z) (g : hom A w y) (v : hom A y z) : Eq (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> g t, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>) (\u2211 (d : hom A w z), prod (hom2 A w x z u f d) (hom2 A w y z g v d)) := (square-to-hom2-pushout A w x y z u f g v, ((hom2-pushout-to-square A w x y z u f g v, \\sq -> refl), (hom2-pushout-to-square A w x y z u f g v, \\alphas -> refl))) #def representable-dhomFrom-uncurry-hom2 (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (\u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (\u2211 (v : hom A a y), (\u2211 (d : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) := family-Eq-total-Eq (hom A a y) (\\v -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (\\v -> (\u2211 (d : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (\\v -> square-hom2-pushout-Eq A a x a y u f (id-arr A a) v) #def representable-dhomFrom-hom2 (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (\u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) := triple_compose_Eq (representable-dhomFrom A a x y f u) (\u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (\u2211 (v : hom A a y), (\u2211 (d : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (\u2211 (d : hom A a y), (\u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (representable-dhomFrom-uncurry A a x y f u) (representable-dhomFrom-uncurry-hom2 A a x y f u) (sigma-fubini (hom A a y) (hom A a y) (\\v d -> prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) #def representable-dhomFrom-hom2-dist (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) := RightCancel_Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) (\u2211 (d : hom A a y), (\u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (representable-dhomFrom-hom2 A a x y f u) (family-Eq-total-Eq (hom A a y) (\\d -> (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) (\\d -> (\u2211 (v : hom A a y), prod (hom2 A a x y u f d) (hom2 A a a y (id-arr A a) v d))) (\\d -> (prod-distribute-sigma (hom2 A a x y u f d) (hom A a y)(\\v -> hom2 A a a y (id-arr A a) v d)))) Now we introduce the hypothesis that A is Segal type. #def Segal-representable-dhomFrom-path-space (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is a Segal type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), (v = d)))) := RightCancel_Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), (v = d)))) (\u2211 (d : hom A a y), (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) (representable-dhomFrom-hom2-dist A a x y f u) (family-Eq-total-Eq (hom A a y) (\\d -> (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), (v = d)))) (\\d -> (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d))) (\\d -> (family-Eq-total-Eq (hom2 A a x y u f d) (\\alpha -> (\u2211 (v : hom A a y), (v = d))) (\\alpha -> (\u2211 (v : hom A a y), hom2 A a a y (id-arr A a) v d)) (\\alpha -> (family-Eq-total-Eq (hom A a y) (\\v -> (v = d)) (\\v -> hom2 A a a y (id-arr A a) v d) (\\v -> (Eq-Segal-homotopy-hom2 A AisSegal a y v d))))))) #def codomain-based-paths-contraction (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. (d : hom A a y) : Eq (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), (v = d))) (hom2 A a x y u f d) := contractible-fibers-projection-Eq (hom2 A a x y u f d) (\\alpha -> (\u2211 (v : hom A a y), (v = d))) (\\alpha -> codomain-based-paths-contractible (hom A a y) d) #def isSegal-representable-dhomFrom-hom2 (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is a Segal type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (hom2 A a x y u f d)) := compose_Eq (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), (v = d)))) (\u2211 (d : hom A a y), (hom2 A a x y u f d)) (Segal-representable-dhomFrom-path-space A AisSegal a x y f u) (family-Eq-total-Eq (hom A a y) (\\d -> prod (hom2 A a x y u f d) (\u2211 (v : hom A a y), (v = d))) (\\d -> hom2 A a x y u f d) (\\d -> codomain-based-paths-contraction A a x y f u d)) #def isSegal-representable-dhomFrom-contractible (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is a Segal type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : isContr (representable-dhomFrom A a x y f u) := isEquiv-toContr-isContr (representable-dhomFrom A a x y f u) (\u2211 (d : hom A a y), (hom2 A a x y u f d)) (isSegal-representable-dhomFrom-hom2 A AisSegal a x y f u) (AisSegal a x y u f) Finally, we see that covariantly hom families in a Segal type are covariant. -- [RS, Proposition 8.13(<-)] #def isSegal-representable-isCovFam (A : U) (AisSegal : isSegal A) (a : A) : isCovFam A (\\x -> hom A a x) := \\x y f u -> isSegal-representable-dhomFrom-contractible A AisSegal a x y f u The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for Segal types - so instead we argue as follows: -- [RS, Proposition 8.13(->)] #def representable-isCovFam-isSegal (A : U) (repiscovfam : (a : A) -> isCovFam A (\\x -> hom A a x)) : isSegal A := \\x y z f g -> first-isContr-sigma (\u2211 (h : hom A x z), hom2 A x y z f g h) (\\hk -> \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v (first hk)) (\\hk -> (first hk, \\(t, s) -> first hk s)) (isEquiv-toContr-isContr (\u2211 (hk : \u2211 (h : hom A x z), hom2 A x y z f g h), \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v (first hk)) (representable-dhomFrom A x y z g f) (sym_Eq (representable-dhomFrom A x y z g f) (\u2211 (hk : \u2211 (h : hom A x z), hom2 A x y z f g h), \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v (first hk)) (compose_Eq (representable-dhomFrom A x y z g f) (\u2211 (h : hom A x z), (prod (hom2 A x y z f g h) (\u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v h))) (\u2211 (hk : \u2211 (h : hom A x z), hom2 A x y z f g h), \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v (first hk)) (representable-dhomFrom-hom2-dist A x y z g f) (assoc (hom A x z) (\\h -> hom2 A x y z f g h) (\\h _ -> \u2211 (v : hom A x z), hom2 A x x z (id-arr A x) v h)))) (repiscovfam x y z g f)) While not needed to prove Proposition 8.13, it is interesting to observe that the dependent hom types in a representable family can be understood as extension types as follows. #def cofibration-union-test (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]> <{(t, s) : 2 * 2 | ((t === 1_2) /\\ (\u0394\u00b9 s))} -> A [ ((t === 1_2) /\\ (s === 0_2)) |-> a, ((t === 1_2) /\\ (s === 1_2)) |-> y ]> := cofibration_union (2 * 2) (\\(t, s) -> (t === 1_2) /\\ \u0394\u00b9 s) (\\(t, s) -> ((t === 0_2) /\\ \u0394\u00b9 s) \\/ (\u0394\u00b9 t /\\ (s === 0_2)) \\/ (\u0394\u00b9 t /\\ (s === 1_2))) (\\(t, s) -> A) (\\(t, s) -> recOR(((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t )) #def base-hom-rewriting (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (<{(t, s) : 2 * 2 | ((t === 1_2) /\\ (\u0394\u00b9 s))} -> A [ ((t === 1_2) /\\ (s === 0_2)) |-> a, ((t === 1_2) /\\ (s === 1_2)) |-> y ]>) (hom A a y) := (\\v -> (\\r -> v ((1_2, r))), ((\\v -> \\(t, s) -> v s, \\v -> refl), (\\v -> \\(t, s) -> v s, \\v -> refl))) #def base-hom-expansion (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]> (hom A a y) := compose_Eq (<{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]> ) (<{(t, s) : 2 * 2 | ((t === 1_2) /\\ (\u0394\u00b9 s))} -> A [ ((t === 1_2) /\\ (s === 0_2)) |-> a, ((t === 1_2) /\\ (s === 1_2)) |-> y ]>) (hom A a y) (cofibration-union-test A a x y f u) (base-hom-rewriting A a x y f u) #def representable-dhomFrom-expansion (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (\u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> (sq (1_2, s)), (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (\u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) := pullback-is-equiv-total-eq ( <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]> ) (hom A a y) (first (base-hom-expansion A a x y f u)) (second (base-hom-expansion A a x y f u)) (\\v -> (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) #def representable-dhomFrom-composite-expansion (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (\u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> (sq (1_2, s)), (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) := RightCancel_Eq (representable-dhomFrom A a x y f u) (\u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> (sq (1_2, s)), (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (\u2211 (v : hom A a y), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> v s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (representable-dhomFrom-uncurry A a x y f u) (representable-dhomFrom-expansion A a x y f u) #def representable-dhomFrom-cofibration-composition (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t]> ) (\u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> (sq (1_2, s)), (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) := cofibration-composition (2 * 2) \u0394\u00b9\u00d7\u0394\u00b9 \u2202\u25a1 (\\(t, s) -> ((t === 0_2) /\\ \u0394\u00b9 s) \\/ (\u0394\u00b9 t /\\ (s === 0_2)) \\/ (\u0394\u00b9 t /\\ (s === 1_2))) (\\ts -> A) (\\(t, s) -> recOR( ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t)) #def representable-dhomFrom-as-extension-type (A : U) -- The ambient type. (a x y : A) -- The representing object and two points in the base. (f : hom A x y) -- An arrow in the base. (u : hom A a x) -- A lift of the domain. : Eq (representable-dhomFrom A a x y f u) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t]> ) := RightCancel_Eq (representable-dhomFrom A a x y f u) (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t]> ) (\u2211 (sq : <{(t, s) : 2 * 2 | \u2202\u25a1 (t, s)} -> A [ ((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>), (<{(t, s) : 2 * 2 | \u0394\u00b9\u00d7\u0394\u00b9 (t, s)} -> A [((t === 0_2) /\\ \u0394\u00b9 s) |-> u s, ((t === 1_2) /\\ \u0394\u00b9 s) |-> (sq (1_2, s)), (\u0394\u00b9 t /\\ (s === 0_2)) |-> a, (\u0394\u00b9 t /\\ (s === 1_2)) |-> f t ]>)) (representable-dhomFrom-composite-expansion A a x y f u) (representable-dhomFrom-cofibration-composition A a x y f u)","title":"Representable covariant families"},{"location":"simplicial-hott/08-covariant/#covariant-lifts-transport-and-uniqueness","text":"In a covariant family C over a base type A, a term u : C x may be transported along an arrow f : hom A x y to give a term in C y. -- [RS17, covariant transport from beginning of Section 8.2] #def covTrans (A : U) (x y : A) (f : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (u : C x) : C y := first (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, covariant lift from beginning of Section 8.2] #def covLift (A : U) (x y : A) (f : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (u : C x) : (dhom A x y f C u (covTrans A x y f C CisCov u)) := second (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) #def covUniqueness (A : U) (x y : A) (f : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (u : C x) (lift : dhomFrom A x y f C u) : (covTrans A x y f C CisCov u) = (first lift) := total-path-to-base-path (C y) (\\v -> dhom A x y f C u v) (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) lift (contracting-htpy (dhomFrom A x y f C u) (CisCov x y f u) lift)","title":"Covariant lifts, transport, and uniqueness"},{"location":"simplicial-hott/08-covariant/#covariant-functoriality","text":"The covariant transport operation defines a covariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law. #def d-id-arr (A : U) (x : A) (C : A -> U) (u : C x) : dhom A x x (id-arr A x) C u u := \\t -> u -- [RS17, Proposition 8.16, Part 2] -- Covariant families preserve identities #def covPresId (A : U) (x : A) (C : A -> U) (CisCov : isCovFam A C) (u : C x) : (covTrans A x x (id-arr A x) C CisCov u) = u := covUniqueness A x x (id-arr A x) C CisCov u (u, d-id-arr A x C u)","title":"Covariant functoriality"},{"location":"simplicial-hott/08-covariant/#natural-transformations","text":"A fiberwise map between covariant families is automatically \"natural\" commuting with the covariant lifts. -- [RS17, Proposition 8.17] -- Covariant naturality #def covariant-transformation-application (A : U) (x y : A) (f : hom A x y) (C D : A -> U) (CisCov : isCovFam A C) (DisCov : isCovFam A D) (phi : (z : A) -> C z -> D z) (u : C x) : dhomFrom A x y f D (phi x u) := (phi y (covTrans A x y f C CisCov u), \\t -> phi (f t) (covLift A x y f C CisCov u t)) #def covariant-transformation-naturality (A : U) (x y : A) (f : hom A x y) (C D : A -> U) (CisCov : isCovFam A C) (DisCov : isCovFam A D) (phi : (z : A) -> C z -> D z) (u : C x) : (covTrans A x y f D DisCov (phi x u)) = (phi y (covTrans A x y f C CisCov u)) := covUniqueness A x y f D DisCov (phi x u) (covariant-transformation-application A x y f C D CisCov DisCov phi u)","title":"Natural transformations"},{"location":"simplicial-hott/09-yoneda/","text":"The Yoneda lemma These formalisations correspond to Section 9 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 8-covariant.md - We use covariant type families. Natural transformations involving a representable functor Fix a Segal type A and a term a : A. The Yoneda lemma characterizes natural transformations from the representable functor (hom A a) to a covariant type fmaily C. Ordinary, such a natural transformation would involve a family of maps (phi : (z : A) -> hom A a z -> C z) together with a proof of naturality of these components, but as is the case for covariant-transformation-naturality the naturality condition is automatic. -- This unfolds a composition triangle to a square with an identity component #def id-domain-square (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a x y : A) -- Three objects (g : hom A a x) (k : hom A x y) : (s : \u0394\u00b9) -> hom A a (k s) := \\s t -> recOR(t <= s |-> (id-comp-witness A a y (Segal-comp A AisSegal a x y g k)) (s , t), s <= t |-> (Segal-comp-witness A AisSegal a x y g k) (t , s)) #def covariant-representable-transformation-application (A : U) (AisSegal : isSegal A) (a x y : A) (f : hom A a x) (g : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (phi : (z : A) -> hom A a z -> C z) : dhomFrom A x y g C (phi x f) := (phi y (Segal-comp A AisSegal a x y f g), \\s -> phi (g s) (\\t -> (id-domain-square A AisSegal a x y f g s t))) #def covariant-representable-transformation-naturality (A : U) (AisSegal : isSegal A) (a x y : A) (f : hom A a x) (g : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (phi : (z : A) -> hom A a z -> C z) : (covTrans A x y g C CisCov (phi x f)) = (phi y (Segal-comp A AisSegal a x y f g)) := covUniqueness A x y g C CisCov (phi x f) (covariant-representable-transformation-application A AisSegal a x y f g C CisCov phi) The Yoneda maps For any Segal type A and term a : A, the Yoneda lemma provides an equivalence between the type (z : A) -> hom A a z -> C z of natural transformations out of the functor (hom A a) and valued in an arbitrary covariant family C and the type (C a). One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the covariant transport operation. -- The map evid evaluates a natural transformation -- out of a representable functor at the identity arrow. #def evid (A : U) -- The ambient type. (a : A) -- The representing object. (C : A -> U) -- A type family. : ((z : A) -> hom A a z -> C z) -> C a := \\phi -> phi a (id-arr A a) -- The inverse map only exists for Segal types. #def yon (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. : C a -> ((z : A) -> hom A a z -> C z) := \\u z f -> covTrans A a z f C CisCov u The Yoneda composites It remains to show that the Yoneda maps are inverses. -- One retraction is straightforward: #def evid-yon (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (u : C a) : (evid A a C) ((yon A AisSegal a C CisCov) u) = u := covPresId A a C CisCov u The other composite carries phi to an a priori distinct natural transformation. We first show that these are pointwise equal at all x : A and f : hom A a x in two steps. -- The first step: #def yon-evid-partial (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) (f : hom A a x) : ((yon A AisSegal a C CisCov)((evid A a C) phi)) x f = (phi x (Segal-comp A AisSegal a a x (id-arr A a) f)) -- phi x f := covariant-representable-transformation-naturality A AisSegal a a x (id-arr A a) f C CisCov phi -- The second step: #def yon-evid-ap (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) (f : hom A a x) : (phi x (Segal-comp A AisSegal a a x (id-arr A a) f)) = phi x f := ap (hom A a x) (C x) (Segal-comp A AisSegal a a x (id-arr A a) f) f (phi x) (Segal-id-comp A AisSegal a x f) -- The composite yon-evid of phi equals phi at all x : A and f : hom A a x. #def yon-evid-twice-pointwise (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) (f : hom A a x) : ((yon A AisSegal a C CisCov)((evid A a C) phi)) x f = phi x f := concat (C x) (((yon A AisSegal a C CisCov)((evid A a C) phi)) x f) (phi x (Segal-comp A AisSegal a a x (id-arr A a) f)) (phi x f) (yon-evid-partial A AisSegal a C CisCov phi x f) (yon-evid-ap A AisSegal a C CisCov phi x f) -- By funext, these are equals as functions of f pointwise in x. #def yon-evid-once-pointwise (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) : ((yon A AisSegal a C CisCov)((evid A a C) phi)) x = phi x := funext (hom A a x) (\\f -> C x) (\\f -> ((yon A AisSegal a C CisCov)((evid A a C) phi)) x f) (\\f -> (phi x f)) (\\f -> yon-evid-twice-pointwise A AisSegal a C CisCov phi x f) -- By funext again, these are equal as functions of x and f. #def yon-evid (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. : ((yon A AisSegal a C CisCov)((evid A a C) phi)) = phi := funext A (\\x -> (hom A a x -> C x)) (\\x -> ((yon A AisSegal a C CisCov)((evid A a C) phi)) x) (\\x -> (phi x)) (\\x -> yon-evid-once-pointwise funext A AisSegal a C CisCov phi x) The Yoneda lemma The Yoneda lemma says that evaluation at the identity defines an equivalence. #def Yoneda-lemma (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. : isEquiv ((z : A) -> hom A a z -> C z) (C a) (evid A a C) := ((yon A AisSegal a C CisCov, yon-evid funext A AisSegal a C CisCov), (yon A AisSegal a C CisCov, evid-yon A AisSegal a C CisCov))","title":"The Yoneda Lemma"},{"location":"simplicial-hott/09-yoneda/#the-yoneda-lemma","text":"These formalisations correspond to Section 9 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"The Yoneda lemma"},{"location":"simplicial-hott/09-yoneda/#prerequisites","text":"hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 8-covariant.md - We use covariant type families.","title":"Prerequisites"},{"location":"simplicial-hott/09-yoneda/#natural-transformations-involving-a-representable-functor","text":"Fix a Segal type A and a term a : A. The Yoneda lemma characterizes natural transformations from the representable functor (hom A a) to a covariant type fmaily C. Ordinary, such a natural transformation would involve a family of maps (phi : (z : A) -> hom A a z -> C z) together with a proof of naturality of these components, but as is the case for covariant-transformation-naturality the naturality condition is automatic. -- This unfolds a composition triangle to a square with an identity component #def id-domain-square (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a x y : A) -- Three objects (g : hom A a x) (k : hom A x y) : (s : \u0394\u00b9) -> hom A a (k s) := \\s t -> recOR(t <= s |-> (id-comp-witness A a y (Segal-comp A AisSegal a x y g k)) (s , t), s <= t |-> (Segal-comp-witness A AisSegal a x y g k) (t , s)) #def covariant-representable-transformation-application (A : U) (AisSegal : isSegal A) (a x y : A) (f : hom A a x) (g : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (phi : (z : A) -> hom A a z -> C z) : dhomFrom A x y g C (phi x f) := (phi y (Segal-comp A AisSegal a x y f g), \\s -> phi (g s) (\\t -> (id-domain-square A AisSegal a x y f g s t))) #def covariant-representable-transformation-naturality (A : U) (AisSegal : isSegal A) (a x y : A) (f : hom A a x) (g : hom A x y) (C : A -> U) (CisCov : isCovFam A C) (phi : (z : A) -> hom A a z -> C z) : (covTrans A x y g C CisCov (phi x f)) = (phi y (Segal-comp A AisSegal a x y f g)) := covUniqueness A x y g C CisCov (phi x f) (covariant-representable-transformation-application A AisSegal a x y f g C CisCov phi)","title":"Natural transformations involving a representable functor"},{"location":"simplicial-hott/09-yoneda/#the-yoneda-maps","text":"For any Segal type A and term a : A, the Yoneda lemma provides an equivalence between the type (z : A) -> hom A a z -> C z of natural transformations out of the functor (hom A a) and valued in an arbitrary covariant family C and the type (C a). One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the covariant transport operation. -- The map evid evaluates a natural transformation -- out of a representable functor at the identity arrow. #def evid (A : U) -- The ambient type. (a : A) -- The representing object. (C : A -> U) -- A type family. : ((z : A) -> hom A a z -> C z) -> C a := \\phi -> phi a (id-arr A a) -- The inverse map only exists for Segal types. #def yon (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. : C a -> ((z : A) -> hom A a z -> C z) := \\u z f -> covTrans A a z f C CisCov u","title":"The Yoneda maps"},{"location":"simplicial-hott/09-yoneda/#the-yoneda-composites","text":"It remains to show that the Yoneda maps are inverses. -- One retraction is straightforward: #def evid-yon (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (u : C a) : (evid A a C) ((yon A AisSegal a C CisCov) u) = u := covPresId A a C CisCov u The other composite carries phi to an a priori distinct natural transformation. We first show that these are pointwise equal at all x : A and f : hom A a x in two steps. -- The first step: #def yon-evid-partial (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) (f : hom A a x) : ((yon A AisSegal a C CisCov)((evid A a C) phi)) x f = (phi x (Segal-comp A AisSegal a a x (id-arr A a) f)) -- phi x f := covariant-representable-transformation-naturality A AisSegal a a x (id-arr A a) f C CisCov phi -- The second step: #def yon-evid-ap (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) (f : hom A a x) : (phi x (Segal-comp A AisSegal a a x (id-arr A a) f)) = phi x f := ap (hom A a x) (C x) (Segal-comp A AisSegal a a x (id-arr A a) f) f (phi x) (Segal-id-comp A AisSegal a x f) -- The composite yon-evid of phi equals phi at all x : A and f : hom A a x. #def yon-evid-twice-pointwise (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) (f : hom A a x) : ((yon A AisSegal a C CisCov)((evid A a C) phi)) x f = phi x f := concat (C x) (((yon A AisSegal a C CisCov)((evid A a C) phi)) x f) (phi x (Segal-comp A AisSegal a a x (id-arr A a) f)) (phi x f) (yon-evid-partial A AisSegal a C CisCov phi x f) (yon-evid-ap A AisSegal a C CisCov phi x f) -- By funext, these are equals as functions of f pointwise in x. #def yon-evid-once-pointwise (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. (x : A) : ((yon A AisSegal a C CisCov)((evid A a C) phi)) x = phi x := funext (hom A a x) (\\f -> C x) (\\f -> ((yon A AisSegal a C CisCov)((evid A a C) phi)) x f) (\\f -> (phi x f)) (\\f -> yon-evid-twice-pointwise A AisSegal a C CisCov phi x f) -- By funext again, these are equal as functions of x and f. #def yon-evid (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. (phi : (z : A) -> hom A a z -> C z) -- A natural transformation. : ((yon A AisSegal a C CisCov)((evid A a C) phi)) = phi := funext A (\\x -> (hom A a x -> C x)) (\\x -> ((yon A AisSegal a C CisCov)((evid A a C) phi)) x) (\\x -> (phi x)) (\\x -> yon-evid-once-pointwise funext A AisSegal a C CisCov phi x)","title":"The Yoneda composites"},{"location":"simplicial-hott/09-yoneda/#the-yoneda-lemma_1","text":"The Yoneda lemma says that evaluation at the identity defines an equivalence. #def Yoneda-lemma (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a : A) -- The representing object. (C : A -> U) -- A type family. (CisCov : isCovFam A C) -- A covariant family. : isEquiv ((z : A) -> hom A a z -> C z) (C a) (evid A a C) := ((yon A AisSegal a C CisCov, yon-evid funext A AisSegal a C CisCov), (yon A AisSegal a C CisCov, evid-yon A AisSegal a C CisCov))","title":"The Yoneda lemma"},{"location":"simplicial-hott/10-rezk-types/","text":"Rezk types This is a literate rzk file: #lang rzk-1 #def isRetr (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) (g : hom A y x) : U := (Segal-comp A AisSegal x y x f g) =_{hom A x x} (id-arr A x) #def Retr (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) : U := \u2211 (g : hom A y x), (isRetr A AisSegal x y f g) #def isSec (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) (h : hom A y x) : U := (Segal-comp A AisSegal x y x f h) =_{hom A x x} (id-arr A x) #def Sec (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) : U := \u2211 (h : hom A y x), (isSec A AisSegal x y f h) #def isIso (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) : U := prod (Retr A AisSegal x y f) (Sec A AisSegal x y f) #def isBiinvertible (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) : U := \u2211 (g : hom A y x), prod (isRetr A AisSegal x y f g) (isSec A AisSegal x y f g) #def biinv-iso (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) : (isBiinvertible A AisSegal x y f) -> (isIso A AisSegal x y f) := (\\(g, (p, q)) -> ((g, p), (g, q)))","title":"Rezk types"},{"location":"simplicial-hott/10-rezk-types/#rezk-types","text":"This is a literate rzk file: #lang rzk-1 #def isRetr (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) (g : hom A y x) : U := (Segal-comp A AisSegal x y x f g) =_{hom A x x} (id-arr A x) #def Retr (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) : U := \u2211 (g : hom A y x), (isRetr A AisSegal x y f g) #def isSec (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) (h : hom A y x) : U := (Segal-comp A AisSegal x y x f h) =_{hom A x x} (id-arr A x) #def Sec (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) : U := \u2211 (h : hom A y x), (isSec A AisSegal x y f h) #def isIso (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) : U := prod (Retr A AisSegal x y f) (Sec A AisSegal x y f) #def isBiinvertible (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) : U := \u2211 (g : hom A y x), prod (isRetr A AisSegal x y f g) (isSec A AisSegal x y f g) #def biinv-iso (A : U) (AisSegal : isSegal A) (x y : A) (f : hom A x y) : (isBiinvertible A AisSegal x y f) -> (isIso A AisSegal x y f) := (\\(g, (p, q)) -> ((g, p), (g, q)))","title":"Rezk types"},{"location":"simplicial-hott/12-cocartesian/","text":"Cocartesian families These formalizations capture cocartesian families as treated in BW23. The goal, for now, is not to give a general structural account as in the paper but ratger to provide the definitions and results that are necessary to prove the cocartesian Yoneda Lemma. This is a literate rzk file: #lang rzk-1 Prerequisites hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 8-covariant.md - We use covariant type families. Type of fiberwise Segal families over a base type #def innerFam (B : U) : U := (\u2211(P : B -> U), (b : B) -> (isSegal (P b))) Definition of cocartesian lifts -- [BW23, Definition 5.1.1] -- the proposition that a dependent arrow in a family is cocartesian -- (alternative version using unpacked extension types because this is preferred for usage) #def isCocartArr (B : U) (b b' : B) (u : hom B b b') (P : B -> U) (e : P b) (e' : P b') (f : dhom B b b' u P e e') : U := (b'' : B) -> (v : hom B b' b'') -> (w : hom B b b'') -> (sigma : hom2 B b b' b'' u v w) -> (e'' : P b'') -> (h : dhom B b b'' w P e e'') -> isContr (\u2211(g : dhom B b' b'' v P e' e''), (dhom2 B b b' b'' u v w sigma P e e' e'' f g h)) Definition of cocartesian lifts -- [BW23, Definition 5.1.2] -- the type of cocartesian lifts of a fixed arrow in the base with a given starting point in the fiber #def CocartLift (B : U) (b b' : B) (u : hom B b b') (P : B -> U) (e : P b) : U := \u2211(e' : P b'), \u2211(f : dhom B b b' u P e e'), isCocartArr B b b' u P e e' f def isInitial (A : U) (a : U) : U := (x : A) -> isContr(hom A a x) def initial-unique (A : U) : isProp(\u2211(a : A), isInitial A a) := \\a -> \\b ->","title":"Cocartesian Families"},{"location":"simplicial-hott/12-cocartesian/#cocartesian-families","text":"These formalizations capture cocartesian families as treated in BW23. The goal, for now, is not to give a general structural account as in the paper but ratger to provide the definitions and results that are necessary to prove the cocartesian Yoneda Lemma. This is a literate rzk file: #lang rzk-1","title":"Cocartesian families"},{"location":"simplicial-hott/12-cocartesian/#prerequisites","text":"hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 8-covariant.md - We use covariant type families.","title":"Prerequisites"},{"location":"simplicial-hott/12-cocartesian/#type-of-fiberwise-segal-families-over-a-base-type","text":"#def innerFam (B : U) : U := (\u2211(P : B -> U), (b : B) -> (isSegal (P b)))","title":"Type of fiberwise Segal families over a base type"},{"location":"simplicial-hott/12-cocartesian/#definition-of-cocartesian-lifts","text":"-- [BW23, Definition 5.1.1] -- the proposition that a dependent arrow in a family is cocartesian -- (alternative version using unpacked extension types because this is preferred for usage) #def isCocartArr (B : U) (b b' : B) (u : hom B b b') (P : B -> U) (e : P b) (e' : P b') (f : dhom B b b' u P e e') : U := (b'' : B) -> (v : hom B b' b'') -> (w : hom B b b'') -> (sigma : hom2 B b b' b'' u v w) -> (e'' : P b'') -> (h : dhom B b b'' w P e e'') -> isContr (\u2211(g : dhom B b' b'' v P e' e''), (dhom2 B b b' b'' u v w sigma P e e' e'' f g h))","title":"Definition of cocartesian lifts"},{"location":"simplicial-hott/12-cocartesian/#definition-of-cocartesian-lifts_1","text":"-- [BW23, Definition 5.1.2] -- the type of cocartesian lifts of a fixed arrow in the base with a given starting point in the fiber #def CocartLift (B : U) (b b' : B) (u : hom B b b') (P : B -> U) (e : P b) : U := \u2211(e' : P b'), \u2211(f : dhom B b b' u P e e'), isCocartArr B b b' u P e e' f","title":"Definition of cocartesian lifts"},{"location":"simplicial-hott/12-cocartesian/#def-isinitial","text":"(A : U) (a : U) : U := (x : A) -> isContr(hom A a x)","title":"def isInitial"},{"location":"simplicial-hott/12-cocartesian/#def-initial-unique","text":"(A : U) : isProp(\u2211(a : A), isInitial A a) := \\a -> \\b ->","title":"def initial-unique"}]}