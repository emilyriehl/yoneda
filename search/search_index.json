{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yoneda for \u221e-categories \u00b6 This is a formalization library for simplicial Homotopy Type Theory (HoTT) with the aim of proving the Yoneda lemma for \u221e-categories following the paper \" A type theory for synthetic \u221e-categories \" [1]. This formalization project could be regarded as a companion to the article \" Could \u221e-category theory be taught to undergraduates? \" [2]. The formalizations are implemented using rzk , an experimental proof assistant for a variant of type theory with shapes developed by Nikolai Kudasov . Formalizations were contributed by Fredrik Bakke , Nikolai Kudasov , Emily Riehl , and Jonathan Weinberger . Our source files are available on github . Another aim of this project is to compare the proof of the Yoneda lemma for \u221e-categories in simplicial HoTT with proofs of the Yoneda lemma for 1-categories in other proof assistants. To that end Sina Hazratpour has contributed a formalization in Lean3 extracted from materials he prepared to teach Introduction to Proofs at Johns Hopkins, which can be found here . We also contributed a proof of the Yoneda lemma for precategories to the Agda-Unimath library. Here we prove the Yoneda lemma for pre-\u221e-categories, since the univalence/completeness condition is not required for this result. By analogy, precategories are the non-univalent 1-categories in HoTT. Checking the Formalisations Locally \u00b6 Install the rzk proof assistant. Then run the following command from the root of our repository : rzk typecheck src/hott/* src/simplicial-hott/* References \u00b6 Emily Riehl & Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 Emily Riehl. Could \u221e-category theory be taught to undergraduates? Notices of the AMS. May 2023. https://www.ams.org/journals/notices/202305/noti2692/noti2692.html","title":"About"},{"location":"#yoneda-for-categories","text":"This is a formalization library for simplicial Homotopy Type Theory (HoTT) with the aim of proving the Yoneda lemma for \u221e-categories following the paper \" A type theory for synthetic \u221e-categories \" [1]. This formalization project could be regarded as a companion to the article \" Could \u221e-category theory be taught to undergraduates? \" [2]. The formalizations are implemented using rzk , an experimental proof assistant for a variant of type theory with shapes developed by Nikolai Kudasov . Formalizations were contributed by Fredrik Bakke , Nikolai Kudasov , Emily Riehl , and Jonathan Weinberger . Our source files are available on github . Another aim of this project is to compare the proof of the Yoneda lemma for \u221e-categories in simplicial HoTT with proofs of the Yoneda lemma for 1-categories in other proof assistants. To that end Sina Hazratpour has contributed a formalization in Lean3 extracted from materials he prepared to teach Introduction to Proofs at Johns Hopkins, which can be found here . We also contributed a proof of the Yoneda lemma for precategories to the Agda-Unimath library. Here we prove the Yoneda lemma for pre-\u221e-categories, since the univalence/completeness condition is not required for this result. By analogy, precategories are the non-univalent 1-categories in HoTT.","title":"Yoneda for \u221e-categories"},{"location":"#checking-the-formalisations-locally","text":"Install the rzk proof assistant. Then run the following command from the root of our repository : rzk typecheck src/hott/* src/simplicial-hott/*","title":"Checking the Formalisations Locally"},{"location":"#references","text":"Emily Riehl & Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 Emily Riehl. Could \u221e-category theory be taught to undergraduates? Notices of the AMS. May 2023. https://www.ams.org/journals/notices/202305/noti2692/noti2692.html","title":"References"},{"location":"hott/00-common.rzk/","text":"0. Common \u00b6 This is a literate rzk file: #lang rzk-1 products of types \u00b6 #def product ( A B : U) : U := \u03a3 ( x : A) , B The following demonstrates the syntax for constructing terms in Sigma types: #def diagonal ( A : U) ( a : A) : product A A := (a , a) The type of logical equivalences between types \u00b6 #def iff ( A B : U) : U := product (A \u2192 B) (B \u2192 A) Basic function definitions \u00b6 #section basic-functions #variables A B C D : U #def comp ( g : B \u2192 C) ( f : A \u2192 B) : A \u2192 C := \\ z \u2192 g (f z) #def triple-comp ( h : C \u2192 D) ( g : B \u2192 C) ( f : A \u2192 B) : A \u2192 D := \\ z \u2192 h (g (f z)) #def identity : A \u2192 A := \\ a \u2192 a #def constant ( b : B) : A \u2192 B := \\ a \u2192 b #end basic-functions Substitution \u00b6 Reindexing a type family along a function into the base type #def reindex ( A B : U) ( f : B \u2192 A) ( C : A \u2192 U) : B \u2192 U := \\ b \u2192 C (f b)","title":"Common"},{"location":"hott/00-common.rzk/#0-common","text":"This is a literate rzk file: #lang rzk-1","title":"0. Common"},{"location":"hott/00-common.rzk/#products-of-types","text":"#def product ( A B : U) : U := \u03a3 ( x : A) , B The following demonstrates the syntax for constructing terms in Sigma types: #def diagonal ( A : U) ( a : A) : product A A := (a , a)","title":"products of types"},{"location":"hott/00-common.rzk/#the-type-of-logical-equivalences-between-types","text":"#def iff ( A B : U) : U := product (A \u2192 B) (B \u2192 A)","title":"The type of logical equivalences between types"},{"location":"hott/00-common.rzk/#basic-function-definitions","text":"#section basic-functions #variables A B C D : U #def comp ( g : B \u2192 C) ( f : A \u2192 B) : A \u2192 C := \\ z \u2192 g (f z) #def triple-comp ( h : C \u2192 D) ( g : B \u2192 C) ( f : A \u2192 B) : A \u2192 D := \\ z \u2192 h (g (f z)) #def identity : A \u2192 A := \\ a \u2192 a #def constant ( b : B) : A \u2192 B := \\ a \u2192 b #end basic-functions","title":"Basic function definitions"},{"location":"hott/00-common.rzk/#substitution","text":"Reindexing a type family along a function into the base type #def reindex ( A B : U) ( f : B \u2192 A) ( C : A \u2192 U) : B \u2192 U := \\ b \u2192 C (f b)","title":"Substitution"},{"location":"hott/01-paths.rzk/","text":"1. Paths \u00b6 This is a literate rzk file: #lang rzk-1 Path induction \u00b6 We define path induction in terms of the built-in J rule, so that we can apply it like any other function. #define ind-path ( A : U) ( a : A) ( C : ( x : A) -> (a = x) -> U) ( d : C a refl ) ( x : A) ( p : a = x) : C x p := idJ (A , a , C , d , x , p) Some basic path algebra \u00b6 #section path-algebra #variable A : U #variables x y z : A Path reversal \u00b6 #def rev ( p : x = y) : y = x := ind-path (A) (x) ( \\ y' p' \u2192 y' = x) ( refl ) (y) (p) Path concatenation \u00b6 We take path concatenation defined by induction on the second path variable as our main definition. #def concat ( p : x = y) ( q : y = z) : (x = z) := ind-path (A) (y) ( \\ z' q' \u2192 (x = z')) (p) (z) (q) We also introduce a version defined by induction on the first path variable, for situations where it is easier to induct on the first path. #def concat' ( p : x = y) : (y = z) \u2192 (x = z) := ind-path (A) (x) ( \\ y' p' \u2192 (y' = z) \u2192 (x = z)) ( \\ q' \u2192 q') (y) (p) #end path-algebra Some basic coherences in path algebra \u00b6 #section basic-path-coherence #variable A : U #variables w x y z : A #def rev-rev ( p : x = y) : (rev A y x (rev A x y p)) = p := ind-path (A) (x) ( \\ y' p' \u2192 (rev A y' x (rev A x y' p')) = p') ( refl ) (y) (p) Left unit law for path concatenation \u00b6 The left unit law for path concatenation does not hold definitionally due to our choice of definition. #def left-unit-concat ( p : x = y) : (concat A x x y refl p) = p := ind-path (A) (x) ( \\ y' p' \u2192 (concat A x x y' refl p') = p') ( refl ) (y) (p) Associativity of path concatenation \u00b6 #def associative-concat ( p : w = x) ( q : x = y) ( r : y = z) : ( concat A w y z (concat A w x y p q) r) = ( concat A w x z p (concat A x y z q r)) := ind-path ( A) ( y) ( \\ z' r' \u2192 concat A w y z' (concat A w x y p q) r' = concat A w x z' p (concat A x y z' q r')) ( refl ) ( z) ( r) #def rev-associative-concat ( p : w = x) ( q : x = y) ( r : y = z) : ( concat A w x z p (concat A x y z q r)) = ( concat A w y z (concat A w x y p q) r) := ind-path ( A) ( y) ( \\ z' r' \u2192 concat A w x z' p (concat A x y z' q r') = concat A w y z' (concat A w x y p q) r') ( refl ) ( z) ( r) #def right-inverse-concat ( p : x = y) : (concat A x y x p (rev A x y p)) = refl := ind-path ( A) ( x) ( \\ y' p' \u2192 concat A x y' x p' (rev A x y' p') = refl ) ( refl ) ( y) ( p) #def left-inverse-concat ( p : x = y) : (concat A y x y (rev A x y p) p) = refl := ind-path ( A) ( x) ( \\ y' p' \u2192 concat A y' x y' (rev A x y' p') p' = refl ) ( refl ) ( y) ( p) Concatenation of two paths with common codomain \u00b6 Concatenation of two paths with common codomain; defined using concat and rev . #def zig-zag-concat ( p : x = y) ( q : z = y) : (x = z) := concat A x y z p (rev A z y q) Concatenation of two paths with common domain \u00b6 Concatenation of two paths with common domain; defined using concat and rev . #def zag-zig-concat ( p : y = x) ( q : y = z) : (x = z) := concat A x y z (rev A y x p) q #def right-cancel-concat ( p q : x = y) ( r : y = z) : ((concat A x y z p r) = (concat A x y z q r)) \u2192 (p = q) := ind-path ( A) ( y) ( \\ z' r' \u2192 ((concat A x y z' p r') = (concat A x y z' q r')) \u2192 (p = q)) ( \\ H \u2192 H) ( z) ( r) #end basic-path-coherence Some derived coherences in path algebra \u00b6 The statements or proofs of the following path algebra coherences reference one of the path algebra coherences defined above. #section derived-path-coherence #variable A : U #variables x y z : A #def rev-concat ( p : x = y) ( q : y = z) : ( rev A x z (concat A x y z p q)) = ( concat A z y x (rev A y z q) (rev A x y p)) := ind-path ( A) ( y) ( \\ z' q' \u2192 (rev A x z' (concat A x y z' p q')) = (concat A z' y x (rev A y z' q') (rev A x y p))) ( rev ( y = x) ( concat A y y x refl (rev A x y p)) ( rev A x y p) ( left-unit-concat A y x (rev A x y p))) ( z) ( q) Postwhiskering paths of paths \u00b6 #def concat-eq-left ( p q : x = y) ( H : p = q) ( r : y = z) : (concat A x y z p r) = (concat A x y z q r) := ind-path ( A) ( y) ( \\ z' r' \u2192 (concat A x y z' p r') = (concat A x y z' q r')) ( H) ( z) ( r) Prewhiskering paths of paths \u00b6 Prewhiskering paths of paths is much harder. #def concat-eq-right ( p : x = y) : ( q : y = z) \u2192 ( r : y = z) \u2192 ( H : q = r) \u2192 ( concat A x y z p q) = (concat A x y z p r) := ind-path ( A) ( x) ( \\ y' p' \u2192 ( q : y' = z) \u2192 ( r : y' = z) \u2192 ( H : q = r) \u2192 ( concat A x y' z p' q) = (concat A x y' z p' r)) ( \\ q r H \u2192 concat ( x = z) ( concat A x x z refl q) ( r) ( concat A x x z refl r) ( concat (x = z) (concat A x x z refl q) q r (left-unit-concat A x z q) H) ( rev (x = z) (concat A x x z refl r) r (left-unit-concat A x z r))) ( y) ( p) Identifying the two definitions of path concatenation \u00b6 #def concat-concat' ( p : x = y) : ( q : y = z) \u2192 ( concat A x y z p q) = (concat' A x y z p q) := ind-path ( A) ( x) ( \\ y' p' \u2192 (q' : y' =_{A} z) \u2192 (concat A x y' z p' q') =_{x =_{A} z} concat' A x y' z p' q') ( \\ q' \u2192 left-unit-concat A x z q') ( y) ( p) #def concat'-concat ( p : x = y) ( q : y = z) : concat' A x y z p q = concat A x y z p q := rev ( x = z) ( concat A x y z p q) ( concat' A x y z p q) ( concat-concat' p q) This is easier to prove for concat' than for concat . #def alt-triangle-rotation ( p : x = z) ( q : x = y) : ( r : y = z) \u2192 ( H : p = concat' A x y z q r) \u2192 ( concat' A y x z (rev A x y q) p) = r := ind-path ( A) ( x) ( \\ y' q' \u2192 ( r' : y' =_{A} z) \u2192 ( H' : p = concat' A x y' z q' r') \u2192 ( concat' A y' x z (rev A x y' q') p) = r') ( \\ r' H' \u2192 H') ( y) ( q) The following needs to be outside the previous section because of the usage of concat-concat' A y x . #end derived-path-coherence #def triangle-rotation ( A : U) ( x y z : A) ( p : x = z) ( q : x = y) ( r : y = z) ( H : p = concat A x y z q r) : (concat A y x z (rev A x y q) p) = r := concat ( y = z) ( concat A y x z (rev A x y q) p) ( concat' A y x z (rev A x y q) p) ( r) ( concat-concat' A y x z (rev A x y q) p) ( alt-triangle-rotation ( A) (x) (y) (z) (p) (q) (r) ( concat ( x = z) ( p) ( concat A x y z q r) ( concat' A x y z q r) ( H) ( concat-concat' A x y z q r))) Application of functions to paths \u00b6 #def ap ( A B : U) ( x y : A) ( f : A \u2192 B) ( p : x = y) : (f x = f y) := ind-path (A) (x) ( \\ y' p' \u2192 (f x = f y')) ( refl ) (y) (p) #def ap-rev ( A B : U) ( x y : A) ( f : A \u2192 B) ( p : x = y) : (ap A B y x f (rev A x y p)) = (rev B (f x) (f y) (ap A B x y f p)) := ind-path ( A) ( x) ( \\ y' p' \u2192 ap A B y' x f (rev A x y' p') = rev B (f x) (f y') (ap A B x y' f p')) ( refl ) ( y) ( p) #def ap-concat ( A B : U) ( x y z : A) ( f : A \u2192 B) ( p : x = y) ( q : y = z) : ( ap A B x z f (concat A x y z p q)) = ( concat B (f x) (f y) (f z) (ap A B x y f p) (ap A B y z f q)) := ind-path ( A) ( y) ( \\ z' q' \u2192 ( ap A B x z' f (concat A x y z' p q')) = ( concat B (f x) (f y) (f z') (ap A B x y f p) (ap A B y z' f q'))) ( refl ) ( z) ( q) #def rev-ap-rev ( A B : U) ( x y : A) ( f : A \u2192 B) ( p : x = y) : (rev B (f y) (f x) (ap A B y x f (rev A x y p))) = (ap A B x y f p) := ind-path ( A) ( x) ( \\ y' p' \u2192 (rev B (f y') (f x) (ap A B y' x f (rev A x y' p'))) = (ap A B x y' f p')) ( refl ) ( y) ( p) The following is for a specific use. #def concat-ap-rev-ap-id ( A B : U) ( x y : A) ( f : A \u2192 B) ( p : x = y) : ( concat ( B) (f y) (f x) (f y) ( ap A B y x f (rev A x y p)) ( ap A B x y f p)) = ( refl ) := ind-path ( A) ( x) ( \\ y' p' \u2192 ( concat ( B) (f y') (f x) (f y') ( ap A B y' x f (rev A x y' p')) (ap A B x y' f p')) = ( refl )) ( refl ) ( y) ( p) #def ap-id ( A : U) ( x y : A) ( p : x = y) : (ap A A x y (identity A) p) = p := ind-path (A) (x) ( \\ y' p' \u2192 (ap A A x y' ( \\ z \u2192 z) p') = p') ( refl ) (y) (p) Application of a function to homotopic paths yields homotopic paths. #def ap-eq ( A B : U) ( x y : A) ( f : A \u2192 B) ( p q : x = y) ( H : p = q) : (ap A B x y f p) = (ap A B x y f q) := ind-path ( x = y) ( p) ( \\ q' H' \u2192 (ap A B x y f p) = (ap A B x y f q')) ( refl ) ( q) ( H) #def ap-comp ( A B C : U) ( x y : A) ( f : A \u2192 B) ( g : B \u2192 C) ( p : x = y) : ( ap A C x y (comp A B C g f) p) = ( ap B C (f x) (f y) g (ap A B x y f p)) := ind-path ( A) ( x) ( \\ y' p' \u2192 ( ap A C x y' ( \\ z \u2192 g (f z)) p') = ( ap B C (f x) (f y') g (ap A B x y' f p'))) ( refl ) ( y) ( p) #def rev-ap-comp ( A B C : U) ( x y : A) ( f : A \u2192 B) ( g : B \u2192 C) ( p : x = y) : ( ap B C (f x) (f y) g (ap A B x y f p)) = ( ap A C x y (comp A B C g f) p) := rev ( g (f x) = g (f y)) ( ap A C x y ( \\ z \u2192 g (f z)) p) ( ap B C (f x) (f y) g (ap A B x y f p)) ( ap-comp A B C x y f g p) Transport \u00b6 #section transport #variable A : U #variable B : A \u2192 U Transport in a type family along a path in the base \u00b6 #def transport ( x y : A) ( p : x = y) ( u : B x) : B y := ind-path (A) (x) ( \\ y' p' \u2192 B y') (u) (y) (p) The lift of a base path to a path from a term in the total space to its transport \u00b6 #def transport-lift ( x y : A) ( p : x = y) ( u : B x) : (x , u) =_{ \u03a3 ( z : A) , B z} (y , transport x y p u) := ind-path ( A) ( x) ( \\ y' p' \u2192 (x , u) =_{ \u03a3 ( z : A) , B z} (y' , transport x y' p' u)) ( refl ) ( y) ( p) Transport along concatenated paths \u00b6 #def transport-concat ( x y z : A) ( p : x = y) ( q : y = z) ( u : B x) : ( transport x z (concat A x y z p q) u) = ( transport y z q (transport x y p u)) := ind-path ( A) ( y) ( \\ z' q' \u2192 ( transport x z' (concat A x y z' p q') u) = ( transport y z' q' (transport x y p u))) ( refl ) ( z) ( q) #def transport-concat-rev ( x y z : A) ( p : x = y) ( q : y = z) ( u : B x) : ( transport y z q (transport x y p u)) = ( transport x z (concat A x y z p q) u) := ind-path ( A) ( y) ( \\ z' q' \u2192 ( transport y z' q' (transport x y p u)) = ( transport x z' (concat A x y z' p q') u)) ( refl ) ( z) ( q) Transport along homotopic paths \u00b6 #def transport2 ( x y : A) ( p q : x = y) ( H : p = q) ( u : B x) : (transport x y p u) = (transport x y q u) := ind-path ( x = y) ( p) ( \\ q' H' \u2192 (transport x y p u) = (transport x y q' u)) ( refl ) ( q) ( H) Transport along a loop \u00b6 #def transport-loop ( a : A) ( b : B a) : (a = a) \u2192 B a := \\ p \u2192 (transport a a p b) #end transport Dependent application \u00b6 #def apd ( A : U) ( B : A \u2192 U) ( x y : A) ( f : ( z : A) \u2192 B z) ( p : x = y) : (transport A B x y p (f x)) = f y := ind-path ( A) ( x) ( ( \\ y' p' \u2192 (transport A B x y' p' (f x)) = f y')) ( refl ) ( y) ( p) Higher-order concatenation \u00b6 For convenience, we record lemmas for higher-order concatenation here. #section higher-concatenation #variable A : U #def triple-concat ( a0 a1 a2 a3 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) : a0 = a3 := concat A a0 a1 a3 p1 (concat A a1 a2 a3 p2 p3) #def quadruple-concat ( a0 a1 a2 a3 a4 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) ( p4 : a3 = a4) : a0 = a4 := triple-concat a0 a1 a2 a4 p1 p2 (concat A a2 a3 a4 p3 p4) #def quintuple-concat ( a0 a1 a2 a3 a4 a5 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) ( p4 : a3 = a4) ( p5 : a4 = a5) : a0 = a5 := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5) #def alternating-quintuple-concat ( a0 : A) ( a1 : A) ( p1 : a0 = a1) ( a2 : A) ( p2 : a1 = a2) ( a3 : A) ( p3 : a2 = a3) ( a4 : A) ( p4 : a3 = a4) ( a5 : A) ( p5 : a4 = a5) : a0 = a5 := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5) #def 12ary-concat ( a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) ( p4 : a3 = a4) ( p5 : a4 = a5) ( p6 : a5 = a6) ( p7 : a6 = a7) ( p8 : a7 = a8) ( p9 : a8 = a9) ( p10 : a9 = a10) ( p11 : a10 = a11) ( p12 : a11 = a12) : a0 = a12 := quintuple-concat a0 a1 a2 a3 a4 a12 p1 p2 p3 p4 ( quintuple-concat a4 a5 a6 a7 a8 a12 p5 p6 p7 p8 ( quadruple-concat a8 a9 a10 a11 a12 p9 p10 p11 p12)) The following is the same as above but with alternating arguments. #def alternating-12ary-concat ( a0 : A) ( a1 : A) ( p1 : a0 = a1) ( a2 : A) ( p2 : a1 = a2) ( a3 : A) ( p3 : a2 = a3) ( a4 : A) ( p4 : a3 = a4) ( a5 : A) ( p5 : a4 = a5) ( a6 : A) ( p6 : a5 = a6) ( a7 : A) ( p7 : a6 = a7) ( a8 : A) ( p8 : a7 = a8) ( a9 : A) ( p9 : a8 = a9) ( a10 : A) ( p10 : a9 = a10) ( a11 : A) ( p11 : a10 = a11) ( a12 : A) ( p12 : a11 = a12) : a0 = a12 := 12ary-concat a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 #end higher-concatenation Higher-order coherences \u00b6 #def rev-refl-id-triple-concat ( A : U) ( x y : A) ( p : x = y) : triple-concat A y x x y (rev A x y p) refl p = refl := ind-path ( A) ( x) ( \\ y' p' \u2192 triple-concat A y' x x y' (rev A x y' p') refl p' = refl ) ( refl ) ( y) ( p) #def ap-rev-refl-id-triple-concat ( A B : U) ( x y : A) ( f : A \u2192 B) ( p : x = y) : (ap A B y y f (triple-concat A y x x y (rev A x y p) refl p)) = refl := ind-path ( A) ( x) ( \\ y' p' \u2192 ( ap A B y' y' f (triple-concat A y' x x y' (rev A x y' p') refl p')) = ( refl )) ( refl ) ( y) ( p) #def ap-triple-concat ( A B : U) ( w x y z : A) ( f : A \u2192 B) ( p : w = x) ( q : x = y) ( r : y = z) : ( ap A B w z f (triple-concat A w x y z p q r)) = ( triple-concat ( B) ( f w) ( f x) ( f y) ( f z) ( ap A B w x f p) ( ap A B x y f q) ( ap A B y z f r)) := ind-path ( A) ( y) ( \\ z' r' \u2192 ( ap A B w z' f (triple-concat A w x y z' p q r')) = ( triple-concat ( B) ( f w) (f x) (f y) (f z') ( ap A B w x f p) ( ap A B x y f q) ( ap A B y z' f r'))) ( ap-concat A B w x y f p q) ( z) ( r) #def triple-concat-eq-first ( A : U) ( w x y z : A) ( p q : w = x) ( r : x = y) ( s : y = z) ( H : p = q) : (triple-concat A w x y z p r s) = (triple-concat A w x y z q r s) := concat-eq-left A w x z p q H (concat A x y z r s) #def triple-concat-eq-second ( A : U) ( w x y z : A) ( p : w = x) ( q r : x = y) ( s : y = z) ( H : q = r) : (triple-concat A w x y z p q s) = (triple-concat A w x y z p r s) := ind-path ( x = y) ( q) ( \\ r' H' \u2192 triple-concat A w x y z p q s = triple-concat A w x y z p r' s) ( refl ) ( r) ( H)","title":"Paths"},{"location":"hott/01-paths.rzk/#1-paths","text":"This is a literate rzk file: #lang rzk-1","title":"1. Paths"},{"location":"hott/01-paths.rzk/#path-induction","text":"We define path induction in terms of the built-in J rule, so that we can apply it like any other function. #define ind-path ( A : U) ( a : A) ( C : ( x : A) -> (a = x) -> U) ( d : C a refl ) ( x : A) ( p : a = x) : C x p := idJ (A , a , C , d , x , p)","title":"Path induction"},{"location":"hott/01-paths.rzk/#some-basic-path-algebra","text":"#section path-algebra #variable A : U #variables x y z : A","title":"Some basic path algebra"},{"location":"hott/01-paths.rzk/#path-reversal","text":"#def rev ( p : x = y) : y = x := ind-path (A) (x) ( \\ y' p' \u2192 y' = x) ( refl ) (y) (p)","title":"Path reversal"},{"location":"hott/01-paths.rzk/#path-concatenation","text":"We take path concatenation defined by induction on the second path variable as our main definition. #def concat ( p : x = y) ( q : y = z) : (x = z) := ind-path (A) (y) ( \\ z' q' \u2192 (x = z')) (p) (z) (q) We also introduce a version defined by induction on the first path variable, for situations where it is easier to induct on the first path. #def concat' ( p : x = y) : (y = z) \u2192 (x = z) := ind-path (A) (x) ( \\ y' p' \u2192 (y' = z) \u2192 (x = z)) ( \\ q' \u2192 q') (y) (p) #end path-algebra","title":"Path concatenation"},{"location":"hott/01-paths.rzk/#some-basic-coherences-in-path-algebra","text":"#section basic-path-coherence #variable A : U #variables w x y z : A #def rev-rev ( p : x = y) : (rev A y x (rev A x y p)) = p := ind-path (A) (x) ( \\ y' p' \u2192 (rev A y' x (rev A x y' p')) = p') ( refl ) (y) (p)","title":"Some basic coherences in path algebra"},{"location":"hott/01-paths.rzk/#left-unit-law-for-path-concatenation","text":"The left unit law for path concatenation does not hold definitionally due to our choice of definition. #def left-unit-concat ( p : x = y) : (concat A x x y refl p) = p := ind-path (A) (x) ( \\ y' p' \u2192 (concat A x x y' refl p') = p') ( refl ) (y) (p)","title":"Left unit law for path concatenation"},{"location":"hott/01-paths.rzk/#associativity-of-path-concatenation","text":"#def associative-concat ( p : w = x) ( q : x = y) ( r : y = z) : ( concat A w y z (concat A w x y p q) r) = ( concat A w x z p (concat A x y z q r)) := ind-path ( A) ( y) ( \\ z' r' \u2192 concat A w y z' (concat A w x y p q) r' = concat A w x z' p (concat A x y z' q r')) ( refl ) ( z) ( r) #def rev-associative-concat ( p : w = x) ( q : x = y) ( r : y = z) : ( concat A w x z p (concat A x y z q r)) = ( concat A w y z (concat A w x y p q) r) := ind-path ( A) ( y) ( \\ z' r' \u2192 concat A w x z' p (concat A x y z' q r') = concat A w y z' (concat A w x y p q) r') ( refl ) ( z) ( r) #def right-inverse-concat ( p : x = y) : (concat A x y x p (rev A x y p)) = refl := ind-path ( A) ( x) ( \\ y' p' \u2192 concat A x y' x p' (rev A x y' p') = refl ) ( refl ) ( y) ( p) #def left-inverse-concat ( p : x = y) : (concat A y x y (rev A x y p) p) = refl := ind-path ( A) ( x) ( \\ y' p' \u2192 concat A y' x y' (rev A x y' p') p' = refl ) ( refl ) ( y) ( p)","title":"Associativity of path concatenation"},{"location":"hott/01-paths.rzk/#concatenation-of-two-paths-with-common-codomain","text":"Concatenation of two paths with common codomain; defined using concat and rev . #def zig-zag-concat ( p : x = y) ( q : z = y) : (x = z) := concat A x y z p (rev A z y q)","title":"Concatenation of two paths with common codomain"},{"location":"hott/01-paths.rzk/#concatenation-of-two-paths-with-common-domain","text":"Concatenation of two paths with common domain; defined using concat and rev . #def zag-zig-concat ( p : y = x) ( q : y = z) : (x = z) := concat A x y z (rev A y x p) q #def right-cancel-concat ( p q : x = y) ( r : y = z) : ((concat A x y z p r) = (concat A x y z q r)) \u2192 (p = q) := ind-path ( A) ( y) ( \\ z' r' \u2192 ((concat A x y z' p r') = (concat A x y z' q r')) \u2192 (p = q)) ( \\ H \u2192 H) ( z) ( r) #end basic-path-coherence","title":"Concatenation of two paths with common domain"},{"location":"hott/01-paths.rzk/#some-derived-coherences-in-path-algebra","text":"The statements or proofs of the following path algebra coherences reference one of the path algebra coherences defined above. #section derived-path-coherence #variable A : U #variables x y z : A #def rev-concat ( p : x = y) ( q : y = z) : ( rev A x z (concat A x y z p q)) = ( concat A z y x (rev A y z q) (rev A x y p)) := ind-path ( A) ( y) ( \\ z' q' \u2192 (rev A x z' (concat A x y z' p q')) = (concat A z' y x (rev A y z' q') (rev A x y p))) ( rev ( y = x) ( concat A y y x refl (rev A x y p)) ( rev A x y p) ( left-unit-concat A y x (rev A x y p))) ( z) ( q)","title":"Some derived coherences in path algebra"},{"location":"hott/01-paths.rzk/#postwhiskering-paths-of-paths","text":"#def concat-eq-left ( p q : x = y) ( H : p = q) ( r : y = z) : (concat A x y z p r) = (concat A x y z q r) := ind-path ( A) ( y) ( \\ z' r' \u2192 (concat A x y z' p r') = (concat A x y z' q r')) ( H) ( z) ( r)","title":"Postwhiskering paths of paths"},{"location":"hott/01-paths.rzk/#prewhiskering-paths-of-paths","text":"Prewhiskering paths of paths is much harder. #def concat-eq-right ( p : x = y) : ( q : y = z) \u2192 ( r : y = z) \u2192 ( H : q = r) \u2192 ( concat A x y z p q) = (concat A x y z p r) := ind-path ( A) ( x) ( \\ y' p' \u2192 ( q : y' = z) \u2192 ( r : y' = z) \u2192 ( H : q = r) \u2192 ( concat A x y' z p' q) = (concat A x y' z p' r)) ( \\ q r H \u2192 concat ( x = z) ( concat A x x z refl q) ( r) ( concat A x x z refl r) ( concat (x = z) (concat A x x z refl q) q r (left-unit-concat A x z q) H) ( rev (x = z) (concat A x x z refl r) r (left-unit-concat A x z r))) ( y) ( p)","title":"Prewhiskering paths of paths"},{"location":"hott/01-paths.rzk/#identifying-the-two-definitions-of-path-concatenation","text":"#def concat-concat' ( p : x = y) : ( q : y = z) \u2192 ( concat A x y z p q) = (concat' A x y z p q) := ind-path ( A) ( x) ( \\ y' p' \u2192 (q' : y' =_{A} z) \u2192 (concat A x y' z p' q') =_{x =_{A} z} concat' A x y' z p' q') ( \\ q' \u2192 left-unit-concat A x z q') ( y) ( p) #def concat'-concat ( p : x = y) ( q : y = z) : concat' A x y z p q = concat A x y z p q := rev ( x = z) ( concat A x y z p q) ( concat' A x y z p q) ( concat-concat' p q) This is easier to prove for concat' than for concat . #def alt-triangle-rotation ( p : x = z) ( q : x = y) : ( r : y = z) \u2192 ( H : p = concat' A x y z q r) \u2192 ( concat' A y x z (rev A x y q) p) = r := ind-path ( A) ( x) ( \\ y' q' \u2192 ( r' : y' =_{A} z) \u2192 ( H' : p = concat' A x y' z q' r') \u2192 ( concat' A y' x z (rev A x y' q') p) = r') ( \\ r' H' \u2192 H') ( y) ( q) The following needs to be outside the previous section because of the usage of concat-concat' A y x . #end derived-path-coherence #def triangle-rotation ( A : U) ( x y z : A) ( p : x = z) ( q : x = y) ( r : y = z) ( H : p = concat A x y z q r) : (concat A y x z (rev A x y q) p) = r := concat ( y = z) ( concat A y x z (rev A x y q) p) ( concat' A y x z (rev A x y q) p) ( r) ( concat-concat' A y x z (rev A x y q) p) ( alt-triangle-rotation ( A) (x) (y) (z) (p) (q) (r) ( concat ( x = z) ( p) ( concat A x y z q r) ( concat' A x y z q r) ( H) ( concat-concat' A x y z q r)))","title":"Identifying the two definitions of path concatenation"},{"location":"hott/01-paths.rzk/#application-of-functions-to-paths","text":"#def ap ( A B : U) ( x y : A) ( f : A \u2192 B) ( p : x = y) : (f x = f y) := ind-path (A) (x) ( \\ y' p' \u2192 (f x = f y')) ( refl ) (y) (p) #def ap-rev ( A B : U) ( x y : A) ( f : A \u2192 B) ( p : x = y) : (ap A B y x f (rev A x y p)) = (rev B (f x) (f y) (ap A B x y f p)) := ind-path ( A) ( x) ( \\ y' p' \u2192 ap A B y' x f (rev A x y' p') = rev B (f x) (f y') (ap A B x y' f p')) ( refl ) ( y) ( p) #def ap-concat ( A B : U) ( x y z : A) ( f : A \u2192 B) ( p : x = y) ( q : y = z) : ( ap A B x z f (concat A x y z p q)) = ( concat B (f x) (f y) (f z) (ap A B x y f p) (ap A B y z f q)) := ind-path ( A) ( y) ( \\ z' q' \u2192 ( ap A B x z' f (concat A x y z' p q')) = ( concat B (f x) (f y) (f z') (ap A B x y f p) (ap A B y z' f q'))) ( refl ) ( z) ( q) #def rev-ap-rev ( A B : U) ( x y : A) ( f : A \u2192 B) ( p : x = y) : (rev B (f y) (f x) (ap A B y x f (rev A x y p))) = (ap A B x y f p) := ind-path ( A) ( x) ( \\ y' p' \u2192 (rev B (f y') (f x) (ap A B y' x f (rev A x y' p'))) = (ap A B x y' f p')) ( refl ) ( y) ( p) The following is for a specific use. #def concat-ap-rev-ap-id ( A B : U) ( x y : A) ( f : A \u2192 B) ( p : x = y) : ( concat ( B) (f y) (f x) (f y) ( ap A B y x f (rev A x y p)) ( ap A B x y f p)) = ( refl ) := ind-path ( A) ( x) ( \\ y' p' \u2192 ( concat ( B) (f y') (f x) (f y') ( ap A B y' x f (rev A x y' p')) (ap A B x y' f p')) = ( refl )) ( refl ) ( y) ( p) #def ap-id ( A : U) ( x y : A) ( p : x = y) : (ap A A x y (identity A) p) = p := ind-path (A) (x) ( \\ y' p' \u2192 (ap A A x y' ( \\ z \u2192 z) p') = p') ( refl ) (y) (p) Application of a function to homotopic paths yields homotopic paths. #def ap-eq ( A B : U) ( x y : A) ( f : A \u2192 B) ( p q : x = y) ( H : p = q) : (ap A B x y f p) = (ap A B x y f q) := ind-path ( x = y) ( p) ( \\ q' H' \u2192 (ap A B x y f p) = (ap A B x y f q')) ( refl ) ( q) ( H) #def ap-comp ( A B C : U) ( x y : A) ( f : A \u2192 B) ( g : B \u2192 C) ( p : x = y) : ( ap A C x y (comp A B C g f) p) = ( ap B C (f x) (f y) g (ap A B x y f p)) := ind-path ( A) ( x) ( \\ y' p' \u2192 ( ap A C x y' ( \\ z \u2192 g (f z)) p') = ( ap B C (f x) (f y') g (ap A B x y' f p'))) ( refl ) ( y) ( p) #def rev-ap-comp ( A B C : U) ( x y : A) ( f : A \u2192 B) ( g : B \u2192 C) ( p : x = y) : ( ap B C (f x) (f y) g (ap A B x y f p)) = ( ap A C x y (comp A B C g f) p) := rev ( g (f x) = g (f y)) ( ap A C x y ( \\ z \u2192 g (f z)) p) ( ap B C (f x) (f y) g (ap A B x y f p)) ( ap-comp A B C x y f g p)","title":"Application of functions to paths"},{"location":"hott/01-paths.rzk/#transport","text":"#section transport #variable A : U #variable B : A \u2192 U","title":"Transport"},{"location":"hott/01-paths.rzk/#transport-in-a-type-family-along-a-path-in-the-base","text":"#def transport ( x y : A) ( p : x = y) ( u : B x) : B y := ind-path (A) (x) ( \\ y' p' \u2192 B y') (u) (y) (p)","title":"Transport in a type family along a path in the base"},{"location":"hott/01-paths.rzk/#the-lift-of-a-base-path-to-a-path-from-a-term-in-the-total-space-to-its-transport","text":"#def transport-lift ( x y : A) ( p : x = y) ( u : B x) : (x , u) =_{ \u03a3 ( z : A) , B z} (y , transport x y p u) := ind-path ( A) ( x) ( \\ y' p' \u2192 (x , u) =_{ \u03a3 ( z : A) , B z} (y' , transport x y' p' u)) ( refl ) ( y) ( p)","title":"The lift of a base path to a path from a term in the total space to its transport"},{"location":"hott/01-paths.rzk/#transport-along-concatenated-paths","text":"#def transport-concat ( x y z : A) ( p : x = y) ( q : y = z) ( u : B x) : ( transport x z (concat A x y z p q) u) = ( transport y z q (transport x y p u)) := ind-path ( A) ( y) ( \\ z' q' \u2192 ( transport x z' (concat A x y z' p q') u) = ( transport y z' q' (transport x y p u))) ( refl ) ( z) ( q) #def transport-concat-rev ( x y z : A) ( p : x = y) ( q : y = z) ( u : B x) : ( transport y z q (transport x y p u)) = ( transport x z (concat A x y z p q) u) := ind-path ( A) ( y) ( \\ z' q' \u2192 ( transport y z' q' (transport x y p u)) = ( transport x z' (concat A x y z' p q') u)) ( refl ) ( z) ( q)","title":"Transport along concatenated paths"},{"location":"hott/01-paths.rzk/#transport-along-homotopic-paths","text":"#def transport2 ( x y : A) ( p q : x = y) ( H : p = q) ( u : B x) : (transport x y p u) = (transport x y q u) := ind-path ( x = y) ( p) ( \\ q' H' \u2192 (transport x y p u) = (transport x y q' u)) ( refl ) ( q) ( H)","title":"Transport along homotopic paths"},{"location":"hott/01-paths.rzk/#transport-along-a-loop","text":"#def transport-loop ( a : A) ( b : B a) : (a = a) \u2192 B a := \\ p \u2192 (transport a a p b) #end transport","title":"Transport along a loop"},{"location":"hott/01-paths.rzk/#dependent-application","text":"#def apd ( A : U) ( B : A \u2192 U) ( x y : A) ( f : ( z : A) \u2192 B z) ( p : x = y) : (transport A B x y p (f x)) = f y := ind-path ( A) ( x) ( ( \\ y' p' \u2192 (transport A B x y' p' (f x)) = f y')) ( refl ) ( y) ( p)","title":"Dependent application"},{"location":"hott/01-paths.rzk/#higher-order-concatenation","text":"For convenience, we record lemmas for higher-order concatenation here. #section higher-concatenation #variable A : U #def triple-concat ( a0 a1 a2 a3 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) : a0 = a3 := concat A a0 a1 a3 p1 (concat A a1 a2 a3 p2 p3) #def quadruple-concat ( a0 a1 a2 a3 a4 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) ( p4 : a3 = a4) : a0 = a4 := triple-concat a0 a1 a2 a4 p1 p2 (concat A a2 a3 a4 p3 p4) #def quintuple-concat ( a0 a1 a2 a3 a4 a5 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) ( p4 : a3 = a4) ( p5 : a4 = a5) : a0 = a5 := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5) #def alternating-quintuple-concat ( a0 : A) ( a1 : A) ( p1 : a0 = a1) ( a2 : A) ( p2 : a1 = a2) ( a3 : A) ( p3 : a2 = a3) ( a4 : A) ( p4 : a3 = a4) ( a5 : A) ( p5 : a4 = a5) : a0 = a5 := quadruple-concat a0 a1 a2 a3 a5 p1 p2 p3 (concat A a3 a4 a5 p4 p5) #def 12ary-concat ( a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 : A) ( p1 : a0 = a1) ( p2 : a1 = a2) ( p3 : a2 = a3) ( p4 : a3 = a4) ( p5 : a4 = a5) ( p6 : a5 = a6) ( p7 : a6 = a7) ( p8 : a7 = a8) ( p9 : a8 = a9) ( p10 : a9 = a10) ( p11 : a10 = a11) ( p12 : a11 = a12) : a0 = a12 := quintuple-concat a0 a1 a2 a3 a4 a12 p1 p2 p3 p4 ( quintuple-concat a4 a5 a6 a7 a8 a12 p5 p6 p7 p8 ( quadruple-concat a8 a9 a10 a11 a12 p9 p10 p11 p12)) The following is the same as above but with alternating arguments. #def alternating-12ary-concat ( a0 : A) ( a1 : A) ( p1 : a0 = a1) ( a2 : A) ( p2 : a1 = a2) ( a3 : A) ( p3 : a2 = a3) ( a4 : A) ( p4 : a3 = a4) ( a5 : A) ( p5 : a4 = a5) ( a6 : A) ( p6 : a5 = a6) ( a7 : A) ( p7 : a6 = a7) ( a8 : A) ( p8 : a7 = a8) ( a9 : A) ( p9 : a8 = a9) ( a10 : A) ( p10 : a9 = a10) ( a11 : A) ( p11 : a10 = a11) ( a12 : A) ( p12 : a11 = a12) : a0 = a12 := 12ary-concat a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 #end higher-concatenation","title":"Higher-order concatenation"},{"location":"hott/01-paths.rzk/#higher-order-coherences","text":"#def rev-refl-id-triple-concat ( A : U) ( x y : A) ( p : x = y) : triple-concat A y x x y (rev A x y p) refl p = refl := ind-path ( A) ( x) ( \\ y' p' \u2192 triple-concat A y' x x y' (rev A x y' p') refl p' = refl ) ( refl ) ( y) ( p) #def ap-rev-refl-id-triple-concat ( A B : U) ( x y : A) ( f : A \u2192 B) ( p : x = y) : (ap A B y y f (triple-concat A y x x y (rev A x y p) refl p)) = refl := ind-path ( A) ( x) ( \\ y' p' \u2192 ( ap A B y' y' f (triple-concat A y' x x y' (rev A x y' p') refl p')) = ( refl )) ( refl ) ( y) ( p) #def ap-triple-concat ( A B : U) ( w x y z : A) ( f : A \u2192 B) ( p : w = x) ( q : x = y) ( r : y = z) : ( ap A B w z f (triple-concat A w x y z p q r)) = ( triple-concat ( B) ( f w) ( f x) ( f y) ( f z) ( ap A B w x f p) ( ap A B x y f q) ( ap A B y z f r)) := ind-path ( A) ( y) ( \\ z' r' \u2192 ( ap A B w z' f (triple-concat A w x y z' p q r')) = ( triple-concat ( B) ( f w) (f x) (f y) (f z') ( ap A B w x f p) ( ap A B x y f q) ( ap A B y z' f r'))) ( ap-concat A B w x y f p q) ( z) ( r) #def triple-concat-eq-first ( A : U) ( w x y z : A) ( p q : w = x) ( r : x = y) ( s : y = z) ( H : p = q) : (triple-concat A w x y z p r s) = (triple-concat A w x y z q r s) := concat-eq-left A w x z p q H (concat A x y z r s) #def triple-concat-eq-second ( A : U) ( w x y z : A) ( p : w = x) ( q r : x = y) ( s : y = z) ( H : q = r) : (triple-concat A w x y z p q s) = (triple-concat A w x y z p r s) := ind-path ( x = y) ( q) ( \\ r' H' \u2192 triple-concat A w x y z p q s = triple-concat A w x y z p r' s) ( refl ) ( r) ( H)","title":"Higher-order coherences"},{"location":"hott/02-homotopies.rzk/","text":"2. Homotopies \u00b6 This is a literate rzk file: #lang rzk-1 Homotopies and their algebra \u00b6 #section homotopies #variables A B : U The type of homotopies between parallel functions #def homotopy ( f g : A \u2192 B) : U := ( a : A) \u2192 (f a = g a) The reversal of a homotopy #def rev-homotopy ( f g : A \u2192 B) ( H : homotopy f g) : homotopy g f := \\ a \u2192 rev B (f a) (g a) (H a) #def concat-homotopy ( f g h : A \u2192 B) ( H : homotopy f g) ( K : homotopy g h) : homotopy f h := \\ a \u2192 concat B (f a) (g a) (h a) (H a) (K a) Homotopy composition is defined in diagrammatic order like concat but unlike composition. #end homotopies Whiskering homotopies \u00b6 #section homotopy-whiskering #variables A B C : U #def postwhisker-homotopy ( f g : A \u2192 B) ( H : homotopy A B f g) ( h : B \u2192 C) : homotopy A C (comp A B C h f) (comp A B C h g) := \\ a \u2192 ap B C (f a) (g a) h (H a) #def prewhisker-homotopy ( f g : B \u2192 C) ( H : homotopy B C f g) ( h : A \u2192 B) : homotopy A C (comp A B C f h) (comp A B C g h) := \\ a \u2192 H (h a) #end homotopy-whiskering #def whisker-homotopy ( A B C D : U) ( h k : B \u2192 C) ( H : homotopy B C h k) ( f : A \u2192 B) ( g : C \u2192 D) : homotopy A D (triple-comp A B C D g h f) (triple-comp A B C D g k f) := postwhisker-homotopy A C D ( comp A B C h f) ( comp A B C k f) ( prewhisker-homotopy A B C h k H f) g Naturality \u00b6 The naturality square associated to a homotopy and a path #def nat-htpy ( A B : U) ( f g : A \u2192 B) ( H : homotopy A B f g) ( x y : A) ( p : x = y) : ( concat B (f x) (f y) (g y) (ap A B x y f p) (H y)) = ( concat B (f x) (g x) (g y) (H x) (ap A B x y g p)) := ind-path ( A) ( x) ( \\ y' p' \u2192 ( concat B (f x) (f y') (g y') (ap A B x y' f p') (H y')) = ( concat B (f x) (g x) (g y') (H x) (ap A B x y' g p'))) ( left-unit-concat B (f x) (g x) (H x)) ( y) ( p) Naturality in another form #def triple-concat-nat-htpy ( A B : U) ( f g : A \u2192 B) ( H : homotopy A B f g) ( x y : A) ( p : x = y) : triple-concat ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (H x)) (ap A B x y f p) (H y) = ap A B x y g p := ind-path ( A) ( x) ( \\ y' p' \u2192 triple-concat ( B) ( g x) ( f x) ( f y') ( g y') ( rev B (f x) (g x) (H x)) ( ap A B x y' f p') ( H y') = ap A B x y' g p') ( rev-refl-id-triple-concat B (f x) (g x) (H x)) ( y) ( p) An application \u00b6 #section cocone-naturality #variable A : U #variable f : A \u2192 A #variable H : homotopy A A f (identity A) #variable a : A In the case of a homotopy H from f to the identity the previous square applies to the path H a to produce the following naturality square. #def cocone-naturality : ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = ( concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a))) := nat-htpy A A f (identity A) H (f a) a (H a) After composing with ap-id , this naturality square transforms to the following: #def reduced-cocone-naturality : ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = ( concat A (f (f a)) (f a) (a) (H (f a)) (H a)) := concat ( (f (f a)) = a) ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) ( concat ( A) ( f (f a)) ( f a) ( a) ( H (f a)) ( ap A A (f a) a (identity A) (H a))) ( concat A (f (f a)) (f a) (a) (H (f a)) (H a)) ( cocone-naturality) ( concat-eq-right ( A) ( f (f a)) ( f a) ( a) ( H (f a)) ( ap A A (f a) a (identity A) (H a)) ( H a) ( ap-id A (f a) a (H a))) Cancelling the path H a on the right and reversing yields a path we need: #def cocone-naturality-coherence : (H (f a)) = (ap A A (f a) a f (H a)) := rev ( f (f a) = f a) ( ap A A (f a) a f (H a)) (H (f a)) ( right-cancel-concat ( A) ( f (f a)) ( f a) ( a) ( ap A A (f a) a f (H a)) ( H (f a)) ( H a) ( reduced-cocone-naturality)) #end cocone-naturality Conjugation with higher homotopies \u00b6 #def triple-concat-higher-homotopy ( A B : U) ( f g : A \u2192 B) ( H K : homotopy A B f g) ( \u03b1 : ( a : A) \u2192 H a = K a) ( x y : A) ( p : f x = f y) : triple-concat B (g x) (f x) (f y) (g y) (rev B (f x) (g x) (H x)) p (H y) = triple-concat B (g x) (f x) (f y) (g y) (rev B (f x) (g x) (K x)) p (K y) := ind-path ( f y = g y) ( H y) ( \\ Ky \u03b1' \u2192 ( triple-concat ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (H x)) (p) (H y)) = ( triple-concat ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (K x)) (p) (Ky))) ( triple-concat-eq-first ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (H x)) ( rev B (f x) (g x) (K x)) ( p) ( H y) ( ap ( f x = g x) ( g x = f x) ( H x) ( K x) ( rev B (f x) (g x)) ( \u03b1 x))) ( K y) (\u03b1 y)","title":"Homotopies"},{"location":"hott/02-homotopies.rzk/#2-homotopies","text":"This is a literate rzk file: #lang rzk-1","title":"2. Homotopies"},{"location":"hott/02-homotopies.rzk/#homotopies-and-their-algebra","text":"#section homotopies #variables A B : U The type of homotopies between parallel functions #def homotopy ( f g : A \u2192 B) : U := ( a : A) \u2192 (f a = g a) The reversal of a homotopy #def rev-homotopy ( f g : A \u2192 B) ( H : homotopy f g) : homotopy g f := \\ a \u2192 rev B (f a) (g a) (H a) #def concat-homotopy ( f g h : A \u2192 B) ( H : homotopy f g) ( K : homotopy g h) : homotopy f h := \\ a \u2192 concat B (f a) (g a) (h a) (H a) (K a) Homotopy composition is defined in diagrammatic order like concat but unlike composition. #end homotopies","title":"Homotopies and their algebra"},{"location":"hott/02-homotopies.rzk/#whiskering-homotopies","text":"#section homotopy-whiskering #variables A B C : U #def postwhisker-homotopy ( f g : A \u2192 B) ( H : homotopy A B f g) ( h : B \u2192 C) : homotopy A C (comp A B C h f) (comp A B C h g) := \\ a \u2192 ap B C (f a) (g a) h (H a) #def prewhisker-homotopy ( f g : B \u2192 C) ( H : homotopy B C f g) ( h : A \u2192 B) : homotopy A C (comp A B C f h) (comp A B C g h) := \\ a \u2192 H (h a) #end homotopy-whiskering #def whisker-homotopy ( A B C D : U) ( h k : B \u2192 C) ( H : homotopy B C h k) ( f : A \u2192 B) ( g : C \u2192 D) : homotopy A D (triple-comp A B C D g h f) (triple-comp A B C D g k f) := postwhisker-homotopy A C D ( comp A B C h f) ( comp A B C k f) ( prewhisker-homotopy A B C h k H f) g","title":"Whiskering homotopies"},{"location":"hott/02-homotopies.rzk/#naturality","text":"The naturality square associated to a homotopy and a path #def nat-htpy ( A B : U) ( f g : A \u2192 B) ( H : homotopy A B f g) ( x y : A) ( p : x = y) : ( concat B (f x) (f y) (g y) (ap A B x y f p) (H y)) = ( concat B (f x) (g x) (g y) (H x) (ap A B x y g p)) := ind-path ( A) ( x) ( \\ y' p' \u2192 ( concat B (f x) (f y') (g y') (ap A B x y' f p') (H y')) = ( concat B (f x) (g x) (g y') (H x) (ap A B x y' g p'))) ( left-unit-concat B (f x) (g x) (H x)) ( y) ( p) Naturality in another form #def triple-concat-nat-htpy ( A B : U) ( f g : A \u2192 B) ( H : homotopy A B f g) ( x y : A) ( p : x = y) : triple-concat ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (H x)) (ap A B x y f p) (H y) = ap A B x y g p := ind-path ( A) ( x) ( \\ y' p' \u2192 triple-concat ( B) ( g x) ( f x) ( f y') ( g y') ( rev B (f x) (g x) (H x)) ( ap A B x y' f p') ( H y') = ap A B x y' g p') ( rev-refl-id-triple-concat B (f x) (g x) (H x)) ( y) ( p)","title":"Naturality"},{"location":"hott/02-homotopies.rzk/#an-application","text":"#section cocone-naturality #variable A : U #variable f : A \u2192 A #variable H : homotopy A A f (identity A) #variable a : A In the case of a homotopy H from f to the identity the previous square applies to the path H a to produce the following naturality square. #def cocone-naturality : ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = ( concat A (f (f a)) (f a) (a) (H (f a)) (ap A A (f a) a (identity A) (H a))) := nat-htpy A A f (identity A) H (f a) a (H a) After composing with ap-id , this naturality square transforms to the following: #def reduced-cocone-naturality : ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) = ( concat A (f (f a)) (f a) (a) (H (f a)) (H a)) := concat ( (f (f a)) = a) ( concat A (f (f a)) (f a) a (ap A A (f a) a f (H a)) (H a)) ( concat ( A) ( f (f a)) ( f a) ( a) ( H (f a)) ( ap A A (f a) a (identity A) (H a))) ( concat A (f (f a)) (f a) (a) (H (f a)) (H a)) ( cocone-naturality) ( concat-eq-right ( A) ( f (f a)) ( f a) ( a) ( H (f a)) ( ap A A (f a) a (identity A) (H a)) ( H a) ( ap-id A (f a) a (H a))) Cancelling the path H a on the right and reversing yields a path we need: #def cocone-naturality-coherence : (H (f a)) = (ap A A (f a) a f (H a)) := rev ( f (f a) = f a) ( ap A A (f a) a f (H a)) (H (f a)) ( right-cancel-concat ( A) ( f (f a)) ( f a) ( a) ( ap A A (f a) a f (H a)) ( H (f a)) ( H a) ( reduced-cocone-naturality)) #end cocone-naturality","title":"An application"},{"location":"hott/02-homotopies.rzk/#conjugation-with-higher-homotopies","text":"#def triple-concat-higher-homotopy ( A B : U) ( f g : A \u2192 B) ( H K : homotopy A B f g) ( \u03b1 : ( a : A) \u2192 H a = K a) ( x y : A) ( p : f x = f y) : triple-concat B (g x) (f x) (f y) (g y) (rev B (f x) (g x) (H x)) p (H y) = triple-concat B (g x) (f x) (f y) (g y) (rev B (f x) (g x) (K x)) p (K y) := ind-path ( f y = g y) ( H y) ( \\ Ky \u03b1' \u2192 ( triple-concat ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (H x)) (p) (H y)) = ( triple-concat ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (K x)) (p) (Ky))) ( triple-concat-eq-first ( B) (g x) (f x) (f y) (g y) ( rev B (f x) (g x) (H x)) ( rev B (f x) (g x) (K x)) ( p) ( H y) ( ap ( f x = g x) ( g x = f x) ( H x) ( K x) ( rev B (f x) (g x)) ( \u03b1 x))) ( K y) (\u03b1 y)","title":"Conjugation with higher homotopies"},{"location":"hott/03-equivalences.rzk/","text":"3. Equivalences \u00b6 This is a literate rzk file: #lang rzk-1 Sections, retractions, and equivalences \u00b6 #section is-equiv #variables A B : U #def has-section ( f : A \u2192 B) : U := \u03a3 ( s : B \u2192 A) , (homotopy B B (comp B A B f s) (identity B)) #def has-retraction ( f : A \u2192 B) : U := \u03a3 ( r : B \u2192 A) , (homotopy A A (comp A B A r f) (identity A)) We define equivalences to be bi-invertible maps. #def is-equiv ( f : A \u2192 B) : U := product (has-retraction f) (has-section f) #end is-equiv Equivalence data \u00b6 #section equivalence-data #variables A B : U #variable f : A \u2192 B #variable is-equiv-f : is-equiv A B f #def section-is-equiv uses ( f ) : B \u2192 A := first ( second is-equiv-f) #def retraction-is-equiv uses ( f ) : B \u2192 A := first ( first is-equiv-f) The homotopy between the section and retraction of an equivalence #def homotopy-section-retraction-is-equiv uses ( f ) : homotopy B A section-is-equiv retraction-is-equiv := concat-homotopy B A ( section-is-equiv) ( triple-comp B A B A retraction-is-equiv f section-is-equiv) ( retraction-is-equiv) ( rev-homotopy B A ( triple-comp B A B A retraction-is-equiv f section-is-equiv) ( section-is-equiv) ( prewhisker-homotopy B A A ( comp A B A retraction-is-equiv f) ( identity A) ( second ( first is-equiv-f)) ( section-is-equiv))) ( postwhisker-homotopy B B A ( comp B A B f section-is-equiv) ( identity B) ( second ( second is-equiv-f)) ( retraction-is-equiv)) #end equivalence-data Invertible maps \u00b6 The following type of more coherent equivalences is not a proposition. #def has-inverse ( A B : U) ( f : A \u2192 B) : U := \u03a3 ( g : B \u2192 A) , ( product ( homotopy A A (comp A B A g f) (identity A)) ( homotopy B B (comp B A B f g) (identity B))) Equivalences are invertible maps \u00b6 Invertible maps are equivalences #def is-equiv-has-inverse ( A B : U) ( f : A \u2192 B) ( has-inverse-f : has-inverse A B f) : is-equiv A B f := ( ( first has-inverse-f , first ( second has-inverse-f)) , ( first has-inverse-f , second ( second has-inverse-f))) Equivalences are invertible #def has-inverse-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) : has-inverse A B f := ( section-is-equiv A B f is-equiv-f , ( concat-homotopy A A ( comp A B A (section-is-equiv A B f is-equiv-f) f) ( comp A B A (retraction-is-equiv A B f is-equiv-f) f) ( identity A) ( prewhisker-homotopy A B A ( section-is-equiv A B f is-equiv-f) ( retraction-is-equiv A B f is-equiv-f) ( homotopy-section-retraction-is-equiv A B f is-equiv-f) ( f)) ( second ( first is-equiv-f)) , ( second ( second is-equiv-f)))) Invertible map data \u00b6 #section has-inverse-data #variables A B : U #variable f : A \u2192 B #variable has-inverse-f : has-inverse A B f The inverse of a map with an inverse #def map-inverse-has-inverse uses ( f ) : B \u2192 A := first (has-inverse-f) The following are some iterated composites associated to a pair of invertible maps. #def retraction-composite-has-inverse uses ( B has-inverse-f ) : A \u2192 A := comp A B A map-inverse-has-inverse f #def section-composite-has-inverse uses ( A has-inverse-f ) : B \u2192 B := comp B A B f map-inverse-has-inverse This composite is parallel to f ; we won't need the dual notion. #def triple-composite-has-inverse uses ( has-inverse-f ) : A \u2192 B := triple-comp A B A B f map-inverse-has-inverse f This composite is also parallel to f ; again we won't need the dual notion. #def quintuple-composite-has-inverse uses ( has-inverse-f ) : A \u2192 B := \\ a \u2192 f (map-inverse-has-inverse (f (map-inverse-has-inverse (f a)))) #end has-inverse-data Composing equivalences \u00b6 The type of equivalences between types uses is-equiv rather than has-inverse . #def Equiv ( A B : U) : U := \u03a3 ( f : A \u2192 B) , (is-equiv A B f) The data of an equivalence is not symmetric so we promote an equivalence to an invertible map to prove symmetry: #def inv-equiv ( A B : U) ( e : Equiv A B) : Equiv B A := ( first (has-inverse-is-equiv A B ( first e) ( second e)) , ( ( first e , second ( second (has-inverse-is-equiv A B ( first e) ( second e)))) , ( first e , first ( second (has-inverse-is-equiv A B ( first e) ( second e)))))) Composition of equivalences in diagrammatic order #def equiv-comp ( A B C : U) ( A\u2243B : Equiv A B) ( B\u2243C : Equiv B C) : Equiv A C := ( ( \\ a \u2192 first B\u2243C ( first A\u2243B a)) , ( ( ( \\ c \u2192 first ( first ( second A\u2243B)) ( first ( first ( second (B\u2243C))) c)) , ( \\ a \u2192 concat A ( first ( first ( second A\u2243B)) ( first ( first ( second B\u2243C)) ( first B\u2243C ( first A\u2243B a)))) ( first ( first ( second A\u2243B)) ( first A\u2243B a)) ( a) ( ap B A ( first ( first ( second B\u2243C)) ( first B\u2243C ( first A\u2243B a))) ( first A\u2243B a) ( first ( first ( second A\u2243B))) ( second ( first ( second B\u2243C)) ( first A\u2243B a))) ( second ( first ( second A\u2243B)) a))) , ( ( \\ c \u2192 first ( second ( second A\u2243B)) ( first ( second ( second (B\u2243C))) c)) , ( \\ c \u2192 concat C ( first B\u2243C ( first A\u2243B ( first ( second ( second A\u2243B)) ( first ( second ( second B\u2243C)) c)))) ( first B\u2243C ( first ( second ( second B\u2243C)) c)) ( c) ( ap B C ( first A\u2243B ( first ( second ( second A\u2243B)) ( first ( second ( second B\u2243C)) c))) ( first ( second ( second B\u2243C)) c) ( first B\u2243C) ( second ( second ( second A\u2243B)) ( first ( second ( second B\u2243C)) c))) ( second ( second ( second B\u2243C)) c))))) Now we compose the functions that are equivalences. #def is-equiv-comp ( A B C : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) ( g : B \u2192 C) ( is-equiv-g : is-equiv B C g) : is-equiv A C (comp A B C g f) := ( ( comp C B A ( retraction-is-equiv A B f is-equiv-f) ( retraction-is-equiv B C g is-equiv-g) , ( \\ a \u2192 concat A ( retraction-is-equiv A B f is-equiv-f ( retraction-is-equiv B C g is-equiv-g (g (f a)))) ( retraction-is-equiv A B f is-equiv-f (f a)) ( a) ( ap B A ( retraction-is-equiv B C g is-equiv-g (g (f a))) ( f a) ( retraction-is-equiv A B f is-equiv-f) ( second ( first is-equiv-g) (f a))) ( second ( first is-equiv-f) a))) , ( comp C B A ( section-is-equiv A B f is-equiv-f) ( section-is-equiv B C g is-equiv-g) , ( \\ c \u2192 concat C ( g (f ( first ( second is-equiv-f) ( first ( second is-equiv-g) c)))) ( g ( first ( second is-equiv-g) c)) ( c) ( ap B C ( f ( first ( second is-equiv-f) ( first ( second is-equiv-g) c))) ( first ( second is-equiv-g) c) ( g) ( second ( second is-equiv-f) ( first ( second is-equiv-g) c))) ( second ( second is-equiv-g) c)))) Right cancellation of equivalences in diagrammatic order #def equiv-right-cancel ( A B C : U) ( A\u2243C : Equiv A C) ( B\u2243C : Equiv B C) : Equiv A B := equiv-comp A C B (A\u2243C) (inv-equiv B C B\u2243C) Left cancellation of equivalences in diagrammatic order #def equiv-left-cancel ( A B C : U) ( A\u2243B : Equiv A B) ( A\u2243C : Equiv A C) : Equiv B C := equiv-comp B A C (inv-equiv A B A\u2243B) (A\u2243C) A composition of three equivalences #def equiv-triple-comp ( A B C D : U) ( A\u2243B : Equiv A B) ( B\u2243C : Equiv B C) ( C\u2243D : Equiv C D) : Equiv A D := equiv-comp A B D (A\u2243B) (equiv-comp B C D B\u2243C C\u2243D) #def is-equiv-triple-comp ( A B C D : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) ( g : B \u2192 C) ( is-equiv-g : is-equiv B C g) ( h : C \u2192 D) ( is-equiv-h : is-equiv C D h) : is-equiv A D (triple-comp A B C D h g f) := is-equiv-comp A B D ( f) ( is-equiv-f) ( comp B C D h g) ( is-equiv-comp B C D g is-equiv-g h is-equiv-h) Equivalences and homotopy \u00b6 If a map is homotopic to an equivalence it is an equivalence. #def is-equiv-homotopy ( A B : U) ( f g : A \u2192 B) ( H : homotopy A B f g) ( is-equiv-g : is-equiv A B g) : is-equiv A B f := ( ( ( first ( first is-equiv-g)) , ( \\ a \u2192 concat A ( first ( first is-equiv-g) (f a)) ( first ( first is-equiv-g) (g a)) ( a) ( ap B A (f a) (g a) ( first ( first is-equiv-g)) (H a)) ( second ( first is-equiv-g) a))) , ( ( first ( second is-equiv-g)) , ( \\ b \u2192 concat B ( f ( first ( second is-equiv-g) b)) ( g ( first ( second is-equiv-g) b)) ( b) ( H ( first ( second is-equiv-g) b)) ( second ( second is-equiv-g) b)))) #def is-equiv-rev-homotopy ( A B : U) ( f g : A \u2192 B) ( H : homotopy A B f g) ( is-equiv-f : is-equiv A B f) : is-equiv A B g := is-equiv-homotopy A B g f (rev-homotopy A B f g H) is-equiv-f Function extensionality \u00b6 By path induction, an identification between functions defines a homotopy. #def htpy-eq ( X : U) ( A : X \u2192 U) ( f g : ( x : X) \u2192 A x) ( p : f = g) : ( x : X) \u2192 (f x = g x) := ind-path ( (x : X) \u2192 A x) ( f) ( \\ g' p' \u2192 (x : X) \u2192 (f x = g' x)) ( \\ x \u2192 refl ) ( g) ( p) The function extensionality axiom asserts that this map defines a family of equivalences. The type that encodes the function extensionality axiom #def FunExt : U := ( X : U) \u2192 ( A : X \u2192 U) \u2192 ( f : ( x : X) \u2192 A x) \u2192 ( g : ( x : X) \u2192 A x) \u2192 is-equiv (f = g) ( (x : X) \u2192 f x = g x) (htpy-eq X A f g) In the formalisations below, some definitions will assume function extensionality: #assume funext : FunExt Whenever a definition (implicitly) uses function extensionality, we write uses (funext) . In particular, the following definitions rely on function extensionality: The equivalence provided by function extensionality #def equiv-FunExt uses ( funext ) ( X : U) ( A : X \u2192 U) ( f g : ( x : X) \u2192 A x) : Equiv (f = g) ( (x : X) \u2192 f x = g x) := (htpy-eq X A f g , funext X A f g) In particular, function extensionality implies that homotopies give rise to identifications. This defines eq-htpy to be the retraction to htpy-eq . #def eq-htpy uses ( funext ) ( X : U) ( A : X \u2192 U) ( f g : ( x : X) \u2192 A x) : ( (x : X) \u2192 f x = g x) \u2192 (f = g) := first ( first (funext X A f g)) Using function extensionality, a fiberwise equivalence defines an equivalence of dependent function types. #def equiv-function-equiv-family uses ( funext ) ( X : U) ( A B : X \u2192 U) ( famequiv : ( x : X) \u2192 Equiv (A x) (B x)) : Equiv ( (x : X) \u2192 A x) ( (x : X) \u2192 B x) := ( ( \\ a x \u2192 first (famequiv x) (a x)) , ( ( ( \\ b x \u2192 first ( first ( second (famequiv x))) (b x)) , ( \\ a \u2192 eq-htpy X A ( \\ x \u2192 first ( first ( second (famequiv x))) ( first (famequiv x) (a x))) ( a) ( \\ x \u2192 second ( first ( second (famequiv x))) (a x)))) , ( ( \\ b x \u2192 first ( second ( second (famequiv x))) (b x)) , ( \\ b \u2192 eq-htpy X B ( \\ x \u2192 first (famequiv x) ( first ( second ( second (famequiv x))) (b x))) ( b) ( \\ x \u2192 second ( second ( second (famequiv x))) (b x)))))) Embeddings \u00b6 #def is-emb ( A B : U) ( f : A \u2192 B) : U := ( x : A) \u2192 ( y : A) \u2192 is-equiv (x = y) (f x = f y) (ap A B x y f) #def Emb ( A B : U) : U := ( \u03a3 (f : A \u2192 B) , is-emb A B f) #def is-emb-is-inhabited-emb ( A B : U) ( f : A \u2192 B) ( e : A \u2192 is-emb A B f) : is-emb A B f := \\ x y \u2192 e x x y #def inv-ap-is-emb ( A B : U) ( f : A \u2192 B) ( is-emb-f : is-emb A B f) ( x y : A) ( p : f x = f y) : (x = y) := first ( first (is-emb-f x y)) p Reversal is an equivalence \u00b6 #def has-retraction-rev ( A : U) ( y : A) : ( x : A) \u2192 has-retraction (x = y) (y = x) (rev A x y) := \\ x \u2192 ( ( rev A y x) , ( \\ p \u2192 ind-path ( A) ( x) ( \\ y' p' \u2192 ( comp ( x = y') (y' = x) (x = y') (rev A y' x) (rev A x y') (p')) =_{x = y'} ( p')) ( refl ) ( y) ( p))) #def has-section-rev ( A : U) ( y x : A) : has-section (x = y) (y = x) (rev A x y) := ( ( rev A y x) , ( ind-path ( A) ( y) ( \\ x' p' \u2192 ( comp ( y = x') (x' = y) (y = x') (rev A x' y) (rev A y x') (p')) =_{y = x'} ( p')) ( refl ) ( x))) #def is-equiv-rev ( A : U) ( x y : A) : is-equiv (x = y) (y = x) (rev A x y) := ((has-retraction-rev A y x) , (has-section-rev A y x))","title":"Equivalences"},{"location":"hott/03-equivalences.rzk/#3-equivalences","text":"This is a literate rzk file: #lang rzk-1","title":"3. Equivalences"},{"location":"hott/03-equivalences.rzk/#sections-retractions-and-equivalences","text":"#section is-equiv #variables A B : U #def has-section ( f : A \u2192 B) : U := \u03a3 ( s : B \u2192 A) , (homotopy B B (comp B A B f s) (identity B)) #def has-retraction ( f : A \u2192 B) : U := \u03a3 ( r : B \u2192 A) , (homotopy A A (comp A B A r f) (identity A)) We define equivalences to be bi-invertible maps. #def is-equiv ( f : A \u2192 B) : U := product (has-retraction f) (has-section f) #end is-equiv","title":"Sections, retractions, and equivalences"},{"location":"hott/03-equivalences.rzk/#equivalence-data","text":"#section equivalence-data #variables A B : U #variable f : A \u2192 B #variable is-equiv-f : is-equiv A B f #def section-is-equiv uses ( f ) : B \u2192 A := first ( second is-equiv-f) #def retraction-is-equiv uses ( f ) : B \u2192 A := first ( first is-equiv-f) The homotopy between the section and retraction of an equivalence #def homotopy-section-retraction-is-equiv uses ( f ) : homotopy B A section-is-equiv retraction-is-equiv := concat-homotopy B A ( section-is-equiv) ( triple-comp B A B A retraction-is-equiv f section-is-equiv) ( retraction-is-equiv) ( rev-homotopy B A ( triple-comp B A B A retraction-is-equiv f section-is-equiv) ( section-is-equiv) ( prewhisker-homotopy B A A ( comp A B A retraction-is-equiv f) ( identity A) ( second ( first is-equiv-f)) ( section-is-equiv))) ( postwhisker-homotopy B B A ( comp B A B f section-is-equiv) ( identity B) ( second ( second is-equiv-f)) ( retraction-is-equiv)) #end equivalence-data","title":"Equivalence data"},{"location":"hott/03-equivalences.rzk/#invertible-maps","text":"The following type of more coherent equivalences is not a proposition. #def has-inverse ( A B : U) ( f : A \u2192 B) : U := \u03a3 ( g : B \u2192 A) , ( product ( homotopy A A (comp A B A g f) (identity A)) ( homotopy B B (comp B A B f g) (identity B)))","title":"Invertible maps"},{"location":"hott/03-equivalences.rzk/#equivalences-are-invertible-maps","text":"Invertible maps are equivalences #def is-equiv-has-inverse ( A B : U) ( f : A \u2192 B) ( has-inverse-f : has-inverse A B f) : is-equiv A B f := ( ( first has-inverse-f , first ( second has-inverse-f)) , ( first has-inverse-f , second ( second has-inverse-f))) Equivalences are invertible #def has-inverse-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) : has-inverse A B f := ( section-is-equiv A B f is-equiv-f , ( concat-homotopy A A ( comp A B A (section-is-equiv A B f is-equiv-f) f) ( comp A B A (retraction-is-equiv A B f is-equiv-f) f) ( identity A) ( prewhisker-homotopy A B A ( section-is-equiv A B f is-equiv-f) ( retraction-is-equiv A B f is-equiv-f) ( homotopy-section-retraction-is-equiv A B f is-equiv-f) ( f)) ( second ( first is-equiv-f)) , ( second ( second is-equiv-f))))","title":"Equivalences are invertible maps"},{"location":"hott/03-equivalences.rzk/#invertible-map-data","text":"#section has-inverse-data #variables A B : U #variable f : A \u2192 B #variable has-inverse-f : has-inverse A B f The inverse of a map with an inverse #def map-inverse-has-inverse uses ( f ) : B \u2192 A := first (has-inverse-f) The following are some iterated composites associated to a pair of invertible maps. #def retraction-composite-has-inverse uses ( B has-inverse-f ) : A \u2192 A := comp A B A map-inverse-has-inverse f #def section-composite-has-inverse uses ( A has-inverse-f ) : B \u2192 B := comp B A B f map-inverse-has-inverse This composite is parallel to f ; we won't need the dual notion. #def triple-composite-has-inverse uses ( has-inverse-f ) : A \u2192 B := triple-comp A B A B f map-inverse-has-inverse f This composite is also parallel to f ; again we won't need the dual notion. #def quintuple-composite-has-inverse uses ( has-inverse-f ) : A \u2192 B := \\ a \u2192 f (map-inverse-has-inverse (f (map-inverse-has-inverse (f a)))) #end has-inverse-data","title":"Invertible map data"},{"location":"hott/03-equivalences.rzk/#composing-equivalences","text":"The type of equivalences between types uses is-equiv rather than has-inverse . #def Equiv ( A B : U) : U := \u03a3 ( f : A \u2192 B) , (is-equiv A B f) The data of an equivalence is not symmetric so we promote an equivalence to an invertible map to prove symmetry: #def inv-equiv ( A B : U) ( e : Equiv A B) : Equiv B A := ( first (has-inverse-is-equiv A B ( first e) ( second e)) , ( ( first e , second ( second (has-inverse-is-equiv A B ( first e) ( second e)))) , ( first e , first ( second (has-inverse-is-equiv A B ( first e) ( second e)))))) Composition of equivalences in diagrammatic order #def equiv-comp ( A B C : U) ( A\u2243B : Equiv A B) ( B\u2243C : Equiv B C) : Equiv A C := ( ( \\ a \u2192 first B\u2243C ( first A\u2243B a)) , ( ( ( \\ c \u2192 first ( first ( second A\u2243B)) ( first ( first ( second (B\u2243C))) c)) , ( \\ a \u2192 concat A ( first ( first ( second A\u2243B)) ( first ( first ( second B\u2243C)) ( first B\u2243C ( first A\u2243B a)))) ( first ( first ( second A\u2243B)) ( first A\u2243B a)) ( a) ( ap B A ( first ( first ( second B\u2243C)) ( first B\u2243C ( first A\u2243B a))) ( first A\u2243B a) ( first ( first ( second A\u2243B))) ( second ( first ( second B\u2243C)) ( first A\u2243B a))) ( second ( first ( second A\u2243B)) a))) , ( ( \\ c \u2192 first ( second ( second A\u2243B)) ( first ( second ( second (B\u2243C))) c)) , ( \\ c \u2192 concat C ( first B\u2243C ( first A\u2243B ( first ( second ( second A\u2243B)) ( first ( second ( second B\u2243C)) c)))) ( first B\u2243C ( first ( second ( second B\u2243C)) c)) ( c) ( ap B C ( first A\u2243B ( first ( second ( second A\u2243B)) ( first ( second ( second B\u2243C)) c))) ( first ( second ( second B\u2243C)) c) ( first B\u2243C) ( second ( second ( second A\u2243B)) ( first ( second ( second B\u2243C)) c))) ( second ( second ( second B\u2243C)) c))))) Now we compose the functions that are equivalences. #def is-equiv-comp ( A B C : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) ( g : B \u2192 C) ( is-equiv-g : is-equiv B C g) : is-equiv A C (comp A B C g f) := ( ( comp C B A ( retraction-is-equiv A B f is-equiv-f) ( retraction-is-equiv B C g is-equiv-g) , ( \\ a \u2192 concat A ( retraction-is-equiv A B f is-equiv-f ( retraction-is-equiv B C g is-equiv-g (g (f a)))) ( retraction-is-equiv A B f is-equiv-f (f a)) ( a) ( ap B A ( retraction-is-equiv B C g is-equiv-g (g (f a))) ( f a) ( retraction-is-equiv A B f is-equiv-f) ( second ( first is-equiv-g) (f a))) ( second ( first is-equiv-f) a))) , ( comp C B A ( section-is-equiv A B f is-equiv-f) ( section-is-equiv B C g is-equiv-g) , ( \\ c \u2192 concat C ( g (f ( first ( second is-equiv-f) ( first ( second is-equiv-g) c)))) ( g ( first ( second is-equiv-g) c)) ( c) ( ap B C ( f ( first ( second is-equiv-f) ( first ( second is-equiv-g) c))) ( first ( second is-equiv-g) c) ( g) ( second ( second is-equiv-f) ( first ( second is-equiv-g) c))) ( second ( second is-equiv-g) c)))) Right cancellation of equivalences in diagrammatic order #def equiv-right-cancel ( A B C : U) ( A\u2243C : Equiv A C) ( B\u2243C : Equiv B C) : Equiv A B := equiv-comp A C B (A\u2243C) (inv-equiv B C B\u2243C) Left cancellation of equivalences in diagrammatic order #def equiv-left-cancel ( A B C : U) ( A\u2243B : Equiv A B) ( A\u2243C : Equiv A C) : Equiv B C := equiv-comp B A C (inv-equiv A B A\u2243B) (A\u2243C) A composition of three equivalences #def equiv-triple-comp ( A B C D : U) ( A\u2243B : Equiv A B) ( B\u2243C : Equiv B C) ( C\u2243D : Equiv C D) : Equiv A D := equiv-comp A B D (A\u2243B) (equiv-comp B C D B\u2243C C\u2243D) #def is-equiv-triple-comp ( A B C D : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) ( g : B \u2192 C) ( is-equiv-g : is-equiv B C g) ( h : C \u2192 D) ( is-equiv-h : is-equiv C D h) : is-equiv A D (triple-comp A B C D h g f) := is-equiv-comp A B D ( f) ( is-equiv-f) ( comp B C D h g) ( is-equiv-comp B C D g is-equiv-g h is-equiv-h)","title":"Composing equivalences"},{"location":"hott/03-equivalences.rzk/#equivalences-and-homotopy","text":"If a map is homotopic to an equivalence it is an equivalence. #def is-equiv-homotopy ( A B : U) ( f g : A \u2192 B) ( H : homotopy A B f g) ( is-equiv-g : is-equiv A B g) : is-equiv A B f := ( ( ( first ( first is-equiv-g)) , ( \\ a \u2192 concat A ( first ( first is-equiv-g) (f a)) ( first ( first is-equiv-g) (g a)) ( a) ( ap B A (f a) (g a) ( first ( first is-equiv-g)) (H a)) ( second ( first is-equiv-g) a))) , ( ( first ( second is-equiv-g)) , ( \\ b \u2192 concat B ( f ( first ( second is-equiv-g) b)) ( g ( first ( second is-equiv-g) b)) ( b) ( H ( first ( second is-equiv-g) b)) ( second ( second is-equiv-g) b)))) #def is-equiv-rev-homotopy ( A B : U) ( f g : A \u2192 B) ( H : homotopy A B f g) ( is-equiv-f : is-equiv A B f) : is-equiv A B g := is-equiv-homotopy A B g f (rev-homotopy A B f g H) is-equiv-f","title":"Equivalences and homotopy"},{"location":"hott/03-equivalences.rzk/#function-extensionality","text":"By path induction, an identification between functions defines a homotopy. #def htpy-eq ( X : U) ( A : X \u2192 U) ( f g : ( x : X) \u2192 A x) ( p : f = g) : ( x : X) \u2192 (f x = g x) := ind-path ( (x : X) \u2192 A x) ( f) ( \\ g' p' \u2192 (x : X) \u2192 (f x = g' x)) ( \\ x \u2192 refl ) ( g) ( p) The function extensionality axiom asserts that this map defines a family of equivalences. The type that encodes the function extensionality axiom #def FunExt : U := ( X : U) \u2192 ( A : X \u2192 U) \u2192 ( f : ( x : X) \u2192 A x) \u2192 ( g : ( x : X) \u2192 A x) \u2192 is-equiv (f = g) ( (x : X) \u2192 f x = g x) (htpy-eq X A f g) In the formalisations below, some definitions will assume function extensionality: #assume funext : FunExt Whenever a definition (implicitly) uses function extensionality, we write uses (funext) . In particular, the following definitions rely on function extensionality: The equivalence provided by function extensionality #def equiv-FunExt uses ( funext ) ( X : U) ( A : X \u2192 U) ( f g : ( x : X) \u2192 A x) : Equiv (f = g) ( (x : X) \u2192 f x = g x) := (htpy-eq X A f g , funext X A f g) In particular, function extensionality implies that homotopies give rise to identifications. This defines eq-htpy to be the retraction to htpy-eq . #def eq-htpy uses ( funext ) ( X : U) ( A : X \u2192 U) ( f g : ( x : X) \u2192 A x) : ( (x : X) \u2192 f x = g x) \u2192 (f = g) := first ( first (funext X A f g)) Using function extensionality, a fiberwise equivalence defines an equivalence of dependent function types. #def equiv-function-equiv-family uses ( funext ) ( X : U) ( A B : X \u2192 U) ( famequiv : ( x : X) \u2192 Equiv (A x) (B x)) : Equiv ( (x : X) \u2192 A x) ( (x : X) \u2192 B x) := ( ( \\ a x \u2192 first (famequiv x) (a x)) , ( ( ( \\ b x \u2192 first ( first ( second (famequiv x))) (b x)) , ( \\ a \u2192 eq-htpy X A ( \\ x \u2192 first ( first ( second (famequiv x))) ( first (famequiv x) (a x))) ( a) ( \\ x \u2192 second ( first ( second (famequiv x))) (a x)))) , ( ( \\ b x \u2192 first ( second ( second (famequiv x))) (b x)) , ( \\ b \u2192 eq-htpy X B ( \\ x \u2192 first (famequiv x) ( first ( second ( second (famequiv x))) (b x))) ( b) ( \\ x \u2192 second ( second ( second (famequiv x))) (b x))))))","title":"Function extensionality"},{"location":"hott/03-equivalences.rzk/#embeddings","text":"#def is-emb ( A B : U) ( f : A \u2192 B) : U := ( x : A) \u2192 ( y : A) \u2192 is-equiv (x = y) (f x = f y) (ap A B x y f) #def Emb ( A B : U) : U := ( \u03a3 (f : A \u2192 B) , is-emb A B f) #def is-emb-is-inhabited-emb ( A B : U) ( f : A \u2192 B) ( e : A \u2192 is-emb A B f) : is-emb A B f := \\ x y \u2192 e x x y #def inv-ap-is-emb ( A B : U) ( f : A \u2192 B) ( is-emb-f : is-emb A B f) ( x y : A) ( p : f x = f y) : (x = y) := first ( first (is-emb-f x y)) p","title":"Embeddings"},{"location":"hott/03-equivalences.rzk/#reversal-is-an-equivalence","text":"#def has-retraction-rev ( A : U) ( y : A) : ( x : A) \u2192 has-retraction (x = y) (y = x) (rev A x y) := \\ x \u2192 ( ( rev A y x) , ( \\ p \u2192 ind-path ( A) ( x) ( \\ y' p' \u2192 ( comp ( x = y') (y' = x) (x = y') (rev A y' x) (rev A x y') (p')) =_{x = y'} ( p')) ( refl ) ( y) ( p))) #def has-section-rev ( A : U) ( y x : A) : has-section (x = y) (y = x) (rev A x y) := ( ( rev A y x) , ( ind-path ( A) ( y) ( \\ x' p' \u2192 ( comp ( y = x') (x' = y) (y = x') (rev A x' y) (rev A y x') (p')) =_{y = x'} ( p')) ( refl ) ( x))) #def is-equiv-rev ( A : U) ( x y : A) : is-equiv (x = y) (y = x) (rev A x y) := ((has-retraction-rev A y x) , (has-section-rev A y x))","title":"Reversal is an equivalence"},{"location":"hott/04-half-adjoint-equivalences.rzk/","text":"4. Half Adjoint Equivalences \u00b6 This is a literate rzk file: #lang rzk-1 Half adjoint equivalences \u00b6 We'll require a more coherent notion of equivalence. Namely, the notion of half adjoint equivalences . #def is-half-adjoint-equiv ( A B : U) ( f : A \u2192 B) : U := \u03a3 ( has-inverse-f : (has-inverse A B f)) , ( ( a : A) \u2192 ( second ( second has-inverse-f) (f a)) = ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f a) ( a) ( f) ( first ( second has-inverse-f) a))) By function extensionality, the previous definition coincides with the following one: #def is-half-adjoint-equiv' ( A B : U) ( f : A \u2192 B) : U := \u03a3 ( has-inverse-f : (has-inverse A B f)) , ( ( a : A) \u2192 ( second ( second has-inverse-f) (f a)) = ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f a) ( a) ( f) ( first ( second has-inverse-f) a))) Coherence data from an invertible map \u00b6 To promote an invertible map to a half adjoint equivalence we keep one homotopy and discard the other. #def has-inverse-kept-htpy ( A B : U) ( f : A \u2192 B) ( has-inverse-f : has-inverse A B f) : homotopy A A ( retraction-composite-has-inverse A B f has-inverse-f) (identity A) := ( first ( second has-inverse-f)) #def has-inverse-discarded-htpy ( A B : U) ( f : A \u2192 B) ( has-inverse-f : has-inverse A B f) : homotopy B B ( section-composite-has-inverse A B f has-inverse-f) (identity B) := ( second ( second has-inverse-f)) The required coherence will be built by transforming an instance of the following naturality square. #section has-inverse-coherence #variables A B : U #variable f : A \u2192 B #variable has-inverse-f : has-inverse A B f #variable a : A #def has-inverse-discarded-naturality-square : concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a ( triple-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) ( has-inverse-discarded-htpy A B f has-inverse-f (f a)) = concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( has-inverse-discarded-htpy A B f has-inverse-f ( triple-composite-has-inverse A B f has-inverse-f a)) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f (has-inverse-kept-htpy A B f has-inverse-f a)) := nat-htpy A B ( triple-composite-has-inverse A B f has-inverse-f) ( f) ( \\ x \u2192 has-inverse-discarded-htpy A B f has-inverse-f (f x)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( a) ( has-inverse-kept-htpy A B f has-inverse-f a) We build a path that will be whiskered into the naturality square above: #def has-inverse-cocone-homotopy-coherence : has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a) = ap A A (retraction-composite-has-inverse A B f has-inverse-f a) a ( retraction-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a) := cocone-naturality-coherence ( A) ( retraction-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f) ( a) #def has-inverse-ap-cocone-homotopy-coherence : ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) = ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( ap A A (retraction-composite-has-inverse A B f has-inverse-f a) a ( retraction-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) := ap-eq A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( ap A A (retraction-composite-has-inverse A B f has-inverse-f a) a ( retraction-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) ( has-inverse-cocone-homotopy-coherence) #def has-inverse-cocone-coherence : ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) = ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a ( triple-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) := concat ( quintuple-composite-has-inverse A B f has-inverse-f a = triple-composite-has-inverse A B f has-inverse-f a) ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a))) ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( ap A A ( retraction-composite-has-inverse A B f has-inverse-f a) a ( retraction-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a))) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a ( triple-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) ( has-inverse-ap-cocone-homotopy-coherence) ( rev-ap-comp A A B ( retraction-composite-has-inverse A B f has-inverse-f a) a ( retraction-composite-has-inverse A B f has-inverse-f) ( f) ( has-inverse-kept-htpy A B f has-inverse-f a)) This morally gives the half adjoint inverse coherence. It just requires rotation. #def has-inverse-replaced-naturality-square : concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a))) ( has-inverse-discarded-htpy A B f has-inverse-f (f a)) = concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( has-inverse-discarded-htpy A B f has-inverse-f ( triple-composite-has-inverse A B f has-inverse-f a)) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f ( has-inverse-kept-htpy A B f has-inverse-f a)) := concat ( quintuple-composite-has-inverse A B f has-inverse-f a = f a) ( concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) f ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a))) ( has-inverse-discarded-htpy A B f has-inverse-f (f a))) ( concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a ( triple-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) ( has-inverse-discarded-htpy A B f has-inverse-f (f a))) ( concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) (f a) ( has-inverse-discarded-htpy A B f has-inverse-f ( triple-composite-has-inverse A B f has-inverse-f a)) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f ( has-inverse-kept-htpy A B f has-inverse-f a))) ( concat-eq-left B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a))) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a ( triple-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) ( has-inverse-cocone-coherence) ( has-inverse-discarded-htpy A B f has-inverse-f (f a))) ( has-inverse-discarded-naturality-square) This will replace the discarded homotopy. #def has-inverse-corrected-htpy : homotopy B B (section-composite-has-inverse A B f has-inverse-f) ( \\ b \u2192 b) := \\ b \u2192 concat B ( (section-composite-has-inverse A B f has-inverse-f) b) ( (section-composite-has-inverse A B f has-inverse-f) ((section-composite-has-inverse A B f has-inverse-f) b)) ( b) ( rev B ( (section-composite-has-inverse A B f has-inverse-f) ((section-composite-has-inverse A B f has-inverse-f) b)) ( (section-composite-has-inverse A B f has-inverse-f) b) ( has-inverse-discarded-htpy A B f has-inverse-f ((section-composite-has-inverse A B f has-inverse-f) b))) ( concat B ( (section-composite-has-inverse A B f has-inverse-f) ((section-composite-has-inverse A B f has-inverse-f) b)) ( (section-composite-has-inverse A B f has-inverse-f) b) ( b) ( ap A B ( (retraction-composite-has-inverse A B f has-inverse-f) (map-inverse-has-inverse A B f has-inverse-f b)) ( map-inverse-has-inverse A B f has-inverse-f b) f ( ( first ( second has-inverse-f)) (map-inverse-has-inverse A B f has-inverse-f b))) ( (has-inverse-discarded-htpy A B f has-inverse-f b))) The following is the half adjoint coherence. #def has-inverse-coherence : ( has-inverse-corrected-htpy (f a)) = ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f ( has-inverse-kept-htpy A B f has-inverse-f a)) := triangle-rotation B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( concat B ( (section-composite-has-inverse A B f has-inverse-f) ((section-composite-has-inverse A B f has-inverse-f) (f a))) ( (section-composite-has-inverse A B f has-inverse-f) (f a)) ( f a) ( ap A B ( (retraction-composite-has-inverse A B f has-inverse-f) (map-inverse-has-inverse A B f has-inverse-f (f a))) ( map-inverse-has-inverse A B f has-inverse-f (f a)) ( f) ( ( first ( second has-inverse-f)) (map-inverse-has-inverse A B f has-inverse-f (f a)))) ( (has-inverse-discarded-htpy A B f has-inverse-f (f a)))) ( has-inverse-discarded-htpy A B f has-inverse-f ( triple-composite-has-inverse A B f has-inverse-f a)) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f ( has-inverse-kept-htpy A B f has-inverse-f a)) ( has-inverse-replaced-naturality-square) #end has-inverse-coherence Invertible maps are half adjoint equivalences \u00b6 To promote an invertible map to a half adjoint equivalence we change the data of the invertible map by discarding the homotopy and replacing it with a corrected one. #def corrected-has-inverse-has-inverse ( A B : U) ( f : A \u2192 B) ( has-inverse-f : has-inverse A B f) : has-inverse A B f := ( map-inverse-has-inverse A B f has-inverse-f , ( has-inverse-kept-htpy A B f has-inverse-f , has-inverse-corrected-htpy A B f has-inverse-f)) Invertible maps are half adjoint equivalences! #def is-half-adjoint-equiv-has-inverse ( A B : U) ( f : A \u2192 B) ( has-inverse-f : has-inverse A B f) : is-half-adjoint-equiv A B f := ( corrected-has-inverse-has-inverse A B f has-inverse-f , has-inverse-coherence A B f has-inverse-f) Equivalences are half adjoint equivalences! #def is-half-adjoint-equiv-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) : is-half-adjoint-equiv A B f := is-half-adjoint-equiv-has-inverse A B f ( has-inverse-is-equiv A B f is-equiv-f) Equivalences of identity types \u00b6 We use the notion of half adjoint equivalence to prove that equivalent types have equivalent identity types. #section equiv-identity-types-equiv #variables A B : U #variable f : A \u2192 B #variable is-hae-f : is-half-adjoint-equiv A B f #def iff-ap-is-half-adjoint-equiv ( x y : A) : iff (x = y) (f x = f y) := ( ap A B x y f , \\ q \u2192 triple-concat A ( x) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( y) ( rev A (retraction-composite-has-inverse A B f ( first is-hae-f) x) x ( ( first ( second ( first is-hae-f))) x)) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q) ( ( first ( second ( first is-hae-f))) y)) #def has-retraction-ap-is-half-adjoint-equiv ( x y : A) : has-retraction (x = y) (f x = f y) (ap A B x y f) := ( ( second (iff-ap-is-half-adjoint-equiv x y)) , ( ind-path ( A) ( x) ( \\ y' p' \u2192 ( second (iff-ap-is-half-adjoint-equiv x y')) (ap A B x y' f p') = ( p')) ( rev-refl-id-triple-concat A ( map-inverse-has-inverse A B f ( first is-hae-f) (f x)) ( x) ( first ( second ( first is-hae-f)) x)) ( y))) #def ap-triple-concat-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : ap A B x y f (( second (iff-ap-is-half-adjoint-equiv x y)) q) = (triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( ap A B x ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) f ( rev A (retraction-composite-has-inverse A B f ( first is-hae-f) x) x ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( f) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y))) := ap-triple-concat A B ( x) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( y) ( f) ( rev A (retraction-composite-has-inverse A B f ( first is-hae-f) x) x ( ( first ( second ( first is-hae-f))) x)) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q) ( ( first ( second ( first is-hae-f))) y) #def ap-rev-triple-concat-eq-first-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( ap A B x ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) f (rev A (retraction-composite-has-inverse A B f ( first is-hae-f) x) x ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( f) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y)) = triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B (f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( f) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( y) ( f) ( ( first ( second ( first is-hae-f))) y)) := triple-concat-eq-first B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( ap A B ( x) ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) f ( rev A (retraction-composite-has-inverse A B f ( first is-hae-f) x) x ( ( first ( second ( first is-hae-f))) x))) ( rev B (f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( f) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y)) ( ap-rev A B (retraction-composite-has-inverse A B f ( first is-hae-f) x) x f ( ( first ( second ( first is-hae-f))) x)) #def ap-ap-triple-concat-eq-first-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : (triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) ( f x) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( f) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y))) = ( triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap B B (f x) (f y) ( section-composite-has-inverse A B f ( first is-hae-f)) q) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y ( f) (( first ( second ( first is-hae-f))) y))) := triple-concat-eq-second B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( f) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap B B (f x) (f y) (section-composite-has-inverse A B f ( first is-hae-f)) q) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y)) ( rev-ap-comp B A B (f x) (f y) ( map-inverse-has-inverse A B f ( first is-hae-f)) f q) -- This needs to be reversed later. #def triple-concat-higher-homotopy-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ( second ( second ( first is-hae-f))) (f x))) ( ap B B (f x) (f y) ( section-composite-has-inverse A B f ( first is-hae-f)) q) ( ( second ( second ( first is-hae-f))) (f y)) = triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) (rev B (f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) (ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f (( first ( second ( first is-hae-f))) x))) (ap B B (f x) (f y) (section-composite-has-inverse A B f ( first is-hae-f)) q) (ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f (( first ( second ( first is-hae-f))) y)) := triple-concat-higher-homotopy A B ( triple-composite-has-inverse A B f ( first is-hae-f)) f ( \\ a \u2192 ((( second ( second ( first is-hae-f)))) (f a))) ( \\ a \u2192 ( ap A B (retraction-composite-has-inverse A B f ( first is-hae-f) a) a f ( (( first ( second ( first is-hae-f)))) a))) ( second is-hae-f) ( x) ( y) ( ap B B (f x) (f y) ( section-composite-has-inverse A B f ( first is-hae-f)) q) #def triple-concat-nat-htpy-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B (f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( (( second ( second ( first is-hae-f)))) (f x))) ( ap B B (f x) (f y) (section-composite-has-inverse A B f ( first is-hae-f)) q) ( (( second ( second ( first is-hae-f)))) (f y)) = ap B B (f x) (f y) (identity B) q := triple-concat-nat-htpy B B ( section-composite-has-inverse A B f ( first is-hae-f)) ( identity B) ( ( second ( second ( first is-hae-f)))) ( f x) ( f y) q #def zag-zig-concat-triple-concat-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B (f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap B B (f x) (f y) (section-composite-has-inverse A B f ( first is-hae-f)) q) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y)) = ap B B (f x) (f y) (identity B) q := zag-zig-concat (f x = f y) ( triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap B B (f x) (f y) ( section-composite-has-inverse A B f ( first is-hae-f)) q) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f (( first ( second ( first is-hae-f))) y))) ( triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) ( f x) ( (( second ( second ( first is-hae-f)))) (f x))) ( ap B B (f x) (f y) ( section-composite-has-inverse A B f ( first is-hae-f)) q) ( (( second ( second ( first is-hae-f)))) (f y))) ( ap B B (f x) (f y) (identity B) q) ( triple-concat-higher-homotopy-is-half-adjoint-equiv x y q) ( triple-concat-nat-htpy-is-half-adjoint-equiv x y q) #def triple-concat-reduction-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : ap B B (f x) (f y) (identity B) q = q := ap-id B (f x) (f y) q #def section-htpy-ap-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : ap A B x y f (( second (iff-ap-is-half-adjoint-equiv x y)) q) = q := alternating-quintuple-concat (f x = f y) ( ap A B x y f (( second (iff-ap-is-half-adjoint-equiv x y)) q)) ( triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( ap A B x ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) f ( rev A (retraction-composite-has-inverse A B f ( first is-hae-f) x) x ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) f ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y))) ( ap-triple-concat-is-half-adjoint-equiv x y q) ( triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) f ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y))) ( ap-rev-triple-concat-eq-first-is-half-adjoint-equiv x y q) ( triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) ( f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap B B (f x) (f y) ( section-composite-has-inverse A B f ( first is-hae-f)) q) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f (( first ( second ( first is-hae-f))) y))) ( ap-ap-triple-concat-eq-first-is-half-adjoint-equiv x y q) ( ap B B (f x) (f y) (identity B) q) ( zag-zig-concat-triple-concat-is-half-adjoint-equiv x y q) ( q) ( triple-concat-reduction-is-half-adjoint-equiv x y q) #def has-section-ap-is-half-adjoint-equiv uses ( is-hae-f ) ( x y : A) : has-section (x = y) (f x = f y) (ap A B x y f) := ( second (iff-ap-is-half-adjoint-equiv x y) , section-htpy-ap-is-half-adjoint-equiv x y) #def is-equiv-ap-is-half-adjoint-equiv uses ( is-hae-f ) ( x y : A) : is-equiv (x = y) (f x = f y) (ap A B x y f) := ( has-retraction-ap-is-half-adjoint-equiv x y , has-section-ap-is-half-adjoint-equiv x y) #end equiv-identity-types-equiv #def is-emb-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) : is-emb A B f := is-equiv-ap-is-half-adjoint-equiv A B f ( is-half-adjoint-equiv-is-equiv A B f is-equiv-f) #def emb-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) : Emb A B := (f , is-emb-is-equiv A B f is-equiv-f) #def equiv-ap-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) ( x y : A) : Equiv (x = y) (f x = f y) := (ap A B x y f , is-emb-is-equiv A B f is-equiv-f x y)","title":"Half Adjoint Equivalences"},{"location":"hott/04-half-adjoint-equivalences.rzk/#4-half-adjoint-equivalences","text":"This is a literate rzk file: #lang rzk-1","title":"4. Half Adjoint Equivalences"},{"location":"hott/04-half-adjoint-equivalences.rzk/#half-adjoint-equivalences","text":"We'll require a more coherent notion of equivalence. Namely, the notion of half adjoint equivalences . #def is-half-adjoint-equiv ( A B : U) ( f : A \u2192 B) : U := \u03a3 ( has-inverse-f : (has-inverse A B f)) , ( ( a : A) \u2192 ( second ( second has-inverse-f) (f a)) = ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f a) ( a) ( f) ( first ( second has-inverse-f) a))) By function extensionality, the previous definition coincides with the following one: #def is-half-adjoint-equiv' ( A B : U) ( f : A \u2192 B) : U := \u03a3 ( has-inverse-f : (has-inverse A B f)) , ( ( a : A) \u2192 ( second ( second has-inverse-f) (f a)) = ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f a) ( a) ( f) ( first ( second has-inverse-f) a)))","title":"Half adjoint equivalences"},{"location":"hott/04-half-adjoint-equivalences.rzk/#coherence-data-from-an-invertible-map","text":"To promote an invertible map to a half adjoint equivalence we keep one homotopy and discard the other. #def has-inverse-kept-htpy ( A B : U) ( f : A \u2192 B) ( has-inverse-f : has-inverse A B f) : homotopy A A ( retraction-composite-has-inverse A B f has-inverse-f) (identity A) := ( first ( second has-inverse-f)) #def has-inverse-discarded-htpy ( A B : U) ( f : A \u2192 B) ( has-inverse-f : has-inverse A B f) : homotopy B B ( section-composite-has-inverse A B f has-inverse-f) (identity B) := ( second ( second has-inverse-f)) The required coherence will be built by transforming an instance of the following naturality square. #section has-inverse-coherence #variables A B : U #variable f : A \u2192 B #variable has-inverse-f : has-inverse A B f #variable a : A #def has-inverse-discarded-naturality-square : concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a ( triple-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) ( has-inverse-discarded-htpy A B f has-inverse-f (f a)) = concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( has-inverse-discarded-htpy A B f has-inverse-f ( triple-composite-has-inverse A B f has-inverse-f a)) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f (has-inverse-kept-htpy A B f has-inverse-f a)) := nat-htpy A B ( triple-composite-has-inverse A B f has-inverse-f) ( f) ( \\ x \u2192 has-inverse-discarded-htpy A B f has-inverse-f (f x)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( a) ( has-inverse-kept-htpy A B f has-inverse-f a) We build a path that will be whiskered into the naturality square above: #def has-inverse-cocone-homotopy-coherence : has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a) = ap A A (retraction-composite-has-inverse A B f has-inverse-f a) a ( retraction-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a) := cocone-naturality-coherence ( A) ( retraction-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f) ( a) #def has-inverse-ap-cocone-homotopy-coherence : ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) = ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( ap A A (retraction-composite-has-inverse A B f has-inverse-f a) a ( retraction-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) := ap-eq A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( ap A A (retraction-composite-has-inverse A B f has-inverse-f a) a ( retraction-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) ( has-inverse-cocone-homotopy-coherence) #def has-inverse-cocone-coherence : ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) = ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a ( triple-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) := concat ( quintuple-composite-has-inverse A B f has-inverse-f a = triple-composite-has-inverse A B f has-inverse-f a) ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a))) ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( ap A A ( retraction-composite-has-inverse A B f has-inverse-f a) a ( retraction-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a))) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a ( triple-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) ( has-inverse-ap-cocone-homotopy-coherence) ( rev-ap-comp A A B ( retraction-composite-has-inverse A B f has-inverse-f a) a ( retraction-composite-has-inverse A B f has-inverse-f) ( f) ( has-inverse-kept-htpy A B f has-inverse-f a)) This morally gives the half adjoint inverse coherence. It just requires rotation. #def has-inverse-replaced-naturality-square : concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a))) ( has-inverse-discarded-htpy A B f has-inverse-f (f a)) = concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( has-inverse-discarded-htpy A B f has-inverse-f ( triple-composite-has-inverse A B f has-inverse-f a)) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f ( has-inverse-kept-htpy A B f has-inverse-f a)) := concat ( quintuple-composite-has-inverse A B f has-inverse-f a = f a) ( concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) f ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a))) ( has-inverse-discarded-htpy A B f has-inverse-f (f a))) ( concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a ( triple-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) ( has-inverse-discarded-htpy A B f has-inverse-f (f a))) ( concat B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) (f a) ( has-inverse-discarded-htpy A B f has-inverse-f ( triple-composite-has-inverse A B f has-inverse-f a)) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f ( has-inverse-kept-htpy A B f has-inverse-f a))) ( concat-eq-left B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( ap A B ( retraction-composite-has-inverse A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a)) ( retraction-composite-has-inverse A B f has-inverse-f a) ( f) ( has-inverse-kept-htpy A B f has-inverse-f ( retraction-composite-has-inverse A B f has-inverse-f a))) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a ( triple-composite-has-inverse A B f has-inverse-f) ( has-inverse-kept-htpy A B f has-inverse-f a)) ( has-inverse-cocone-coherence) ( has-inverse-discarded-htpy A B f has-inverse-f (f a))) ( has-inverse-discarded-naturality-square) This will replace the discarded homotopy. #def has-inverse-corrected-htpy : homotopy B B (section-composite-has-inverse A B f has-inverse-f) ( \\ b \u2192 b) := \\ b \u2192 concat B ( (section-composite-has-inverse A B f has-inverse-f) b) ( (section-composite-has-inverse A B f has-inverse-f) ((section-composite-has-inverse A B f has-inverse-f) b)) ( b) ( rev B ( (section-composite-has-inverse A B f has-inverse-f) ((section-composite-has-inverse A B f has-inverse-f) b)) ( (section-composite-has-inverse A B f has-inverse-f) b) ( has-inverse-discarded-htpy A B f has-inverse-f ((section-composite-has-inverse A B f has-inverse-f) b))) ( concat B ( (section-composite-has-inverse A B f has-inverse-f) ((section-composite-has-inverse A B f has-inverse-f) b)) ( (section-composite-has-inverse A B f has-inverse-f) b) ( b) ( ap A B ( (retraction-composite-has-inverse A B f has-inverse-f) (map-inverse-has-inverse A B f has-inverse-f b)) ( map-inverse-has-inverse A B f has-inverse-f b) f ( ( first ( second has-inverse-f)) (map-inverse-has-inverse A B f has-inverse-f b))) ( (has-inverse-discarded-htpy A B f has-inverse-f b))) The following is the half adjoint coherence. #def has-inverse-coherence : ( has-inverse-corrected-htpy (f a)) = ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f ( has-inverse-kept-htpy A B f has-inverse-f a)) := triangle-rotation B ( quintuple-composite-has-inverse A B f has-inverse-f a) ( triple-composite-has-inverse A B f has-inverse-f a) ( f a) ( concat B ( (section-composite-has-inverse A B f has-inverse-f) ((section-composite-has-inverse A B f has-inverse-f) (f a))) ( (section-composite-has-inverse A B f has-inverse-f) (f a)) ( f a) ( ap A B ( (retraction-composite-has-inverse A B f has-inverse-f) (map-inverse-has-inverse A B f has-inverse-f (f a))) ( map-inverse-has-inverse A B f has-inverse-f (f a)) ( f) ( ( first ( second has-inverse-f)) (map-inverse-has-inverse A B f has-inverse-f (f a)))) ( (has-inverse-discarded-htpy A B f has-inverse-f (f a)))) ( has-inverse-discarded-htpy A B f has-inverse-f ( triple-composite-has-inverse A B f has-inverse-f a)) ( ap A B (retraction-composite-has-inverse A B f has-inverse-f a) a f ( has-inverse-kept-htpy A B f has-inverse-f a)) ( has-inverse-replaced-naturality-square) #end has-inverse-coherence","title":"Coherence data from an invertible map"},{"location":"hott/04-half-adjoint-equivalences.rzk/#invertible-maps-are-half-adjoint-equivalences","text":"To promote an invertible map to a half adjoint equivalence we change the data of the invertible map by discarding the homotopy and replacing it with a corrected one. #def corrected-has-inverse-has-inverse ( A B : U) ( f : A \u2192 B) ( has-inverse-f : has-inverse A B f) : has-inverse A B f := ( map-inverse-has-inverse A B f has-inverse-f , ( has-inverse-kept-htpy A B f has-inverse-f , has-inverse-corrected-htpy A B f has-inverse-f)) Invertible maps are half adjoint equivalences! #def is-half-adjoint-equiv-has-inverse ( A B : U) ( f : A \u2192 B) ( has-inverse-f : has-inverse A B f) : is-half-adjoint-equiv A B f := ( corrected-has-inverse-has-inverse A B f has-inverse-f , has-inverse-coherence A B f has-inverse-f) Equivalences are half adjoint equivalences! #def is-half-adjoint-equiv-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) : is-half-adjoint-equiv A B f := is-half-adjoint-equiv-has-inverse A B f ( has-inverse-is-equiv A B f is-equiv-f)","title":"Invertible maps are half adjoint equivalences"},{"location":"hott/04-half-adjoint-equivalences.rzk/#equivalences-of-identity-types","text":"We use the notion of half adjoint equivalence to prove that equivalent types have equivalent identity types. #section equiv-identity-types-equiv #variables A B : U #variable f : A \u2192 B #variable is-hae-f : is-half-adjoint-equiv A B f #def iff-ap-is-half-adjoint-equiv ( x y : A) : iff (x = y) (f x = f y) := ( ap A B x y f , \\ q \u2192 triple-concat A ( x) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( y) ( rev A (retraction-composite-has-inverse A B f ( first is-hae-f) x) x ( ( first ( second ( first is-hae-f))) x)) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q) ( ( first ( second ( first is-hae-f))) y)) #def has-retraction-ap-is-half-adjoint-equiv ( x y : A) : has-retraction (x = y) (f x = f y) (ap A B x y f) := ( ( second (iff-ap-is-half-adjoint-equiv x y)) , ( ind-path ( A) ( x) ( \\ y' p' \u2192 ( second (iff-ap-is-half-adjoint-equiv x y')) (ap A B x y' f p') = ( p')) ( rev-refl-id-triple-concat A ( map-inverse-has-inverse A B f ( first is-hae-f) (f x)) ( x) ( first ( second ( first is-hae-f)) x)) ( y))) #def ap-triple-concat-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : ap A B x y f (( second (iff-ap-is-half-adjoint-equiv x y)) q) = (triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( ap A B x ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) f ( rev A (retraction-composite-has-inverse A B f ( first is-hae-f) x) x ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( f) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y))) := ap-triple-concat A B ( x) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( y) ( f) ( rev A (retraction-composite-has-inverse A B f ( first is-hae-f) x) x ( ( first ( second ( first is-hae-f))) x)) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q) ( ( first ( second ( first is-hae-f))) y) #def ap-rev-triple-concat-eq-first-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( ap A B x ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) f (rev A (retraction-composite-has-inverse A B f ( first is-hae-f) x) x ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( f) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y)) = triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B (f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( f) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( y) ( f) ( ( first ( second ( first is-hae-f))) y)) := triple-concat-eq-first B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( ap A B ( x) ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) f ( rev A (retraction-composite-has-inverse A B f ( first is-hae-f) x) x ( ( first ( second ( first is-hae-f))) x))) ( rev B (f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( f) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y)) ( ap-rev A B (retraction-composite-has-inverse A B f ( first is-hae-f) x) x f ( ( first ( second ( first is-hae-f))) x)) #def ap-ap-triple-concat-eq-first-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : (triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) ( f x) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( f) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y))) = ( triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap B B (f x) (f y) ( section-composite-has-inverse A B f ( first is-hae-f)) q) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y ( f) (( first ( second ( first is-hae-f))) y))) := triple-concat-eq-second B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) ( f) ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap B B (f x) (f y) (section-composite-has-inverse A B f ( first is-hae-f)) q) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y)) ( rev-ap-comp B A B (f x) (f y) ( map-inverse-has-inverse A B f ( first is-hae-f)) f q) -- This needs to be reversed later. #def triple-concat-higher-homotopy-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ( second ( second ( first is-hae-f))) (f x))) ( ap B B (f x) (f y) ( section-composite-has-inverse A B f ( first is-hae-f)) q) ( ( second ( second ( first is-hae-f))) (f y)) = triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) (rev B (f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) (ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f (( first ( second ( first is-hae-f))) x))) (ap B B (f x) (f y) (section-composite-has-inverse A B f ( first is-hae-f)) q) (ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f (( first ( second ( first is-hae-f))) y)) := triple-concat-higher-homotopy A B ( triple-composite-has-inverse A B f ( first is-hae-f)) f ( \\ a \u2192 ((( second ( second ( first is-hae-f)))) (f a))) ( \\ a \u2192 ( ap A B (retraction-composite-has-inverse A B f ( first is-hae-f) a) a f ( (( first ( second ( first is-hae-f)))) a))) ( second is-hae-f) ( x) ( y) ( ap B B (f x) (f y) ( section-composite-has-inverse A B f ( first is-hae-f)) q) #def triple-concat-nat-htpy-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B (f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( (( second ( second ( first is-hae-f)))) (f x))) ( ap B B (f x) (f y) (section-composite-has-inverse A B f ( first is-hae-f)) q) ( (( second ( second ( first is-hae-f)))) (f y)) = ap B B (f x) (f y) (identity B) q := triple-concat-nat-htpy B B ( section-composite-has-inverse A B f ( first is-hae-f)) ( identity B) ( ( second ( second ( first is-hae-f)))) ( f x) ( f y) q #def zag-zig-concat-triple-concat-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B (f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap B B (f x) (f y) (section-composite-has-inverse A B f ( first is-hae-f)) q) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y)) = ap B B (f x) (f y) (identity B) q := zag-zig-concat (f x = f y) ( triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap B B (f x) (f y) ( section-composite-has-inverse A B f ( first is-hae-f)) q) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f (( first ( second ( first is-hae-f))) y))) ( triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) ( f x) ( (( second ( second ( first is-hae-f)))) (f x))) ( ap B B (f x) (f y) ( section-composite-has-inverse A B f ( first is-hae-f)) q) ( (( second ( second ( first is-hae-f)))) (f y))) ( ap B B (f x) (f y) (identity B) q) ( triple-concat-higher-homotopy-is-half-adjoint-equiv x y q) ( triple-concat-nat-htpy-is-half-adjoint-equiv x y q) #def triple-concat-reduction-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : ap B B (f x) (f y) (identity B) q = q := ap-id B (f x) (f y) q #def section-htpy-ap-is-half-adjoint-equiv ( x y : A) ( q : f x = f y) : ap A B x y f (( second (iff-ap-is-half-adjoint-equiv x y)) q) = q := alternating-quintuple-concat (f x = f y) ( ap A B x y f (( second (iff-ap-is-half-adjoint-equiv x y)) q)) ( triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( ap A B x ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) f ( rev A (retraction-composite-has-inverse A B f ( first is-hae-f) x) x ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) f ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y))) ( ap-triple-concat-is-half-adjoint-equiv x y q) ( triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) (f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) f ( ap B A (f x) (f y) (map-inverse-has-inverse A B f ( first is-hae-f)) q)) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f ( ( first ( second ( first is-hae-f))) y))) ( ap-rev-triple-concat-eq-first-is-half-adjoint-equiv x y q) ( triple-concat B ( f x) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y))) ( f y) ( rev B ( f (retraction-composite-has-inverse A B f ( first is-hae-f) x)) ( f x) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f x)) x f ( ( first ( second ( first is-hae-f))) x))) ( ap B B (f x) (f y) ( section-composite-has-inverse A B f ( first is-hae-f)) q) ( ap A B ((map-inverse-has-inverse A B f ( first is-hae-f)) (f y)) y f (( first ( second ( first is-hae-f))) y))) ( ap-ap-triple-concat-eq-first-is-half-adjoint-equiv x y q) ( ap B B (f x) (f y) (identity B) q) ( zag-zig-concat-triple-concat-is-half-adjoint-equiv x y q) ( q) ( triple-concat-reduction-is-half-adjoint-equiv x y q) #def has-section-ap-is-half-adjoint-equiv uses ( is-hae-f ) ( x y : A) : has-section (x = y) (f x = f y) (ap A B x y f) := ( second (iff-ap-is-half-adjoint-equiv x y) , section-htpy-ap-is-half-adjoint-equiv x y) #def is-equiv-ap-is-half-adjoint-equiv uses ( is-hae-f ) ( x y : A) : is-equiv (x = y) (f x = f y) (ap A B x y f) := ( has-retraction-ap-is-half-adjoint-equiv x y , has-section-ap-is-half-adjoint-equiv x y) #end equiv-identity-types-equiv #def is-emb-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) : is-emb A B f := is-equiv-ap-is-half-adjoint-equiv A B f ( is-half-adjoint-equiv-is-equiv A B f is-equiv-f) #def emb-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) : Emb A B := (f , is-emb-is-equiv A B f is-equiv-f) #def equiv-ap-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) ( x y : A) : Equiv (x = y) (f x = f y) := (ap A B x y f , is-emb-is-equiv A B f is-equiv-f x y)","title":"Equivalences of identity types"},{"location":"hott/05-sigma.rzk/","text":"5. Sigma types \u00b6 This is a literate rzk file: #lang rzk-1 Paths involving products \u00b6 #section paths-in-products #variables A B : U #def path-product ( a a' : A) ( b b' : B) ( e_A : a = a') ( e_B : b = b') : ( a , b) =_{product A B} (a' , b') := transport A ( \\ x \u2192 (a , b) =_{product A B} (x , b')) a a' e_A ( transport B ( \\ y \u2192 (a , b) =_{product A B} (a , y)) b b' e_B refl ) #def first-path-product ( x y : product A B) ( e : x =_{product A B} y) : first x = first y := ap (product A B) A x y ( \\ z \u2192 first z) e #def second-path-product ( x y : product A B) ( e : x =_{product A B} y) : second x = second y := ap (product A B) B x y ( \\ z \u2192 second z) e #end paths-in-products Identity types of Sigma types \u00b6 #section paths-in-sigma #variable A : U #variable B : A \u2192 U #def first-path-\u03a3 ( s t : \u03a3 ( a : A) , B a) ( e : s = t) : first s = first t := ap ( \u03a3 (a : A) , B a) A s t ( \\ z \u2192 first z) e #def second-path-\u03a3 ( s t : \u03a3 ( a : A) , B a) ( e : s = t) : ( transport A B ( first s) ( first t) (first-path-\u03a3 s t e) ( second s)) = ( second t) := ind-path ( \u03a3 (a : A) , B a) ( s) ( \\ t' e' \u2192 ( transport A B ( first s) ( first t') (first-path-\u03a3 s t' e') ( second s)) = ( second t')) ( refl ) ( t) ( e) Rijke 22, Definition 9.3.1 #def Eq-\u03a3 ( s t : \u03a3 ( a : A) , B a) : U := \u03a3 ( p : ( first s) = ( first t)) , ( transport A B ( first s) ( first t) p ( second s)) = ( second t) Rijke 22, Definition 9.3.3 #def pair-eq ( s t : \u03a3 ( a : A) , B a) ( e : s = t) : Eq-\u03a3 s t := (first-path-\u03a3 s t e , second-path-\u03a3 s t e) A path in a fiber defines a path in the total space. #def eq-eq-fiber-\u03a3 ( x : A) ( u v : B x) ( p : u = v) : (x , u) =_{ \u03a3 ( a : A) , B a} (x , v) := ind-path (B x) (u) ( \\ v' p' \u2192 (x , u) = (x , v')) ( refl ) (v) (p) The following is essentially eq-pair but with explicit arguments. #def path-of-pairs-pair-of-paths ( x y : A) ( p : x = y) : ( u : B x) \u2192 ( v : B y) \u2192 ( (transport A B x y p u) = v) \u2192 ( x , u) =_{ \u03a3 ( z : A) , B z} (y , v) := ind-path ( A) ( x) ( \\ y' p' \u2192 (u' : B x) \u2192 ( v' : B y') \u2192 ((transport A B x y' p' u') = v') \u2192 (x , u') =_{ \u03a3 ( z : A) , B z} (y' , v')) ( \\ u' v' q' \u2192 (eq-eq-fiber-\u03a3 x u' v' q')) ( y) ( p) The inverse to pair-eq #def eq-pair ( s t : \u03a3 ( a : A) , B a) ( e : Eq-\u03a3 s t) : (s = t) := path-of-pairs-pair-of-paths ( first s) ( first t) ( first e) ( second s) ( second t) ( second e) #def eq-pair-pair-eq ( s t : \u03a3 ( a : A) , B a) ( e : s = t) : (eq-pair s t (pair-eq s t e)) = e := ind-path ( \u03a3 (a : A) , (B a)) ( s) ( \\ t' e' \u2192 (eq-pair s t' (pair-eq s t' e')) = e') ( refl ) ( t) ( e) Here we've decomposed e : Eq-\u03a3 s t as (e0, e1) and decomposed s and t similarly for induction purposes. #def pair-eq-eq-pair-split ( s0 : A) ( s1 : B s0) ( t0 : A) ( e0 : s0 = t0) : ( t1 : B t0) \u2192 ( e1 : (transport A B s0 t0 e0 s1) = t1) \u2192 ( ( pair-eq (s0 , s1) (t0 , t1) (eq-pair (s0 , s1) (t0 , t1) (e0 , e1))) =_{Eq-\u03a3 (s0 , s1) (t0 , t1)} ( e0 , e1)) := ind-path ( A) ( s0) ( \\ t0' e0' \u2192 ( t1 : B t0') \u2192 ( e1 : (transport A B s0 t0' e0' s1) = t1) \u2192 ( pair-eq (s0 , s1) (t0' , t1) (eq-pair (s0 , s1) (t0' , t1) (e0' , e1))) =_{Eq-\u03a3 (s0 , s1) (t0' , t1)} ( e0' , e1)) ( ind-path ( B s0) ( s1) ( \\ t1' e1' \u2192 ( pair-eq ( s0 , s1) ( s0 , t1') ( eq-pair (s0 , s1) (s0 , t1') ( refl , e1'))) =_{Eq-\u03a3 (s0 , s1) (s0 , t1')} ( refl , e1')) ( refl )) ( t0) ( e0) #def pair-eq-eq-pair ( s t : \u03a3 ( a : A) , B a) ( e : Eq-\u03a3 s t) : ( pair-eq s t (eq-pair s t e)) =_{Eq-\u03a3 s t} e := pair-eq-eq-pair-split ( first s) ( second s) ( first t) ( first e) ( second t) ( second e) #def extensionality-\u03a3 ( s t : \u03a3 ( a : A) , B a) : Equiv (s = t) (Eq-\u03a3 s t) := ( pair-eq s t , ( ( eq-pair s t , eq-pair-pair-eq s t) , ( eq-pair s t , pair-eq-eq-pair s t))) #end paths-in-sigma Identity types of Sigma types over a product \u00b6 #section paths-in-sigma-over-product #variables A B : U #variable C : A \u2192 B \u2192 U #def product-transport ( a a' : A) ( b b' : B) ( p : a = a') ( q : b = b') ( c : C a b) : C a' b' := ind-path ( B) ( b) ( \\ b'' q' \u2192 C a' b'') ( ind-path (A) (a) ( \\ a'' p' \u2192 C a'' b) (c) (a') (p)) ( b') ( q) #def Eq-\u03a3-over-product ( s t : \u03a3 ( a : A) , ( \u03a3 (b : B) , C a b)) : U := \u03a3 ( p : ( first s) = ( first t)) , ( \u03a3 ( q : ( first ( second s)) = ( first ( second t))) , ( product-transport ( first s) ( first t) ( first ( second s)) ( first ( second t)) p q ( second ( second s)) = ( second ( second t)))) Warning The following definition of triple-eq is the lazy definition with bad computational properties. #def triple-eq ( s t : \u03a3 ( a : A) , ( \u03a3 (b : B) , C a b)) ( e : s = t) : Eq-\u03a3-over-product s t := ind-path ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( s) ( \\ t' e' \u2192 (Eq-\u03a3-over-product s t')) ( ( refl , ( refl , refl ))) ( t) ( e) It's surprising that the following typechecks since we defined product-transport by a dual path induction over both p and q , rather than by saying that when p is refl this is ordinary transport. The inverse with explicit arguments #def triple-of-paths-path-of-triples ( a a' : A) ( u u' : B) ( c : C a u) ( p : a = a') : ( q : u = u') \u2192 ( c' : C a' u') \u2192 ( r : product-transport a a' u u' p q c = c') \u2192 ( (a , (u , c)) =_{ ( \u03a3 (x : A) , ( \u03a3 (y : B) , C x y))} (a' , (u' , c'))) := ind-path ( A) ( a) ( \\ a'' p' \u2192 ( q : u = u') \u2192 ( c' : C a'' u') \u2192 ( r : product-transport a a'' u u' p' q c = c') \u2192 ( (a , (u , c)) =_{ ( \u03a3 (x : A) , ( \u03a3 (y : B) , C x y))} (a'' , (u' , c')))) ( \\ q c' r \u2192 eq-eq-fiber-\u03a3 ( A) ( \\ x \u2192 (\u03a3 (v : B) , C x v)) (a) ( u , c) ( u' , c') ( path-of-pairs-pair-of-paths B ( \\ y \u2192 C a y) u u' q c c' r)) ( a') ( p) #def eq-triple ( s t : \u03a3 ( a : A) , ( \u03a3 (b : B) , C a b)) ( e : Eq-\u03a3-over-product s t) : (s = t) := triple-of-paths-path-of-triples ( first s) ( first t) ( first ( second s)) ( first ( second t)) ( second ( second s)) ( first e) ( first ( second e)) ( second ( second t)) ( second ( second e)) #def eq-triple-triple-eq ( s t : \u03a3 ( a : A) , ( \u03a3 (b : B) , C a b)) ( e : s = t) : (eq-triple s t (triple-eq s t e)) = e := ind-path ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( s) ( \\ t' e' \u2192 (eq-triple s t' (triple-eq s t' e')) = e') ( refl ) ( t) ( e) Here we've decomposed s , t and e for induction purposes: #def triple-eq-eq-triple-split ( a a' : A) ( b b' : B) ( c : C a b) : ( p : a = a') \u2192 ( q : b = b') \u2192 ( c' : C a' b') \u2192 ( r : product-transport a a' b b' p q c = c') \u2192 ( triple-eq ( a , (b , c)) (a' , (b' , c')) ( eq-triple (a , (b , c)) (a' , (b' , c')) (p , (q , r)))) = ( p , (q , r)) := ind-path ( A) ( a) ( \\ a'' p' \u2192 ( q : b = b') \u2192 ( c' : C a'' b') \u2192 ( r : product-transport a a'' b b' p' q c = c') \u2192 ( triple-eq ( a , (b , c)) (a'' , (b' , c')) ( eq-triple (a , (b , c)) (a'' , (b' , c')) (p' , (q , r)))) = ( p' , (q , r))) ( ind-path ( B) ( b) ( \\ b'' q' \u2192 ( c' : C a b'') \u2192 ( r : product-transport a a b b'' refl q' c = c') \u2192 ( triple-eq ( a , (b , c)) (a , (b'' , c')) ( eq-triple (a , (b , c)) (a , (b'' , c')) ( refl , (q' , r)))) = ( refl , (q' , r))) ( ind-path ( C a b) ( c) ( \\ c'' r' \u2192 triple-eq ( a , (b , c)) (a , (b , c'')) ( eq-triple ( a , (b , c)) (a , (b , c'')) ( refl , ( refl , r'))) = ( refl , ( refl , r'))) ( refl )) ( b')) ( a') #def triple-eq-eq-triple ( s t : \u03a3 ( a : A) , ( \u03a3 (b : B) , C a b)) ( e : Eq-\u03a3-over-product s t) : (triple-eq s t (eq-triple s t e)) = e := triple-eq-eq-triple-split ( first s) ( first t) ( first ( second s)) ( first ( second t)) ( second ( second s)) ( first e) ( first ( second e)) ( second ( second t)) ( second ( second e)) #def extensionality-\u03a3-over-product ( s t : \u03a3 ( a : A) , ( \u03a3 (b : B) , C a b)) : Equiv (s = t) (Eq-\u03a3-over-product s t) := ( triple-eq s t , ( ( eq-triple s t , eq-triple-triple-eq s t) , ( eq-triple s t , triple-eq-eq-triple s t))) #end paths-in-sigma-over-product Symmetry of products \u00b6 #def sym-product ( A B : U) : Equiv (product A B) (product B A) := ( \\ (a , b) \u2192 (b , a) , ( ( \\ (b , a) \u2192 (a , b) , \\ p \u2192 refl ) , ( \\ (b , a) \u2192 (a , b) , \\ p \u2192 refl ))) Fubini \u00b6 Given a family over a pair of independent types, the order of summation is unimportant. #def fubini-\u03a3 ( A B : U) ( C : A \u2192 B \u2192 U) : Equiv ( \u03a3 (x : A) , \u03a3 ( y : B) , C x y) ( \u03a3 (y : B) , \u03a3 ( x : A) , C x y) := ( \\ t \u2192 ( first ( second t) , ( first t , second ( second t))) , ( ( \\ t \u2192 ( first ( second t) , ( first t , second ( second t))) , \\ t \u2192 refl ) , ( \\ t \u2192 ( first ( second t) , ( first t , second ( second t))) , \\ t \u2192 refl ))) Products distribute inside Sigma types #def distributive-product-\u03a3 ( A B : U) ( C : B \u2192 U) : Equiv ( product A (\u03a3 (b : B) , C b)) ( \u03a3 (b : B) , product A (C b)) := ( \\ (a , (b , c)) \u2192 (b , (a , c)) , ( ( \\ (b , (a , c)) \u2192 (a , (b , c)) , \\ z \u2192 refl ) , ( \\ (b , (a , c)) \u2192 (a , (b , c)) , \\ z \u2192 refl ))) Associativity \u00b6 #def associative-\u03a3 ( A : U) ( B : A \u2192 U) ( C : ( a : A) \u2192 B a \u2192 U) : Equiv ( \u03a3 (a : A) , \u03a3 ( b : B a) , C a b) ( \u03a3 (ab : \u03a3 ( a : A) , B a) , C ( first ab) ( second ab)) := ( \\ (a , (b , c)) \u2192 ((a , b) , c) , ( ( \\ ((a , b) , c) \u2192 (a , (b , c)) , \\ _ \u2192 refl ) , ( \\ ((a , b) , c) \u2192 (a , (b , c)) , \\ _ \u2192 refl ))) Currying \u00b6 This is the dependent version of the currying equivalence. #def equiv-dependent-curry ( A : U) ( B : A \u2192 U) ( C : ( a : A) \u2192 B a \u2192 U) : Equiv ( (p : \u03a3 ( a : A) , (B a)) \u2192 C ( first p) ( second p)) ( (a : A) \u2192 ( b : B a) \u2192 C a b) := ( ( \\ s a b \u2192 s (a , b)) , ( ( ( \\ f (a , b) \u2192 f a b , \\ f \u2192 refl ) , ( \\ f (a , b) \u2192 f a b , \\ s \u2192 refl ))))","title":"Sigma types"},{"location":"hott/05-sigma.rzk/#5-sigma-types","text":"This is a literate rzk file: #lang rzk-1","title":"5. Sigma types"},{"location":"hott/05-sigma.rzk/#paths-involving-products","text":"#section paths-in-products #variables A B : U #def path-product ( a a' : A) ( b b' : B) ( e_A : a = a') ( e_B : b = b') : ( a , b) =_{product A B} (a' , b') := transport A ( \\ x \u2192 (a , b) =_{product A B} (x , b')) a a' e_A ( transport B ( \\ y \u2192 (a , b) =_{product A B} (a , y)) b b' e_B refl ) #def first-path-product ( x y : product A B) ( e : x =_{product A B} y) : first x = first y := ap (product A B) A x y ( \\ z \u2192 first z) e #def second-path-product ( x y : product A B) ( e : x =_{product A B} y) : second x = second y := ap (product A B) B x y ( \\ z \u2192 second z) e #end paths-in-products","title":"Paths involving products"},{"location":"hott/05-sigma.rzk/#identity-types-of-sigma-types","text":"#section paths-in-sigma #variable A : U #variable B : A \u2192 U #def first-path-\u03a3 ( s t : \u03a3 ( a : A) , B a) ( e : s = t) : first s = first t := ap ( \u03a3 (a : A) , B a) A s t ( \\ z \u2192 first z) e #def second-path-\u03a3 ( s t : \u03a3 ( a : A) , B a) ( e : s = t) : ( transport A B ( first s) ( first t) (first-path-\u03a3 s t e) ( second s)) = ( second t) := ind-path ( \u03a3 (a : A) , B a) ( s) ( \\ t' e' \u2192 ( transport A B ( first s) ( first t') (first-path-\u03a3 s t' e') ( second s)) = ( second t')) ( refl ) ( t) ( e) Rijke 22, Definition 9.3.1 #def Eq-\u03a3 ( s t : \u03a3 ( a : A) , B a) : U := \u03a3 ( p : ( first s) = ( first t)) , ( transport A B ( first s) ( first t) p ( second s)) = ( second t) Rijke 22, Definition 9.3.3 #def pair-eq ( s t : \u03a3 ( a : A) , B a) ( e : s = t) : Eq-\u03a3 s t := (first-path-\u03a3 s t e , second-path-\u03a3 s t e) A path in a fiber defines a path in the total space. #def eq-eq-fiber-\u03a3 ( x : A) ( u v : B x) ( p : u = v) : (x , u) =_{ \u03a3 ( a : A) , B a} (x , v) := ind-path (B x) (u) ( \\ v' p' \u2192 (x , u) = (x , v')) ( refl ) (v) (p) The following is essentially eq-pair but with explicit arguments. #def path-of-pairs-pair-of-paths ( x y : A) ( p : x = y) : ( u : B x) \u2192 ( v : B y) \u2192 ( (transport A B x y p u) = v) \u2192 ( x , u) =_{ \u03a3 ( z : A) , B z} (y , v) := ind-path ( A) ( x) ( \\ y' p' \u2192 (u' : B x) \u2192 ( v' : B y') \u2192 ((transport A B x y' p' u') = v') \u2192 (x , u') =_{ \u03a3 ( z : A) , B z} (y' , v')) ( \\ u' v' q' \u2192 (eq-eq-fiber-\u03a3 x u' v' q')) ( y) ( p) The inverse to pair-eq #def eq-pair ( s t : \u03a3 ( a : A) , B a) ( e : Eq-\u03a3 s t) : (s = t) := path-of-pairs-pair-of-paths ( first s) ( first t) ( first e) ( second s) ( second t) ( second e) #def eq-pair-pair-eq ( s t : \u03a3 ( a : A) , B a) ( e : s = t) : (eq-pair s t (pair-eq s t e)) = e := ind-path ( \u03a3 (a : A) , (B a)) ( s) ( \\ t' e' \u2192 (eq-pair s t' (pair-eq s t' e')) = e') ( refl ) ( t) ( e) Here we've decomposed e : Eq-\u03a3 s t as (e0, e1) and decomposed s and t similarly for induction purposes. #def pair-eq-eq-pair-split ( s0 : A) ( s1 : B s0) ( t0 : A) ( e0 : s0 = t0) : ( t1 : B t0) \u2192 ( e1 : (transport A B s0 t0 e0 s1) = t1) \u2192 ( ( pair-eq (s0 , s1) (t0 , t1) (eq-pair (s0 , s1) (t0 , t1) (e0 , e1))) =_{Eq-\u03a3 (s0 , s1) (t0 , t1)} ( e0 , e1)) := ind-path ( A) ( s0) ( \\ t0' e0' \u2192 ( t1 : B t0') \u2192 ( e1 : (transport A B s0 t0' e0' s1) = t1) \u2192 ( pair-eq (s0 , s1) (t0' , t1) (eq-pair (s0 , s1) (t0' , t1) (e0' , e1))) =_{Eq-\u03a3 (s0 , s1) (t0' , t1)} ( e0' , e1)) ( ind-path ( B s0) ( s1) ( \\ t1' e1' \u2192 ( pair-eq ( s0 , s1) ( s0 , t1') ( eq-pair (s0 , s1) (s0 , t1') ( refl , e1'))) =_{Eq-\u03a3 (s0 , s1) (s0 , t1')} ( refl , e1')) ( refl )) ( t0) ( e0) #def pair-eq-eq-pair ( s t : \u03a3 ( a : A) , B a) ( e : Eq-\u03a3 s t) : ( pair-eq s t (eq-pair s t e)) =_{Eq-\u03a3 s t} e := pair-eq-eq-pair-split ( first s) ( second s) ( first t) ( first e) ( second t) ( second e) #def extensionality-\u03a3 ( s t : \u03a3 ( a : A) , B a) : Equiv (s = t) (Eq-\u03a3 s t) := ( pair-eq s t , ( ( eq-pair s t , eq-pair-pair-eq s t) , ( eq-pair s t , pair-eq-eq-pair s t))) #end paths-in-sigma","title":"Identity types of Sigma types"},{"location":"hott/05-sigma.rzk/#identity-types-of-sigma-types-over-a-product","text":"#section paths-in-sigma-over-product #variables A B : U #variable C : A \u2192 B \u2192 U #def product-transport ( a a' : A) ( b b' : B) ( p : a = a') ( q : b = b') ( c : C a b) : C a' b' := ind-path ( B) ( b) ( \\ b'' q' \u2192 C a' b'') ( ind-path (A) (a) ( \\ a'' p' \u2192 C a'' b) (c) (a') (p)) ( b') ( q) #def Eq-\u03a3-over-product ( s t : \u03a3 ( a : A) , ( \u03a3 (b : B) , C a b)) : U := \u03a3 ( p : ( first s) = ( first t)) , ( \u03a3 ( q : ( first ( second s)) = ( first ( second t))) , ( product-transport ( first s) ( first t) ( first ( second s)) ( first ( second t)) p q ( second ( second s)) = ( second ( second t)))) Warning The following definition of triple-eq is the lazy definition with bad computational properties. #def triple-eq ( s t : \u03a3 ( a : A) , ( \u03a3 (b : B) , C a b)) ( e : s = t) : Eq-\u03a3-over-product s t := ind-path ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( s) ( \\ t' e' \u2192 (Eq-\u03a3-over-product s t')) ( ( refl , ( refl , refl ))) ( t) ( e) It's surprising that the following typechecks since we defined product-transport by a dual path induction over both p and q , rather than by saying that when p is refl this is ordinary transport. The inverse with explicit arguments #def triple-of-paths-path-of-triples ( a a' : A) ( u u' : B) ( c : C a u) ( p : a = a') : ( q : u = u') \u2192 ( c' : C a' u') \u2192 ( r : product-transport a a' u u' p q c = c') \u2192 ( (a , (u , c)) =_{ ( \u03a3 (x : A) , ( \u03a3 (y : B) , C x y))} (a' , (u' , c'))) := ind-path ( A) ( a) ( \\ a'' p' \u2192 ( q : u = u') \u2192 ( c' : C a'' u') \u2192 ( r : product-transport a a'' u u' p' q c = c') \u2192 ( (a , (u , c)) =_{ ( \u03a3 (x : A) , ( \u03a3 (y : B) , C x y))} (a'' , (u' , c')))) ( \\ q c' r \u2192 eq-eq-fiber-\u03a3 ( A) ( \\ x \u2192 (\u03a3 (v : B) , C x v)) (a) ( u , c) ( u' , c') ( path-of-pairs-pair-of-paths B ( \\ y \u2192 C a y) u u' q c c' r)) ( a') ( p) #def eq-triple ( s t : \u03a3 ( a : A) , ( \u03a3 (b : B) , C a b)) ( e : Eq-\u03a3-over-product s t) : (s = t) := triple-of-paths-path-of-triples ( first s) ( first t) ( first ( second s)) ( first ( second t)) ( second ( second s)) ( first e) ( first ( second e)) ( second ( second t)) ( second ( second e)) #def eq-triple-triple-eq ( s t : \u03a3 ( a : A) , ( \u03a3 (b : B) , C a b)) ( e : s = t) : (eq-triple s t (triple-eq s t e)) = e := ind-path ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( s) ( \\ t' e' \u2192 (eq-triple s t' (triple-eq s t' e')) = e') ( refl ) ( t) ( e) Here we've decomposed s , t and e for induction purposes: #def triple-eq-eq-triple-split ( a a' : A) ( b b' : B) ( c : C a b) : ( p : a = a') \u2192 ( q : b = b') \u2192 ( c' : C a' b') \u2192 ( r : product-transport a a' b b' p q c = c') \u2192 ( triple-eq ( a , (b , c)) (a' , (b' , c')) ( eq-triple (a , (b , c)) (a' , (b' , c')) (p , (q , r)))) = ( p , (q , r)) := ind-path ( A) ( a) ( \\ a'' p' \u2192 ( q : b = b') \u2192 ( c' : C a'' b') \u2192 ( r : product-transport a a'' b b' p' q c = c') \u2192 ( triple-eq ( a , (b , c)) (a'' , (b' , c')) ( eq-triple (a , (b , c)) (a'' , (b' , c')) (p' , (q , r)))) = ( p' , (q , r))) ( ind-path ( B) ( b) ( \\ b'' q' \u2192 ( c' : C a b'') \u2192 ( r : product-transport a a b b'' refl q' c = c') \u2192 ( triple-eq ( a , (b , c)) (a , (b'' , c')) ( eq-triple (a , (b , c)) (a , (b'' , c')) ( refl , (q' , r)))) = ( refl , (q' , r))) ( ind-path ( C a b) ( c) ( \\ c'' r' \u2192 triple-eq ( a , (b , c)) (a , (b , c'')) ( eq-triple ( a , (b , c)) (a , (b , c'')) ( refl , ( refl , r'))) = ( refl , ( refl , r'))) ( refl )) ( b')) ( a') #def triple-eq-eq-triple ( s t : \u03a3 ( a : A) , ( \u03a3 (b : B) , C a b)) ( e : Eq-\u03a3-over-product s t) : (triple-eq s t (eq-triple s t e)) = e := triple-eq-eq-triple-split ( first s) ( first t) ( first ( second s)) ( first ( second t)) ( second ( second s)) ( first e) ( first ( second e)) ( second ( second t)) ( second ( second e)) #def extensionality-\u03a3-over-product ( s t : \u03a3 ( a : A) , ( \u03a3 (b : B) , C a b)) : Equiv (s = t) (Eq-\u03a3-over-product s t) := ( triple-eq s t , ( ( eq-triple s t , eq-triple-triple-eq s t) , ( eq-triple s t , triple-eq-eq-triple s t))) #end paths-in-sigma-over-product","title":"Identity types of Sigma types over a product"},{"location":"hott/05-sigma.rzk/#symmetry-of-products","text":"#def sym-product ( A B : U) : Equiv (product A B) (product B A) := ( \\ (a , b) \u2192 (b , a) , ( ( \\ (b , a) \u2192 (a , b) , \\ p \u2192 refl ) , ( \\ (b , a) \u2192 (a , b) , \\ p \u2192 refl )))","title":"Symmetry of products"},{"location":"hott/05-sigma.rzk/#fubini","text":"Given a family over a pair of independent types, the order of summation is unimportant. #def fubini-\u03a3 ( A B : U) ( C : A \u2192 B \u2192 U) : Equiv ( \u03a3 (x : A) , \u03a3 ( y : B) , C x y) ( \u03a3 (y : B) , \u03a3 ( x : A) , C x y) := ( \\ t \u2192 ( first ( second t) , ( first t , second ( second t))) , ( ( \\ t \u2192 ( first ( second t) , ( first t , second ( second t))) , \\ t \u2192 refl ) , ( \\ t \u2192 ( first ( second t) , ( first t , second ( second t))) , \\ t \u2192 refl ))) Products distribute inside Sigma types #def distributive-product-\u03a3 ( A B : U) ( C : B \u2192 U) : Equiv ( product A (\u03a3 (b : B) , C b)) ( \u03a3 (b : B) , product A (C b)) := ( \\ (a , (b , c)) \u2192 (b , (a , c)) , ( ( \\ (b , (a , c)) \u2192 (a , (b , c)) , \\ z \u2192 refl ) , ( \\ (b , (a , c)) \u2192 (a , (b , c)) , \\ z \u2192 refl )))","title":"Fubini"},{"location":"hott/05-sigma.rzk/#associativity","text":"#def associative-\u03a3 ( A : U) ( B : A \u2192 U) ( C : ( a : A) \u2192 B a \u2192 U) : Equiv ( \u03a3 (a : A) , \u03a3 ( b : B a) , C a b) ( \u03a3 (ab : \u03a3 ( a : A) , B a) , C ( first ab) ( second ab)) := ( \\ (a , (b , c)) \u2192 ((a , b) , c) , ( ( \\ ((a , b) , c) \u2192 (a , (b , c)) , \\ _ \u2192 refl ) , ( \\ ((a , b) , c) \u2192 (a , (b , c)) , \\ _ \u2192 refl )))","title":"Associativity"},{"location":"hott/05-sigma.rzk/#currying","text":"This is the dependent version of the currying equivalence. #def equiv-dependent-curry ( A : U) ( B : A \u2192 U) ( C : ( a : A) \u2192 B a \u2192 U) : Equiv ( (p : \u03a3 ( a : A) , (B a)) \u2192 C ( first p) ( second p)) ( (a : A) \u2192 ( b : B a) \u2192 C a b) := ( ( \\ s a b \u2192 s (a , b)) , ( ( ( \\ f (a , b) \u2192 f a b , \\ f \u2192 refl ) , ( \\ f (a , b) \u2192 f a b , \\ s \u2192 refl ))))","title":"Currying"},{"location":"hott/06-contractible.rzk/","text":"6. Contractible \u00b6 This is a literate rzk file: #lang rzk-1 Contractible types \u00b6 The type of contractibility proofs #def is-contr ( A : U) : U := \u03a3 ( x : A) , ( (y : A) \u2192 x = y) Contractible type data \u00b6 #section contractible-data #variable A : U #variable is-contr-A : is-contr A #def center-contraction : A := ( first is-contr-A) The path from the contraction center to any point #def homotopy-contraction : ( z : A) \u2192 center-contraction = z := second is-contr-A #def realign-homotopy-contraction uses ( is-contr-A ) : ( z : A) \u2192 center-contraction = z := \\ z \u2192 ( concat A center-contraction center-contraction z (rev A center-contraction center-contraction ( homotopy-contraction center-contraction)) (homotopy-contraction z)) #def path-realign-homotopy-contraction uses ( is-contr-A ) : ( realign-homotopy-contraction center-contraction) = refl := ( left-inverse-concat A center-contraction center-contraction ( homotopy-contraction center-contraction)) A path between any pair of terms in a contractible type #def eq-is-contr uses ( is-contr-A ) ( x y : A) : x = y := zag-zig-concat A x center-contraction y ( homotopy-contraction x) (homotopy-contraction y) #end contractible-data Unit type \u00b6 The prototypical contractible type is the unit type, which is built-in to rzk. #def ind-unit ( C : Unit \u2192 U) ( C-unit : C unit ) ( x : Unit) : C x := C-unit #def is-prop-unit ( x y : Unit) : x = y := refl The terminal projection as a constant map #def terminal-map ( A : U) : A \u2192 Unit := constant A Unit unit Identity types of unit types \u00b6 #def terminal-map-of-path-types-of-Unit-has-retr ( x y : Unit) : has-retraction (x = y) Unit (terminal-map (x = y)) := ( \\ a \u2192 refl , \\ p \u2192 ind-path (Unit) (x) ( \\ y' p' \u2192 refl =_{x = y'} p') ( refl ) (y) (p)) #def terminal-map-of-path-types-of-Unit-has-sec ( x y : Unit) : has-section (x = y) Unit (terminal-map (x = y)) := ( \\ a \u2192 refl , \\ a \u2192 refl ) #def terminal-map-of-path-types-of-Unit-is-equiv ( x y : Unit) : is-equiv (x = y) Unit (terminal-map (x = y)) := ( terminal-map-of-path-types-of-Unit-has-retr x y , terminal-map-of-path-types-of-Unit-has-sec x y) Characterization of contractibility \u00b6 A type is contractible if and only if its terminal map is an equivalence. #def terminal-map-is-equiv ( A : U) : U := is-equiv A Unit (terminal-map A) #def contr-implies-terminal-map-is-equiv-retr ( A : U) ( is-contr-A : is-contr A) : has-retraction A Unit (terminal-map A) := ( constant Unit A (center-contraction A is-contr-A) , \\ y \u2192 (homotopy-contraction A is-contr-A) y) #def contr-implies-terminal-map-is-equiv-sec ( A : U) ( is-contr-A : is-contr A) : has-section A Unit (terminal-map A) := ( constant Unit A (center-contraction A is-contr-A) , \\ z \u2192 refl ) #def contr-implies-terminal-map-is-equiv ( A : U) ( is-contr-A : is-contr A) : is-equiv A Unit (terminal-map A) := ( contr-implies-terminal-map-is-equiv-retr A is-contr-A , contr-implies-terminal-map-is-equiv-sec A is-contr-A) #def terminal-map-is-equiv-implies-contr ( A : U) ( e : terminal-map-is-equiv A) : is-contr A := ( ( first ( first e)) unit , ( second ( first e))) #def contr-iff-terminal-map-is-equiv ( A : U) : iff (is-contr A) (terminal-map-is-equiv A) := ( ( contr-implies-terminal-map-is-equiv A) , ( terminal-map-is-equiv-implies-contr A)) #def equiv-with-contractible-domain-implies-contractible-codomain ( A B : U) ( f : Equiv A B) ( is-contr-A : is-contr A) : is-contr B := ( terminal-map-is-equiv-implies-contr B ( second ( equiv-comp B A Unit ( inv-equiv A B f) ( ( terminal-map A) , ( contr-implies-terminal-map-is-equiv A is-contr-A))))) #def equiv-with-contractible-codomain-implies-contractible-domain ( A B : U) ( f : Equiv A B) ( is-contr-B : is-contr B) : is-contr A := ( equiv-with-contractible-domain-implies-contractible-codomain B A ( inv-equiv A B f) is-contr-B) #def equiv-then-domain-contractible-iff-codomain-contractible ( A B : U) ( f : Equiv A B) : ( iff (is-contr A) (is-contr B)) := ( \\ is-contr-A \u2192 ( equiv-with-contractible-domain-implies-contractible-codomain A B f is-contr-A) , \\ is-contr-B \u2192 ( equiv-with-contractible-codomain-implies-contractible-domain A B f is-contr-B)) #def path-types-of-Unit-are-contractible ( x y : Unit) : is-contr (x = y) := ( terminal-map-is-equiv-implies-contr ( x = y) (terminal-map-of-path-types-of-Unit-is-equiv x y)) Retracts of contractible types \u00b6 A retract of contractible types is contractible. The type of proofs that A is a retract of B #def is-retract-of ( A B : U) : U := \u03a3 ( s : A \u2192 B) , has-retraction A B s #section retraction-data #variables A B : U #variable is-retract-of-A-B : is-retract-of A B #def is-retract-of-section : A \u2192 B := first is-retract-of-A-B #def is-retract-of-retraction : B \u2192 A := first ( second is-retract-of-A-B) #def is-retract-of-homotopy : homotopy A A (comp A B A is-retract-of-retraction is-retract-of-section) (identity A) := second ( second is-retract-of-A-B) If A is a retract of a contractible type it has a term #def is-retract-of-is-contr-isInhabited uses ( is-retract-of-A-B ) ( is-contr-B : is-contr B) : A := is-retract-of-retraction (center-contraction B is-contr-B) If A is a retract of a contractible type it has a contracting homotopy #def is-retract-of-is-contr-hasHtpy uses ( is-retract-of-A-B ) ( is-contr-B : is-contr B) ( a : A) : ( is-retract-of-is-contr-isInhabited is-contr-B) = a := concat ( A) ( is-retract-of-is-contr-isInhabited is-contr-B) ( (comp A B A is-retract-of-retraction is-retract-of-section) a) ( a) ( ap B A (center-contraction B is-contr-B) (is-retract-of-section a) ( is-retract-of-retraction) ( homotopy-contraction B is-contr-B (is-retract-of-section a))) ( is-retract-of-homotopy a) If A is a retract of a contractible type it is contractible #def is-contr-is-retract-of-is-contr uses ( is-retract-of-A-B ) ( is-contr-B : is-contr B) : is-contr A := ( is-retract-of-is-contr-isInhabited is-contr-B , is-retract-of-is-contr-hasHtpy is-contr-B) #end retraction-data Functions between contractible types \u00b6 Any function between contractible types is an equivalence #def is-equiv-are-contr ( A B : U) ( is-contr-A : is-contr A) ( is-contr-B : is-contr B) ( f : A \u2192 B) : is-equiv A B f := ( ( \\ b \u2192 center-contraction A is-contr-A , \\ a \u2192 homotopy-contraction A is-contr-A a) , ( \\ b \u2192 center-contraction A is-contr-A , \\ b \u2192 eq-is-contr B is-contr-B (f (center-contraction A is-contr-A)) b)) A type equivalent to a contractible type is contractible #def is-contr-equiv-is-contr' ( A B : U) ( e : Equiv A B) ( is-contr-B : is-contr B) : is-contr A := is-contr-is-retract-of-is-contr A B ( first e , first ( second e)) is-contr-B #def is-contr-equiv-is-contr ( A B : U) ( e : Equiv A B) ( is-contr-A : is-contr A) : is-contr B := is-contr-is-retract-of-is-contr B A ( first ( second ( second e)) , ( first e , second ( second ( second e)))) ( is-contr-A) Based path spaces \u00b6 For example, we prove that based path spaces are contractible. Transport in the space of paths starting at a is concatenation #def concat-as-based-transport ( A : U) ( a x y : A) ( p : a = x) ( q : x = y) : ( transport A ( \\ z \u2192 (a = z)) x y q p) = (concat A a x y p q) := ind-path ( A) ( x) ( \\ y' q' \u2192 ( transport A ( \\ z \u2192 (a = z)) x y' q' p) = (concat A a x y' p q')) ( refl ) ( y) ( q) The center of contraction in the based path space is (a , refl ) . The center of contraction in the based path space #def center-based-paths ( A : U) ( a : A) : \u03a3 ( x : A) , (a = x) := (a , refl ) The contracting homotopy in the based path space #def contraction-based-paths ( A : U) ( a : A) ( p : \u03a3 ( x : A) , a = x) : (center-based-paths A a) = p := path-of-pairs-pair-of-paths A ( \\ z \u2192 a = z) a ( first p) ( second p) ( refl ) ( second p) ( concat ( a = ( first p)) ( transport A ( \\ z \u2192 (a = z)) a ( first p) ( second p) ( refl )) ( concat A a a ( first p) ( refl ) ( second p)) ( second p) ( concat-as-based-transport A a a ( first p) ( refl ) ( second p)) ( left-unit-concat A a ( first p) ( second p))) Based path spaces are contractible #def is-contr-based-paths ( A : U) ( a : A) : is-contr ( \u03a3 (x : A) , a = x) := (center-based-paths A a , contraction-based-paths A a) Contractible products \u00b6 #def is-contr-product ( A B : U) ( is-contr-A : is-contr A) ( is-contr-B : is-contr B) : is-contr (product A B) := ( ( first is-contr-A , first is-contr-B) , \\ p \u2192 path-product A B ( first is-contr-A) ( first p) ( first is-contr-B) ( second p) ( second is-contr-A ( first p)) ( second is-contr-B ( second p))) #def first-is-contr-product ( A B : U) ( AxB-is-contr : is-contr (product A B)) : is-contr A := ( first ( first AxB-is-contr) , \\ a \u2192 first-path-product A B ( first AxB-is-contr) ( a , second ( first AxB-is-contr)) ( second AxB-is-contr (a , second ( first AxB-is-contr)))) #def is-contr-base-is-contr-\u03a3 ( A : U) ( B : A \u2192 U) ( b : ( a : A) \u2192 B a) ( is-contr-AB : is-contr ( \u03a3 (a : A) , B a)) : is-contr A := ( first ( first is-contr-AB) , \\ a \u2192 first-path-\u03a3 A B ( first is-contr-AB) ( a , b a) ( second is-contr-AB (a , b a))) Singleton induction \u00b6 A type is contractible if and only if it has singleton induction. #def ev-pt ( A : U) ( a : A) ( B : A \u2192 U) : ( (x : A) \u2192 B x) \u2192 B a := \\ f \u2192 f a #def has-singleton-induction-pointed ( A : U) ( a : A) ( B : A \u2192 U) : U := has-section ( (x : A) \u2192 B x) (B a) (ev-pt A a B) #def has-singleton-induction-pointed-structure ( A : U) ( a : A) : U := ( B : A \u2192 U) \u2192 has-section ( (x : A) \u2192 B x) (B a) (ev-pt A a B) #def has-singleton-induction ( A : U) : U := \u03a3 ( a : A) , ( B : A \u2192 U) \u2192 (has-singleton-induction-pointed A a B) #def ind-sing ( A : U) ( a : A) ( B : A \u2192 U) ( singleton-ind-A : has-singleton-induction-pointed A a B) : (B a) \u2192 ( (x : A) \u2192 B x) := ( first singleton-ind-A) #def compute-ind-sing ( A : U) ( a : A) ( B : A \u2192 U) ( singleton-ind-A : has-singleton-induction-pointed A a B) : ( homotopy ( B a) ( B a) ( comp ( B a) ( (x : A) \u2192 B x) ( B a) ( ev-pt A a B) ( ind-sing A a B singleton-ind-A)) ( identity (B a))) := ( second singleton-ind-A) #def contr-implies-singleton-induction-ind ( A : U) ( is-contr-A : is-contr A) : (has-singleton-induction A) := ( ( center-contraction A is-contr-A) , \\ B \u2192 ( ( \\ b x \u2192 ( transport A B ( center-contraction A is-contr-A) x ( realign-homotopy-contraction A is-contr-A x) b)) , ( \\ b \u2192 ( ap ( (center-contraction A is-contr-A) = (center-contraction A is-contr-A)) ( B (center-contraction A is-contr-A)) ( realign-homotopy-contraction A is-contr-A ( center-contraction A is-contr-A)) refl _{(center-contraction A is-contr-A)} ( \\ p \u2192 ( transport-loop A B (center-contraction A is-contr-A) b p)) ( path-realign-homotopy-contraction A is-contr-A))))) #def contr-implies-singleton-induction-pointed ( A : U) ( is-contr-A : is-contr A) ( B : A \u2192 U) : has-singleton-induction-pointed A (center-contraction A is-contr-A) B := ( second (contr-implies-singleton-induction-ind A is-contr-A)) B #def singleton-induction-ind-implies-contr ( A : U) ( a : A) ( f : has-singleton-induction-pointed-structure A a) : ( is-contr A) := ( a , ( first (f ( \\ x \u2192 a = x))) ( refl _{a}))","title":"Contractible"},{"location":"hott/06-contractible.rzk/#6-contractible","text":"This is a literate rzk file: #lang rzk-1","title":"6. Contractible"},{"location":"hott/06-contractible.rzk/#contractible-types","text":"The type of contractibility proofs #def is-contr ( A : U) : U := \u03a3 ( x : A) , ( (y : A) \u2192 x = y)","title":"Contractible types"},{"location":"hott/06-contractible.rzk/#contractible-type-data","text":"#section contractible-data #variable A : U #variable is-contr-A : is-contr A #def center-contraction : A := ( first is-contr-A) The path from the contraction center to any point #def homotopy-contraction : ( z : A) \u2192 center-contraction = z := second is-contr-A #def realign-homotopy-contraction uses ( is-contr-A ) : ( z : A) \u2192 center-contraction = z := \\ z \u2192 ( concat A center-contraction center-contraction z (rev A center-contraction center-contraction ( homotopy-contraction center-contraction)) (homotopy-contraction z)) #def path-realign-homotopy-contraction uses ( is-contr-A ) : ( realign-homotopy-contraction center-contraction) = refl := ( left-inverse-concat A center-contraction center-contraction ( homotopy-contraction center-contraction)) A path between any pair of terms in a contractible type #def eq-is-contr uses ( is-contr-A ) ( x y : A) : x = y := zag-zig-concat A x center-contraction y ( homotopy-contraction x) (homotopy-contraction y) #end contractible-data","title":"Contractible type data"},{"location":"hott/06-contractible.rzk/#unit-type","text":"The prototypical contractible type is the unit type, which is built-in to rzk. #def ind-unit ( C : Unit \u2192 U) ( C-unit : C unit ) ( x : Unit) : C x := C-unit #def is-prop-unit ( x y : Unit) : x = y := refl The terminal projection as a constant map #def terminal-map ( A : U) : A \u2192 Unit := constant A Unit unit","title":"Unit type"},{"location":"hott/06-contractible.rzk/#identity-types-of-unit-types","text":"#def terminal-map-of-path-types-of-Unit-has-retr ( x y : Unit) : has-retraction (x = y) Unit (terminal-map (x = y)) := ( \\ a \u2192 refl , \\ p \u2192 ind-path (Unit) (x) ( \\ y' p' \u2192 refl =_{x = y'} p') ( refl ) (y) (p)) #def terminal-map-of-path-types-of-Unit-has-sec ( x y : Unit) : has-section (x = y) Unit (terminal-map (x = y)) := ( \\ a \u2192 refl , \\ a \u2192 refl ) #def terminal-map-of-path-types-of-Unit-is-equiv ( x y : Unit) : is-equiv (x = y) Unit (terminal-map (x = y)) := ( terminal-map-of-path-types-of-Unit-has-retr x y , terminal-map-of-path-types-of-Unit-has-sec x y)","title":"Identity types of unit types"},{"location":"hott/06-contractible.rzk/#characterization-of-contractibility","text":"A type is contractible if and only if its terminal map is an equivalence. #def terminal-map-is-equiv ( A : U) : U := is-equiv A Unit (terminal-map A) #def contr-implies-terminal-map-is-equiv-retr ( A : U) ( is-contr-A : is-contr A) : has-retraction A Unit (terminal-map A) := ( constant Unit A (center-contraction A is-contr-A) , \\ y \u2192 (homotopy-contraction A is-contr-A) y) #def contr-implies-terminal-map-is-equiv-sec ( A : U) ( is-contr-A : is-contr A) : has-section A Unit (terminal-map A) := ( constant Unit A (center-contraction A is-contr-A) , \\ z \u2192 refl ) #def contr-implies-terminal-map-is-equiv ( A : U) ( is-contr-A : is-contr A) : is-equiv A Unit (terminal-map A) := ( contr-implies-terminal-map-is-equiv-retr A is-contr-A , contr-implies-terminal-map-is-equiv-sec A is-contr-A) #def terminal-map-is-equiv-implies-contr ( A : U) ( e : terminal-map-is-equiv A) : is-contr A := ( ( first ( first e)) unit , ( second ( first e))) #def contr-iff-terminal-map-is-equiv ( A : U) : iff (is-contr A) (terminal-map-is-equiv A) := ( ( contr-implies-terminal-map-is-equiv A) , ( terminal-map-is-equiv-implies-contr A)) #def equiv-with-contractible-domain-implies-contractible-codomain ( A B : U) ( f : Equiv A B) ( is-contr-A : is-contr A) : is-contr B := ( terminal-map-is-equiv-implies-contr B ( second ( equiv-comp B A Unit ( inv-equiv A B f) ( ( terminal-map A) , ( contr-implies-terminal-map-is-equiv A is-contr-A))))) #def equiv-with-contractible-codomain-implies-contractible-domain ( A B : U) ( f : Equiv A B) ( is-contr-B : is-contr B) : is-contr A := ( equiv-with-contractible-domain-implies-contractible-codomain B A ( inv-equiv A B f) is-contr-B) #def equiv-then-domain-contractible-iff-codomain-contractible ( A B : U) ( f : Equiv A B) : ( iff (is-contr A) (is-contr B)) := ( \\ is-contr-A \u2192 ( equiv-with-contractible-domain-implies-contractible-codomain A B f is-contr-A) , \\ is-contr-B \u2192 ( equiv-with-contractible-codomain-implies-contractible-domain A B f is-contr-B)) #def path-types-of-Unit-are-contractible ( x y : Unit) : is-contr (x = y) := ( terminal-map-is-equiv-implies-contr ( x = y) (terminal-map-of-path-types-of-Unit-is-equiv x y))","title":"Characterization of contractibility"},{"location":"hott/06-contractible.rzk/#retracts-of-contractible-types","text":"A retract of contractible types is contractible. The type of proofs that A is a retract of B #def is-retract-of ( A B : U) : U := \u03a3 ( s : A \u2192 B) , has-retraction A B s #section retraction-data #variables A B : U #variable is-retract-of-A-B : is-retract-of A B #def is-retract-of-section : A \u2192 B := first is-retract-of-A-B #def is-retract-of-retraction : B \u2192 A := first ( second is-retract-of-A-B) #def is-retract-of-homotopy : homotopy A A (comp A B A is-retract-of-retraction is-retract-of-section) (identity A) := second ( second is-retract-of-A-B) If A is a retract of a contractible type it has a term #def is-retract-of-is-contr-isInhabited uses ( is-retract-of-A-B ) ( is-contr-B : is-contr B) : A := is-retract-of-retraction (center-contraction B is-contr-B) If A is a retract of a contractible type it has a contracting homotopy #def is-retract-of-is-contr-hasHtpy uses ( is-retract-of-A-B ) ( is-contr-B : is-contr B) ( a : A) : ( is-retract-of-is-contr-isInhabited is-contr-B) = a := concat ( A) ( is-retract-of-is-contr-isInhabited is-contr-B) ( (comp A B A is-retract-of-retraction is-retract-of-section) a) ( a) ( ap B A (center-contraction B is-contr-B) (is-retract-of-section a) ( is-retract-of-retraction) ( homotopy-contraction B is-contr-B (is-retract-of-section a))) ( is-retract-of-homotopy a) If A is a retract of a contractible type it is contractible #def is-contr-is-retract-of-is-contr uses ( is-retract-of-A-B ) ( is-contr-B : is-contr B) : is-contr A := ( is-retract-of-is-contr-isInhabited is-contr-B , is-retract-of-is-contr-hasHtpy is-contr-B) #end retraction-data","title":"Retracts of contractible types"},{"location":"hott/06-contractible.rzk/#functions-between-contractible-types","text":"Any function between contractible types is an equivalence #def is-equiv-are-contr ( A B : U) ( is-contr-A : is-contr A) ( is-contr-B : is-contr B) ( f : A \u2192 B) : is-equiv A B f := ( ( \\ b \u2192 center-contraction A is-contr-A , \\ a \u2192 homotopy-contraction A is-contr-A a) , ( \\ b \u2192 center-contraction A is-contr-A , \\ b \u2192 eq-is-contr B is-contr-B (f (center-contraction A is-contr-A)) b)) A type equivalent to a contractible type is contractible #def is-contr-equiv-is-contr' ( A B : U) ( e : Equiv A B) ( is-contr-B : is-contr B) : is-contr A := is-contr-is-retract-of-is-contr A B ( first e , first ( second e)) is-contr-B #def is-contr-equiv-is-contr ( A B : U) ( e : Equiv A B) ( is-contr-A : is-contr A) : is-contr B := is-contr-is-retract-of-is-contr B A ( first ( second ( second e)) , ( first e , second ( second ( second e)))) ( is-contr-A)","title":"Functions between contractible types"},{"location":"hott/06-contractible.rzk/#based-path-spaces","text":"For example, we prove that based path spaces are contractible. Transport in the space of paths starting at a is concatenation #def concat-as-based-transport ( A : U) ( a x y : A) ( p : a = x) ( q : x = y) : ( transport A ( \\ z \u2192 (a = z)) x y q p) = (concat A a x y p q) := ind-path ( A) ( x) ( \\ y' q' \u2192 ( transport A ( \\ z \u2192 (a = z)) x y' q' p) = (concat A a x y' p q')) ( refl ) ( y) ( q) The center of contraction in the based path space is (a , refl ) . The center of contraction in the based path space #def center-based-paths ( A : U) ( a : A) : \u03a3 ( x : A) , (a = x) := (a , refl ) The contracting homotopy in the based path space #def contraction-based-paths ( A : U) ( a : A) ( p : \u03a3 ( x : A) , a = x) : (center-based-paths A a) = p := path-of-pairs-pair-of-paths A ( \\ z \u2192 a = z) a ( first p) ( second p) ( refl ) ( second p) ( concat ( a = ( first p)) ( transport A ( \\ z \u2192 (a = z)) a ( first p) ( second p) ( refl )) ( concat A a a ( first p) ( refl ) ( second p)) ( second p) ( concat-as-based-transport A a a ( first p) ( refl ) ( second p)) ( left-unit-concat A a ( first p) ( second p))) Based path spaces are contractible #def is-contr-based-paths ( A : U) ( a : A) : is-contr ( \u03a3 (x : A) , a = x) := (center-based-paths A a , contraction-based-paths A a)","title":"Based path spaces"},{"location":"hott/06-contractible.rzk/#contractible-products","text":"#def is-contr-product ( A B : U) ( is-contr-A : is-contr A) ( is-contr-B : is-contr B) : is-contr (product A B) := ( ( first is-contr-A , first is-contr-B) , \\ p \u2192 path-product A B ( first is-contr-A) ( first p) ( first is-contr-B) ( second p) ( second is-contr-A ( first p)) ( second is-contr-B ( second p))) #def first-is-contr-product ( A B : U) ( AxB-is-contr : is-contr (product A B)) : is-contr A := ( first ( first AxB-is-contr) , \\ a \u2192 first-path-product A B ( first AxB-is-contr) ( a , second ( first AxB-is-contr)) ( second AxB-is-contr (a , second ( first AxB-is-contr)))) #def is-contr-base-is-contr-\u03a3 ( A : U) ( B : A \u2192 U) ( b : ( a : A) \u2192 B a) ( is-contr-AB : is-contr ( \u03a3 (a : A) , B a)) : is-contr A := ( first ( first is-contr-AB) , \\ a \u2192 first-path-\u03a3 A B ( first is-contr-AB) ( a , b a) ( second is-contr-AB (a , b a)))","title":"Contractible products"},{"location":"hott/06-contractible.rzk/#singleton-induction","text":"A type is contractible if and only if it has singleton induction. #def ev-pt ( A : U) ( a : A) ( B : A \u2192 U) : ( (x : A) \u2192 B x) \u2192 B a := \\ f \u2192 f a #def has-singleton-induction-pointed ( A : U) ( a : A) ( B : A \u2192 U) : U := has-section ( (x : A) \u2192 B x) (B a) (ev-pt A a B) #def has-singleton-induction-pointed-structure ( A : U) ( a : A) : U := ( B : A \u2192 U) \u2192 has-section ( (x : A) \u2192 B x) (B a) (ev-pt A a B) #def has-singleton-induction ( A : U) : U := \u03a3 ( a : A) , ( B : A \u2192 U) \u2192 (has-singleton-induction-pointed A a B) #def ind-sing ( A : U) ( a : A) ( B : A \u2192 U) ( singleton-ind-A : has-singleton-induction-pointed A a B) : (B a) \u2192 ( (x : A) \u2192 B x) := ( first singleton-ind-A) #def compute-ind-sing ( A : U) ( a : A) ( B : A \u2192 U) ( singleton-ind-A : has-singleton-induction-pointed A a B) : ( homotopy ( B a) ( B a) ( comp ( B a) ( (x : A) \u2192 B x) ( B a) ( ev-pt A a B) ( ind-sing A a B singleton-ind-A)) ( identity (B a))) := ( second singleton-ind-A) #def contr-implies-singleton-induction-ind ( A : U) ( is-contr-A : is-contr A) : (has-singleton-induction A) := ( ( center-contraction A is-contr-A) , \\ B \u2192 ( ( \\ b x \u2192 ( transport A B ( center-contraction A is-contr-A) x ( realign-homotopy-contraction A is-contr-A x) b)) , ( \\ b \u2192 ( ap ( (center-contraction A is-contr-A) = (center-contraction A is-contr-A)) ( B (center-contraction A is-contr-A)) ( realign-homotopy-contraction A is-contr-A ( center-contraction A is-contr-A)) refl _{(center-contraction A is-contr-A)} ( \\ p \u2192 ( transport-loop A B (center-contraction A is-contr-A) b p)) ( path-realign-homotopy-contraction A is-contr-A))))) #def contr-implies-singleton-induction-pointed ( A : U) ( is-contr-A : is-contr A) ( B : A \u2192 U) : has-singleton-induction-pointed A (center-contraction A is-contr-A) B := ( second (contr-implies-singleton-induction-ind A is-contr-A)) B #def singleton-induction-ind-implies-contr ( A : U) ( a : A) ( f : has-singleton-induction-pointed-structure A a) : ( is-contr A) := ( a , ( first (f ( \\ x \u2192 a = x))) ( refl _{a}))","title":"Singleton induction"},{"location":"hott/07-fibers.rzk/","text":"7. Fibers \u00b6 This is a literate rzk file: #lang rzk-1 Fibers \u00b6 The homotopy fiber of a map is the following type: The fiber of a map #def fib ( A B : U) ( f : A \u2192 B) ( b : B) : U := \u03a3 ( a : A) , (f a) = b We calculate the transport of (a , q) : fib b along p : a = a': #def transport-in-fiber ( A B : U) ( f : A \u2192 B) ( b : B) ( a a' : A) ( u : (f a) = b) ( p : a = a') : ( transport A ( \\ x \u2192 (f x) = b) a a' p u) = ( concat B (f a') (f a) b (ap A B a' a f (rev A a a' p)) u) := ind-path ( A) ( a) ( \\ a'' p' \u2192 ( transport (A) ( \\ x \u2192 (f x) = b) (a) (a'') (p') (u)) = ( concat (B) (f a'') (f a) (b) (ap A B a'' a f (rev A a a'' p')) (u))) ( rev ( (f a) = b) (concat B (f a) (f a) b refl u) (u) ( left-unit-concat B (f a) b u)) ( a') ( p) Contractible maps \u00b6 A map is contractible just when its fibers are contractible. Contractible maps #def is-contr-map ( A B : U) ( f : A \u2192 B) : U := ( b : B) \u2192 is-contr (fib A B f b) Contractible maps are equivalences: #section is-contr-map-is-equiv #variables A B : U #variable f : A \u2192 B #variable is-contr-f : is-contr-map A B f The inverse to a contractible map #def is-contr-map-inverse : B \u2192 A := \\ b \u2192 first (center-contraction (fib A B f b) (is-contr-f b)) #def has-section-is-contr-map : has-section A B f := ( is-contr-map-inverse , \\ b \u2192 second (center-contraction (fib A B f b) (is-contr-f b))) #def is-contr-map-data-in-fiber uses ( is-contr-f ) ( a : A) : fib A B f (f a) := (is-contr-map-inverse (f a) , ( second has-section-is-contr-map) (f a)) #def is-contr-map-path-in-fiber ( a : A) : (is-contr-map-data-in-fiber a) =_{fib A B f (f a)} (a , refl ) := eq-is-contr ( fib A B f (f a)) ( is-contr-f (f a)) ( is-contr-map-data-in-fiber a) ( a , refl ) #def is-contr-map-has-retraction uses ( is-contr-f ) : has-retraction A B f := ( is-contr-map-inverse , \\ a \u2192 ( ap (fib A B f (f a)) A ( is-contr-map-data-in-fiber a) ( (a , refl )) ( \\ u \u2192 first u) ( is-contr-map-path-in-fiber a))) #def is-equiv-is-contr-map uses ( is-contr-f ) : is-equiv A B f := (is-contr-map-has-retraction , has-section-is-contr-map) #end is-contr-map-is-equiv Half adjoint equivalences are contractible \u00b6 We now show that half adjoint equivalences are contractible maps. If f is a half adjoint equivalence, its fibers are inhabited #def is-split-surjection-is-half-adjoint-equiv ( A B : U) ( f : A \u2192 B) ( is-hae-f : is-half-adjoint-equiv A B f) ( b : B) : fib A B f b := ( (map-inverse-has-inverse A B f ( first is-hae-f)) b , ( second ( second ( first is-hae-f))) b) It takes much more work to construct the contracting homotopy. The base path of this homotopy is straightforward. #section half-adjoint-equivalence-fiber-data #variables A B : U #variable f : A \u2192 B #variable is-hae-f : is-half-adjoint-equiv A B f #variable b : B #variable z : fib A B f b #def base-path-fib-is-half-adjoint-equiv : ((map-inverse-has-inverse A B f ( first is-hae-f)) b) = ( first z) := concat A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z))) ( ( first ( second ( first is-hae-f))) ( first z)) Specializing the above to isHAE-fib-base-path : #def transport-base-path-fib-is-half-adjoint-equiv : transport A ( \\ x \u2192 (f x) = b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv) ( ( second ( second ( first is-hae-f))) b) = concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv))) ( ( second ( second ( first is-hae-f))) b) := transport-in-fiber A B f b ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( ( second ( second ( first is-hae-f))) b) ( base-path-fib-is-half-adjoint-equiv) #def rev-coherence-base-path-fib-is-half-adjoint-equiv : rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv) = concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))) := rev-concat A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z))) ( ( first ( second ( first is-hae-f))) ( first z)) #def compute-rev-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv))) ( ( second ( second ( first is-hae-f))) b) = concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first is-hae-f))) b) := concat-eq-left B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv))) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ap-eq A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv)) ( concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z))))) ( rev-coherence-base-path-fib-is-half-adjoint-equiv)) ( ( second ( second ( first is-hae-f))) b) #def compute-ap-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first is-hae-f))) b) = concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first is-hae-f))) b) := concat-eq-left B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ap-concat A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z))))) ( ( second ( second ( first is-hae-f))) b) #def compute-rev-ap-rev-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first is-hae-f))) b) = concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( ap B A (f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)))) ( ( second ( second ( first is-hae-f))) b) := concat-eq-left B ( f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( ap B A ( f ( first z)) b (map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)))) ( concat-eq-right B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z))))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( ap B A (f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z))) ( ap-eq A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b ( f ( first z)) ( map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))) ( ap B A ( f ( first z)) ( b) ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)) ( rev-ap-rev B A (f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)))) ( ( second ( second ( first is-hae-f))) b) #def compute-ap-ap-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( ap B A (f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)))) ( ( second ( second ( first is-hae-f))) b) = concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z))) ( ( second ( second ( first is-hae-f))) b) := concat-eq-left B ( f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( ap B A ( f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)))) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z))) ( concat-eq-right B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( ap B A (f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z))) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z)) ( rev-ap-comp B A B ( f ( first z)) ( b) ( map-inverse-has-inverse A B f ( first is-hae-f)) ( f) ( second z))) ( ( second ( second ( first is-hae-f))) b) #def compute-assoc-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z))) ( ( second ( second ( first is-hae-f))) b) = concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z)) ( ( second ( second ( first is-hae-f))) b)) := associative-concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z)) ( ( second ( second ( first is-hae-f))) b) #def compute-nat-transport-base-path-fib-is-half-adjoint-equiv : concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z)) ( ( second ( second ( first is-hae-f))) b)) = concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) := concat-eq-right B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap B B ( f ( first z)) ( b) ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z)) ( ( second ( second ( first is-hae-f))) b)) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) ( nat-htpy B B ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( identity B) ( second ( second ( first is-hae-f))) ( f ( first z)) ( b) ( second z)) #def compute-ap-id-transport-base-path-fib-is-half-adjoint-equiv : concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) = concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( second z)) := concat-eq-right B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( second z)) ( concat-eq-right B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z)) ( second z) ( ap-id B (f ( first z)) b ( second z))) #def compute-reassoc-transport-base-path-fib-is-half-adjoint-equiv : concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( second z)) = concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ( second ( second ( first is-hae-f))) (f ( first z)))) ( second z) := rev-associative-concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( second z) #def compute-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ( second ( second ( first is-hae-f))) (f ( first z)))) ( second z) = concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) f ( (( first ( second ( first is-hae-f)))) ( first z)))) ( second z) := concat-eq-left B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ( second ( second ( first is-hae-f))) (f ( first z)))) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) ( f) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat-eq-right B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) f ( (( first ( second ( first is-hae-f)))) ( first z))) ( ( second is-hae-f) ( first z))) ( second z) #def reduction-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) f ( (( first ( second ( first is-hae-f)))) ( first z)))) ( second z) = concat B (f ( first z)) (f ( first z)) b ( refl ) ( second z) := concat-eq-left B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) f ( (( first ( second ( first is-hae-f)))) ( first z)))) ( refl ) ( concat-ap-rev-ap-id A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) ( f) ( (( first ( second ( first is-hae-f)))) ( first z))) ( second z) #def final-reduction-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv uses ( A ) : concat B (f ( first z)) (f ( first z)) b ( refl ) ( second z) = second z := left-unit-concat B (f ( first z)) b ( second z) #def path-transport-base-path-fib-is-half-adjoint-equiv : transport A ( \\ x \u2192 (f x) = b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv) ( ( second ( second ( first is-hae-f))) b) = second z := alternating-12ary-concat ( (f ( first z)) = b) ( transport A ( \\ x \u2192 (f x) = b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv) ( ( second ( second ( first is-hae-f))) b)) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv))) ( ( second ( second ( first is-hae-f))) b)) ( transport-base-path-fib-is-half-adjoint-equiv) ( concat B ( f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first is-hae-f))) b)) ( compute-rev-transport-base-path-fib-is-half-adjoint-equiv) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first is-hae-f))) b)) ( compute-ap-transport-base-path-fib-is-half-adjoint-equiv) ( concat B ( f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( ap B A (f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)))) ( ( second ( second ( first is-hae-f))) b)) ( compute-rev-ap-rev-transport-base-path-fib-is-half-adjoint-equiv) ( concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z))) ( ( second ( second ( first is-hae-f))) b)) ( compute-ap-ap-transport-base-path-fib-is-half-adjoint-equiv) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap B B ( f ( first z)) ( b) ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z)) ( ( second ( second ( first is-hae-f))) b))) ( compute-assoc-transport-base-path-fib-is-half-adjoint-equiv) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z)))) ( compute-nat-transport-base-path-fib-is-half-adjoint-equiv) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( second z))) (compute-ap-id-transport-base-path-fib-is-half-adjoint-equiv) ( concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ( second ( second ( first is-hae-f))) (f ( first z)))) ( second z)) ( compute-reassoc-transport-base-path-fib-is-half-adjoint-equiv) ( concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) f ( ( first ( second ( first is-hae-f))) ( first z)))) ( second z)) ( compute-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv) ( concat B (f ( first z)) (f ( first z)) b ( refl ) ( second z)) ( reduction-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv) ( second z) ( final-reduction-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv) Finally, we may define the contracting homotopy: #def contraction-fib-is-half-adjoint-equiv : (is-split-surjection-is-half-adjoint-equiv A B f is-hae-f b) = z := path-of-pairs-pair-of-paths A ( \\ x \u2192 (f x) = b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv) ( ( second ( second ( first is-hae-f))) b) ( second z) ( path-transport-base-path-fib-is-half-adjoint-equiv) #end half-adjoint-equivalence-fiber-data Half adjoint equivalences define contractible maps: #def is-contr-map-is-half-adjoint-equiv ( A B : U) ( f : A \u2192 B) ( is-hae-f : is-half-adjoint-equiv A B f) : is-contr-map A B f := \\ b \u2192 ( is-split-surjection-is-half-adjoint-equiv A B f is-hae-f b , contraction-fib-is-half-adjoint-equiv A B f is-hae-f b) Equivalences are contractible maps \u00b6 #def is-contr-map-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) : is-contr-map A B f := \\ b \u2192 ( is-split-surjection-is-half-adjoint-equiv A B f ( is-half-adjoint-equiv-is-equiv A B f is-equiv-f) b , \\ z \u2192 contraction-fib-is-half-adjoint-equiv A B f ( is-half-adjoint-equiv-is-equiv A B f is-equiv-f) b z) #def is-contr-map-iff-is-equiv ( A B : U) ( f : A \u2192 B) : iff (is-contr-map A B f) (is-equiv A B f) := (is-equiv-is-contr-map A B f , is-contr-map-is-equiv A B f)","title":"Fibers"},{"location":"hott/07-fibers.rzk/#7-fibers","text":"This is a literate rzk file: #lang rzk-1","title":"7. Fibers"},{"location":"hott/07-fibers.rzk/#fibers","text":"The homotopy fiber of a map is the following type: The fiber of a map #def fib ( A B : U) ( f : A \u2192 B) ( b : B) : U := \u03a3 ( a : A) , (f a) = b We calculate the transport of (a , q) : fib b along p : a = a': #def transport-in-fiber ( A B : U) ( f : A \u2192 B) ( b : B) ( a a' : A) ( u : (f a) = b) ( p : a = a') : ( transport A ( \\ x \u2192 (f x) = b) a a' p u) = ( concat B (f a') (f a) b (ap A B a' a f (rev A a a' p)) u) := ind-path ( A) ( a) ( \\ a'' p' \u2192 ( transport (A) ( \\ x \u2192 (f x) = b) (a) (a'') (p') (u)) = ( concat (B) (f a'') (f a) (b) (ap A B a'' a f (rev A a a'' p')) (u))) ( rev ( (f a) = b) (concat B (f a) (f a) b refl u) (u) ( left-unit-concat B (f a) b u)) ( a') ( p)","title":"Fibers"},{"location":"hott/07-fibers.rzk/#contractible-maps","text":"A map is contractible just when its fibers are contractible. Contractible maps #def is-contr-map ( A B : U) ( f : A \u2192 B) : U := ( b : B) \u2192 is-contr (fib A B f b) Contractible maps are equivalences: #section is-contr-map-is-equiv #variables A B : U #variable f : A \u2192 B #variable is-contr-f : is-contr-map A B f The inverse to a contractible map #def is-contr-map-inverse : B \u2192 A := \\ b \u2192 first (center-contraction (fib A B f b) (is-contr-f b)) #def has-section-is-contr-map : has-section A B f := ( is-contr-map-inverse , \\ b \u2192 second (center-contraction (fib A B f b) (is-contr-f b))) #def is-contr-map-data-in-fiber uses ( is-contr-f ) ( a : A) : fib A B f (f a) := (is-contr-map-inverse (f a) , ( second has-section-is-contr-map) (f a)) #def is-contr-map-path-in-fiber ( a : A) : (is-contr-map-data-in-fiber a) =_{fib A B f (f a)} (a , refl ) := eq-is-contr ( fib A B f (f a)) ( is-contr-f (f a)) ( is-contr-map-data-in-fiber a) ( a , refl ) #def is-contr-map-has-retraction uses ( is-contr-f ) : has-retraction A B f := ( is-contr-map-inverse , \\ a \u2192 ( ap (fib A B f (f a)) A ( is-contr-map-data-in-fiber a) ( (a , refl )) ( \\ u \u2192 first u) ( is-contr-map-path-in-fiber a))) #def is-equiv-is-contr-map uses ( is-contr-f ) : is-equiv A B f := (is-contr-map-has-retraction , has-section-is-contr-map) #end is-contr-map-is-equiv","title":"Contractible maps"},{"location":"hott/07-fibers.rzk/#half-adjoint-equivalences-are-contractible","text":"We now show that half adjoint equivalences are contractible maps. If f is a half adjoint equivalence, its fibers are inhabited #def is-split-surjection-is-half-adjoint-equiv ( A B : U) ( f : A \u2192 B) ( is-hae-f : is-half-adjoint-equiv A B f) ( b : B) : fib A B f b := ( (map-inverse-has-inverse A B f ( first is-hae-f)) b , ( second ( second ( first is-hae-f))) b) It takes much more work to construct the contracting homotopy. The base path of this homotopy is straightforward. #section half-adjoint-equivalence-fiber-data #variables A B : U #variable f : A \u2192 B #variable is-hae-f : is-half-adjoint-equiv A B f #variable b : B #variable z : fib A B f b #def base-path-fib-is-half-adjoint-equiv : ((map-inverse-has-inverse A B f ( first is-hae-f)) b) = ( first z) := concat A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z))) ( ( first ( second ( first is-hae-f))) ( first z)) Specializing the above to isHAE-fib-base-path : #def transport-base-path-fib-is-half-adjoint-equiv : transport A ( \\ x \u2192 (f x) = b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv) ( ( second ( second ( first is-hae-f))) b) = concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv))) ( ( second ( second ( first is-hae-f))) b) := transport-in-fiber A B f b ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( ( second ( second ( first is-hae-f))) b) ( base-path-fib-is-half-adjoint-equiv) #def rev-coherence-base-path-fib-is-half-adjoint-equiv : rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv) = concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))) := rev-concat A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z))) ( ( first ( second ( first is-hae-f))) ( first z)) #def compute-rev-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv))) ( ( second ( second ( first is-hae-f))) b) = concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first is-hae-f))) b) := concat-eq-left B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv))) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ap-eq A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv)) ( concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z))))) ( rev-coherence-base-path-fib-is-half-adjoint-equiv)) ( ( second ( second ( first is-hae-f))) b) #def compute-ap-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first is-hae-f))) b) = concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first is-hae-f))) b) := concat-eq-left B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ap-concat A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z))))) ( ( second ( second ( first is-hae-f))) b) #def compute-rev-ap-rev-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first is-hae-f))) b) = concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( ap B A (f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)))) ( ( second ( second ( first is-hae-f))) b) := concat-eq-left B ( f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( ap B A ( f ( first z)) b (map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)))) ( concat-eq-right B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z))))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( ap B A (f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z))) ( ap-eq A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b ( f ( first z)) ( map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))) ( ap B A ( f ( first z)) ( b) ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)) ( rev-ap-rev B A (f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)))) ( ( second ( second ( first is-hae-f))) b) #def compute-ap-ap-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( ap B A (f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)))) ( ( second ( second ( first is-hae-f))) b) = concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z))) ( ( second ( second ( first is-hae-f))) b) := concat-eq-left B ( f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( ap B A ( f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)))) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z))) ( concat-eq-right B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( ap B A (f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z))) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z)) ( rev-ap-comp B A B ( f ( first z)) ( b) ( map-inverse-has-inverse A B f ( first is-hae-f)) ( f) ( second z))) ( ( second ( second ( first is-hae-f))) b) #def compute-assoc-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z))) ( ( second ( second ( first is-hae-f))) b) = concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z)) ( ( second ( second ( first is-hae-f))) b)) := associative-concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z)) ( ( second ( second ( first is-hae-f))) b) #def compute-nat-transport-base-path-fib-is-half-adjoint-equiv : concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z)) ( ( second ( second ( first is-hae-f))) b)) = concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) := concat-eq-right B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap B B ( f ( first z)) ( b) ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z)) ( ( second ( second ( first is-hae-f))) b)) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) ( nat-htpy B B ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( identity B) ( second ( second ( first is-hae-f))) ( f ( first z)) ( b) ( second z)) #def compute-ap-id-transport-base-path-fib-is-half-adjoint-equiv : concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) = concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( second z)) := concat-eq-right B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( second z)) ( concat-eq-right B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z)) ( second z) ( ap-id B (f ( first z)) b ( second z))) #def compute-reassoc-transport-base-path-fib-is-half-adjoint-equiv : concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( second z)) = concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ( second ( second ( first is-hae-f))) (f ( first z)))) ( second z) := rev-associative-concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( second z) #def compute-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ( second ( second ( first is-hae-f))) (f ( first z)))) ( second z) = concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) f ( (( first ( second ( first is-hae-f)))) ( first z)))) ( second z) := concat-eq-left B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ( second ( second ( first is-hae-f))) (f ( first z)))) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) ( f) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat-eq-right B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) f ( (( first ( second ( first is-hae-f)))) ( first z))) ( ( second is-hae-f) ( first z))) ( second z) #def reduction-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv : concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) f ( (( first ( second ( first is-hae-f)))) ( first z)))) ( second z) = concat B (f ( first z)) (f ( first z)) b ( refl ) ( second z) := concat-eq-left B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) f ( (( first ( second ( first is-hae-f)))) ( first z)))) ( refl ) ( concat-ap-rev-ap-id A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) ( f) ( (( first ( second ( first is-hae-f)))) ( first z))) ( second z) #def final-reduction-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv uses ( A ) : concat B (f ( first z)) (f ( first z)) b ( refl ) ( second z) = second z := left-unit-concat B (f ( first z)) b ( second z) #def path-transport-base-path-fib-is-half-adjoint-equiv : transport A ( \\ x \u2192 (f x) = b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv) ( ( second ( second ( first is-hae-f))) b) = second z := alternating-12ary-concat ( (f ( first z)) = b) ( transport A ( \\ x \u2192 (f x) = b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv) ( ( second ( second ( first is-hae-f))) b)) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( rev A ((map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv))) ( ( second ( second ( first is-hae-f))) b)) ( transport-base-path-fib-is-half-adjoint-equiv) ( concat B ( f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( ap A B ( first z) ((map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( concat A ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z))) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first is-hae-f))) b)) ( compute-rev-transport-base-path-fib-is-half-adjoint-equiv) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( ap B A b (f ( first z)) (map-inverse-has-inverse A B f ( first is-hae-f)) ( rev B (f ( first z)) b ( second z)))))) ( ( second ( second ( first is-hae-f))) b)) ( compute-ap-transport-base-path-fib-is-half-adjoint-equiv) ( concat B ( f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) f ( ap B A (f ( first z)) b ( map-inverse-has-inverse A B f ( first is-hae-f)) ( second z)))) ( ( second ( second ( first is-hae-f))) b)) ( compute-rev-ap-rev-transport-base-path-fib-is-half-adjoint-equiv) ( concat B (f ( first z)) (f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap B B (f ( first z)) b ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z))) ( ( second ( second ( first is-hae-f))) b)) ( compute-ap-ap-transport-base-path-fib-is-half-adjoint-equiv) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) b)) ( b) ( ap B B ( f ( first z)) ( b) ( comp B A B f (map-inverse-has-inverse A B f ( first is-hae-f))) ( second z)) ( ( second ( second ( first is-hae-f))) b))) ( compute-assoc-transport-base-path-fib-is-half-adjoint-equiv) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( ap B B (f ( first z)) b (identity B) ( second z)))) ( compute-nat-transport-base-path-fib-is-half-adjoint-equiv) ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( b) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) f ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( concat B ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( b) ( ( second ( second ( first is-hae-f))) (f ( first z))) ( second z))) (compute-ap-id-transport-base-path-fib-is-half-adjoint-equiv) ( concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ( second ( second ( first is-hae-f))) (f ( first z)))) ( second z)) ( compute-reassoc-transport-base-path-fib-is-half-adjoint-equiv) ( concat B (f ( first z)) (f ( first z)) b ( concat B ( f ( first z)) ( f ((map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z)))) ( f ( first z)) ( ap A B ( first z) ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( f) ( rev A ( (map-inverse-has-inverse A B f ( first is-hae-f)) (f ( first z))) ( first z) ( ( first ( second ( first is-hae-f))) ( first z)))) ( ap A B ( retraction-composite-has-inverse A B f ( first is-hae-f) ( first z)) ( first z) f ( ( first ( second ( first is-hae-f))) ( first z)))) ( second z)) ( compute-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv) ( concat B (f ( first z)) (f ( first z)) b ( refl ) ( second z)) ( reduction-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv) ( second z) ( final-reduction-half-adjoint-equiv-transport-base-path-fib-is-half-adjoint-equiv) Finally, we may define the contracting homotopy: #def contraction-fib-is-half-adjoint-equiv : (is-split-surjection-is-half-adjoint-equiv A B f is-hae-f b) = z := path-of-pairs-pair-of-paths A ( \\ x \u2192 (f x) = b) ( (map-inverse-has-inverse A B f ( first is-hae-f)) b) ( first z) ( base-path-fib-is-half-adjoint-equiv) ( ( second ( second ( first is-hae-f))) b) ( second z) ( path-transport-base-path-fib-is-half-adjoint-equiv) #end half-adjoint-equivalence-fiber-data Half adjoint equivalences define contractible maps: #def is-contr-map-is-half-adjoint-equiv ( A B : U) ( f : A \u2192 B) ( is-hae-f : is-half-adjoint-equiv A B f) : is-contr-map A B f := \\ b \u2192 ( is-split-surjection-is-half-adjoint-equiv A B f is-hae-f b , contraction-fib-is-half-adjoint-equiv A B f is-hae-f b)","title":"Half adjoint equivalences are contractible"},{"location":"hott/07-fibers.rzk/#equivalences-are-contractible-maps","text":"#def is-contr-map-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) : is-contr-map A B f := \\ b \u2192 ( is-split-surjection-is-half-adjoint-equiv A B f ( is-half-adjoint-equiv-is-equiv A B f is-equiv-f) b , \\ z \u2192 contraction-fib-is-half-adjoint-equiv A B f ( is-half-adjoint-equiv-is-equiv A B f is-equiv-f) b z) #def is-contr-map-iff-is-equiv ( A B : U) ( f : A \u2192 B) : iff (is-contr-map A B f) (is-equiv A B f) := (is-equiv-is-contr-map A B f , is-contr-map-is-equiv A B f)","title":"Equivalences are contractible maps"},{"location":"hott/08-families-of-maps.rzk/","text":"8. Families of maps \u00b6 This is a literate rzk file: #lang rzk-1 Fiber of total map \u00b6 We now calculate the fiber of the map on total spaces associated to a family of maps. #def total-map ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) : ( \u03a3 (x : A) , B x) \u2192 ( \u03a3 (x : A) , C x) := \\ z \u2192 ( first z , f ( first z) ( second z)) #def total-map-to-fiber ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( w : ( \u03a3 (x : A) , C x)) : fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w) \u2192 ( fib (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) w) := \\ (b , p) \u2192 ( ( first w , b) , eq-eq-fiber-\u03a3 A C ( first w) (f ( first w) b) ( second w) p) #def total-map-from-fiber ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( w : ( \u03a3 (x : A) , C x)) : fib ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) w \u2192 fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w) := \\ (z , p) \u2192 ind-path ( \u03a3 (x : A) , C x) ( total-map A B C f z) ( \\ w' p' \u2192 fib (B ( first w')) (C ( first w')) (f ( first w')) ( second w')) ( second z , refl ) ( w) ( p) #def total-map-to-fiber-retraction ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( w : ( \u03a3 (x : A) , C x)) : has-retraction ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) w) ( total-map-to-fiber A B C f w) := ( ( total-map-from-fiber A B C f w) , ( \\ (b , p) \u2192 ind-path ( C ( first w)) ( f ( first w) b) ( \\ w1 p' \u2192 ( ( total-map-from-fiber A B C f (( first w , w1))) ( (total-map-to-fiber A B C f ( first w , w1)) (b , p'))) =_{(fib (B ( first w)) (C ( first w)) (f ( first w)) (w1))} ( b , p')) ( refl ) ( second w) ( p))) #def total-map-to-fiber-section ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( w : ( \u03a3 (x : A) , C x)) : has-section ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) w) ( total-map-to-fiber A B C f w) := ( ( total-map-from-fiber A B C f w) , ( \\ (z , p) \u2192 ind-path ( \u03a3 (x : A) , C x) ( first z , f ( first z) ( second z)) ( \\ w' p' \u2192 ( ( total-map-to-fiber A B C f w') ( ( total-map-from-fiber A B C f w') (z , p'))) = ( z , p')) ( refl ) ( w) ( p))) #def total-map-to-fiber-is-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( w : ( \u03a3 (x : A) , C x)) : is-equiv ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f) w) ( total-map-to-fiber A B C f w) := ( total-map-to-fiber-retraction A B C f w , total-map-to-fiber-section A B C f w) #def total-map-fiber-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( w : ( \u03a3 (x : A) , C x)) : Equiv ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f) w) := (total-map-to-fiber A B C f w , total-map-to-fiber-is-equiv A B C f w) Families of equivalences \u00b6 A family of equivalences induces an equivalence on total spaces and conversely. It will be easiest to work with the incoherent notion of two-sided-inverses. #def invertible-family-total-inverse ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( invfamily : ( a : A) \u2192 has-inverse (B a) (C a) (f a)) : ( \u03a3 (x : A) , C x) \u2192 ( \u03a3 (x : A) , B x) := \\ (a , c) \u2192 (a , (map-inverse-has-inverse (B a) (C a) (f a) (invfamily a)) c) #def invertible-family-total-retraction ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( invfamily : ( a : A) \u2192 has-inverse (B a) (C a) (f a)) : has-retraction ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f) := ( invertible-family-total-inverse A B C f invfamily , \\ (a , b) \u2192 (eq-eq-fiber-\u03a3 A B a ( (map-inverse-has-inverse (B a) (C a) (f a) (invfamily a)) (f a b)) b ( ( first ( second (invfamily a))) b))) #def invertible-family-total-section ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( invfamily : ( a : A) \u2192 has-inverse (B a) (C a) (f a)) : has-section ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) := ( invertible-family-total-inverse A B C f invfamily , \\ (a , c) \u2192 ( eq-eq-fiber-\u03a3 A C a ( f a ((map-inverse-has-inverse (B a) (C a) (f a) (invfamily a)) c)) c ( ( second ( second (invfamily a))) c))) #def invertible-family-total-invertible ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( invfamily : ( a : A) \u2192 has-inverse (B a) (C a) (f a)) : has-inverse ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f) := ( invertible-family-total-inverse A B C f invfamily , ( second (invertible-family-total-retraction A B C f invfamily) , second (invertible-family-total-section A B C f invfamily))) #def family-of-equiv-total-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( familyequiv : ( a : A) \u2192 is-equiv (B a) (C a) (f a)) : is-equiv ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) := is-equiv-has-inverse ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) ( invertible-family-total-invertible A B C f ( \\ a \u2192 has-inverse-is-equiv (B a) (C a) (f a) (familyequiv a))) #def total-equiv-family-equiv ( A : U) ( B C : A \u2192 U) ( familyeq : ( a : A) \u2192 Equiv (B a) (C a)) : Equiv ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) := ( total-map A B C ( \\ a \u2192 first (familyeq a)) , family-of-equiv-total-equiv A B C ( \\ a \u2192 first (familyeq a)) ( \\ a \u2192 second (familyeq a))) The one-way result: that a family of equivalence gives an invertible map (and thus an equivalence) on total spaces. #def total-has-inverse-family-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( familyequiv : ( a : A) \u2192 is-equiv (B a) (C a) (f a)) : has-inverse ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) := invertible-family-total-invertible A B C f ( \\ a \u2192 has-inverse-is-equiv (B a) (C a) (f a) (familyequiv a)) For the converse, we make use of our calculation on fibers. The first implication could be proven similarly. #def total-contr-map-family-of-contr-maps ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( totalcontrmap : is-contr-map ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f)) ( a : A) : is-contr-map (B a) (C a) (f a) := \\ c \u2192 is-contr-equiv-is-contr' ( fib (B a) (C a) (f a) c) ( fib (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f) ((a , c))) ( total-map-fiber-equiv A B C f ((a , c))) ( totalcontrmap ((a , c))) #def total-equiv-family-of-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( totalequiv : is-equiv ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f)) ( a : A) : is-equiv (B a) (C a) (f a) := is-equiv-is-contr-map (B a) (C a) (f a) ( total-contr-map-family-of-contr-maps A B C f ( is-contr-map-is-equiv ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f) totalequiv) a) #def family-equiv-total-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( totalequiv : is-equiv ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f)) ( a : A) : Equiv (B a) (C a) := ( f a , total-equiv-family-of-equiv A B C f totalequiv a) In summary, a family of maps is an equivalence iff the map on total spaces is an equivalence. #def total-equiv-iff-family-of-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) : iff ( (a : A) \u2192 is-equiv (B a) (C a) (f a)) ( is-equiv (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f)) := (family-of-equiv-total-equiv A B C f , total-equiv-family-of-equiv A B C f) Codomain based path spaces \u00b6 #def equiv-rev ( A : U) ( x y : A) : Equiv (x = y) (y = x) := (rev A x y , ((rev A y x , rev-rev A x y) , (rev A y x , rev-rev A y x))) An equivalence between the based path spaces #def equiv-based-paths ( A : U) ( a : A) : Equiv ( \u03a3 (x : A) , x = a) ( \u03a3 (x : A) , a = x) := total-equiv-family-equiv A ( \\ x \u2192 x = a) ( \\ x \u2192 a = x) ( \\ x \u2192 equiv-rev A x a) Codomain based path spaces are contractible #def is-contr-codomain-based-paths ( A : U) ( a : A) : is-contr ( \u03a3 (x : A) , x = a) := is-contr-equiv-is-contr' ( \u03a3 (x : A) , x = a) ( \u03a3 (x : A) , a = x) ( equiv-based-paths A a) ( is-contr-based-paths A a) Pullback of a type family \u00b6 A family of types over B pulls back along any function f : A \u2192 B to define a family of types over A. #def pullback ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) : A \u2192 U := \\ a \u2192 C (f a) The pullback of a family along homotopic maps is equivalent. #section is-equiv-pullback-htpy #variables A B : U #variables f g : A \u2192 B #variable \u03b1 : homotopy A B f g #variable C : B \u2192 U #variable a : A #def pullback-homotopy : (pullback A B f C a) \u2192 (pullback A B g C a) := transport B C (f a) (g a) (\u03b1 a) #def map-inverse-pullback-homotopy : (pullback A B g C a) \u2192 (pullback A B f C a) := transport B C (g a) (f a) (rev B (f a) (g a) (\u03b1 a)) #def has-retraction-pullback-homotopy : has-retraction ( pullback A B f C a) ( pullback A B g C a) ( pullback-homotopy) := ( map-inverse-pullback-homotopy , \\ c \u2192 concat ( pullback A B f C a) ( transport B C (g a) (f a) ( rev B (f a) (g a) (\u03b1 a)) ( transport B C (f a) (g a) (\u03b1 a) c)) ( transport B C (f a) (f a) ( concat B (f a) (g a) (f a) (\u03b1 a) (rev B (f a) (g a) (\u03b1 a))) c) ( c) ( transport-concat-rev B C (f a) (g a) (f a) (\u03b1 a) ( rev B (f a) (g a) (\u03b1 a)) c) ( transport2 B C (f a) (f a) ( concat B (f a) (g a) (f a) (\u03b1 a) (rev B (f a) (g a) (\u03b1 a))) refl ( right-inverse-concat B (f a) (g a) (\u03b1 a)) c)) #def has-section-pullback-homotopy : has-section (pullback A B f C a) (pullback A B g C a) ( pullback-homotopy) := ( map-inverse-pullback-homotopy , \\ c \u2192 concat ( pullback A B g C a) ( transport B C (f a) (g a) (\u03b1 a) ( transport B C (g a) (f a) (rev B (f a) (g a) (\u03b1 a)) c)) ( transport B C (g a) (g a) ( concat B (g a) (f a) (g a) (rev B (f a) (g a) (\u03b1 a)) (\u03b1 a)) c) ( c) ( transport-concat-rev B C (g a) (f a) (g a) ( rev B (f a) (g a) (\u03b1 a)) (\u03b1 a) (c)) ( transport2 B C (g a) (g a) ( concat B (g a) (f a) (g a) (rev B (f a) (g a) (\u03b1 a)) (\u03b1 a)) ( refl ) ( left-inverse-concat B (f a) (g a) (\u03b1 a)) c)) #def is-equiv-pullback-homotopy uses ( \u03b1 ) : is-equiv ( pullback A B f C a) ( pullback A B g C a) ( pullback-homotopy) := ( has-retraction-pullback-homotopy , has-section-pullback-homotopy) #def equiv-pullback-homotopy uses ( \u03b1 ) : Equiv (pullback A B f C a) (pullback A B g C a) := (pullback-homotopy , is-equiv-pullback-homotopy) #end is-equiv-pullback-htpy The total space of a pulled back family of types maps to the original total space. #def pullback-comparison-map ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) : ( \u03a3 (a : A) , (pullback A B f C) a) \u2192 ( \u03a3 (b : B) , C b) := \\ (a , c) \u2192 (f a , c) Now we show that if a family is pulled back along an equivalence, the total spaces are equivalent by proving that the comparison is a contractible map. For this, we first prove that each fiber is equivalent to a fiber of the original map. #def pullback-comparison-fiber ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( z : \u03a3 ( b : B) , C b) : U := fib ( \u03a3 (a : A) , (pullback A B f C) a) ( \u03a3 (b : B) , C b) ( pullback-comparison-map A B f C) z #def pullback-comparison-fiber-to-fiber ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( z : \u03a3 ( b : B) , C b) : (pullback-comparison-fiber A B f C z) \u2192 (fib A B f ( first z)) := \\ (w , p) \u2192 ind-path ( \u03a3 (b : B) , C b) ( pullback-comparison-map A B f C w) ( \\ z' p' \u2192 ( fib A B f ( first z'))) ( first w , refl ) ( z) ( p) #def from-base-fiber-to-pullback-comparison-fiber ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( b : B) : (fib A B f b) \u2192 ( c : C b) \u2192 (pullback-comparison-fiber A B f C (b , c)) := \\ (a , p) \u2192 ind-path ( B) ( f a) ( \\ b' p' \u2192 (c : C b') \u2192 (pullback-comparison-fiber A B f C ((b' , c)))) ( \\ c \u2192 ((a , c) , refl )) ( b) ( p) #def pullback-comparison-fiber-to-fiber-inv ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( z : \u03a3 ( b : B) , C b) : (fib A B f ( first z)) \u2192 (pullback-comparison-fiber A B f C z) := \\ (a , p) \u2192 from-base-fiber-to-pullback-comparison-fiber A B f C ( first z) (a , p) ( second z) #def pullback-comparison-fiber-to-fiber-retracting-homotopy ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( z : \u03a3 ( b : B) , C b) ( (w , p) : pullback-comparison-fiber A B f C z) : ( (pullback-comparison-fiber-to-fiber-inv A B f C z) ( (pullback-comparison-fiber-to-fiber A B f C z) (w , p))) = (w , p) := ind-path ( \u03a3 (b : B) , C b) ( pullback-comparison-map A B f C w) ( \\ z' p' \u2192 ( ( pullback-comparison-fiber-to-fiber-inv A B f C z') ( ( pullback-comparison-fiber-to-fiber A B f C z') (w , p'))) = ( w , p')) ( refl ) ( z) ( p) #def pullback-comparison-fiber-to-fiber-section-homotopy-map ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( b : B) ( (a , p) : fib A B f b) : ( c : C b) \u2192 ((pullback-comparison-fiber-to-fiber A B f C (b , c)) ((pullback-comparison-fiber-to-fiber-inv A B f C (b , c)) (a , p))) = (a , p) := ind-path ( B) ( f a) ( \\ b' p' \u2192 ( c : C b') \u2192 ( ( pullback-comparison-fiber-to-fiber A B f C (b' , c)) ( (pullback-comparison-fiber-to-fiber-inv A B f C (b' , c)) (a , p'))) = ( a , p')) ( \\ c \u2192 refl ) ( b) ( p) #def pullback-comparison-fiber-to-fiber-section-homotopy ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( z : \u03a3 ( b : B) , C b) ( (a , p) : fib A B f ( first z)) : ( pullback-comparison-fiber-to-fiber A B f C z ( pullback-comparison-fiber-to-fiber-inv A B f C z (a , p))) = (a , p) := pullback-comparison-fiber-to-fiber-section-homotopy-map A B f C ( first z) (a , p) ( second z) #def equiv-pullback-comparison-fiber ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( z : \u03a3 ( b : B) , C b) : Equiv (pullback-comparison-fiber A B f C z) (fib A B f ( first z)) := ( pullback-comparison-fiber-to-fiber A B f C z , ( ( pullback-comparison-fiber-to-fiber-inv A B f C z , pullback-comparison-fiber-to-fiber-retracting-homotopy A B f C z) , ( pullback-comparison-fiber-to-fiber-inv A B f C z , pullback-comparison-fiber-to-fiber-section-homotopy A B f C z))) As a corollary, we show that pullback along an equivalence induces an equivalence of total spaces. #def total-equiv-pullback-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) ( C : B \u2192 U) : Equiv ( \u03a3 (a : A) , (pullback A B f C) a) ( \u03a3 (b : B) , C b) := ( pullback-comparison-map A B f C , is-equiv-is-contr-map ( \u03a3 (a : A) , (pullback A B f C) a) ( \u03a3 (b : B) , C b) ( pullback-comparison-map A B f C) ( \\ z \u2192 ( is-contr-equiv-is-contr' ( pullback-comparison-fiber A B f C z) ( fib A B f ( first z)) ( equiv-pullback-comparison-fiber A B f C z) ( is-contr-map-is-equiv A B f is-equiv-f ( first z))))) Fundamental theorem of identity types \u00b6 #section fundamental-thm-id-types #variable A : U #variable a : A #variable B : A \u2192 U #variable f : ( x : A) \u2192 (a = x) \u2192 B x #def fund-id-fam-of-eqs-implies-sum-over-codomain-contr : ( (x : A) \u2192 (is-equiv (a = x) (B x) (f x))) \u2192 ( is-contr (\u03a3 (x : A) , B x)) := ( \\ familyequiv \u2192 ( equiv-with-contractible-domain-implies-contractible-codomain ( \u03a3 (x : A) , a = x) ( \u03a3 (x : A) , B x) ( ( total-map A ( \\ x \u2192 (a = x)) B f) , ( is-equiv-has-inverse (\u03a3 (x : A) , a = x) ( \u03a3 (x : A) , B x) ( total-map A ( \\ x \u2192 (a = x)) B f) ( total-has-inverse-family-equiv A ( \\ x \u2192 (a = x)) B f familyequiv))) ( is-contr-based-paths A a))) #def fund-id-sum-over-codomain-contr-implies-fam-of-eqs : ( is-contr (\u03a3 (x : A) , B x)) \u2192 ( (x : A) \u2192 (is-equiv (a = x) (B x) (f x))) := ( \\ is-contr-\u03a3-A-B x \u2192 total-equiv-family-of-equiv A ( \\ x' \u2192 (a = x')) ( B) ( f) ( is-equiv-are-contr ( \u03a3 (x' : A) , (a = x')) ( \u03a3 (x' : A) , (B x')) ( is-contr-based-paths A a) ( is-contr-\u03a3-A-B) ( total-map A ( \\ x' \u2192 (a = x')) B f)) ( x)) This allows us to apply \"based path induction\" to a family satisfying the fundamental theorem: -- Please suggest a better name. #def ind-based-path ( familyequiv : ( z : A) \u2192 (is-equiv (a = z) (B z) (f z))) ( P : ( z : A) \u2192 B z \u2192 U) ( p0 : P a (f a refl )) ( u : A) ( p : B u) : P u p := ind-sing ( \u03a3 (v : A) , B v) ( a , f a refl ) ( \\ (u' , p') \u2192 P u' p') ( contr-implies-singleton-induction-pointed ( \u03a3 (z : A) , B z) ( fund-id-fam-of-eqs-implies-sum-over-codomain-contr familyequiv) ( \\ (x' , p') \u2192 P x' p')) ( p0) ( u , p) #end fundamental-thm-id-types 2-of-3 for equivalences \u00b6 The following functions refine equiv-right-cancel and equiv-left-cancel by providing control over the underlying maps of the equivalence. #def is-equiv-right-factor ( A B C : U) ( f : A \u2192 B) ( g : B \u2192 C) ( is-equiv-g : is-equiv B C g) ( is-equiv-gf : is-equiv A C (comp A B C g f)) : is-equiv A B f := ( ( comp B C A (retraction-is-equiv A C (comp A B C g f) is-equiv-gf) g , ( second ( first is-equiv-gf))) , ( comp B C A (section-is-equiv A C (comp A B C g f) is-equiv-gf) g , \\ b \u2192 inv-ap-is-emb B C g ( is-emb-is-equiv B C g is-equiv-g) ( f ((section-is-equiv A C (comp A B C g f) is-equiv-gf) (g b))) b ( ( second ( second is-equiv-gf)) (g b)))) #def is-equiv-left-factor ( A B C : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) ( g : B \u2192 C) ( is-equiv-gf : is-equiv A C (comp A B C g f)) : is-equiv B C g := ( ( comp C A B f (retraction-is-equiv A C (comp A B C g f) is-equiv-gf) , \\ b \u2192 triple-concat B ( f ((retraction-is-equiv A C (comp A B C g f) is-equiv-gf) (g b))) ( f ((retraction-is-equiv A C (comp A B C g f) is-equiv-gf) (g (f ((section-is-equiv A B f is-equiv-f) b))))) ( f ((section-is-equiv A B f is-equiv-f) b)) ( b) ( ap B B ( b) ( f ((section-is-equiv A B f is-equiv-f) b)) ( \\ b0 \u2192 ( f ((retraction-is-equiv A C ( comp A B C g f) is-equiv-gf) (g b0)))) ( rev B (f ((section-is-equiv A B f is-equiv-f) b)) b ( ( second ( second is-equiv-f)) b))) ( ( whisker-homotopy B A A B ( \\ a \u2192 ( retraction-is-equiv A C ( comp A B C g f) is-equiv-gf) (g (f a))) ( \\ a \u2192 a) ( second ( first is-equiv-gf)) ( section-is-equiv A B f is-equiv-f) f) b) ( ( second ( second is-equiv-f)) b)) , ( comp C A B ( f) ( section-is-equiv A C (comp A B C g f) is-equiv-gf) , ( second ( second is-equiv-gf)))) Maps over product types \u00b6 For later use, we specialize the previous results to the case of a family of types over a product type. #section fibered-map-over-product #variables A A' B B' : U #variable C : A \u2192 B \u2192 U #variable C' : A' \u2192 B' \u2192 U #variable f : A \u2192 A' #variable g : B \u2192 B' #variable h : ( a : A) \u2192 ( b : B) \u2192 ( c : C a b) \u2192 C' (f a) (g b) #def total-map-fibered-map-over-product : ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) \u2192 ( \u03a3 (a' : A') , ( \u03a3 (b' : B') , C' a' b')) := \\ (a , (b , c)) \u2192 (f a , (g b , h a b c)) #def pullback-is-equiv-base-is-equiv-total-is-equiv ( is-equiv-total : is-equiv ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a' : A') , ( \u03a3 (b' : B') , C' a' b')) ( total-map-fibered-map-over-product)) ( is-equiv-f : is-equiv A A' f) : is-equiv ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a : A) , ( \u03a3 (b' : B') , C' (f a) b')) ( \\ (a , (b , c)) \u2192 (a , (g b , h a b c))) := is-equiv-right-factor ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a : A) , ( \u03a3 (b' : B') , C' (f a) b')) ( \u03a3 (a' : A') , ( \u03a3 (b' : B') , C' a' b')) ( \\ (a , (b , c)) \u2192 (a , (g b , h a b c))) ( \\ (a , (b' , c')) \u2192 (f a , (b' , c'))) ( second ( total-equiv-pullback-is-equiv ( A) (A') ( f) (is-equiv-f) ( \\ a' \u2192 (\u03a3 (b' : B') , C' a' b')))) ( is-equiv-total) #def pullback-is-equiv-bases-are-equiv-total-is-equiv ( is-equiv-total : is-equiv ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a' : A') , ( \u03a3 (b' : B') , C' a' b')) ( total-map-fibered-map-over-product)) ( is-equiv-f : is-equiv A A' f) ( is-equiv-g : is-equiv B B' g) : is-equiv ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a : A) , ( \u03a3 (b : B) , C' (f a) (g b))) ( \\ (a , (b , c)) \u2192 (a , (b , h a b c))) := is-equiv-right-factor ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a : A) , ( \u03a3 (b : B) , C' (f a) (g b))) ( \u03a3 (a : A) , ( \u03a3 (b' : B') , C' (f a) b')) ( \\ (a , (b , c)) \u2192 (a , (b , h a b c))) ( \\ (a , (b , c)) \u2192 (a , (g b , c))) ( family-of-equiv-total-equiv A ( \\ a \u2192 (\u03a3 (b : B) , C' (f a) (g b))) ( \\ a \u2192 (\u03a3 (b' : B') , C' (f a) b')) ( \\ a (b , c) \u2192 (g b , c)) ( \\ a \u2192 ( second ( total-equiv-pullback-is-equiv ( B) (B') ( g) (is-equiv-g) ( \\ b' \u2192 C' (f a) b'))))) ( pullback-is-equiv-base-is-equiv-total-is-equiv is-equiv-total is-equiv-f) #def fibered-map-is-equiv-bases-are-equiv-total-map-is-equiv ( is-equiv-total : is-equiv ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a' : A') , ( \u03a3 (b' : B') , C' a' b')) ( total-map-fibered-map-over-product)) ( is-equiv-f : is-equiv A A' f) ( is-equiv-g : is-equiv B B' g) ( a0 : A) ( b0 : B) : is-equiv (C a0 b0) (C' (f a0) (g b0)) (h a0 b0) := total-equiv-family-of-equiv B ( \\ b \u2192 C a0 b) ( \\ b \u2192 C' (f a0) (g b)) ( \\ b c \u2192 h a0 b c) ( total-equiv-family-of-equiv ( A) ( \\ a \u2192 (\u03a3 (b : B) , C a b)) ( \\ a \u2192 (\u03a3 (b : B) , C' (f a) (g b))) ( \\ a (b , c) \u2192 (b , h a b c)) ( pullback-is-equiv-bases-are-equiv-total-is-equiv is-equiv-total is-equiv-f is-equiv-g) ( a0)) ( b0) #end fibered-map-over-product","title":"Families of maps"},{"location":"hott/08-families-of-maps.rzk/#8-families-of-maps","text":"This is a literate rzk file: #lang rzk-1","title":"8. Families of maps"},{"location":"hott/08-families-of-maps.rzk/#fiber-of-total-map","text":"We now calculate the fiber of the map on total spaces associated to a family of maps. #def total-map ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) : ( \u03a3 (x : A) , B x) \u2192 ( \u03a3 (x : A) , C x) := \\ z \u2192 ( first z , f ( first z) ( second z)) #def total-map-to-fiber ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( w : ( \u03a3 (x : A) , C x)) : fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w) \u2192 ( fib (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) w) := \\ (b , p) \u2192 ( ( first w , b) , eq-eq-fiber-\u03a3 A C ( first w) (f ( first w) b) ( second w) p) #def total-map-from-fiber ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( w : ( \u03a3 (x : A) , C x)) : fib ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) w \u2192 fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w) := \\ (z , p) \u2192 ind-path ( \u03a3 (x : A) , C x) ( total-map A B C f z) ( \\ w' p' \u2192 fib (B ( first w')) (C ( first w')) (f ( first w')) ( second w')) ( second z , refl ) ( w) ( p) #def total-map-to-fiber-retraction ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( w : ( \u03a3 (x : A) , C x)) : has-retraction ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) w) ( total-map-to-fiber A B C f w) := ( ( total-map-from-fiber A B C f w) , ( \\ (b , p) \u2192 ind-path ( C ( first w)) ( f ( first w) b) ( \\ w1 p' \u2192 ( ( total-map-from-fiber A B C f (( first w , w1))) ( (total-map-to-fiber A B C f ( first w , w1)) (b , p'))) =_{(fib (B ( first w)) (C ( first w)) (f ( first w)) (w1))} ( b , p')) ( refl ) ( second w) ( p))) #def total-map-to-fiber-section ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( w : ( \u03a3 (x : A) , C x)) : has-section ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) w) ( total-map-to-fiber A B C f w) := ( ( total-map-from-fiber A B C f w) , ( \\ (z , p) \u2192 ind-path ( \u03a3 (x : A) , C x) ( first z , f ( first z) ( second z)) ( \\ w' p' \u2192 ( ( total-map-to-fiber A B C f w') ( ( total-map-from-fiber A B C f w') (z , p'))) = ( z , p')) ( refl ) ( w) ( p))) #def total-map-to-fiber-is-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( w : ( \u03a3 (x : A) , C x)) : is-equiv ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f) w) ( total-map-to-fiber A B C f w) := ( total-map-to-fiber-retraction A B C f w , total-map-to-fiber-section A B C f w) #def total-map-fiber-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( w : ( \u03a3 (x : A) , C x)) : Equiv ( fib (B ( first w)) (C ( first w)) (f ( first w)) ( second w)) ( fib (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f) w) := (total-map-to-fiber A B C f w , total-map-to-fiber-is-equiv A B C f w)","title":"Fiber of total map"},{"location":"hott/08-families-of-maps.rzk/#families-of-equivalences","text":"A family of equivalences induces an equivalence on total spaces and conversely. It will be easiest to work with the incoherent notion of two-sided-inverses. #def invertible-family-total-inverse ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( invfamily : ( a : A) \u2192 has-inverse (B a) (C a) (f a)) : ( \u03a3 (x : A) , C x) \u2192 ( \u03a3 (x : A) , B x) := \\ (a , c) \u2192 (a , (map-inverse-has-inverse (B a) (C a) (f a) (invfamily a)) c) #def invertible-family-total-retraction ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( invfamily : ( a : A) \u2192 has-inverse (B a) (C a) (f a)) : has-retraction ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f) := ( invertible-family-total-inverse A B C f invfamily , \\ (a , b) \u2192 (eq-eq-fiber-\u03a3 A B a ( (map-inverse-has-inverse (B a) (C a) (f a) (invfamily a)) (f a b)) b ( ( first ( second (invfamily a))) b))) #def invertible-family-total-section ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( invfamily : ( a : A) \u2192 has-inverse (B a) (C a) (f a)) : has-section ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) := ( invertible-family-total-inverse A B C f invfamily , \\ (a , c) \u2192 ( eq-eq-fiber-\u03a3 A C a ( f a ((map-inverse-has-inverse (B a) (C a) (f a) (invfamily a)) c)) c ( ( second ( second (invfamily a))) c))) #def invertible-family-total-invertible ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( invfamily : ( a : A) \u2192 has-inverse (B a) (C a) (f a)) : has-inverse ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f) := ( invertible-family-total-inverse A B C f invfamily , ( second (invertible-family-total-retraction A B C f invfamily) , second (invertible-family-total-section A B C f invfamily))) #def family-of-equiv-total-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( familyequiv : ( a : A) \u2192 is-equiv (B a) (C a) (f a)) : is-equiv ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) := is-equiv-has-inverse ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) ( invertible-family-total-invertible A B C f ( \\ a \u2192 has-inverse-is-equiv (B a) (C a) (f a) (familyequiv a))) #def total-equiv-family-equiv ( A : U) ( B C : A \u2192 U) ( familyeq : ( a : A) \u2192 Equiv (B a) (C a)) : Equiv ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) := ( total-map A B C ( \\ a \u2192 first (familyeq a)) , family-of-equiv-total-equiv A B C ( \\ a \u2192 first (familyeq a)) ( \\ a \u2192 second (familyeq a))) The one-way result: that a family of equivalence gives an invertible map (and thus an equivalence) on total spaces. #def total-has-inverse-family-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( familyequiv : ( a : A) \u2192 is-equiv (B a) (C a) (f a)) : has-inverse ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) (total-map A B C f) := invertible-family-total-invertible A B C f ( \\ a \u2192 has-inverse-is-equiv (B a) (C a) (f a) (familyequiv a)) For the converse, we make use of our calculation on fibers. The first implication could be proven similarly. #def total-contr-map-family-of-contr-maps ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( totalcontrmap : is-contr-map ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f)) ( a : A) : is-contr-map (B a) (C a) (f a) := \\ c \u2192 is-contr-equiv-is-contr' ( fib (B a) (C a) (f a) c) ( fib (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f) ((a , c))) ( total-map-fiber-equiv A B C f ((a , c))) ( totalcontrmap ((a , c))) #def total-equiv-family-of-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( totalequiv : is-equiv ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f)) ( a : A) : is-equiv (B a) (C a) (f a) := is-equiv-is-contr-map (B a) (C a) (f a) ( total-contr-map-family-of-contr-maps A B C f ( is-contr-map-is-equiv ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f) totalequiv) a) #def family-equiv-total-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) ( totalequiv : is-equiv ( \u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f)) ( a : A) : Equiv (B a) (C a) := ( f a , total-equiv-family-of-equiv A B C f totalequiv a) In summary, a family of maps is an equivalence iff the map on total spaces is an equivalence. #def total-equiv-iff-family-of-equiv ( A : U) ( B C : A \u2192 U) ( f : ( a : A) \u2192 (B a) \u2192 (C a)) : iff ( (a : A) \u2192 is-equiv (B a) (C a) (f a)) ( is-equiv (\u03a3 (x : A) , B x) ( \u03a3 (x : A) , C x) ( total-map A B C f)) := (family-of-equiv-total-equiv A B C f , total-equiv-family-of-equiv A B C f)","title":"Families of equivalences"},{"location":"hott/08-families-of-maps.rzk/#codomain-based-path-spaces","text":"#def equiv-rev ( A : U) ( x y : A) : Equiv (x = y) (y = x) := (rev A x y , ((rev A y x , rev-rev A x y) , (rev A y x , rev-rev A y x))) An equivalence between the based path spaces #def equiv-based-paths ( A : U) ( a : A) : Equiv ( \u03a3 (x : A) , x = a) ( \u03a3 (x : A) , a = x) := total-equiv-family-equiv A ( \\ x \u2192 x = a) ( \\ x \u2192 a = x) ( \\ x \u2192 equiv-rev A x a) Codomain based path spaces are contractible #def is-contr-codomain-based-paths ( A : U) ( a : A) : is-contr ( \u03a3 (x : A) , x = a) := is-contr-equiv-is-contr' ( \u03a3 (x : A) , x = a) ( \u03a3 (x : A) , a = x) ( equiv-based-paths A a) ( is-contr-based-paths A a)","title":"Codomain based path spaces"},{"location":"hott/08-families-of-maps.rzk/#pullback-of-a-type-family","text":"A family of types over B pulls back along any function f : A \u2192 B to define a family of types over A. #def pullback ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) : A \u2192 U := \\ a \u2192 C (f a) The pullback of a family along homotopic maps is equivalent. #section is-equiv-pullback-htpy #variables A B : U #variables f g : A \u2192 B #variable \u03b1 : homotopy A B f g #variable C : B \u2192 U #variable a : A #def pullback-homotopy : (pullback A B f C a) \u2192 (pullback A B g C a) := transport B C (f a) (g a) (\u03b1 a) #def map-inverse-pullback-homotopy : (pullback A B g C a) \u2192 (pullback A B f C a) := transport B C (g a) (f a) (rev B (f a) (g a) (\u03b1 a)) #def has-retraction-pullback-homotopy : has-retraction ( pullback A B f C a) ( pullback A B g C a) ( pullback-homotopy) := ( map-inverse-pullback-homotopy , \\ c \u2192 concat ( pullback A B f C a) ( transport B C (g a) (f a) ( rev B (f a) (g a) (\u03b1 a)) ( transport B C (f a) (g a) (\u03b1 a) c)) ( transport B C (f a) (f a) ( concat B (f a) (g a) (f a) (\u03b1 a) (rev B (f a) (g a) (\u03b1 a))) c) ( c) ( transport-concat-rev B C (f a) (g a) (f a) (\u03b1 a) ( rev B (f a) (g a) (\u03b1 a)) c) ( transport2 B C (f a) (f a) ( concat B (f a) (g a) (f a) (\u03b1 a) (rev B (f a) (g a) (\u03b1 a))) refl ( right-inverse-concat B (f a) (g a) (\u03b1 a)) c)) #def has-section-pullback-homotopy : has-section (pullback A B f C a) (pullback A B g C a) ( pullback-homotopy) := ( map-inverse-pullback-homotopy , \\ c \u2192 concat ( pullback A B g C a) ( transport B C (f a) (g a) (\u03b1 a) ( transport B C (g a) (f a) (rev B (f a) (g a) (\u03b1 a)) c)) ( transport B C (g a) (g a) ( concat B (g a) (f a) (g a) (rev B (f a) (g a) (\u03b1 a)) (\u03b1 a)) c) ( c) ( transport-concat-rev B C (g a) (f a) (g a) ( rev B (f a) (g a) (\u03b1 a)) (\u03b1 a) (c)) ( transport2 B C (g a) (g a) ( concat B (g a) (f a) (g a) (rev B (f a) (g a) (\u03b1 a)) (\u03b1 a)) ( refl ) ( left-inverse-concat B (f a) (g a) (\u03b1 a)) c)) #def is-equiv-pullback-homotopy uses ( \u03b1 ) : is-equiv ( pullback A B f C a) ( pullback A B g C a) ( pullback-homotopy) := ( has-retraction-pullback-homotopy , has-section-pullback-homotopy) #def equiv-pullback-homotopy uses ( \u03b1 ) : Equiv (pullback A B f C a) (pullback A B g C a) := (pullback-homotopy , is-equiv-pullback-homotopy) #end is-equiv-pullback-htpy The total space of a pulled back family of types maps to the original total space. #def pullback-comparison-map ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) : ( \u03a3 (a : A) , (pullback A B f C) a) \u2192 ( \u03a3 (b : B) , C b) := \\ (a , c) \u2192 (f a , c) Now we show that if a family is pulled back along an equivalence, the total spaces are equivalent by proving that the comparison is a contractible map. For this, we first prove that each fiber is equivalent to a fiber of the original map. #def pullback-comparison-fiber ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( z : \u03a3 ( b : B) , C b) : U := fib ( \u03a3 (a : A) , (pullback A B f C) a) ( \u03a3 (b : B) , C b) ( pullback-comparison-map A B f C) z #def pullback-comparison-fiber-to-fiber ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( z : \u03a3 ( b : B) , C b) : (pullback-comparison-fiber A B f C z) \u2192 (fib A B f ( first z)) := \\ (w , p) \u2192 ind-path ( \u03a3 (b : B) , C b) ( pullback-comparison-map A B f C w) ( \\ z' p' \u2192 ( fib A B f ( first z'))) ( first w , refl ) ( z) ( p) #def from-base-fiber-to-pullback-comparison-fiber ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( b : B) : (fib A B f b) \u2192 ( c : C b) \u2192 (pullback-comparison-fiber A B f C (b , c)) := \\ (a , p) \u2192 ind-path ( B) ( f a) ( \\ b' p' \u2192 (c : C b') \u2192 (pullback-comparison-fiber A B f C ((b' , c)))) ( \\ c \u2192 ((a , c) , refl )) ( b) ( p) #def pullback-comparison-fiber-to-fiber-inv ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( z : \u03a3 ( b : B) , C b) : (fib A B f ( first z)) \u2192 (pullback-comparison-fiber A B f C z) := \\ (a , p) \u2192 from-base-fiber-to-pullback-comparison-fiber A B f C ( first z) (a , p) ( second z) #def pullback-comparison-fiber-to-fiber-retracting-homotopy ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( z : \u03a3 ( b : B) , C b) ( (w , p) : pullback-comparison-fiber A B f C z) : ( (pullback-comparison-fiber-to-fiber-inv A B f C z) ( (pullback-comparison-fiber-to-fiber A B f C z) (w , p))) = (w , p) := ind-path ( \u03a3 (b : B) , C b) ( pullback-comparison-map A B f C w) ( \\ z' p' \u2192 ( ( pullback-comparison-fiber-to-fiber-inv A B f C z') ( ( pullback-comparison-fiber-to-fiber A B f C z') (w , p'))) = ( w , p')) ( refl ) ( z) ( p) #def pullback-comparison-fiber-to-fiber-section-homotopy-map ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( b : B) ( (a , p) : fib A B f b) : ( c : C b) \u2192 ((pullback-comparison-fiber-to-fiber A B f C (b , c)) ((pullback-comparison-fiber-to-fiber-inv A B f C (b , c)) (a , p))) = (a , p) := ind-path ( B) ( f a) ( \\ b' p' \u2192 ( c : C b') \u2192 ( ( pullback-comparison-fiber-to-fiber A B f C (b' , c)) ( (pullback-comparison-fiber-to-fiber-inv A B f C (b' , c)) (a , p'))) = ( a , p')) ( \\ c \u2192 refl ) ( b) ( p) #def pullback-comparison-fiber-to-fiber-section-homotopy ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( z : \u03a3 ( b : B) , C b) ( (a , p) : fib A B f ( first z)) : ( pullback-comparison-fiber-to-fiber A B f C z ( pullback-comparison-fiber-to-fiber-inv A B f C z (a , p))) = (a , p) := pullback-comparison-fiber-to-fiber-section-homotopy-map A B f C ( first z) (a , p) ( second z) #def equiv-pullback-comparison-fiber ( A B : U) ( f : A \u2192 B) ( C : B \u2192 U) ( z : \u03a3 ( b : B) , C b) : Equiv (pullback-comparison-fiber A B f C z) (fib A B f ( first z)) := ( pullback-comparison-fiber-to-fiber A B f C z , ( ( pullback-comparison-fiber-to-fiber-inv A B f C z , pullback-comparison-fiber-to-fiber-retracting-homotopy A B f C z) , ( pullback-comparison-fiber-to-fiber-inv A B f C z , pullback-comparison-fiber-to-fiber-section-homotopy A B f C z))) As a corollary, we show that pullback along an equivalence induces an equivalence of total spaces. #def total-equiv-pullback-is-equiv ( A B : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) ( C : B \u2192 U) : Equiv ( \u03a3 (a : A) , (pullback A B f C) a) ( \u03a3 (b : B) , C b) := ( pullback-comparison-map A B f C , is-equiv-is-contr-map ( \u03a3 (a : A) , (pullback A B f C) a) ( \u03a3 (b : B) , C b) ( pullback-comparison-map A B f C) ( \\ z \u2192 ( is-contr-equiv-is-contr' ( pullback-comparison-fiber A B f C z) ( fib A B f ( first z)) ( equiv-pullback-comparison-fiber A B f C z) ( is-contr-map-is-equiv A B f is-equiv-f ( first z)))))","title":"Pullback of a type family"},{"location":"hott/08-families-of-maps.rzk/#fundamental-theorem-of-identity-types","text":"#section fundamental-thm-id-types #variable A : U #variable a : A #variable B : A \u2192 U #variable f : ( x : A) \u2192 (a = x) \u2192 B x #def fund-id-fam-of-eqs-implies-sum-over-codomain-contr : ( (x : A) \u2192 (is-equiv (a = x) (B x) (f x))) \u2192 ( is-contr (\u03a3 (x : A) , B x)) := ( \\ familyequiv \u2192 ( equiv-with-contractible-domain-implies-contractible-codomain ( \u03a3 (x : A) , a = x) ( \u03a3 (x : A) , B x) ( ( total-map A ( \\ x \u2192 (a = x)) B f) , ( is-equiv-has-inverse (\u03a3 (x : A) , a = x) ( \u03a3 (x : A) , B x) ( total-map A ( \\ x \u2192 (a = x)) B f) ( total-has-inverse-family-equiv A ( \\ x \u2192 (a = x)) B f familyequiv))) ( is-contr-based-paths A a))) #def fund-id-sum-over-codomain-contr-implies-fam-of-eqs : ( is-contr (\u03a3 (x : A) , B x)) \u2192 ( (x : A) \u2192 (is-equiv (a = x) (B x) (f x))) := ( \\ is-contr-\u03a3-A-B x \u2192 total-equiv-family-of-equiv A ( \\ x' \u2192 (a = x')) ( B) ( f) ( is-equiv-are-contr ( \u03a3 (x' : A) , (a = x')) ( \u03a3 (x' : A) , (B x')) ( is-contr-based-paths A a) ( is-contr-\u03a3-A-B) ( total-map A ( \\ x' \u2192 (a = x')) B f)) ( x)) This allows us to apply \"based path induction\" to a family satisfying the fundamental theorem: -- Please suggest a better name. #def ind-based-path ( familyequiv : ( z : A) \u2192 (is-equiv (a = z) (B z) (f z))) ( P : ( z : A) \u2192 B z \u2192 U) ( p0 : P a (f a refl )) ( u : A) ( p : B u) : P u p := ind-sing ( \u03a3 (v : A) , B v) ( a , f a refl ) ( \\ (u' , p') \u2192 P u' p') ( contr-implies-singleton-induction-pointed ( \u03a3 (z : A) , B z) ( fund-id-fam-of-eqs-implies-sum-over-codomain-contr familyequiv) ( \\ (x' , p') \u2192 P x' p')) ( p0) ( u , p) #end fundamental-thm-id-types","title":"Fundamental theorem of identity types"},{"location":"hott/08-families-of-maps.rzk/#2-of-3-for-equivalences","text":"The following functions refine equiv-right-cancel and equiv-left-cancel by providing control over the underlying maps of the equivalence. #def is-equiv-right-factor ( A B C : U) ( f : A \u2192 B) ( g : B \u2192 C) ( is-equiv-g : is-equiv B C g) ( is-equiv-gf : is-equiv A C (comp A B C g f)) : is-equiv A B f := ( ( comp B C A (retraction-is-equiv A C (comp A B C g f) is-equiv-gf) g , ( second ( first is-equiv-gf))) , ( comp B C A (section-is-equiv A C (comp A B C g f) is-equiv-gf) g , \\ b \u2192 inv-ap-is-emb B C g ( is-emb-is-equiv B C g is-equiv-g) ( f ((section-is-equiv A C (comp A B C g f) is-equiv-gf) (g b))) b ( ( second ( second is-equiv-gf)) (g b)))) #def is-equiv-left-factor ( A B C : U) ( f : A \u2192 B) ( is-equiv-f : is-equiv A B f) ( g : B \u2192 C) ( is-equiv-gf : is-equiv A C (comp A B C g f)) : is-equiv B C g := ( ( comp C A B f (retraction-is-equiv A C (comp A B C g f) is-equiv-gf) , \\ b \u2192 triple-concat B ( f ((retraction-is-equiv A C (comp A B C g f) is-equiv-gf) (g b))) ( f ((retraction-is-equiv A C (comp A B C g f) is-equiv-gf) (g (f ((section-is-equiv A B f is-equiv-f) b))))) ( f ((section-is-equiv A B f is-equiv-f) b)) ( b) ( ap B B ( b) ( f ((section-is-equiv A B f is-equiv-f) b)) ( \\ b0 \u2192 ( f ((retraction-is-equiv A C ( comp A B C g f) is-equiv-gf) (g b0)))) ( rev B (f ((section-is-equiv A B f is-equiv-f) b)) b ( ( second ( second is-equiv-f)) b))) ( ( whisker-homotopy B A A B ( \\ a \u2192 ( retraction-is-equiv A C ( comp A B C g f) is-equiv-gf) (g (f a))) ( \\ a \u2192 a) ( second ( first is-equiv-gf)) ( section-is-equiv A B f is-equiv-f) f) b) ( ( second ( second is-equiv-f)) b)) , ( comp C A B ( f) ( section-is-equiv A C (comp A B C g f) is-equiv-gf) , ( second ( second is-equiv-gf))))","title":"2-of-3 for equivalences"},{"location":"hott/08-families-of-maps.rzk/#maps-over-product-types","text":"For later use, we specialize the previous results to the case of a family of types over a product type. #section fibered-map-over-product #variables A A' B B' : U #variable C : A \u2192 B \u2192 U #variable C' : A' \u2192 B' \u2192 U #variable f : A \u2192 A' #variable g : B \u2192 B' #variable h : ( a : A) \u2192 ( b : B) \u2192 ( c : C a b) \u2192 C' (f a) (g b) #def total-map-fibered-map-over-product : ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) \u2192 ( \u03a3 (a' : A') , ( \u03a3 (b' : B') , C' a' b')) := \\ (a , (b , c)) \u2192 (f a , (g b , h a b c)) #def pullback-is-equiv-base-is-equiv-total-is-equiv ( is-equiv-total : is-equiv ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a' : A') , ( \u03a3 (b' : B') , C' a' b')) ( total-map-fibered-map-over-product)) ( is-equiv-f : is-equiv A A' f) : is-equiv ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a : A) , ( \u03a3 (b' : B') , C' (f a) b')) ( \\ (a , (b , c)) \u2192 (a , (g b , h a b c))) := is-equiv-right-factor ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a : A) , ( \u03a3 (b' : B') , C' (f a) b')) ( \u03a3 (a' : A') , ( \u03a3 (b' : B') , C' a' b')) ( \\ (a , (b , c)) \u2192 (a , (g b , h a b c))) ( \\ (a , (b' , c')) \u2192 (f a , (b' , c'))) ( second ( total-equiv-pullback-is-equiv ( A) (A') ( f) (is-equiv-f) ( \\ a' \u2192 (\u03a3 (b' : B') , C' a' b')))) ( is-equiv-total) #def pullback-is-equiv-bases-are-equiv-total-is-equiv ( is-equiv-total : is-equiv ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a' : A') , ( \u03a3 (b' : B') , C' a' b')) ( total-map-fibered-map-over-product)) ( is-equiv-f : is-equiv A A' f) ( is-equiv-g : is-equiv B B' g) : is-equiv ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a : A) , ( \u03a3 (b : B) , C' (f a) (g b))) ( \\ (a , (b , c)) \u2192 (a , (b , h a b c))) := is-equiv-right-factor ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a : A) , ( \u03a3 (b : B) , C' (f a) (g b))) ( \u03a3 (a : A) , ( \u03a3 (b' : B') , C' (f a) b')) ( \\ (a , (b , c)) \u2192 (a , (b , h a b c))) ( \\ (a , (b , c)) \u2192 (a , (g b , c))) ( family-of-equiv-total-equiv A ( \\ a \u2192 (\u03a3 (b : B) , C' (f a) (g b))) ( \\ a \u2192 (\u03a3 (b' : B') , C' (f a) b')) ( \\ a (b , c) \u2192 (g b , c)) ( \\ a \u2192 ( second ( total-equiv-pullback-is-equiv ( B) (B') ( g) (is-equiv-g) ( \\ b' \u2192 C' (f a) b'))))) ( pullback-is-equiv-base-is-equiv-total-is-equiv is-equiv-total is-equiv-f) #def fibered-map-is-equiv-bases-are-equiv-total-map-is-equiv ( is-equiv-total : is-equiv ( \u03a3 (a : A) , ( \u03a3 (b : B) , C a b)) ( \u03a3 (a' : A') , ( \u03a3 (b' : B') , C' a' b')) ( total-map-fibered-map-over-product)) ( is-equiv-f : is-equiv A A' f) ( is-equiv-g : is-equiv B B' g) ( a0 : A) ( b0 : B) : is-equiv (C a0 b0) (C' (f a0) (g b0)) (h a0 b0) := total-equiv-family-of-equiv B ( \\ b \u2192 C a0 b) ( \\ b \u2192 C' (f a0) (g b)) ( \\ b c \u2192 h a0 b c) ( total-equiv-family-of-equiv ( A) ( \\ a \u2192 (\u03a3 (b : B) , C a b)) ( \\ a \u2192 (\u03a3 (b : B) , C' (f a) (g b))) ( \\ a (b , c) \u2192 (b , h a b c)) ( pullback-is-equiv-bases-are-equiv-total-is-equiv is-equiv-total is-equiv-f is-equiv-g) ( a0)) ( b0) #end fibered-map-over-product","title":"Maps over product types"},{"location":"hott/09-propositions.rzk/","text":"9. Propositions \u00b6 This is a literate rzk file: #lang rzk-1 Propositions \u00b6 A type is a proposition when its identity types are contractible. #def is-prop ( A : U) : U := ( a : A) \u2192 ( b : A) \u2192 is-contr (a = b) #def is-prop-Unit : is-prop Unit := \\ x y \u2192 (path-types-of-Unit-are-contractible x y) Alternative characterizations: definitions \u00b6 #def all-elements-equal ( A : U) : U := ( a : A) \u2192 ( b : A) \u2192 (a = b) #def is-contr-is-inhabited ( A : U) : U := A \u2192 is-contr A #def is-emb-terminal-map ( A : U) : U := is-emb A Unit (terminal-map A) Alternative characterizations: proofs \u00b6 #def all-elements-equal-is-prop ( A : U) ( is-prop-A : is-prop A) : all-elements-equal A := \\ a b \u2192 ( first (is-prop-A a b)) #def is-contr-is-inhabited-all-elements-equal ( A : U) ( all-elements-equal-A : all-elements-equal A) : is-contr-is-inhabited A := \\ a \u2192 (a , all-elements-equal-A a) #def terminal-map-is-emb-is-inhabited-is-contr-is-inhabited ( A : U) ( c : is-contr-is-inhabited A) : A \u2192 (is-emb-terminal-map A) := \\ x \u2192 ( is-emb-is-equiv A Unit (terminal-map A) ( contr-implies-terminal-map-is-equiv A (c x))) #def terminal-map-is-emb-is-contr-is-inhabited ( A : U) ( c : is-contr-is-inhabited A) : (is-emb-terminal-map A) := ( is-emb-is-inhabited-emb A Unit (terminal-map A) ( terminal-map-is-emb-is-inhabited-is-contr-is-inhabited A c)) #def is-prop-is-emb-terminal-map ( A : U) ( f : is-emb-terminal-map A) : is-prop A := \\ x y \u2192 ( is-contr-equiv-is-contr' (x = y) ( unit = unit ) ( (ap A Unit x y (terminal-map A)) , (f x y)) ( path-types-of-Unit-are-contractible unit unit )) #def is-prop-is-contr-is-inhabited ( A : U) ( c : is-contr-is-inhabited A) : is-prop A := ( is-prop-is-emb-terminal-map A ( terminal-map-is-emb-is-contr-is-inhabited A c))","title":"Propositions"},{"location":"hott/09-propositions.rzk/#9-propositions","text":"This is a literate rzk file: #lang rzk-1","title":"9. Propositions"},{"location":"hott/09-propositions.rzk/#propositions","text":"A type is a proposition when its identity types are contractible. #def is-prop ( A : U) : U := ( a : A) \u2192 ( b : A) \u2192 is-contr (a = b) #def is-prop-Unit : is-prop Unit := \\ x y \u2192 (path-types-of-Unit-are-contractible x y)","title":"Propositions"},{"location":"hott/09-propositions.rzk/#alternative-characterizations-definitions","text":"#def all-elements-equal ( A : U) : U := ( a : A) \u2192 ( b : A) \u2192 (a = b) #def is-contr-is-inhabited ( A : U) : U := A \u2192 is-contr A #def is-emb-terminal-map ( A : U) : U := is-emb A Unit (terminal-map A)","title":"Alternative characterizations: definitions"},{"location":"hott/09-propositions.rzk/#alternative-characterizations-proofs","text":"#def all-elements-equal-is-prop ( A : U) ( is-prop-A : is-prop A) : all-elements-equal A := \\ a b \u2192 ( first (is-prop-A a b)) #def is-contr-is-inhabited-all-elements-equal ( A : U) ( all-elements-equal-A : all-elements-equal A) : is-contr-is-inhabited A := \\ a \u2192 (a , all-elements-equal-A a) #def terminal-map-is-emb-is-inhabited-is-contr-is-inhabited ( A : U) ( c : is-contr-is-inhabited A) : A \u2192 (is-emb-terminal-map A) := \\ x \u2192 ( is-emb-is-equiv A Unit (terminal-map A) ( contr-implies-terminal-map-is-equiv A (c x))) #def terminal-map-is-emb-is-contr-is-inhabited ( A : U) ( c : is-contr-is-inhabited A) : (is-emb-terminal-map A) := ( is-emb-is-inhabited-emb A Unit (terminal-map A) ( terminal-map-is-emb-is-inhabited-is-contr-is-inhabited A c)) #def is-prop-is-emb-terminal-map ( A : U) ( f : is-emb-terminal-map A) : is-prop A := \\ x y \u2192 ( is-contr-equiv-is-contr' (x = y) ( unit = unit ) ( (ap A Unit x y (terminal-map A)) , (f x y)) ( path-types-of-Unit-are-contractible unit unit )) #def is-prop-is-contr-is-inhabited ( A : U) ( c : is-contr-is-inhabited A) : is-prop A := ( is-prop-is-emb-terminal-map A ( terminal-map-is-emb-is-contr-is-inhabited A c))","title":"Alternative characterizations: proofs"},{"location":"hott/10-trivial-fibrations.rzk/","text":"10. Trivial Fibrations \u00b6 This is a literate rzk file: #lang rzk-1 In what follows we show that the projection from the total space of a Sigma type is an equivalence if and only if its fibers are contractible. #def total-space-projection ( A : U) ( B : A \u2192 U) : ( \u03a3 (x : A) , B x) \u2192 A := \\ z \u2192 first z Contractible fibers \u00b6 The following type asserts that the fibers of a type family are contractible. #def contractible-fibers ( A : U) ( B : A \u2192 U) : U := ( (x : A) \u2192 is-contr (B x)) #section contractible-fibers-data #variable A : U #variable B : A \u2192 U #variable contractible-fibers-A-B : contractible-fibers A B The center of contraction in contractible fibers #def contractible-fibers-section : ( x : A) \u2192 B x := \\ x \u2192 center-contraction (B x) (contractible-fibers-A-B x) The section of the total space projection built from the contraction centers #def contractible-fibers-actual-section uses ( contractible-fibers-A-B ) : ( a : A) \u2192 \u03a3 ( x : A) , B x := \\ a \u2192 (a , contractible-fibers-section a) #def contractible-fibers-section-htpy uses ( contractible-fibers-A-B ) : homotopy A A ( comp A (\u03a3 (x : A) , B x) A ( total-space-projection A B) (contractible-fibers-actual-section)) ( identity A) := \\ x \u2192 refl #def contractible-fibers-section-is-section uses ( contractible-fibers-A-B ) : has-section ( \u03a3 (x : A) , B x) A (total-space-projection A B) := (contractible-fibers-actual-section , contractible-fibers-section-htpy) This can be used to define the retraction homotopy for the total space projection, called first here: #def contractible-fibers-retraction-htpy : ( z : \u03a3 ( x : A) , B x) \u2192 (contractible-fibers-actual-section) ( first z) = z := \\ z \u2192 eq-eq-fiber-\u03a3 A B ( first z) ( (contractible-fibers-section) ( first z)) ( second z) ( homotopy-contraction (B ( first z)) (contractible-fibers-A-B ( first z)) ( second z)) #def contractible-fibers-retraction uses ( contractible-fibers-A-B ) : has-retraction ( \u03a3 (x : A) , B x) A (total-space-projection A B) := (contractible-fibers-actual-section , contractible-fibers-retraction-htpy) The first half of our main result: #def is-equiv-projection-contractible-fibers uses ( contractible-fibers-A-B ) : is-equiv ( \u03a3 (x : A) , B x) A (total-space-projection A B) := (contractible-fibers-retraction , contractible-fibers-section-is-section) #def equiv-projection-contractible-fibers uses ( contractible-fibers-A-B ) : Equiv ( \u03a3 (x : A) , B x) A := (total-space-projection A B , is-equiv-projection-contractible-fibers) #end contractible-fibers-data Projection equivalences \u00b6 From a projection equivalence, it's not hard to inhabit fibers: #def inhabited-fibers-is-equiv-projection ( A : U) ( B : A \u2192 U) ( proj-B-to-A-is-equiv : is-equiv ( \u03a3 (x : A) , B x) A (total-space-projection A B)) ( a : A) : B a := transport A B ( first (( first ( second proj-B-to-A-is-equiv)) a)) a ( ( second ( second proj-B-to-A-is-equiv)) a) ( second (( first ( second proj-B-to-A-is-equiv)) a)) This is great but we need more coherence to show that the inhabited fibers are contractible; the following proof fails: #def is-equiv-projection-implies-contractible-fibers ( A : U) ( B : A \u2192 U) ( proj-B-to-A-is-equiv : is-equiv (\u03a3 (x : A) , B x) A (total-space-projection A B)) : contractible-fibers A B := ( \\ x \u2192 (second (first (first proj-B-to-A-is-equiv) x) , ( \\ u \u2192 second-path-\u03a3 A B (first (first proj-B-to-A-is-equiv) x) (x , u) ( second (first proj-B-to-A-is-equiv) (x , u))))) #section projection-hae-data #variable A : U #variable B : A \u2192 U #variable proj-B-to-A-is-half-adjoint-equivalence : is-half-adjoint-equiv ( \u03a3 (x : A) , B x) A (total-space-projection A B) #variable w : ( \u03a3 (x : A) , B x) We start over from a stronger hypothesis of a half adjoint equivalence. #def projection-hae-inverse ( a : A) : \u03a3 ( x : A) , B x := ( first ( first proj-B-to-A-is-half-adjoint-equivalence)) a #def projection-hae-base-htpy uses ( B ) ( a : A) : ( first (projection-hae-inverse a)) = a := ( second ( second ( first proj-B-to-A-is-half-adjoint-equivalence))) a #def projection-hae-section uses ( proj-B-to-A-is-half-adjoint-equivalence ) ( a : A) : B a := transport A B ( first (projection-hae-inverse a)) a ( projection-hae-base-htpy a) ( second (projection-hae-inverse a)) #def projection-hae-total-htpy : (projection-hae-inverse ( first w)) = w := ( first ( second ( first proj-B-to-A-is-half-adjoint-equivalence))) w #def projection-hae-fibered-htpy : (transport A B ( first ((projection-hae-inverse ( first w)))) ( first w) ( first-path-\u03a3 A B ( projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( second (projection-hae-inverse ( first w)))) = ( second w) := second-path-\u03a3 A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy) #def projection-hae-base-coherence : ( projection-hae-base-htpy ( first w)) = ( first-path-\u03a3 A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) := ( second proj-B-to-A-is-half-adjoint-equivalence) w #def projection-hae-transport-coherence : ( projection-hae-section ( first w)) = ( transport A B ( first ((projection-hae-inverse ( first w)))) ( first w) ( first-path-\u03a3 A B ( projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( second (projection-hae-inverse ( first w)))) := transport2 A B ( first (projection-hae-inverse ( first w))) ( first w) ( projection-hae-base-htpy ( first w)) ( first-path-\u03a3 A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( projection-hae-base-coherence) ( second (projection-hae-inverse ( first w))) #def projection-hae-fibered-homotopy-contraction : (projection-hae-section ( first w)) =_{B ( first w)} ( second w) := concat (B ( first w)) ( projection-hae-section ( first w)) ( transport A B ( first ((projection-hae-inverse ( first w)))) ( first w) ( first-path-\u03a3 A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( second (projection-hae-inverse ( first w)))) ( second w) ( projection-hae-transport-coherence) ( projection-hae-fibered-htpy) #end projection-hae-data Finally, we have: #def contractible-fibers-is-half-adjoint-equiv-projection ( A : U) ( B : A \u2192 U) ( proj-B-to-A-is-half-adjoint-equivalence : is-half-adjoint-equiv ( \u03a3 (x : A) , B x) A (total-space-projection A B)) : contractible-fibers A B := \\ x \u2192 ( (projection-hae-section A B proj-B-to-A-is-half-adjoint-equivalence x) , \\ u \u2192 projection-hae-fibered-homotopy-contraction A B proj-B-to-A-is-half-adjoint-equivalence (x , u)) The converse to our first result #def contractible-fibers-is-equiv-projection ( A : U) ( B : A \u2192 U) ( proj-B-to-A-is-equiv : is-equiv ( \u03a3 (x : A) , B x) A (total-space-projection A B)) : contractible-fibers A B := contractible-fibers-is-half-adjoint-equiv-projection A B ( is-half-adjoint-equiv-is-equiv (\u03a3 (x : A) , B x) A ( total-space-projection A B) proj-B-to-A-is-equiv) The main theorem #def projection-theorem ( A : U) ( B : A \u2192 U) : iff ( is-equiv (\u03a3 (x : A) , B x) A (total-space-projection A B)) ( contractible-fibers A B) := ( \\ proj-B-to-A-is-equiv \u2192 contractible-fibers-is-equiv-projection A B proj-B-to-A-is-equiv , \\ contractible-fibers-A-B \u2192 is-equiv-projection-contractible-fibers A B contractible-fibers-A-B)","title":"Trivial fibrations"},{"location":"hott/10-trivial-fibrations.rzk/#10-trivial-fibrations","text":"This is a literate rzk file: #lang rzk-1 In what follows we show that the projection from the total space of a Sigma type is an equivalence if and only if its fibers are contractible. #def total-space-projection ( A : U) ( B : A \u2192 U) : ( \u03a3 (x : A) , B x) \u2192 A := \\ z \u2192 first z","title":"10. Trivial Fibrations"},{"location":"hott/10-trivial-fibrations.rzk/#contractible-fibers","text":"The following type asserts that the fibers of a type family are contractible. #def contractible-fibers ( A : U) ( B : A \u2192 U) : U := ( (x : A) \u2192 is-contr (B x)) #section contractible-fibers-data #variable A : U #variable B : A \u2192 U #variable contractible-fibers-A-B : contractible-fibers A B The center of contraction in contractible fibers #def contractible-fibers-section : ( x : A) \u2192 B x := \\ x \u2192 center-contraction (B x) (contractible-fibers-A-B x) The section of the total space projection built from the contraction centers #def contractible-fibers-actual-section uses ( contractible-fibers-A-B ) : ( a : A) \u2192 \u03a3 ( x : A) , B x := \\ a \u2192 (a , contractible-fibers-section a) #def contractible-fibers-section-htpy uses ( contractible-fibers-A-B ) : homotopy A A ( comp A (\u03a3 (x : A) , B x) A ( total-space-projection A B) (contractible-fibers-actual-section)) ( identity A) := \\ x \u2192 refl #def contractible-fibers-section-is-section uses ( contractible-fibers-A-B ) : has-section ( \u03a3 (x : A) , B x) A (total-space-projection A B) := (contractible-fibers-actual-section , contractible-fibers-section-htpy) This can be used to define the retraction homotopy for the total space projection, called first here: #def contractible-fibers-retraction-htpy : ( z : \u03a3 ( x : A) , B x) \u2192 (contractible-fibers-actual-section) ( first z) = z := \\ z \u2192 eq-eq-fiber-\u03a3 A B ( first z) ( (contractible-fibers-section) ( first z)) ( second z) ( homotopy-contraction (B ( first z)) (contractible-fibers-A-B ( first z)) ( second z)) #def contractible-fibers-retraction uses ( contractible-fibers-A-B ) : has-retraction ( \u03a3 (x : A) , B x) A (total-space-projection A B) := (contractible-fibers-actual-section , contractible-fibers-retraction-htpy) The first half of our main result: #def is-equiv-projection-contractible-fibers uses ( contractible-fibers-A-B ) : is-equiv ( \u03a3 (x : A) , B x) A (total-space-projection A B) := (contractible-fibers-retraction , contractible-fibers-section-is-section) #def equiv-projection-contractible-fibers uses ( contractible-fibers-A-B ) : Equiv ( \u03a3 (x : A) , B x) A := (total-space-projection A B , is-equiv-projection-contractible-fibers) #end contractible-fibers-data","title":"Contractible fibers"},{"location":"hott/10-trivial-fibrations.rzk/#projection-equivalences","text":"From a projection equivalence, it's not hard to inhabit fibers: #def inhabited-fibers-is-equiv-projection ( A : U) ( B : A \u2192 U) ( proj-B-to-A-is-equiv : is-equiv ( \u03a3 (x : A) , B x) A (total-space-projection A B)) ( a : A) : B a := transport A B ( first (( first ( second proj-B-to-A-is-equiv)) a)) a ( ( second ( second proj-B-to-A-is-equiv)) a) ( second (( first ( second proj-B-to-A-is-equiv)) a)) This is great but we need more coherence to show that the inhabited fibers are contractible; the following proof fails: #def is-equiv-projection-implies-contractible-fibers ( A : U) ( B : A \u2192 U) ( proj-B-to-A-is-equiv : is-equiv (\u03a3 (x : A) , B x) A (total-space-projection A B)) : contractible-fibers A B := ( \\ x \u2192 (second (first (first proj-B-to-A-is-equiv) x) , ( \\ u \u2192 second-path-\u03a3 A B (first (first proj-B-to-A-is-equiv) x) (x , u) ( second (first proj-B-to-A-is-equiv) (x , u))))) #section projection-hae-data #variable A : U #variable B : A \u2192 U #variable proj-B-to-A-is-half-adjoint-equivalence : is-half-adjoint-equiv ( \u03a3 (x : A) , B x) A (total-space-projection A B) #variable w : ( \u03a3 (x : A) , B x) We start over from a stronger hypothesis of a half adjoint equivalence. #def projection-hae-inverse ( a : A) : \u03a3 ( x : A) , B x := ( first ( first proj-B-to-A-is-half-adjoint-equivalence)) a #def projection-hae-base-htpy uses ( B ) ( a : A) : ( first (projection-hae-inverse a)) = a := ( second ( second ( first proj-B-to-A-is-half-adjoint-equivalence))) a #def projection-hae-section uses ( proj-B-to-A-is-half-adjoint-equivalence ) ( a : A) : B a := transport A B ( first (projection-hae-inverse a)) a ( projection-hae-base-htpy a) ( second (projection-hae-inverse a)) #def projection-hae-total-htpy : (projection-hae-inverse ( first w)) = w := ( first ( second ( first proj-B-to-A-is-half-adjoint-equivalence))) w #def projection-hae-fibered-htpy : (transport A B ( first ((projection-hae-inverse ( first w)))) ( first w) ( first-path-\u03a3 A B ( projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( second (projection-hae-inverse ( first w)))) = ( second w) := second-path-\u03a3 A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy) #def projection-hae-base-coherence : ( projection-hae-base-htpy ( first w)) = ( first-path-\u03a3 A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) := ( second proj-B-to-A-is-half-adjoint-equivalence) w #def projection-hae-transport-coherence : ( projection-hae-section ( first w)) = ( transport A B ( first ((projection-hae-inverse ( first w)))) ( first w) ( first-path-\u03a3 A B ( projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( second (projection-hae-inverse ( first w)))) := transport2 A B ( first (projection-hae-inverse ( first w))) ( first w) ( projection-hae-base-htpy ( first w)) ( first-path-\u03a3 A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( projection-hae-base-coherence) ( second (projection-hae-inverse ( first w))) #def projection-hae-fibered-homotopy-contraction : (projection-hae-section ( first w)) =_{B ( first w)} ( second w) := concat (B ( first w)) ( projection-hae-section ( first w)) ( transport A B ( first ((projection-hae-inverse ( first w)))) ( first w) ( first-path-\u03a3 A B (projection-hae-inverse ( first w)) w ( projection-hae-total-htpy)) ( second (projection-hae-inverse ( first w)))) ( second w) ( projection-hae-transport-coherence) ( projection-hae-fibered-htpy) #end projection-hae-data Finally, we have: #def contractible-fibers-is-half-adjoint-equiv-projection ( A : U) ( B : A \u2192 U) ( proj-B-to-A-is-half-adjoint-equivalence : is-half-adjoint-equiv ( \u03a3 (x : A) , B x) A (total-space-projection A B)) : contractible-fibers A B := \\ x \u2192 ( (projection-hae-section A B proj-B-to-A-is-half-adjoint-equivalence x) , \\ u \u2192 projection-hae-fibered-homotopy-contraction A B proj-B-to-A-is-half-adjoint-equivalence (x , u)) The converse to our first result #def contractible-fibers-is-equiv-projection ( A : U) ( B : A \u2192 U) ( proj-B-to-A-is-equiv : is-equiv ( \u03a3 (x : A) , B x) A (total-space-projection A B)) : contractible-fibers A B := contractible-fibers-is-half-adjoint-equiv-projection A B ( is-half-adjoint-equiv-is-equiv (\u03a3 (x : A) , B x) A ( total-space-projection A B) proj-B-to-A-is-equiv) The main theorem #def projection-theorem ( A : U) ( B : A \u2192 U) : iff ( is-equiv (\u03a3 (x : A) , B x) A (total-space-projection A B)) ( contractible-fibers A B) := ( \\ proj-B-to-A-is-equiv \u2192 contractible-fibers-is-equiv-projection A B proj-B-to-A-is-equiv , \\ contractible-fibers-A-B \u2192 is-equiv-projection-contractible-fibers A B contractible-fibers-A-B)","title":"Projection equivalences"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/","text":"3. Simplicial Type Theory \u00b6 These formalisations correspond in part to Section 3 of the RS17 paper. This is a literate rzk file: #lang rzk-1 Simplices and their subshapes \u00b6 Simplices \u00b6 The 1-simplex #def \u0394\u00b9 : 2 \u2192 TOPE := \\ t \u2192 TOP The 2-simplex #def \u0394\u00b2 : ( 2 \u00d7 2 ) \u2192 TOPE := \\ (t , s) \u2192 s \u2264 t The 3-simplex #def \u0394\u00b3 : ( 2 \u00d7 2 \u00d7 2 ) \u2192 TOPE := \\ ((t1 , t2) , t3) \u2192 t3 \u2264 t2 \u2227 t2 \u2264 t1 Boundaries of simplices \u00b6 The boundary of a 1-simplex #def \u2202\u0394\u00b9 : \u0394\u00b9 \u2192 TOPE := \\ t \u2192 (t \u2261 0\u2082 \u2228 t \u2261 1\u2082 ) The boundary of a 2-simplex #def \u2202\u0394\u00b2 : \u0394\u00b2 \u2192 TOPE := \\ (t , s) \u2192 (s \u2261 0\u2082 \u2228 t \u2261 1\u2082 \u2228 s \u2261 t) The inner horn \u00b6 #def \u039b : ( 2 \u00d7 2 ) \u2192 TOPE := \\ (t , s) \u2192 (s \u2261 0\u2082 \u2228 t \u2261 1\u2082 ) Products \u00b6 The product of topes defines the product of shapes. #def shape-prod ( I J : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03c7 : J \u2192 TOPE) : (I \u00d7 J) \u2192 TOPE := \\ (t , s) \u2192 \u03c8 t \u2227 \u03c7 s The square as a product #def \u0394\u00b9\u00d7\u0394\u00b9 : ( 2 \u00d7 2 ) \u2192 TOPE := shape-prod 2 2 \u0394\u00b9 \u0394\u00b9 The total boundary of the square #def \u2202\u25a1 : ( 2 \u00d7 2 ) \u2192 TOPE := \\ (t ,s) \u2192 ((\u2202\u0394\u00b9 t) \u2227 (\u0394\u00b9 s)) \u2228 ((\u0394\u00b9 t) \u2227 (\u2202\u0394\u00b9 s)) The vertical boundary of the square #def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : ( 2 \u00d7 2 ) \u2192 TOPE := shape-prod 2 2 \u2202\u0394\u00b9 \u0394\u00b9 The horizontal boundary of the square #def \u0394\u00b9\u00d7\u2202\u0394\u00b9 : ( 2 \u00d7 2 ) \u2192 TOPE := shape-prod 2 2 \u0394\u00b9 \u2202\u0394\u00b9 The prism from a 2-simplex in an arrow type #def \u0394\u00b2\u00d7\u0394\u00b9 : ( 2 \u00d7 2 \u00d7 2 ) \u2192 TOPE := shape-prod ( 2 \u00d7 2 ) 2 \u0394\u00b2 \u0394\u00b9 Intersections \u00b6 The intersection of shapes is defined by conjunction on topes. #def shape-intersection ( I : CUBE) ( \u03c8 \u03c7 : I \u2192 TOPE) : I \u2192 TOPE := \\ t \u2192 \u03c8 t \u2227 \u03c7 t Unions \u00b6 The union of shapes is defined by disjunction on topes. #def shapeUnion ( I : CUBE) ( \u03c8 \u03c7 : I \u2192 TOPE) : I \u2192 TOPE := \\ t \u2192 \u03c8 t \u2228 \u03c7 t","title":"Simplicial Type Theory"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#3-simplicial-type-theory","text":"These formalisations correspond in part to Section 3 of the RS17 paper. This is a literate rzk file: #lang rzk-1","title":"3. Simplicial Type Theory"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#simplices-and-their-subshapes","text":"","title":"Simplices and their subshapes"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#simplices","text":"The 1-simplex #def \u0394\u00b9 : 2 \u2192 TOPE := \\ t \u2192 TOP The 2-simplex #def \u0394\u00b2 : ( 2 \u00d7 2 ) \u2192 TOPE := \\ (t , s) \u2192 s \u2264 t The 3-simplex #def \u0394\u00b3 : ( 2 \u00d7 2 \u00d7 2 ) \u2192 TOPE := \\ ((t1 , t2) , t3) \u2192 t3 \u2264 t2 \u2227 t2 \u2264 t1","title":"Simplices"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#boundaries-of-simplices","text":"The boundary of a 1-simplex #def \u2202\u0394\u00b9 : \u0394\u00b9 \u2192 TOPE := \\ t \u2192 (t \u2261 0\u2082 \u2228 t \u2261 1\u2082 ) The boundary of a 2-simplex #def \u2202\u0394\u00b2 : \u0394\u00b2 \u2192 TOPE := \\ (t , s) \u2192 (s \u2261 0\u2082 \u2228 t \u2261 1\u2082 \u2228 s \u2261 t)","title":"Boundaries of simplices"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#the-inner-horn","text":"#def \u039b : ( 2 \u00d7 2 ) \u2192 TOPE := \\ (t , s) \u2192 (s \u2261 0\u2082 \u2228 t \u2261 1\u2082 )","title":"The inner horn"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#products","text":"The product of topes defines the product of shapes. #def shape-prod ( I J : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03c7 : J \u2192 TOPE) : (I \u00d7 J) \u2192 TOPE := \\ (t , s) \u2192 \u03c8 t \u2227 \u03c7 s The square as a product #def \u0394\u00b9\u00d7\u0394\u00b9 : ( 2 \u00d7 2 ) \u2192 TOPE := shape-prod 2 2 \u0394\u00b9 \u0394\u00b9 The total boundary of the square #def \u2202\u25a1 : ( 2 \u00d7 2 ) \u2192 TOPE := \\ (t ,s) \u2192 ((\u2202\u0394\u00b9 t) \u2227 (\u0394\u00b9 s)) \u2228 ((\u0394\u00b9 t) \u2227 (\u2202\u0394\u00b9 s)) The vertical boundary of the square #def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : ( 2 \u00d7 2 ) \u2192 TOPE := shape-prod 2 2 \u2202\u0394\u00b9 \u0394\u00b9 The horizontal boundary of the square #def \u0394\u00b9\u00d7\u2202\u0394\u00b9 : ( 2 \u00d7 2 ) \u2192 TOPE := shape-prod 2 2 \u0394\u00b9 \u2202\u0394\u00b9 The prism from a 2-simplex in an arrow type #def \u0394\u00b2\u00d7\u0394\u00b9 : ( 2 \u00d7 2 \u00d7 2 ) \u2192 TOPE := shape-prod ( 2 \u00d7 2 ) 2 \u0394\u00b2 \u0394\u00b9","title":"Products"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#intersections","text":"The intersection of shapes is defined by conjunction on topes. #def shape-intersection ( I : CUBE) ( \u03c8 \u03c7 : I \u2192 TOPE) : I \u2192 TOPE := \\ t \u2192 \u03c8 t \u2227 \u03c7 t","title":"Intersections"},{"location":"simplicial-hott/03-simplicial-type-theory.rzk/#unions","text":"The union of shapes is defined by disjunction on topes. #def shapeUnion ( I : CUBE) ( \u03c8 \u03c7 : I \u2192 TOPE) : I \u2192 TOPE := \\ t \u2192 \u03c8 t \u2228 \u03c7 t","title":"Unions"},{"location":"simplicial-hott/04-extension-types.rzk/","text":"4. Equivalences involving extension types \u00b6 These formalisations correspond to Section 3 of the RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 hott/4-equivalences.rzk \u2014 contains the definitions of Equiv and comp-equiv the file hott/4-equivalences.rzk relies in turn on the previous files in hott/ Commutation of arguments and currying \u00b6 RS17, Theorem 4.1 #def flip-ext-fun ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( X : U) ( Y : \u03c8 \u2192 X \u2192 U) ( f : ( t : \u03d5) \u2192 ( x : X) \u2192 Y t x) : Equiv ( (t : \u03c8) \u2192 ( (x : X) \u2192 Y t x) [\u03d5 t \u21a6 f t]) ( (x : X) \u2192 ( t : \u03c8) \u2192 Y t x [\u03d5 t \u21a6 f t x]) := ( \\ g x t \u2192 g t x , ( ( \\ h t x \u2192 (h x) t , \\ g \u2192 refl ) , ( \\ h t x \u2192 (h x) t , \\ h \u2192 refl ))) #def flip-ext-fun-inv ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( X : U) ( Y : \u03c8 \u2192 X \u2192 U) ( f : ( t : \u03d5) \u2192 ( x : X) \u2192 Y t x) : Equiv ( (x : X) \u2192 ( t : \u03c8) \u2192 Y t x [\u03d5 t \u21a6 f t x]) ( (t : \u03c8) \u2192 ( (x : X) \u2192 Y t x) [\u03d5 t \u21a6 f t]) := ( \\ h t x \u2192 (h x) t , ( ( \\ g x t \u2192 g t x , \\ h \u2192 refl ) , ( \\ g x t \u2192 g t x , \\ g \u2192 refl ))) RS17, Theorem 4.2 #def curry-uncurry ( I J : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( \u03b6 : J \u2192 TOPE) ( \u03c7 : \u03b6 \u2192 TOPE) ( X : \u03c8 \u2192 \u03b6 \u2192 U) ( f : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 X t s) : Equiv ( (t : \u03c8) \u2192 ( (s : \u03b6) \u2192 X t s [\u03c7 s \u21a6 f (t , s)]) [\u03d5 t \u21a6 \\ s \u2192 f (t , s)]) ( ((t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s) \u2192 X t s [(\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 f (t , s)]) := ( \\ g (t , s) \u2192 (g t) s , ( ( \\ h t s \u2192 h (t , s) , \\ g \u2192 refl ) , ( \\ h t s \u2192 h (t , s) , \\ h \u2192 refl ))) #def uncurry-opcurry ( I J : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( \u03b6 : J \u2192 TOPE) ( \u03c7 : \u03b6 \u2192 TOPE) ( X : \u03c8 \u2192 \u03b6 \u2192 U) ( f : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 X t s) : Equiv ( ((t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s) \u2192 X t s [(\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 f (t , s)]) ( ( s : \u03b6) \u2192 ( (t : \u03c8) \u2192 X t s [\u03d5 t \u21a6 f (t , s)]) [\u03c7 s \u21a6 \\ t \u2192 f (t , s)]) := ( \\ h s t \u2192 h (t , s) , ( ( \\ g (t , s) \u2192 (g s) t , \\ h \u2192 refl ) , ( \\ g (t , s) \u2192 (g s) t , \\ g \u2192 refl ))) #def fubini ( I J : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( \u03b6 : J \u2192 TOPE) ( \u03c7 : \u03b6 \u2192 TOPE) ( X : \u03c8 \u2192 \u03b6 \u2192 U) ( f : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 X t s) : Equiv ( ( t : \u03c8) \u2192 ( (s : \u03b6) \u2192 X t s [\u03c7 s \u21a6 f (t , s)]) [\u03d5 t \u21a6 \\ s \u2192 f (t , s)]) ( ( s : \u03b6) \u2192 ( (t : \u03c8) \u2192 X t s [\u03d5 t \u21a6 f (t , s)]) [\u03c7 s \u21a6 \\ t \u2192 f (t , s)]) := equiv-comp ( ( t : \u03c8) \u2192 ( (s : \u03b6) \u2192 X t s [\u03c7 s \u21a6 f (t , s)]) [\u03d5 t \u21a6 \\ s \u2192 f (t , s)]) ( ( (t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s) \u2192 X t s [(\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 f (t , s)]) ( ( s : \u03b6) \u2192 ( (t : \u03c8) \u2192 X t s [\u03d5 t \u21a6 f (t , s)]) [\u03c7 s \u21a6 \\ t \u2192 f (t , s)]) ( curry-uncurry I J \u03c8 \u03d5 \u03b6 \u03c7 X f) ( uncurry-opcurry I J \u03c8 \u03d5 \u03b6 \u03c7 X f) Extending into \u03a3-types (the non-axiom of choice) \u00b6 RS17, Theorem 4.3 #def axiom-choice ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( X : \u03c8 \u2192 U) ( Y : ( t : \u03c8) \u2192 ( x : X t) \u2192 U) ( a : ( t : \u03d5) \u2192 X t) ( b : ( t : \u03d5) \u2192 Y t (a t)) : Equiv ( (t : \u03c8) \u2192 ( \u03a3 (x : X t) , Y t x) [\u03d5 t \u21a6 (a t , b t)]) ( \u03a3 ( f : ( (t : \u03c8) \u2192 X t [\u03d5 t \u21a6 a t])) , ( (t : \u03c8) \u2192 Y t (f t) [\u03d5 t \u21a6 b t])) := ( \\ g \u2192 ( \\ t \u2192 ( first (g t)) , \\ t \u2192 second (g t)) , ( ( \\ (f , h) t \u2192 (f t , h t) , \\ _ \u2192 refl ) , ( \\ (f , h) t \u2192 (f t , h t) , \\ _ \u2192 refl ))) Composites and unions of cofibrations \u00b6 The original form. RS17, Theorem 4.4 #def cofibration-composition ( I : CUBE) ( \u03c7 : I \u2192 TOPE) ( \u03c8 : \u03c7 \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( X : \u03c7 \u2192 U) ( a : ( t : \u03d5) \u2192 X t) : Equiv ( (t : \u03c7) \u2192 X t [\u03d5 t \u21a6 a t]) ( \u03a3 ( f : ( t : \u03c8) \u2192 X t [\u03d5 t \u21a6 a t]) , ( (t : \u03c7) \u2192 X t [\u03c8 t \u21a6 f t])) := ( \\ h \u2192 ( \\ t \u2192 h t , \\ t \u2192 h t) , ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl ) , ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl )))) A reformulated version via tope disjunction instead of inclusion (see https://github.com/rzk-lang/rzk/issues/8 ). RS17, Theorem 4.4 #def cofibration-composition' ( I : CUBE) ( \u03c7 \u03c8 \u03d5 : I \u2192 TOPE) ( X : \u03c7 \u2192 U) ( a : ( t : I | \u03c7 t \u2227 \u03c8 t \u2227 \u03d5 t) \u2192 X t) : Equiv ( (t : \u03c7) \u2192 X t [\u03c7 t \u2227 \u03c8 t \u2227 \u03d5 t \u21a6 a t]) ( \u03a3 ( f : ( t : I | \u03c7 t \u2227 \u03c8 t) \u2192 X t [\u03c7 t \u2227 \u03c8 t \u2227 \u03d5 t \u21a6 a t]) , ( (t : \u03c7) \u2192 X t [\u03c7 t \u2227 \u03c8 t \u21a6 f t])) := ( \\ h \u2192 ( \\ t \u2192 h t , \\ t \u2192 h t) , ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl ) , ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl ))) RS17, Theorem 4.5 #def cofibration-union ( I : CUBE) ( \u03d5 \u03c8 : I \u2192 TOPE) ( X : ( t : I | \u03d5 t \u2228 \u03c8 t) \u2192 U) ( a : ( t : \u03c8) \u2192 X t) : Equiv ( (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 X t [\u03c8 t \u21a6 a t]) ( (t : \u03d5) \u2192 X t [\u03d5 t \u2227 \u03c8 t \u21a6 a t]) := ( \\ h t \u2192 h t , ( ( \\ g t \u2192 recOR (\u03d5 t \u21a6 g t , \u03c8 t \u21a6 a t) , \\ _ \u2192 refl ) , ( \\ g t \u2192 recOR (\u03d5 t \u21a6 g t , \u03c8 t \u21a6 a t) , \\ _ \u2192 refl ))) Relative function extensionality \u00b6 There are various equivalent forms of the relative function extensionality axiom. Here we state the one that will be most useful and derive an application. #def ext-htpy-eq ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( A : \u03c8 \u2192 U) ( a : ( t : \u03d5) \u2192 A t) ( f g : ( t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) ( p : f = g) : ( t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl ] := ind-path ( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) ( f) ( \\ g' p' \u2192 (t : \u03c8) \u2192 (f t = g' t) [\u03d5 t \u21a6 refl ]) ( \\ t \u2192 refl ) ( g) ( p) The type that encodes the extension extensionality axiom. As suggested by footnote 8, we assert this as an \"extension extensionality\" axiom RS17, Proposition 4.8(ii) #def ExtExt : U := ( I : CUBE) \u2192 ( \u03c8 : I \u2192 TOPE) \u2192 ( \u03d5 : \u03c8 \u2192 TOPE) \u2192 ( A : \u03c8 \u2192 U) \u2192 ( a : ( t : \u03d5) \u2192 A t) \u2192 ( f : ( t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) \u2192 ( g : ( t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) \u2192 is-equiv ( f = g) ( (t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl ]) ( ext-htpy-eq I \u03c8 \u03d5 A a f g) #assume extext : ExtExt The equivalence provided by extension extensionality #def equiv-ExtExt uses ( extext ) ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( A : \u03c8 \u2192 U) ( a : ( t : \u03d5) \u2192 A t) ( f g : ( t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) : Equiv (f = g) ( (t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl ]) := (ext-htpy-eq I \u03c8 \u03d5 A a f g , extext I \u03c8 \u03d5 A a f g) In particular, extension extensionality implies that homotopies give rise to identifications. This definition defines eq-ext-htpy to be the retraction to ext-htpy-eq . #def eq-ext-htpy uses ( extext ) ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( A : \u03c8 \u2192 U) ( a : ( t : \u03d5) \u2192 A t) ( f g : ( t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) : ( (t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl ]) \u2192 (f = g) := first ( first (extext I \u03c8 \u03d5 A a f g)) By extension extensionality, fiberwise equivalences of extension types define equivalences of extension types. For simplicity, we extend from BOT . #def equiv-extension-equiv-family uses ( extext ) ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( A B : \u03c8 \u2192 U) ( famequiv : ( t : \u03c8) \u2192 (Equiv (A t) (B t))) : Equiv ( (t : \u03c8) \u2192 A t) ( (t : \u03c8) \u2192 B t) := ( ( \\ a t \u2192 ( first (famequiv t)) (a t)) , ( ( ( \\ b t \u2192 ( first ( first ( second (famequiv t)))) (b t)) , ( \\ a \u2192 eq-ext-htpy ( I) ( \u03c8) ( \\ t \u2192 BOT ) ( A) ( \\ u \u2192 recBOT ) ( \\ t \u2192 first ( first ( second (famequiv t))) ( first (famequiv t) (a t))) ( a) ( \\ t \u2192 second ( first ( second (famequiv t))) (a t)))) , ( ( \\ b t \u2192 first ( second ( second (famequiv t))) (b t)) , ( \\ b \u2192 eq-ext-htpy ( I) ( \u03c8) ( \\ t \u2192 BOT ) ( B) ( \\ u \u2192 recBOT ) ( \\ t \u2192 first (famequiv t) ( first ( second ( second (famequiv t))) (b t))) ( b) ( \\ t \u2192 second ( second ( second (famequiv t))) (b t))))))","title":"Extension Types"},{"location":"simplicial-hott/04-extension-types.rzk/#4-equivalences-involving-extension-types","text":"These formalisations correspond to Section 3 of the RS17 paper. This is a literate rzk file: #lang rzk-1","title":"4. Equivalences involving extension types"},{"location":"simplicial-hott/04-extension-types.rzk/#prerequisites","text":"hott/4-equivalences.rzk \u2014 contains the definitions of Equiv and comp-equiv the file hott/4-equivalences.rzk relies in turn on the previous files in hott/","title":"Prerequisites"},{"location":"simplicial-hott/04-extension-types.rzk/#commutation-of-arguments-and-currying","text":"RS17, Theorem 4.1 #def flip-ext-fun ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( X : U) ( Y : \u03c8 \u2192 X \u2192 U) ( f : ( t : \u03d5) \u2192 ( x : X) \u2192 Y t x) : Equiv ( (t : \u03c8) \u2192 ( (x : X) \u2192 Y t x) [\u03d5 t \u21a6 f t]) ( (x : X) \u2192 ( t : \u03c8) \u2192 Y t x [\u03d5 t \u21a6 f t x]) := ( \\ g x t \u2192 g t x , ( ( \\ h t x \u2192 (h x) t , \\ g \u2192 refl ) , ( \\ h t x \u2192 (h x) t , \\ h \u2192 refl ))) #def flip-ext-fun-inv ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( X : U) ( Y : \u03c8 \u2192 X \u2192 U) ( f : ( t : \u03d5) \u2192 ( x : X) \u2192 Y t x) : Equiv ( (x : X) \u2192 ( t : \u03c8) \u2192 Y t x [\u03d5 t \u21a6 f t x]) ( (t : \u03c8) \u2192 ( (x : X) \u2192 Y t x) [\u03d5 t \u21a6 f t]) := ( \\ h t x \u2192 (h x) t , ( ( \\ g x t \u2192 g t x , \\ h \u2192 refl ) , ( \\ g x t \u2192 g t x , \\ g \u2192 refl ))) RS17, Theorem 4.2 #def curry-uncurry ( I J : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( \u03b6 : J \u2192 TOPE) ( \u03c7 : \u03b6 \u2192 TOPE) ( X : \u03c8 \u2192 \u03b6 \u2192 U) ( f : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 X t s) : Equiv ( (t : \u03c8) \u2192 ( (s : \u03b6) \u2192 X t s [\u03c7 s \u21a6 f (t , s)]) [\u03d5 t \u21a6 \\ s \u2192 f (t , s)]) ( ((t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s) \u2192 X t s [(\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 f (t , s)]) := ( \\ g (t , s) \u2192 (g t) s , ( ( \\ h t s \u2192 h (t , s) , \\ g \u2192 refl ) , ( \\ h t s \u2192 h (t , s) , \\ h \u2192 refl ))) #def uncurry-opcurry ( I J : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( \u03b6 : J \u2192 TOPE) ( \u03c7 : \u03b6 \u2192 TOPE) ( X : \u03c8 \u2192 \u03b6 \u2192 U) ( f : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 X t s) : Equiv ( ((t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s) \u2192 X t s [(\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 f (t , s)]) ( ( s : \u03b6) \u2192 ( (t : \u03c8) \u2192 X t s [\u03d5 t \u21a6 f (t , s)]) [\u03c7 s \u21a6 \\ t \u2192 f (t , s)]) := ( \\ h s t \u2192 h (t , s) , ( ( \\ g (t , s) \u2192 (g s) t , \\ h \u2192 refl ) , ( \\ g (t , s) \u2192 (g s) t , \\ g \u2192 refl ))) #def fubini ( I J : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( \u03b6 : J \u2192 TOPE) ( \u03c7 : \u03b6 \u2192 TOPE) ( X : \u03c8 \u2192 \u03b6 \u2192 U) ( f : ((t , s) : I \u00d7 J | (\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s)) \u2192 X t s) : Equiv ( ( t : \u03c8) \u2192 ( (s : \u03b6) \u2192 X t s [\u03c7 s \u21a6 f (t , s)]) [\u03d5 t \u21a6 \\ s \u2192 f (t , s)]) ( ( s : \u03b6) \u2192 ( (t : \u03c8) \u2192 X t s [\u03d5 t \u21a6 f (t , s)]) [\u03c7 s \u21a6 \\ t \u2192 f (t , s)]) := equiv-comp ( ( t : \u03c8) \u2192 ( (s : \u03b6) \u2192 X t s [\u03c7 s \u21a6 f (t , s)]) [\u03d5 t \u21a6 \\ s \u2192 f (t , s)]) ( ( (t , s) : I \u00d7 J | \u03c8 t \u2227 \u03b6 s) \u2192 X t s [(\u03d5 t \u2227 \u03b6 s) \u2228 (\u03c8 t \u2227 \u03c7 s) \u21a6 f (t , s)]) ( ( s : \u03b6) \u2192 ( (t : \u03c8) \u2192 X t s [\u03d5 t \u21a6 f (t , s)]) [\u03c7 s \u21a6 \\ t \u2192 f (t , s)]) ( curry-uncurry I J \u03c8 \u03d5 \u03b6 \u03c7 X f) ( uncurry-opcurry I J \u03c8 \u03d5 \u03b6 \u03c7 X f)","title":"Commutation of arguments and currying"},{"location":"simplicial-hott/04-extension-types.rzk/#extending-into-types-the-non-axiom-of-choice","text":"RS17, Theorem 4.3 #def axiom-choice ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( X : \u03c8 \u2192 U) ( Y : ( t : \u03c8) \u2192 ( x : X t) \u2192 U) ( a : ( t : \u03d5) \u2192 X t) ( b : ( t : \u03d5) \u2192 Y t (a t)) : Equiv ( (t : \u03c8) \u2192 ( \u03a3 (x : X t) , Y t x) [\u03d5 t \u21a6 (a t , b t)]) ( \u03a3 ( f : ( (t : \u03c8) \u2192 X t [\u03d5 t \u21a6 a t])) , ( (t : \u03c8) \u2192 Y t (f t) [\u03d5 t \u21a6 b t])) := ( \\ g \u2192 ( \\ t \u2192 ( first (g t)) , \\ t \u2192 second (g t)) , ( ( \\ (f , h) t \u2192 (f t , h t) , \\ _ \u2192 refl ) , ( \\ (f , h) t \u2192 (f t , h t) , \\ _ \u2192 refl )))","title":"Extending into \u03a3-types (the non-axiom of choice)"},{"location":"simplicial-hott/04-extension-types.rzk/#composites-and-unions-of-cofibrations","text":"The original form. RS17, Theorem 4.4 #def cofibration-composition ( I : CUBE) ( \u03c7 : I \u2192 TOPE) ( \u03c8 : \u03c7 \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( X : \u03c7 \u2192 U) ( a : ( t : \u03d5) \u2192 X t) : Equiv ( (t : \u03c7) \u2192 X t [\u03d5 t \u21a6 a t]) ( \u03a3 ( f : ( t : \u03c8) \u2192 X t [\u03d5 t \u21a6 a t]) , ( (t : \u03c7) \u2192 X t [\u03c8 t \u21a6 f t])) := ( \\ h \u2192 ( \\ t \u2192 h t , \\ t \u2192 h t) , ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl ) , ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl )))) A reformulated version via tope disjunction instead of inclusion (see https://github.com/rzk-lang/rzk/issues/8 ). RS17, Theorem 4.4 #def cofibration-composition' ( I : CUBE) ( \u03c7 \u03c8 \u03d5 : I \u2192 TOPE) ( X : \u03c7 \u2192 U) ( a : ( t : I | \u03c7 t \u2227 \u03c8 t \u2227 \u03d5 t) \u2192 X t) : Equiv ( (t : \u03c7) \u2192 X t [\u03c7 t \u2227 \u03c8 t \u2227 \u03d5 t \u21a6 a t]) ( \u03a3 ( f : ( t : I | \u03c7 t \u2227 \u03c8 t) \u2192 X t [\u03c7 t \u2227 \u03c8 t \u2227 \u03d5 t \u21a6 a t]) , ( (t : \u03c7) \u2192 X t [\u03c7 t \u2227 \u03c8 t \u21a6 f t])) := ( \\ h \u2192 ( \\ t \u2192 h t , \\ t \u2192 h t) , ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl ) , ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl ))) RS17, Theorem 4.5 #def cofibration-union ( I : CUBE) ( \u03d5 \u03c8 : I \u2192 TOPE) ( X : ( t : I | \u03d5 t \u2228 \u03c8 t) \u2192 U) ( a : ( t : \u03c8) \u2192 X t) : Equiv ( (t : I | \u03d5 t \u2228 \u03c8 t) \u2192 X t [\u03c8 t \u21a6 a t]) ( (t : \u03d5) \u2192 X t [\u03d5 t \u2227 \u03c8 t \u21a6 a t]) := ( \\ h t \u2192 h t , ( ( \\ g t \u2192 recOR (\u03d5 t \u21a6 g t , \u03c8 t \u21a6 a t) , \\ _ \u2192 refl ) , ( \\ g t \u2192 recOR (\u03d5 t \u21a6 g t , \u03c8 t \u21a6 a t) , \\ _ \u2192 refl )))","title":"Composites and unions of cofibrations"},{"location":"simplicial-hott/04-extension-types.rzk/#relative-function-extensionality","text":"There are various equivalent forms of the relative function extensionality axiom. Here we state the one that will be most useful and derive an application. #def ext-htpy-eq ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( A : \u03c8 \u2192 U) ( a : ( t : \u03d5) \u2192 A t) ( f g : ( t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) ( p : f = g) : ( t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl ] := ind-path ( (t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) ( f) ( \\ g' p' \u2192 (t : \u03c8) \u2192 (f t = g' t) [\u03d5 t \u21a6 refl ]) ( \\ t \u2192 refl ) ( g) ( p) The type that encodes the extension extensionality axiom. As suggested by footnote 8, we assert this as an \"extension extensionality\" axiom RS17, Proposition 4.8(ii) #def ExtExt : U := ( I : CUBE) \u2192 ( \u03c8 : I \u2192 TOPE) \u2192 ( \u03d5 : \u03c8 \u2192 TOPE) \u2192 ( A : \u03c8 \u2192 U) \u2192 ( a : ( t : \u03d5) \u2192 A t) \u2192 ( f : ( t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) \u2192 ( g : ( t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) \u2192 is-equiv ( f = g) ( (t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl ]) ( ext-htpy-eq I \u03c8 \u03d5 A a f g) #assume extext : ExtExt The equivalence provided by extension extensionality #def equiv-ExtExt uses ( extext ) ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( A : \u03c8 \u2192 U) ( a : ( t : \u03d5) \u2192 A t) ( f g : ( t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) : Equiv (f = g) ( (t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl ]) := (ext-htpy-eq I \u03c8 \u03d5 A a f g , extext I \u03c8 \u03d5 A a f g) In particular, extension extensionality implies that homotopies give rise to identifications. This definition defines eq-ext-htpy to be the retraction to ext-htpy-eq . #def eq-ext-htpy uses ( extext ) ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( \u03d5 : \u03c8 \u2192 TOPE) ( A : \u03c8 \u2192 U) ( a : ( t : \u03d5) \u2192 A t) ( f g : ( t : \u03c8) \u2192 A t [\u03d5 t \u21a6 a t]) : ( (t : \u03c8) \u2192 (f t = g t) [\u03d5 t \u21a6 refl ]) \u2192 (f = g) := first ( first (extext I \u03c8 \u03d5 A a f g)) By extension extensionality, fiberwise equivalences of extension types define equivalences of extension types. For simplicity, we extend from BOT . #def equiv-extension-equiv-family uses ( extext ) ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( A B : \u03c8 \u2192 U) ( famequiv : ( t : \u03c8) \u2192 (Equiv (A t) (B t))) : Equiv ( (t : \u03c8) \u2192 A t) ( (t : \u03c8) \u2192 B t) := ( ( \\ a t \u2192 ( first (famequiv t)) (a t)) , ( ( ( \\ b t \u2192 ( first ( first ( second (famequiv t)))) (b t)) , ( \\ a \u2192 eq-ext-htpy ( I) ( \u03c8) ( \\ t \u2192 BOT ) ( A) ( \\ u \u2192 recBOT ) ( \\ t \u2192 first ( first ( second (famequiv t))) ( first (famequiv t) (a t))) ( a) ( \\ t \u2192 second ( first ( second (famequiv t))) (a t)))) , ( ( \\ b t \u2192 first ( second ( second (famequiv t))) (b t)) , ( \\ b \u2192 eq-ext-htpy ( I) ( \u03c8) ( \\ t \u2192 BOT ) ( B) ( \\ u \u2192 recBOT ) ( \\ t \u2192 first (famequiv t) ( first ( second ( second (famequiv t))) (b t))) ( b) ( \\ t \u2192 second ( second ( second (famequiv t))) (b t))))))","title":"Relative function extensionality"},{"location":"simplicial-hott/05-segal-types.rzk/","text":"Segal Types \u00b6 These formalisations correspond to Section 5 of the RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 hott/1-paths.md - We require basic path algebra. hott/2-contractible.md - We require the notion of contractible types and their data. hott/total-space.md \u2014 We rely on is-equiv-projection-contractible-fibers and total-space-projection in the proof of Theorem 5.5. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. Some of the definitions in this file rely on function extensionality and extension extensionality: #assume funext : FunExt #assume extext : ExtExt Hom types \u00b6 Extension types are used to define the type of arrows between fixed terms: x y RS17, Definition 5.1 #def hom ( A : U) ( x y : A) : U := ( t : \u0394\u00b9) \u2192 A [ t \u2261 0\u2082 \u21a6 x , -- the left endpoint is exactly x t \u2261 1\u2082 \u21a6 y] -- the right endpoint is exactly y Extension types are also used to define the type of commutative triangles: x y z f g h RS17, Definition 5.2 #def hom2 ( A : U) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) : U := ( (t\u2081 , t\u2082) : \u0394\u00b2) \u2192 A [ t\u2082 \u2261 0\u2082 \u21a6 f t\u2081 , -- the top edge is exactly `f`, t\u2081 \u2261 1\u2082 \u21a6 g t\u2082 , -- the right edge is exactly `g`, and t\u2082 \u2261 t\u2081 \u21a6 h t\u2082] -- the diagonal is exactly `h` The Segal condition \u00b6 A type is Segal if every composable pair of arrows has a unique composite. Note this is a considerable simplification of the usual Segal condition, which also requires homotopical uniqueness of higher-order composites. RS17, Definition 5.3 #def is-segal ( A : U) : U := ( x : A) \u2192 ( y : A) \u2192 ( z : A) \u2192 ( f : hom A x y) \u2192 ( g : hom A y z) \u2192 is-contr ( \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) Segal types have a composition functor and witnesses to the composition relation. Composition is written in diagrammatic order to match the order of arguments in is-segal . #def comp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : hom A x z := first ( first (is-segal-A x y z f g)) #def witness-comp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : hom2 A x y z f g (comp-is-segal A is-segal-A x y z f g) := second ( first (is-segal-A x y z f g)) Composition in a Segal type is unique in the following sense. If there is a witness that an arrow \\(h\\) is a composite of \\(f\\) and \\(g\\) , then the specified composite equals \\(h\\) . x y z f g h \u03b1 = x y z f g comp-is-segal witness-comp-is-segal #def uniqueness-comp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) ( alpha : hom2 A x y z f g h) : ( comp-is-segal A is-segal-A x y z f g) = h := first-path-\u03a3 ( hom A x z) ( hom2 A x y z f g) ( comp-is-segal A is-segal-A x y z f g , witness-comp-is-segal A is-segal-A x y z f g) ( h , alpha) ( homotopy-contraction ( \u03a3 (k : hom A x z) , (hom2 A x y z f g k)) ( is-segal-A x y z f g) ( h , alpha)) Characterizing Segal types \u00b6 Our aim is to prove that a type is Segal if and only if the horn-restriction map, defined below, is an equivalence. x y z f g A pair of composable arrows form a horn. #def horn ( A : U) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : \u039b \u2192 A := \\ (t , s) \u2192 recOR ( s \u2261 0\u2082 \u21a6 f t , t \u2261 1\u2082 \u21a6 g s) The underlying horn of a simplex: #def horn-restriction ( A : U) : (\u0394\u00b2 \u2192 A) \u2192 (\u039b \u2192 A) := \\ f t \u2192 f t This provides an alternate definition of Segal types. #def is-local-horn-inclusion ( A : U) : U := is-equiv (\u0394\u00b2 \u2192 A) (\u039b \u2192 A) (horn-restriction A) Now we prove this definition is equivalent to the original one. Here, we prove the equivalence used in [RS17, Theorem 5.5]. However, we do this by constructing the equivalence directly, instead of using a composition of equivalences, as it is easier to write down and it computes better (we can use refl for the witnesses of the equivalence). #def compositions-are-horn-fillings ( A : U) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : Equiv ( \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) ( (t : \u0394\u00b2) \u2192 A [\u039b t \u21a6 horn A x y z f g t]) := ( \\ hh t \u2192 ( second hh) t , ( ( \\ k \u2192 ( \\ t \u2192 k (t , t) , \\ (t , s) \u2192 k (t , s)) , \\ hh \u2192 refl ) , ( \\ k \u2192 ( \\ t \u2192 k (t , t) , \\ (t , s) \u2192 k (t , s)) , \\ hh \u2192 refl ))) #def equiv-horn-restriction ( A : U) : Equiv ( \u0394\u00b2 \u2192 A) ( \u03a3 ( k : \u039b \u2192 A) , ( \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h)))) := ( \\ k \u2192 ( ( \\ t \u2192 k t) , ( \\ t \u2192 k (t , t) , \\ t \u2192 k t)) , ( ( \\ khh t \u2192 ( second ( second khh)) t , \\ k \u2192 refl ) , ( \\ khh t \u2192 ( second ( second khh)) t , \\ k \u2192 refl ))) RS17, Theorem 5.5 (the hard direction) #def equiv-horn-restriction-is-segal ( A : U) ( is-segal-A : is-segal A) : Equiv (\u0394\u00b2 \u2192 A) (\u039b \u2192 A) := equiv-comp ( \u0394\u00b2 \u2192 A) ( \u03a3 ( k : \u039b \u2192 A) , ( \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h)))) ( \u039b \u2192 A) ( equiv-horn-restriction A) ( total-space-projection ( \u039b \u2192 A) ( \\ k \u2192 \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h))) , ( is-equiv-projection-contractible-fibers ( \u039b \u2192 A) ( \\ k \u2192 \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h))) ( \\ k \u2192 is-segal-A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t))))) We verify that the mapping in Segal-equiv-horn-restriction A is-segal-A is exactly horn-restriction A . #def test-equiv-horn-restriction-is-segal ( A : U) ( is-segal-A : is-segal A) : ( first (equiv-horn-restriction-is-segal A is-segal-A)) = (horn-restriction A) := refl Segal types are types that are local at the horn inclusion #def is-local-horn-inclusion-is-segal ( A : U) ( is-segal-A : is-segal A) : is-local-horn-inclusion A := second (equiv-horn-restriction-is-segal A is-segal-A) Types that are local at the horn inclusion are Segal types #def is-segal-is-local-horn-inclusion ( A : U) ( is-local-horn-inclusion-A : is-local-horn-inclusion A) : is-segal A := \\ x y z f g \u2192 contractible-fibers-is-equiv-projection ( \u039b \u2192 A) ( \\ k \u2192 \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h))) ( second ( equiv-comp ( \u03a3 ( k : \u039b \u2192 A) , \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h))) ( \u0394\u00b2 \u2192 A) ( \u039b \u2192 A) ( inv-equiv ( \u0394\u00b2 \u2192 A) ( \u03a3 ( k : \u039b \u2192 A) , \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h))) ( equiv-horn-restriction A)) ( horn-restriction A , is-local-horn-inclusion-A))) ( horn A x y z f g) We have now proven that both notions of Segal types are logically equivalent. RS17, Theorem 5.5 #def is-segal-iff-is-local-horn-inclusion ( A : U) : iff (is-segal A) (is-local-horn-inclusion A) := (is-local-horn-inclusion-is-segal A , is-segal-is-local-horn-inclusion A) Segal function and extension types \u00b6 Using the new characterization of Segal types, we can show that the type of functions or extensions into a family of Segal types is again a Segal type. For instance if \\(X\\) is a type and \\(A : X \u2192 U\\) is such that \\(A x\\) is a Segal type for all \\(x\\) then \\((x : X) \u2192 A x\\) is a Segal type. RS17, Corollary 5.6(i) #def is-segal-function-type uses ( funext ) ( X : U) ( A : X \u2192 U) ( fiberwise-is-segal-A : ( x : X) \u2192 is-local-horn-inclusion (A x)) : is-local-horn-inclusion ( (x : X) \u2192 A x) := is-equiv-triple-comp ( \u0394\u00b2 \u2192 ((x : X) \u2192 A x)) ( (x : X) \u2192 \u0394\u00b2 \u2192 A x) ( (x : X) \u2192 \u039b \u2192 A x) ( \u039b \u2192 ((x : X) \u2192 A x)) ( \\ g x t \u2192 g t x) -- first equivalence ( second (flip-ext-fun ( 2 \u00d7 2 ) ( \u0394\u00b2) ( \\ t \u2192 BOT ) ( X) ( \\ t \u2192 A) ( \\ t \u2192 recBOT ))) ( \\ h x t \u2192 h x t) -- second equivalence ( second (equiv-function-equiv-family ( funext) ( X) ( \\ x \u2192 (\u0394\u00b2 \u2192 A x)) ( \\ x \u2192 (\u039b \u2192 A x)) ( \\ x \u2192 (horn-restriction (A x) , fiberwise-is-segal-A x)))) ( \\ h t x \u2192 (h x) t) -- third equivalence ( second (flip-ext-fun-inv ( 2 \u00d7 2 ) ( \u039b) ( \\ t \u2192 BOT ) ( X) ( \\ t \u2192 A) ( \\ t \u2192 recBOT ))) If \\(X\\) is a shape and \\(A : X \u2192 U\\) is such that \\(A x\\) is a Segal type for all \\(x\\) then \\((x : X) \u2192 A x\\) is a Segal type. RS17, Corollary 5.6(ii) #def is-segal-extension-type' uses ( extext ) ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( A : \u03c8 \u2192 U) ( fiberwise-is-segal-A : ( s : \u03c8) \u2192 is-local-horn-inclusion (A s)) : is-local-horn-inclusion ( (s : \u03c8) \u2192 A s) := is-equiv-triple-comp ( \u0394\u00b2 \u2192 (s : \u03c8) \u2192 A s) ( (s : \u03c8) \u2192 \u0394\u00b2 \u2192 A s) ( (s : \u03c8) \u2192 \u039b \u2192 A s) ( \u039b \u2192 (s : \u03c8) \u2192 A s) ( \\ g s t \u2192 g t s) -- first equivalence ( second ( fubini ( 2 \u00d7 2 ) ( I) ( \u0394\u00b2) ( \\ t \u2192 BOT ) ( \u03c8) ( \\ s \u2192 BOT ) ( \\ t s \u2192 A s) ( \\ u \u2192 recBOT ))) ( \\ h s t \u2192 h s t) -- second equivalence ( second (equiv-extension-equiv-family extext I \u03c8 ( \\ s \u2192 \u0394\u00b2 \u2192 A s) ( \\ s \u2192 \u039b \u2192 A s) ( \\ s \u2192 (horn-restriction (A s) , fiberwise-is-segal-A s)))) ( \\ h t s \u2192 (h s) t) -- third equivalence ( second ( fubini ( I) ( 2 \u00d7 2 ) ( \u03c8) ( \\ s \u2192 BOT ) ( \u039b) ( \\ t \u2192 BOT ) ( \\ s t \u2192 A s) ( \\ u \u2192 recBOT ))) #def is-segal-extension-type uses ( extext ) ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( A : \u03c8 \u2192 U) ( fiberwise-is-segal-A : ( s : \u03c8) \u2192 is-segal (A s)) : is-segal ( (s : \u03c8) \u2192 A s) := is-segal-is-local-horn-inclusion ( (s : \u03c8) \u2192 A s) ( is-segal-extension-type' ( I) (\u03c8) (A) ( \\ s \u2192 is-local-horn-inclusion-is-segal (A s) (fiberwise-is-segal-A s))) In particular, the arrow type of a Segal type is Segal. First, we define the arrow type: #def arr ( A : U) : U := \u0394\u00b9 \u2192 A For later use, an equivalent characterization of the arrow type. #def arr-\u03a3-hom ( A : U) : ( arr A) \u2192 ( \u03a3 (x : A) , ( \u03a3 (y : A) , hom A x y)) := \\ f \u2192 (f 0\u2082 , (f 1\u2082 , f)) #def is-equiv-arr-\u03a3-hom ( A : U) : is-equiv (arr A) ( \u03a3 (x : A) , ( \u03a3 (y : A) , hom A x y)) (arr-\u03a3-hom A) := ( ( \\ (x , (y , f)) \u2192 f , \\ f \u2192 refl ) , ( \\ (x , (y , f)) \u2192 f , \\ xyf \u2192 refl )) #def equiv-arr-\u03a3-hom ( A : U) : Equiv (arr A) ( \u03a3 (x : A) , ( \u03a3 (y : A) , hom A x y)) := ( arr-\u03a3-hom A , is-equiv-arr-\u03a3-hom A) RS17, Corollary 5.6(ii), special case for locality at the horn inclusion #def is-local-horn-inclusion-arr uses ( extext ) ( A : U) ( is-segal-A : is-local-horn-inclusion A) : is-local-horn-inclusion (arr A) := is-segal-extension-type' ( 2 ) ( \u0394\u00b9) ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A) RS17, Corollary 5.6(ii), special case for the Segal condition #def is-segal-arr uses ( extext ) ( A : U) ( is-segal-A : is-segal A) : is-segal (arr A) := is-segal-extension-type ( 2 ) ( \u0394\u00b9) ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A) Identity \u00b6 All types have identity arrows and witnesses to the identity composition law. x x x RS17, Definition 5.7 #def id-hom ( A : U) ( x : A) : hom A x x := \\ t \u2192 x Witness for the right identity law: x y y f y f f RS17, Proposition 5.8a #def comp-id-witness ( A : U) ( x y : A) ( f : hom A x y) : hom2 A x y y f (id-hom A y) f := \\ (t , s) \u2192 f t Witness for the left identity law: x x y x f f f RS17, Proposition 5.8b #def id-comp-witness ( A : U) ( x y : A) ( f : hom A x y) : hom2 A x x y (id-hom A x) f f := \\ (t , s) \u2192 f s In a Segal type, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. Thus, an identity axiom was not needed in the definition of Segal types. If A is Segal then the right unit law holds #def comp-id-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : ( comp-is-segal A is-segal-A x y y f (id-hom A y)) = f := uniqueness-comp-is-segal ( A) ( is-segal-A) ( x) (y) (y) ( f) ( id-hom A y) ( f) ( comp-id-witness A x y f) If A is Segal then the left unit law holds #def id-comp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : (comp-is-segal A is-segal-A x x y (id-hom A x) f) =_{hom A x y} f := uniqueness-comp-is-segal ( A) ( is-segal-A) ( x) (x) (y) ( id-hom A x) ( f) ( f) ( id-comp-witness A x y f) Associativity \u00b6 We now prove that composition in a Segal type is associative, by using the fact that the type of arrows in a Segal type is itself a Segal type. \u2022 \u2022 \u2022 \u2022 #def unfolding-square ( A : U) ( triangle : \u0394\u00b2 \u2192 A) : \u0394\u00b9\u00d7\u0394\u00b9 \u2192 A := \\ (t , s) \u2192 recOR ( t \u2264 s \u21a6 triangle (s , t) , s \u2264 t \u21a6 triangle (t , s)) For use in the proof of associativity: x y z y f g comp-is-segal g f #def witness-square-comp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : \u0394\u00b9\u00d7\u0394\u00b9 \u2192 A := unfolding-square A (witness-comp-is-segal A is-segal-A x y z f g) The witness-square-comp-is-segal as an arrow in the arrow type: x y z y f g #def arr-in-arr-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : hom (arr A) f g := \\ t s \u2192 witness-square-comp-is-segal A is-segal-A x y z f g (t , s) w x x y y z f g h #def witness-asociative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : hom2 (arr A) f g h (arr-in-arr-is-segal A is-segal-A w x y f g) (arr-in-arr-is-segal A is-segal-A x y z g h) (comp-is-segal (arr A) (is-segal-arr A is-segal-A) f g h (arr-in-arr-is-segal A is-segal-A w x y f g) (arr-in-arr-is-segal A is-segal-A x y z g h)) := witness-comp-is-segal ( arr A) ( is-segal-arr A is-segal-A) f g h ( arr-in-arr-is-segal A is-segal-A w x y f g) ( arr-in-arr-is-segal A is-segal-A x y z g h) w x y z g f h The witness-associative-is-segal curries to define a diagram \\(\u0394\u00b2\u00d7\u0394\u00b9 \u2192 A\\) . The tetrahedron-associative-is-segal is extracted via the middle-simplex map \\(((t , s) , r) \u21a6 ((t , r) , s)\\) from \\(\u0394\u00b3\\) to \\(\u0394\u00b2\u00d7\u0394\u00b9\\) . #def tetrahedron-associative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : \u0394\u00b3 \u2192 A := \\ ((t , s) , r) \u2192 (witness-asociative-is-segal A is-segal-A w x y z f g h) (t , r) s w x y z g f h The diagonal composite of three arrows extracted from the tetrahedron-associative-is-segal . #def triple-comp-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : hom A w z := \\ t \u2192 tetrahedron-associative-is-segal A is-segal-A w x y z f g h ( (t , t) , t) w x y z g f h #def left-witness-asociative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : hom2 A w y z (comp-is-segal A is-segal-A w x y f g) h (triple-comp-is-segal A is-segal-A w x y z f g h) := \\ (t , s) \u2192 tetrahedron-associative-is-segal A is-segal-A w x y z f g h ( (t , t) , s) The front face: w x y z g f h #def right-witness-asociative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : hom2 A w x z ( f) ( comp-is-segal A is-segal-A x y z g h) ( triple-comp-is-segal A is-segal-A w x y z f g h) := \\ (t , s) \u2192 tetrahedron-associative-is-segal A is-segal-A w x y z f g h ( (t , s) , s) #def left-associative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : ( comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h) = ( triple-comp-is-segal A is-segal-A w x y z f g h) := uniqueness-comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h ( triple-comp-is-segal A is-segal-A w x y z f g h) ( left-witness-asociative-is-segal A is-segal-A w x y z f g h) #def right-associative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : ( comp-is-segal A is-segal-A w x z f (comp-is-segal A is-segal-A x y z g h)) = ( triple-comp-is-segal A is-segal-A w x y z f g h) := uniqueness-comp-is-segal ( A) (is-segal-A) (w) (x) (z) (f) (comp-is-segal A is-segal-A x y z g h) ( triple-comp-is-segal A is-segal-A w x y z f g h) ( right-witness-asociative-is-segal A is-segal-A w x y z f g h) We conclude that Segal composition is associative. RS17, Proposition 5.9 #def associative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : ( comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h) = ( comp-is-segal A is-segal-A w x z f (comp-is-segal A is-segal-A x y z g h)) := zig-zag-concat ( hom A w z) ( comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h) ( triple-comp-is-segal A is-segal-A w x y z f g h) ( comp-is-segal A is-segal-A w x z f (comp-is-segal A is-segal-A x y z g h)) ( left-associative-is-segal A is-segal-A w x y z f g h) ( right-associative-is-segal A is-segal-A w x y z f g h) #def postcomp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : ( z : A) \u2192 (hom A z x) \u2192 (hom A z y) := \\ z g \u2192 comp-is-segal A is-segal-A z x y g f #def precomp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : ( z : A) \u2192 (hom A y z) \u2192 (hom A x z) := \\ z \u2192 comp-is-segal A is-segal-A x y z f Homotopies \u00b6 We may define a \"homotopy\" to be a path between parallel arrows. In a Segal type, homotopies are equivalent to terms in hom2 types involving an identity arrow. #def map-hom2-homotopy ( A : U) ( x y : A) ( f g : hom A x y) : (f = g) \u2192 (hom2 A x x y (id-hom A x) f g) := ind-path ( hom A x y) ( f) ( \\ g' p' \u2192 (hom2 A x x y (id-hom A x) f g')) ( id-comp-witness A x y f) ( g) #def map-total-hom2-homotopy ( A : U) ( x y : A) ( f : hom A x y) : ( \u03a3 (g : hom A x y) , (f = g)) \u2192 ( \u03a3 (g : hom A x y) , (hom2 A x x y (id-hom A x) f g)) := \\ (g , p) \u2192 (g , map-hom2-homotopy A x y f g p) #def is-equiv-map-total-hom2-homotopy-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : is-equiv ( \u03a3 (g : hom A x y) , f = g) ( \u03a3 (g : hom A x y) , (hom2 A x x y (id-hom A x) f g)) ( map-total-hom2-homotopy A x y f) := is-equiv-are-contr ( \u03a3 (g : hom A x y) , (f = g)) ( \u03a3 (g : hom A x y) , (hom2 A x x y (id-hom A x) f g)) ( is-contr-based-paths (hom A x y) f) ( is-segal-A x x y (id-hom A x) f) ( map-total-hom2-homotopy A x y f) RS17, Proposition 5.10 #def equiv-homotopy-hom2-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f h : hom A x y) : Equiv (f = h) (hom2 A x x y (id-hom A x) f h) := ( ( map-hom2-homotopy A x y f h) , ( total-equiv-family-of-equiv ( hom A x y) ( \\ k \u2192 (f = k)) ( \\ k \u2192 (hom2 A x x y (id-hom A x) f k)) ( map-hom2-homotopy A x y f) ( is-equiv-map-total-hom2-homotopy-is-segal A is-segal-A x y f) ( h))) A dual notion of homotopy can be defined similarly. #def map-hom2-homotopy' ( A : U) ( x y : A) ( f g : hom A x y) ( p : f = g) : (hom2 A x y y f (id-hom A y) g) := ind-path ( hom A x y) ( f) ( \\ g' p' \u2192 (hom2 A x y y f (id-hom A y) g')) ( comp-id-witness A x y f) ( g) ( p) #def map-total-hom2-homotopy' ( A : U) ( x y : A) ( f : hom A x y) : ( \u03a3 (g : hom A x y) , (f = g)) \u2192 ( \u03a3 (g : hom A x y) , (hom2 A x y y f (id-hom A y) g)) := \\ (g , p) \u2192 (g , map-hom2-homotopy' A x y f g p) #def is-equiv-map-total-hom2-homotopy'-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : is-equiv ( \u03a3 (g : hom A x y) , f = g) ( \u03a3 (g : hom A x y) , (hom2 A x y y f (id-hom A y) g)) ( map-total-hom2-homotopy' A x y f) := is-equiv-are-contr ( \u03a3 (g : hom A x y) , (f = g)) ( \u03a3 (g : hom A x y) , (hom2 A x y y f (id-hom A y) g)) ( is-contr-based-paths (hom A x y) f) ( is-segal-A x y y f (id-hom A y)) ( map-total-hom2-homotopy' A x y f) RS17, Proposition 5.10 #def equiv-homotopy-hom2'-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f h : hom A x y) : Equiv (f = h) (hom2 A x y y f (id-hom A y) h) := ( ( map-hom2-homotopy' A x y f h) , ( total-equiv-family-of-equiv ( hom A x y) ( \\ k \u2192 (f = k)) ( \\ k \u2192 (hom2 A x y y f (id-hom A y) k)) ( map-hom2-homotopy' A x y f) ( is-equiv-map-total-hom2-homotopy'-is-segal A is-segal-A x y f) ( h))) More generally, a homotopy between a composite and another map is equivalent to the data provided by a commutative triangle with that boundary. #def map-hom2-eq-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) ( p : (comp-is-segal A is-segal-A x y z f g) = h) : ( hom2 A x y z f g h) := ind-path ( hom A x z) ( comp-is-segal A is-segal-A x y z f g) ( \\ h' p' \u2192 hom2 A x y z f g h') ( witness-comp-is-segal A is-segal-A x y z f g) ( h) ( p) #def map-total-hom2-eq-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : ( \u03a3 (h : hom A x z) , (comp-is-segal A is-segal-A x y z f g) = h) \u2192 ( \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) := \\ (h , p) \u2192 (h , map-hom2-eq-is-segal A is-segal-A x y z f g h p) #def is-equiv-map-total-hom2-eq-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : is-equiv ( \u03a3 (h : hom A x z) , (comp-is-segal A is-segal-A x y z f g) = h) ( \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) ( map-total-hom2-eq-is-segal A is-segal-A x y z f g) := is-equiv-are-contr ( \u03a3 (h : hom A x z) , (comp-is-segal A is-segal-A x y z f g) = h) ( \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) ( is-contr-based-paths (hom A x z) (comp-is-segal A is-segal-A x y z f g)) ( is-segal-A x y z f g) ( map-total-hom2-eq-is-segal A is-segal-A x y z f g) RS17, Proposition 5.12 #def equiv-hom2-eq-comp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( k : hom A x z) : Equiv ((comp-is-segal A is-segal-A x y z f g) = k) (hom2 A x y z f g k) := ( ( map-hom2-eq-is-segal A is-segal-A x y z f g k) , ( total-equiv-family-of-equiv ( hom A x z) ( \\ m \u2192 (comp-is-segal A is-segal-A x y z f g) = m) ( hom2 A x y z f g) ( map-hom2-eq-is-segal A is-segal-A x y z f g) ( is-equiv-map-total-hom2-eq-is-segal A is-segal-A x y z f g) ( k))) Homotopies form a congruence, meaning that homotopies are respected by composition: RS17, Proposition 5.13 #def congruence-homotopy-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f g : hom A x y) ( h k : hom A y z) ( p : f = g) ( q : h = k) : ( comp-is-segal A is-segal-A x y z f h) = ( comp-is-segal A is-segal-A x y z g k) := ind-path ( hom A y z) ( h) ( \\ k' q' \u2192 ( comp-is-segal A is-segal-A x y z f h) = ( comp-is-segal A is-segal-A x y z g k')) ( ind-path ( hom A x y) ( f) ( \\ g' p' \u2192 ( comp-is-segal A is-segal-A x y z f h) = ( comp-is-segal A is-segal-A x y z g' h)) ( refl ) ( g) ( p)) ( k) ( q) As a special case of the above: #def postwhisker-homotopy-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f g : hom A x y) ( h : hom A y z) ( p : f = g) : ( comp-is-segal A is-segal-A x y z f h) = (comp-is-segal A is-segal-A x y z g h) := congruence-homotopy-is-segal A is-segal-A x y z f g h h p refl As a special case of the above: #def prewhisker-homotopy-is-segal ( A : U) ( is-segal-A : is-segal A) ( w x y : A) ( k : hom A w x) ( f g : hom A x y) ( p : f = g) : ( comp-is-segal A is-segal-A w x y k f) = ( comp-is-segal A is-segal-A w x y k g) := congruence-homotopy-is-segal A is-segal-A w x y k k f g refl p RS17, Proposition 5.14(a) #def compute-postwhisker-homotopy-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f g : hom A x y) ( h : hom A y z) ( p : f = g) : ( postwhisker-homotopy-is-segal A is-segal-A x y z f g h p) = ( ap (hom A x y) (hom A x z) f g ( \\ k \u2192 comp-is-segal A is-segal-A x y z k h) p) := ind-path ( hom A x y) ( f) ( \\ g' p' \u2192 ( postwhisker-homotopy-is-segal A is-segal-A x y z f g' h p') = ( ap (hom A x y) (hom A x z) (f) (g') ( \\ k \u2192 comp-is-segal A is-segal-A x y z k h) (p'))) ( refl ) ( g) ( p) RS17, Proposition 5.14(b) #def prewhisker-homotopy-is-ap-is-segal ( A : U) ( is-segal-A : is-segal A) ( w x y : A) ( k : hom A w x) ( f g : hom A x y) ( p : f = g) : ( prewhisker-homotopy-is-segal A is-segal-A w x y k f g p) = ( ap (hom A x y) (hom A w y) f g (comp-is-segal A is-segal-A w x y k) p) := ind-path ( hom A x y) ( f) ( \\ g' p' \u2192 ( prewhisker-homotopy-is-segal A is-segal-A w x y k f g' p') = ( ap (hom A x y) (hom A w y) f g' (comp-is-segal A is-segal-A w x y k) p')) ( refl ) ( g) ( p) #section is-segal-Unit #def is-contr-Unit : is-contr Unit := ( unit , \\ _ \u2192 refl ) #def is-contr-\u0394\u00b2\u2192Unit uses ( extext ) : is-contr (\u0394\u00b2 \u2192 Unit) := ( \\ _ \u2192 unit , \\ k \u2192 eq-ext-htpy extext ( 2 \u00d7 2 ) \u0394\u00b2 ( \\ _ \u2192 BOT ) ( \\ _ \u2192 Unit) ( \\ _ \u2192 recBOT ) ( \\ _ \u2192 unit ) k ( \\ _ \u2192 refl )) #def is-segal-Unit uses ( extext ) : is-segal Unit := \\ x y z f g \u2192 is-contr-is-retract-of-is-contr ( \u03a3 (h : hom Unit x z) , (hom2 Unit x y z f g h)) ( \u0394\u00b2 \u2192 Unit) ( ( \\ (_ , k) \u2192 k) , ( \\ k \u2192 (( \\ t \u2192 k (t , t)) , k) , \\ _ \u2192 refl )) ( is-contr-\u0394\u00b2\u2192 Unit ) #end is-segal-Unit @import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap); text, textPath { font-family: Noto Serif; font-size: 20px; dominant-baseline: middle; text-anchor: middle; }","title":"Segal Types"},{"location":"simplicial-hott/05-segal-types.rzk/#segal-types","text":"These formalisations correspond to Section 5 of the RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Segal Types"},{"location":"simplicial-hott/05-segal-types.rzk/#prerequisites","text":"hott/1-paths.md - We require basic path algebra. hott/2-contractible.md - We require the notion of contractible types and their data. hott/total-space.md \u2014 We rely on is-equiv-projection-contractible-fibers and total-space-projection in the proof of Theorem 5.5. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. Some of the definitions in this file rely on function extensionality and extension extensionality: #assume funext : FunExt #assume extext : ExtExt","title":"Prerequisites"},{"location":"simplicial-hott/05-segal-types.rzk/#hom-types","text":"Extension types are used to define the type of arrows between fixed terms: x y RS17, Definition 5.1 #def hom ( A : U) ( x y : A) : U := ( t : \u0394\u00b9) \u2192 A [ t \u2261 0\u2082 \u21a6 x , -- the left endpoint is exactly x t \u2261 1\u2082 \u21a6 y] -- the right endpoint is exactly y Extension types are also used to define the type of commutative triangles: x y z f g h RS17, Definition 5.2 #def hom2 ( A : U) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) : U := ( (t\u2081 , t\u2082) : \u0394\u00b2) \u2192 A [ t\u2082 \u2261 0\u2082 \u21a6 f t\u2081 , -- the top edge is exactly `f`, t\u2081 \u2261 1\u2082 \u21a6 g t\u2082 , -- the right edge is exactly `g`, and t\u2082 \u2261 t\u2081 \u21a6 h t\u2082] -- the diagonal is exactly `h`","title":"Hom types"},{"location":"simplicial-hott/05-segal-types.rzk/#the-segal-condition","text":"A type is Segal if every composable pair of arrows has a unique composite. Note this is a considerable simplification of the usual Segal condition, which also requires homotopical uniqueness of higher-order composites. RS17, Definition 5.3 #def is-segal ( A : U) : U := ( x : A) \u2192 ( y : A) \u2192 ( z : A) \u2192 ( f : hom A x y) \u2192 ( g : hom A y z) \u2192 is-contr ( \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) Segal types have a composition functor and witnesses to the composition relation. Composition is written in diagrammatic order to match the order of arguments in is-segal . #def comp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : hom A x z := first ( first (is-segal-A x y z f g)) #def witness-comp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : hom2 A x y z f g (comp-is-segal A is-segal-A x y z f g) := second ( first (is-segal-A x y z f g)) Composition in a Segal type is unique in the following sense. If there is a witness that an arrow \\(h\\) is a composite of \\(f\\) and \\(g\\) , then the specified composite equals \\(h\\) . x y z f g h \u03b1 = x y z f g comp-is-segal witness-comp-is-segal #def uniqueness-comp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) ( alpha : hom2 A x y z f g h) : ( comp-is-segal A is-segal-A x y z f g) = h := first-path-\u03a3 ( hom A x z) ( hom2 A x y z f g) ( comp-is-segal A is-segal-A x y z f g , witness-comp-is-segal A is-segal-A x y z f g) ( h , alpha) ( homotopy-contraction ( \u03a3 (k : hom A x z) , (hom2 A x y z f g k)) ( is-segal-A x y z f g) ( h , alpha))","title":"The Segal condition"},{"location":"simplicial-hott/05-segal-types.rzk/#characterizing-segal-types","text":"Our aim is to prove that a type is Segal if and only if the horn-restriction map, defined below, is an equivalence. x y z f g A pair of composable arrows form a horn. #def horn ( A : U) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : \u039b \u2192 A := \\ (t , s) \u2192 recOR ( s \u2261 0\u2082 \u21a6 f t , t \u2261 1\u2082 \u21a6 g s) The underlying horn of a simplex: #def horn-restriction ( A : U) : (\u0394\u00b2 \u2192 A) \u2192 (\u039b \u2192 A) := \\ f t \u2192 f t This provides an alternate definition of Segal types. #def is-local-horn-inclusion ( A : U) : U := is-equiv (\u0394\u00b2 \u2192 A) (\u039b \u2192 A) (horn-restriction A) Now we prove this definition is equivalent to the original one. Here, we prove the equivalence used in [RS17, Theorem 5.5]. However, we do this by constructing the equivalence directly, instead of using a composition of equivalences, as it is easier to write down and it computes better (we can use refl for the witnesses of the equivalence). #def compositions-are-horn-fillings ( A : U) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : Equiv ( \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) ( (t : \u0394\u00b2) \u2192 A [\u039b t \u21a6 horn A x y z f g t]) := ( \\ hh t \u2192 ( second hh) t , ( ( \\ k \u2192 ( \\ t \u2192 k (t , t) , \\ (t , s) \u2192 k (t , s)) , \\ hh \u2192 refl ) , ( \\ k \u2192 ( \\ t \u2192 k (t , t) , \\ (t , s) \u2192 k (t , s)) , \\ hh \u2192 refl ))) #def equiv-horn-restriction ( A : U) : Equiv ( \u0394\u00b2 \u2192 A) ( \u03a3 ( k : \u039b \u2192 A) , ( \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h)))) := ( \\ k \u2192 ( ( \\ t \u2192 k t) , ( \\ t \u2192 k (t , t) , \\ t \u2192 k t)) , ( ( \\ khh t \u2192 ( second ( second khh)) t , \\ k \u2192 refl ) , ( \\ khh t \u2192 ( second ( second khh)) t , \\ k \u2192 refl ))) RS17, Theorem 5.5 (the hard direction) #def equiv-horn-restriction-is-segal ( A : U) ( is-segal-A : is-segal A) : Equiv (\u0394\u00b2 \u2192 A) (\u039b \u2192 A) := equiv-comp ( \u0394\u00b2 \u2192 A) ( \u03a3 ( k : \u039b \u2192 A) , ( \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h)))) ( \u039b \u2192 A) ( equiv-horn-restriction A) ( total-space-projection ( \u039b \u2192 A) ( \\ k \u2192 \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h))) , ( is-equiv-projection-contractible-fibers ( \u039b \u2192 A) ( \\ k \u2192 \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h))) ( \\ k \u2192 is-segal-A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t))))) We verify that the mapping in Segal-equiv-horn-restriction A is-segal-A is exactly horn-restriction A . #def test-equiv-horn-restriction-is-segal ( A : U) ( is-segal-A : is-segal A) : ( first (equiv-horn-restriction-is-segal A is-segal-A)) = (horn-restriction A) := refl Segal types are types that are local at the horn inclusion #def is-local-horn-inclusion-is-segal ( A : U) ( is-segal-A : is-segal A) : is-local-horn-inclusion A := second (equiv-horn-restriction-is-segal A is-segal-A) Types that are local at the horn inclusion are Segal types #def is-segal-is-local-horn-inclusion ( A : U) ( is-local-horn-inclusion-A : is-local-horn-inclusion A) : is-segal A := \\ x y z f g \u2192 contractible-fibers-is-equiv-projection ( \u039b \u2192 A) ( \\ k \u2192 \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h))) ( second ( equiv-comp ( \u03a3 ( k : \u039b \u2192 A) , \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h))) ( \u0394\u00b2 \u2192 A) ( \u039b \u2192 A) ( inv-equiv ( \u0394\u00b2 \u2192 A) ( \u03a3 ( k : \u039b \u2192 A) , \u03a3 ( h : hom A (k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 ))) , ( hom2 A ( k ( 0\u2082 , 0\u2082 )) (k ( 1\u2082 , 0\u2082 )) (k ( 1\u2082 , 1\u2082 )) ( \\ t \u2192 k (t , 0\u2082 )) ( \\ t \u2192 k ( 1\u2082 , t)) ( h))) ( equiv-horn-restriction A)) ( horn-restriction A , is-local-horn-inclusion-A))) ( horn A x y z f g) We have now proven that both notions of Segal types are logically equivalent. RS17, Theorem 5.5 #def is-segal-iff-is-local-horn-inclusion ( A : U) : iff (is-segal A) (is-local-horn-inclusion A) := (is-local-horn-inclusion-is-segal A , is-segal-is-local-horn-inclusion A)","title":"Characterizing Segal types"},{"location":"simplicial-hott/05-segal-types.rzk/#segal-function-and-extension-types","text":"Using the new characterization of Segal types, we can show that the type of functions or extensions into a family of Segal types is again a Segal type. For instance if \\(X\\) is a type and \\(A : X \u2192 U\\) is such that \\(A x\\) is a Segal type for all \\(x\\) then \\((x : X) \u2192 A x\\) is a Segal type. RS17, Corollary 5.6(i) #def is-segal-function-type uses ( funext ) ( X : U) ( A : X \u2192 U) ( fiberwise-is-segal-A : ( x : X) \u2192 is-local-horn-inclusion (A x)) : is-local-horn-inclusion ( (x : X) \u2192 A x) := is-equiv-triple-comp ( \u0394\u00b2 \u2192 ((x : X) \u2192 A x)) ( (x : X) \u2192 \u0394\u00b2 \u2192 A x) ( (x : X) \u2192 \u039b \u2192 A x) ( \u039b \u2192 ((x : X) \u2192 A x)) ( \\ g x t \u2192 g t x) -- first equivalence ( second (flip-ext-fun ( 2 \u00d7 2 ) ( \u0394\u00b2) ( \\ t \u2192 BOT ) ( X) ( \\ t \u2192 A) ( \\ t \u2192 recBOT ))) ( \\ h x t \u2192 h x t) -- second equivalence ( second (equiv-function-equiv-family ( funext) ( X) ( \\ x \u2192 (\u0394\u00b2 \u2192 A x)) ( \\ x \u2192 (\u039b \u2192 A x)) ( \\ x \u2192 (horn-restriction (A x) , fiberwise-is-segal-A x)))) ( \\ h t x \u2192 (h x) t) -- third equivalence ( second (flip-ext-fun-inv ( 2 \u00d7 2 ) ( \u039b) ( \\ t \u2192 BOT ) ( X) ( \\ t \u2192 A) ( \\ t \u2192 recBOT ))) If \\(X\\) is a shape and \\(A : X \u2192 U\\) is such that \\(A x\\) is a Segal type for all \\(x\\) then \\((x : X) \u2192 A x\\) is a Segal type. RS17, Corollary 5.6(ii) #def is-segal-extension-type' uses ( extext ) ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( A : \u03c8 \u2192 U) ( fiberwise-is-segal-A : ( s : \u03c8) \u2192 is-local-horn-inclusion (A s)) : is-local-horn-inclusion ( (s : \u03c8) \u2192 A s) := is-equiv-triple-comp ( \u0394\u00b2 \u2192 (s : \u03c8) \u2192 A s) ( (s : \u03c8) \u2192 \u0394\u00b2 \u2192 A s) ( (s : \u03c8) \u2192 \u039b \u2192 A s) ( \u039b \u2192 (s : \u03c8) \u2192 A s) ( \\ g s t \u2192 g t s) -- first equivalence ( second ( fubini ( 2 \u00d7 2 ) ( I) ( \u0394\u00b2) ( \\ t \u2192 BOT ) ( \u03c8) ( \\ s \u2192 BOT ) ( \\ t s \u2192 A s) ( \\ u \u2192 recBOT ))) ( \\ h s t \u2192 h s t) -- second equivalence ( second (equiv-extension-equiv-family extext I \u03c8 ( \\ s \u2192 \u0394\u00b2 \u2192 A s) ( \\ s \u2192 \u039b \u2192 A s) ( \\ s \u2192 (horn-restriction (A s) , fiberwise-is-segal-A s)))) ( \\ h t s \u2192 (h s) t) -- third equivalence ( second ( fubini ( I) ( 2 \u00d7 2 ) ( \u03c8) ( \\ s \u2192 BOT ) ( \u039b) ( \\ t \u2192 BOT ) ( \\ s t \u2192 A s) ( \\ u \u2192 recBOT ))) #def is-segal-extension-type uses ( extext ) ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( A : \u03c8 \u2192 U) ( fiberwise-is-segal-A : ( s : \u03c8) \u2192 is-segal (A s)) : is-segal ( (s : \u03c8) \u2192 A s) := is-segal-is-local-horn-inclusion ( (s : \u03c8) \u2192 A s) ( is-segal-extension-type' ( I) (\u03c8) (A) ( \\ s \u2192 is-local-horn-inclusion-is-segal (A s) (fiberwise-is-segal-A s))) In particular, the arrow type of a Segal type is Segal. First, we define the arrow type: #def arr ( A : U) : U := \u0394\u00b9 \u2192 A For later use, an equivalent characterization of the arrow type. #def arr-\u03a3-hom ( A : U) : ( arr A) \u2192 ( \u03a3 (x : A) , ( \u03a3 (y : A) , hom A x y)) := \\ f \u2192 (f 0\u2082 , (f 1\u2082 , f)) #def is-equiv-arr-\u03a3-hom ( A : U) : is-equiv (arr A) ( \u03a3 (x : A) , ( \u03a3 (y : A) , hom A x y)) (arr-\u03a3-hom A) := ( ( \\ (x , (y , f)) \u2192 f , \\ f \u2192 refl ) , ( \\ (x , (y , f)) \u2192 f , \\ xyf \u2192 refl )) #def equiv-arr-\u03a3-hom ( A : U) : Equiv (arr A) ( \u03a3 (x : A) , ( \u03a3 (y : A) , hom A x y)) := ( arr-\u03a3-hom A , is-equiv-arr-\u03a3-hom A) RS17, Corollary 5.6(ii), special case for locality at the horn inclusion #def is-local-horn-inclusion-arr uses ( extext ) ( A : U) ( is-segal-A : is-local-horn-inclusion A) : is-local-horn-inclusion (arr A) := is-segal-extension-type' ( 2 ) ( \u0394\u00b9) ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A) RS17, Corollary 5.6(ii), special case for the Segal condition #def is-segal-arr uses ( extext ) ( A : U) ( is-segal-A : is-segal A) : is-segal (arr A) := is-segal-extension-type ( 2 ) ( \u0394\u00b9) ( \\ _ \u2192 A) ( \\ _ \u2192 is-segal-A)","title":"Segal function and extension types"},{"location":"simplicial-hott/05-segal-types.rzk/#identity","text":"All types have identity arrows and witnesses to the identity composition law. x x x RS17, Definition 5.7 #def id-hom ( A : U) ( x : A) : hom A x x := \\ t \u2192 x Witness for the right identity law: x y y f y f f RS17, Proposition 5.8a #def comp-id-witness ( A : U) ( x y : A) ( f : hom A x y) : hom2 A x y y f (id-hom A y) f := \\ (t , s) \u2192 f t Witness for the left identity law: x x y x f f f RS17, Proposition 5.8b #def id-comp-witness ( A : U) ( x y : A) ( f : hom A x y) : hom2 A x x y (id-hom A x) f f := \\ (t , s) \u2192 f s In a Segal type, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. Thus, an identity axiom was not needed in the definition of Segal types. If A is Segal then the right unit law holds #def comp-id-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : ( comp-is-segal A is-segal-A x y y f (id-hom A y)) = f := uniqueness-comp-is-segal ( A) ( is-segal-A) ( x) (y) (y) ( f) ( id-hom A y) ( f) ( comp-id-witness A x y f) If A is Segal then the left unit law holds #def id-comp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : (comp-is-segal A is-segal-A x x y (id-hom A x) f) =_{hom A x y} f := uniqueness-comp-is-segal ( A) ( is-segal-A) ( x) (x) (y) ( id-hom A x) ( f) ( f) ( id-comp-witness A x y f)","title":"Identity"},{"location":"simplicial-hott/05-segal-types.rzk/#associativity","text":"We now prove that composition in a Segal type is associative, by using the fact that the type of arrows in a Segal type is itself a Segal type. \u2022 \u2022 \u2022 \u2022 #def unfolding-square ( A : U) ( triangle : \u0394\u00b2 \u2192 A) : \u0394\u00b9\u00d7\u0394\u00b9 \u2192 A := \\ (t , s) \u2192 recOR ( t \u2264 s \u21a6 triangle (s , t) , s \u2264 t \u21a6 triangle (t , s)) For use in the proof of associativity: x y z y f g comp-is-segal g f #def witness-square-comp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : \u0394\u00b9\u00d7\u0394\u00b9 \u2192 A := unfolding-square A (witness-comp-is-segal A is-segal-A x y z f g) The witness-square-comp-is-segal as an arrow in the arrow type: x y z y f g #def arr-in-arr-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : hom (arr A) f g := \\ t s \u2192 witness-square-comp-is-segal A is-segal-A x y z f g (t , s) w x x y y z f g h #def witness-asociative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : hom2 (arr A) f g h (arr-in-arr-is-segal A is-segal-A w x y f g) (arr-in-arr-is-segal A is-segal-A x y z g h) (comp-is-segal (arr A) (is-segal-arr A is-segal-A) f g h (arr-in-arr-is-segal A is-segal-A w x y f g) (arr-in-arr-is-segal A is-segal-A x y z g h)) := witness-comp-is-segal ( arr A) ( is-segal-arr A is-segal-A) f g h ( arr-in-arr-is-segal A is-segal-A w x y f g) ( arr-in-arr-is-segal A is-segal-A x y z g h) w x y z g f h The witness-associative-is-segal curries to define a diagram \\(\u0394\u00b2\u00d7\u0394\u00b9 \u2192 A\\) . The tetrahedron-associative-is-segal is extracted via the middle-simplex map \\(((t , s) , r) \u21a6 ((t , r) , s)\\) from \\(\u0394\u00b3\\) to \\(\u0394\u00b2\u00d7\u0394\u00b9\\) . #def tetrahedron-associative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : \u0394\u00b3 \u2192 A := \\ ((t , s) , r) \u2192 (witness-asociative-is-segal A is-segal-A w x y z f g h) (t , r) s w x y z g f h The diagonal composite of three arrows extracted from the tetrahedron-associative-is-segal . #def triple-comp-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : hom A w z := \\ t \u2192 tetrahedron-associative-is-segal A is-segal-A w x y z f g h ( (t , t) , t) w x y z g f h #def left-witness-asociative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : hom2 A w y z (comp-is-segal A is-segal-A w x y f g) h (triple-comp-is-segal A is-segal-A w x y z f g h) := \\ (t , s) \u2192 tetrahedron-associative-is-segal A is-segal-A w x y z f g h ( (t , t) , s) The front face: w x y z g f h #def right-witness-asociative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : hom2 A w x z ( f) ( comp-is-segal A is-segal-A x y z g h) ( triple-comp-is-segal A is-segal-A w x y z f g h) := \\ (t , s) \u2192 tetrahedron-associative-is-segal A is-segal-A w x y z f g h ( (t , s) , s) #def left-associative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : ( comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h) = ( triple-comp-is-segal A is-segal-A w x y z f g h) := uniqueness-comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h ( triple-comp-is-segal A is-segal-A w x y z f g h) ( left-witness-asociative-is-segal A is-segal-A w x y z f g h) #def right-associative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : ( comp-is-segal A is-segal-A w x z f (comp-is-segal A is-segal-A x y z g h)) = ( triple-comp-is-segal A is-segal-A w x y z f g h) := uniqueness-comp-is-segal ( A) (is-segal-A) (w) (x) (z) (f) (comp-is-segal A is-segal-A x y z g h) ( triple-comp-is-segal A is-segal-A w x y z f g h) ( right-witness-asociative-is-segal A is-segal-A w x y z f g h) We conclude that Segal composition is associative. RS17, Proposition 5.9 #def associative-is-segal uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( w x y z : A) ( f : hom A w x) ( g : hom A x y) ( h : hom A y z) : ( comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h) = ( comp-is-segal A is-segal-A w x z f (comp-is-segal A is-segal-A x y z g h)) := zig-zag-concat ( hom A w z) ( comp-is-segal A is-segal-A w y z (comp-is-segal A is-segal-A w x y f g) h) ( triple-comp-is-segal A is-segal-A w x y z f g h) ( comp-is-segal A is-segal-A w x z f (comp-is-segal A is-segal-A x y z g h)) ( left-associative-is-segal A is-segal-A w x y z f g h) ( right-associative-is-segal A is-segal-A w x y z f g h) #def postcomp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : ( z : A) \u2192 (hom A z x) \u2192 (hom A z y) := \\ z g \u2192 comp-is-segal A is-segal-A z x y g f #def precomp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : ( z : A) \u2192 (hom A y z) \u2192 (hom A x z) := \\ z \u2192 comp-is-segal A is-segal-A x y z f","title":"Associativity"},{"location":"simplicial-hott/05-segal-types.rzk/#homotopies","text":"We may define a \"homotopy\" to be a path between parallel arrows. In a Segal type, homotopies are equivalent to terms in hom2 types involving an identity arrow. #def map-hom2-homotopy ( A : U) ( x y : A) ( f g : hom A x y) : (f = g) \u2192 (hom2 A x x y (id-hom A x) f g) := ind-path ( hom A x y) ( f) ( \\ g' p' \u2192 (hom2 A x x y (id-hom A x) f g')) ( id-comp-witness A x y f) ( g) #def map-total-hom2-homotopy ( A : U) ( x y : A) ( f : hom A x y) : ( \u03a3 (g : hom A x y) , (f = g)) \u2192 ( \u03a3 (g : hom A x y) , (hom2 A x x y (id-hom A x) f g)) := \\ (g , p) \u2192 (g , map-hom2-homotopy A x y f g p) #def is-equiv-map-total-hom2-homotopy-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : is-equiv ( \u03a3 (g : hom A x y) , f = g) ( \u03a3 (g : hom A x y) , (hom2 A x x y (id-hom A x) f g)) ( map-total-hom2-homotopy A x y f) := is-equiv-are-contr ( \u03a3 (g : hom A x y) , (f = g)) ( \u03a3 (g : hom A x y) , (hom2 A x x y (id-hom A x) f g)) ( is-contr-based-paths (hom A x y) f) ( is-segal-A x x y (id-hom A x) f) ( map-total-hom2-homotopy A x y f) RS17, Proposition 5.10 #def equiv-homotopy-hom2-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f h : hom A x y) : Equiv (f = h) (hom2 A x x y (id-hom A x) f h) := ( ( map-hom2-homotopy A x y f h) , ( total-equiv-family-of-equiv ( hom A x y) ( \\ k \u2192 (f = k)) ( \\ k \u2192 (hom2 A x x y (id-hom A x) f k)) ( map-hom2-homotopy A x y f) ( is-equiv-map-total-hom2-homotopy-is-segal A is-segal-A x y f) ( h))) A dual notion of homotopy can be defined similarly. #def map-hom2-homotopy' ( A : U) ( x y : A) ( f g : hom A x y) ( p : f = g) : (hom2 A x y y f (id-hom A y) g) := ind-path ( hom A x y) ( f) ( \\ g' p' \u2192 (hom2 A x y y f (id-hom A y) g')) ( comp-id-witness A x y f) ( g) ( p) #def map-total-hom2-homotopy' ( A : U) ( x y : A) ( f : hom A x y) : ( \u03a3 (g : hom A x y) , (f = g)) \u2192 ( \u03a3 (g : hom A x y) , (hom2 A x y y f (id-hom A y) g)) := \\ (g , p) \u2192 (g , map-hom2-homotopy' A x y f g p) #def is-equiv-map-total-hom2-homotopy'-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : is-equiv ( \u03a3 (g : hom A x y) , f = g) ( \u03a3 (g : hom A x y) , (hom2 A x y y f (id-hom A y) g)) ( map-total-hom2-homotopy' A x y f) := is-equiv-are-contr ( \u03a3 (g : hom A x y) , (f = g)) ( \u03a3 (g : hom A x y) , (hom2 A x y y f (id-hom A y) g)) ( is-contr-based-paths (hom A x y) f) ( is-segal-A x y y f (id-hom A y)) ( map-total-hom2-homotopy' A x y f) RS17, Proposition 5.10 #def equiv-homotopy-hom2'-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f h : hom A x y) : Equiv (f = h) (hom2 A x y y f (id-hom A y) h) := ( ( map-hom2-homotopy' A x y f h) , ( total-equiv-family-of-equiv ( hom A x y) ( \\ k \u2192 (f = k)) ( \\ k \u2192 (hom2 A x y y f (id-hom A y) k)) ( map-hom2-homotopy' A x y f) ( is-equiv-map-total-hom2-homotopy'-is-segal A is-segal-A x y f) ( h))) More generally, a homotopy between a composite and another map is equivalent to the data provided by a commutative triangle with that boundary. #def map-hom2-eq-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) ( p : (comp-is-segal A is-segal-A x y z f g) = h) : ( hom2 A x y z f g h) := ind-path ( hom A x z) ( comp-is-segal A is-segal-A x y z f g) ( \\ h' p' \u2192 hom2 A x y z f g h') ( witness-comp-is-segal A is-segal-A x y z f g) ( h) ( p) #def map-total-hom2-eq-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : ( \u03a3 (h : hom A x z) , (comp-is-segal A is-segal-A x y z f g) = h) \u2192 ( \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) := \\ (h , p) \u2192 (h , map-hom2-eq-is-segal A is-segal-A x y z f g h p) #def is-equiv-map-total-hom2-eq-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : is-equiv ( \u03a3 (h : hom A x z) , (comp-is-segal A is-segal-A x y z f g) = h) ( \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) ( map-total-hom2-eq-is-segal A is-segal-A x y z f g) := is-equiv-are-contr ( \u03a3 (h : hom A x z) , (comp-is-segal A is-segal-A x y z f g) = h) ( \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) ( is-contr-based-paths (hom A x z) (comp-is-segal A is-segal-A x y z f g)) ( is-segal-A x y z f g) ( map-total-hom2-eq-is-segal A is-segal-A x y z f g) RS17, Proposition 5.12 #def equiv-hom2-eq-comp-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( k : hom A x z) : Equiv ((comp-is-segal A is-segal-A x y z f g) = k) (hom2 A x y z f g k) := ( ( map-hom2-eq-is-segal A is-segal-A x y z f g k) , ( total-equiv-family-of-equiv ( hom A x z) ( \\ m \u2192 (comp-is-segal A is-segal-A x y z f g) = m) ( hom2 A x y z f g) ( map-hom2-eq-is-segal A is-segal-A x y z f g) ( is-equiv-map-total-hom2-eq-is-segal A is-segal-A x y z f g) ( k))) Homotopies form a congruence, meaning that homotopies are respected by composition: RS17, Proposition 5.13 #def congruence-homotopy-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f g : hom A x y) ( h k : hom A y z) ( p : f = g) ( q : h = k) : ( comp-is-segal A is-segal-A x y z f h) = ( comp-is-segal A is-segal-A x y z g k) := ind-path ( hom A y z) ( h) ( \\ k' q' \u2192 ( comp-is-segal A is-segal-A x y z f h) = ( comp-is-segal A is-segal-A x y z g k')) ( ind-path ( hom A x y) ( f) ( \\ g' p' \u2192 ( comp-is-segal A is-segal-A x y z f h) = ( comp-is-segal A is-segal-A x y z g' h)) ( refl ) ( g) ( p)) ( k) ( q) As a special case of the above: #def postwhisker-homotopy-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f g : hom A x y) ( h : hom A y z) ( p : f = g) : ( comp-is-segal A is-segal-A x y z f h) = (comp-is-segal A is-segal-A x y z g h) := congruence-homotopy-is-segal A is-segal-A x y z f g h h p refl As a special case of the above: #def prewhisker-homotopy-is-segal ( A : U) ( is-segal-A : is-segal A) ( w x y : A) ( k : hom A w x) ( f g : hom A x y) ( p : f = g) : ( comp-is-segal A is-segal-A w x y k f) = ( comp-is-segal A is-segal-A w x y k g) := congruence-homotopy-is-segal A is-segal-A w x y k k f g refl p RS17, Proposition 5.14(a) #def compute-postwhisker-homotopy-is-segal ( A : U) ( is-segal-A : is-segal A) ( x y z : A) ( f g : hom A x y) ( h : hom A y z) ( p : f = g) : ( postwhisker-homotopy-is-segal A is-segal-A x y z f g h p) = ( ap (hom A x y) (hom A x z) f g ( \\ k \u2192 comp-is-segal A is-segal-A x y z k h) p) := ind-path ( hom A x y) ( f) ( \\ g' p' \u2192 ( postwhisker-homotopy-is-segal A is-segal-A x y z f g' h p') = ( ap (hom A x y) (hom A x z) (f) (g') ( \\ k \u2192 comp-is-segal A is-segal-A x y z k h) (p'))) ( refl ) ( g) ( p) RS17, Proposition 5.14(b) #def prewhisker-homotopy-is-ap-is-segal ( A : U) ( is-segal-A : is-segal A) ( w x y : A) ( k : hom A w x) ( f g : hom A x y) ( p : f = g) : ( prewhisker-homotopy-is-segal A is-segal-A w x y k f g p) = ( ap (hom A x y) (hom A w y) f g (comp-is-segal A is-segal-A w x y k) p) := ind-path ( hom A x y) ( f) ( \\ g' p' \u2192 ( prewhisker-homotopy-is-segal A is-segal-A w x y k f g' p') = ( ap (hom A x y) (hom A w y) f g' (comp-is-segal A is-segal-A w x y k) p')) ( refl ) ( g) ( p) #section is-segal-Unit #def is-contr-Unit : is-contr Unit := ( unit , \\ _ \u2192 refl ) #def is-contr-\u0394\u00b2\u2192Unit uses ( extext ) : is-contr (\u0394\u00b2 \u2192 Unit) := ( \\ _ \u2192 unit , \\ k \u2192 eq-ext-htpy extext ( 2 \u00d7 2 ) \u0394\u00b2 ( \\ _ \u2192 BOT ) ( \\ _ \u2192 Unit) ( \\ _ \u2192 recBOT ) ( \\ _ \u2192 unit ) k ( \\ _ \u2192 refl )) #def is-segal-Unit uses ( extext ) : is-segal Unit := \\ x y z f g \u2192 is-contr-is-retract-of-is-contr ( \u03a3 (h : hom Unit x z) , (hom2 Unit x y z f g h)) ( \u0394\u00b2 \u2192 Unit) ( ( \\ (_ , k) \u2192 k) , ( \\ k \u2192 (( \\ t \u2192 k (t , t)) , k) , \\ _ \u2192 refl )) ( is-contr-\u0394\u00b2\u2192 Unit ) #end is-segal-Unit @import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap); text, textPath { font-family: Noto Serif; font-size: 20px; dominant-baseline: middle; text-anchor: middle; }","title":"Homotopies"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/","text":"The 2-category of Segal types \u00b6 These formalisations correspond to Section 6 of the RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types. Some of the definitions in this file rely on extension extensionality: #assume extext : ExtExt Functors \u00b6 Functions between types induce an action on hom types, preserving sources and targets. The action is called ap-hom to avoid conflicting with ap . RS17, Section 6.1 #def ap-hom ( A B : U) ( F : A \u2192 B) ( x y : A) ( f : hom A x y) : hom B (F x) (F y) := \\ t \u2192 F (f t) #def ap-hom2 ( A B : U) ( F : A \u2192 B) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) ( \u03b1 : hom2 A x y z f g h) : hom2 B (F x) (F y) (F z) ( ap-hom A B F x y f) (ap-hom A B F y z g) (ap-hom A B F x z h) := \\ t \u2192 F (\u03b1 t) Functions between types automatically preserve identity arrows. Preservation of identities follows from extension extensionality because these arrows are pointwise equal. RS17, Proposition 6.1.a #def functors-pres-id uses ( extext ) ( A B : U) ( F : A \u2192 B) ( x : A) : ( ap-hom A B F x x (id-hom A x)) = (id-hom B (F x)) := eq-ext-htpy ( extext) ( 2 ) ( \u0394\u00b9) ( \u2202\u0394\u00b9) ( \\ t \u2192 B) ( \\ t \u2192 recOR (t \u2261 0\u2082 \u21a6 F x , t \u2261 1\u2082 \u21a6 F x)) ( ap-hom A B F x x (id-hom A x)) ( id-hom B (F x)) ( \\ t \u2192 refl ) Preservation of composition requires the Segal hypothesis. RS17, Proposition 6.1.b #def functors-pres-comp ( A B : U) ( is-segal-A : is-segal A) ( is-segal-B : is-segal B) ( F : A \u2192 B) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : ( comp-is-segal B is-segal-B ( F x) (F y) (F z) ( ap-hom A B F x y f) ( ap-hom A B F y z g)) = ( ap-hom A B F x z (comp-is-segal A is-segal-A x y z f g)) := uniqueness-comp-is-segal B is-segal-B ( F x) (F y) (F z) ( ap-hom A B F x y f) ( ap-hom A B F y z g) ( ap-hom A B F x z (comp-is-segal A is-segal-A x y z f g)) ( ap-hom2 A B F x y z f g ( comp-is-segal A is-segal-A x y z f g) ( witness-comp-is-segal A is-segal-A x y z f g)) Natural transformations \u00b6 Given two simplicial maps f g : ( x : A) \u2192 B x , a natural transformation from f to g is an arrow \u03b7 : hom ( (x : A) \u2192 B x) f g between them. RS17, Definition 6.2 #def nat-trans ( A : U) ( B : A \u2192 U) ( f g : ( x : A) \u2192 (B x)) : U := hom ( (x : A) \u2192 (B x)) f g Equivalently , natural transformations can be determined by their components , i.e. as a family of arrows ( x : A) \u2192 hom (B x) (f x) (g x) . #def nat-trans-components ( A : U) ( B : A \u2192 U) ( f g : ( x : A) \u2192 (B x)) : U := ( x : A) \u2192 hom (B x) (f x) (g x) #def ev-components-nat-trans ( A : U) ( B : A \u2192 U) ( f g : ( x : A) \u2192 (B x)) ( \u03b7 : nat-trans A B f g) : nat-trans-components A B f g := \\ x t \u2192 \u03b7 t x #def nat-trans-nat-trans-components ( A : U) ( B : A \u2192 U) ( f g : ( x : A) \u2192 (B x)) ( \u03b7 : nat-trans-components A B f g) : nat-trans A B f g := \\ t x \u2192 \u03b7 x t Natural transformation extensionality \u00b6 RS17, Proposition 6.3 #def is-equiv-ev-components-nat-trans ( A : U) ( B : A \u2192 U) ( f g : ( x : A) \u2192 (B x)) : is-equiv ( nat-trans A B f g) ( nat-trans-components A B f g) ( ev-components-nat-trans A B f g) := ( ( \\ \u03b7 t x \u2192 \u03b7 x t , \\ _ \u2192 refl ) , ( \\ \u03b7 t x \u2192 \u03b7 x t , \\ _ \u2192 refl )) #def equiv-components-nat-trans ( A : U) ( B : A \u2192 U) ( f g : ( x : A) \u2192 (B x)) : Equiv (nat-trans A B f g) (nat-trans-components A B f g) := ( ev-components-nat-trans A B f g , is-equiv-ev-components-nat-trans A B f g) Horizontal composition \u00b6 Horizontal composition of natural transformations makes sense over any type. In particular , contrary to what is written in [RS17] we do not need C to be Segal. #def horizontal-comp-nat-trans ( A B C : U) ( f g : A \u2192 B) ( f' g' : B \u2192 C) ( \u03b7 : nat-trans A ( \\ _ \u2192 B) f g) ( \u03b7' : nat-trans B ( \\ _ \u2192 C) f' g') : nat-trans A ( \\ _ \u2192 C) ( \\ x \u2192 f' (f x)) ( \\ x \u2192 g' (g x)) := \\ t x \u2192 \u03b7' t (\u03b7 t x) #def horizontal-comp-nat-trans-components ( A B C : U) ( f g : A \u2192 B) ( f' g' : B \u2192 C) ( \u03b7 : nat-trans-components A ( \\ _ \u2192 B) f g) ( \u03b7' : nat-trans-components B ( \\ _ \u2192 C) f' g') : nat-trans-components A ( \\ _ \u2192 C) ( \\ x \u2192 f' (f x)) ( \\ x \u2192 g' (g x)) := \\ x t \u2192 \u03b7' (\u03b7 x t) t Vertical composition \u00b6 We can define vertical composition for natural transformations in families of Segal types. #def vertical-comp-nat-trans-components ( A : U) ( B : A \u2192 U) ( is-segal-B : ( x : A) \u2192 is-segal (B x)) ( f g h : ( x : A) \u2192 (B x)) ( \u03b7 : nat-trans-components A B f g) ( \u03b7' : nat-trans-components A B g h) : nat-trans-components A B f h := \\ x \u2192 comp-is-segal (B x) (is-segal-B x) (f x) (g x) (h x) (\u03b7 x) (\u03b7' x) #def vertical-comp-nat-trans ( A : U) ( B : A \u2192 U) ( is-segal-B : ( x : A) \u2192 is-segal (B x)) ( f g h : ( x : A) \u2192 (B x)) ( \u03b7 : nat-trans A B f g) ( \u03b7' : nat-trans A B g h) : nat-trans A B f h := \\ t x \u2192 vertical-comp-nat-trans-components A B is-segal-B f g h ( \\ x' t' \u2192 \u03b7 t' x') ( \\ x' t' \u2192 \u03b7' t' x') ( x) ( t) The identity natural transformation is identity arrows on components RS17, Proposition 6.5(ii) #def id-arr-components-id-nat-trans ( A : U) ( B : A \u2192 U) ( f : ( x : A) \u2192 (B x)) ( a : A) : ( \\ t \u2192 id-hom ((x : A) \u2192 B x) f t a) =_{\u0394\u00b9 \u2192 B a} id-hom (B a) (f a) := refl","title":"2-Category of Segal Types"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#the-2-category-of-segal-types","text":"These formalisations correspond to Section 6 of the RS17 paper. This is a literate rzk file: #lang rzk-1","title":"The 2-category of Segal types"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#prerequisites","text":"3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types. Some of the definitions in this file rely on extension extensionality: #assume extext : ExtExt","title":"Prerequisites"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#functors","text":"Functions between types induce an action on hom types, preserving sources and targets. The action is called ap-hom to avoid conflicting with ap . RS17, Section 6.1 #def ap-hom ( A B : U) ( F : A \u2192 B) ( x y : A) ( f : hom A x y) : hom B (F x) (F y) := \\ t \u2192 F (f t) #def ap-hom2 ( A B : U) ( F : A \u2192 B) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) ( \u03b1 : hom2 A x y z f g h) : hom2 B (F x) (F y) (F z) ( ap-hom A B F x y f) (ap-hom A B F y z g) (ap-hom A B F x z h) := \\ t \u2192 F (\u03b1 t) Functions between types automatically preserve identity arrows. Preservation of identities follows from extension extensionality because these arrows are pointwise equal. RS17, Proposition 6.1.a #def functors-pres-id uses ( extext ) ( A B : U) ( F : A \u2192 B) ( x : A) : ( ap-hom A B F x x (id-hom A x)) = (id-hom B (F x)) := eq-ext-htpy ( extext) ( 2 ) ( \u0394\u00b9) ( \u2202\u0394\u00b9) ( \\ t \u2192 B) ( \\ t \u2192 recOR (t \u2261 0\u2082 \u21a6 F x , t \u2261 1\u2082 \u21a6 F x)) ( ap-hom A B F x x (id-hom A x)) ( id-hom B (F x)) ( \\ t \u2192 refl ) Preservation of composition requires the Segal hypothesis. RS17, Proposition 6.1.b #def functors-pres-comp ( A B : U) ( is-segal-A : is-segal A) ( is-segal-B : is-segal B) ( F : A \u2192 B) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : ( comp-is-segal B is-segal-B ( F x) (F y) (F z) ( ap-hom A B F x y f) ( ap-hom A B F y z g)) = ( ap-hom A B F x z (comp-is-segal A is-segal-A x y z f g)) := uniqueness-comp-is-segal B is-segal-B ( F x) (F y) (F z) ( ap-hom A B F x y f) ( ap-hom A B F y z g) ( ap-hom A B F x z (comp-is-segal A is-segal-A x y z f g)) ( ap-hom2 A B F x y z f g ( comp-is-segal A is-segal-A x y z f g) ( witness-comp-is-segal A is-segal-A x y z f g))","title":"Functors"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#natural-transformations","text":"Given two simplicial maps f g : ( x : A) \u2192 B x , a natural transformation from f to g is an arrow \u03b7 : hom ( (x : A) \u2192 B x) f g between them. RS17, Definition 6.2 #def nat-trans ( A : U) ( B : A \u2192 U) ( f g : ( x : A) \u2192 (B x)) : U := hom ( (x : A) \u2192 (B x)) f g Equivalently , natural transformations can be determined by their components , i.e. as a family of arrows ( x : A) \u2192 hom (B x) (f x) (g x) . #def nat-trans-components ( A : U) ( B : A \u2192 U) ( f g : ( x : A) \u2192 (B x)) : U := ( x : A) \u2192 hom (B x) (f x) (g x) #def ev-components-nat-trans ( A : U) ( B : A \u2192 U) ( f g : ( x : A) \u2192 (B x)) ( \u03b7 : nat-trans A B f g) : nat-trans-components A B f g := \\ x t \u2192 \u03b7 t x #def nat-trans-nat-trans-components ( A : U) ( B : A \u2192 U) ( f g : ( x : A) \u2192 (B x)) ( \u03b7 : nat-trans-components A B f g) : nat-trans A B f g := \\ t x \u2192 \u03b7 x t","title":"Natural transformations"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#natural-transformation-extensionality","text":"RS17, Proposition 6.3 #def is-equiv-ev-components-nat-trans ( A : U) ( B : A \u2192 U) ( f g : ( x : A) \u2192 (B x)) : is-equiv ( nat-trans A B f g) ( nat-trans-components A B f g) ( ev-components-nat-trans A B f g) := ( ( \\ \u03b7 t x \u2192 \u03b7 x t , \\ _ \u2192 refl ) , ( \\ \u03b7 t x \u2192 \u03b7 x t , \\ _ \u2192 refl )) #def equiv-components-nat-trans ( A : U) ( B : A \u2192 U) ( f g : ( x : A) \u2192 (B x)) : Equiv (nat-trans A B f g) (nat-trans-components A B f g) := ( ev-components-nat-trans A B f g , is-equiv-ev-components-nat-trans A B f g)","title":"Natural transformation extensionality"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#horizontal-composition","text":"Horizontal composition of natural transformations makes sense over any type. In particular , contrary to what is written in [RS17] we do not need C to be Segal. #def horizontal-comp-nat-trans ( A B C : U) ( f g : A \u2192 B) ( f' g' : B \u2192 C) ( \u03b7 : nat-trans A ( \\ _ \u2192 B) f g) ( \u03b7' : nat-trans B ( \\ _ \u2192 C) f' g') : nat-trans A ( \\ _ \u2192 C) ( \\ x \u2192 f' (f x)) ( \\ x \u2192 g' (g x)) := \\ t x \u2192 \u03b7' t (\u03b7 t x) #def horizontal-comp-nat-trans-components ( A B C : U) ( f g : A \u2192 B) ( f' g' : B \u2192 C) ( \u03b7 : nat-trans-components A ( \\ _ \u2192 B) f g) ( \u03b7' : nat-trans-components B ( \\ _ \u2192 C) f' g') : nat-trans-components A ( \\ _ \u2192 C) ( \\ x \u2192 f' (f x)) ( \\ x \u2192 g' (g x)) := \\ x t \u2192 \u03b7' (\u03b7 x t) t","title":"Horizontal composition"},{"location":"simplicial-hott/06-2cat-of-segal-types.rzk/#vertical-composition","text":"We can define vertical composition for natural transformations in families of Segal types. #def vertical-comp-nat-trans-components ( A : U) ( B : A \u2192 U) ( is-segal-B : ( x : A) \u2192 is-segal (B x)) ( f g h : ( x : A) \u2192 (B x)) ( \u03b7 : nat-trans-components A B f g) ( \u03b7' : nat-trans-components A B g h) : nat-trans-components A B f h := \\ x \u2192 comp-is-segal (B x) (is-segal-B x) (f x) (g x) (h x) (\u03b7 x) (\u03b7' x) #def vertical-comp-nat-trans ( A : U) ( B : A \u2192 U) ( is-segal-B : ( x : A) \u2192 is-segal (B x)) ( f g h : ( x : A) \u2192 (B x)) ( \u03b7 : nat-trans A B f g) ( \u03b7' : nat-trans A B g h) : nat-trans A B f h := \\ t x \u2192 vertical-comp-nat-trans-components A B is-segal-B f g h ( \\ x' t' \u2192 \u03b7 t' x') ( \\ x' t' \u2192 \u03b7' t' x') ( x) ( t) The identity natural transformation is identity arrows on components RS17, Proposition 6.5(ii) #def id-arr-components-id-nat-trans ( A : U) ( B : A \u2192 U) ( f : ( x : A) \u2192 (B x)) ( a : A) : ( \\ t \u2192 id-hom ((x : A) \u2192 B x) f t a) =_{\u0394\u00b9 \u2192 B a} id-hom (B a) (f a) := refl","title":"Vertical composition"},{"location":"simplicial-hott/07-discrete.rzk/","text":"Discrete types \u00b6 These formalisations correspond to Section 7 of the RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 hott/1-paths.md - We require basic path algebra. hott/4-equivalences.md - We require the notion of equivalence between types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types. Some of the definitions in this file rely on function extensionality and extension extensionality: #assume funext : FunExt #assume extext : ExtExt The definition \u00b6 Discrete types are types in which the hom-types are canonically equivalent to identity types. RS17, Definition 7.1 #def hom-eq ( A : U) ( x y : A) ( p : x = y) : hom A x y := ind-path (A) (x) ( \\ y' p' \u2192 hom A x y') ((id-hom A x)) (y) (p) #def is-discrete ( A : U) : U := ( x : A) \u2192 ( y : A) \u2192 is-equiv (x = y) (hom A x y) (hom-eq A x y) Families of discrete types \u00b6 By function extensionality, the dependent function type associated to a family of discrete types is discrete. #def equiv-hom-eq-function-type-is-discrete uses ( funext ) ( X : U) ( A : X \u2192 U) ( is-discrete-A : ( x : X) \u2192 is-discrete (A x)) ( f g : ( x : X) \u2192 A x) : Equiv (f = g) ( hom ((x : X) \u2192 A x) f g) := equiv-triple-comp ( f = g) ( (x : X) \u2192 f x = g x) ( (x : X) \u2192 hom (A x) (f x) (g x)) ( hom ((x : X) \u2192 A x) f g) ( equiv-FunExt funext X A f g) ( equiv-function-equiv-family funext X ( \\ x \u2192 (f x = g x)) ( \\ x \u2192 hom (A x) (f x) (g x)) ( \\ x \u2192 (hom-eq (A x) (f x) (g x) , (is-discrete-A x (f x) (g x))))) ( flip-ext-fun-inv ( 2 ) ( \u0394\u00b9) ( \u2202\u0394\u00b9) ( X) ( \\ t x \u2192 A x) ( \\ t x \u2192 recOR (t \u2261 0\u2082 \u21a6 f x , t \u2261 1\u2082 \u21a6 g x))) #def compute-hom-eq-function-type-is-discrete uses ( funext ) ( X : U) ( A : X \u2192 U) ( is-discrete-A : ( x : X) \u2192 is-discrete (A x)) ( f g : ( x : X) \u2192 A x) ( h : f = g) : ( hom-eq ((x : X) \u2192 A x) f g h) = ( first (equiv-hom-eq-function-type-is-discrete X A is-discrete-A f g)) h := ind-path ( (x : X) \u2192 A x) ( f) ( \\ g' h' \u2192 hom-eq ((x : X) \u2192 A x) f g' h' = ( first (equiv-hom-eq-function-type-is-discrete X A is-discrete-A f g')) h') ( refl ) ( g) ( h) RS17, Proposition 7.2 #def is-discrete-function-type uses ( funext ) ( X : U) ( A : X \u2192 U) ( is-discrete-A : ( x : X) \u2192 is-discrete (A x)) : is-discrete ( (x : X) \u2192 A x) := \\ f g \u2192 is-equiv-homotopy ( f = g) ( hom ((x : X) \u2192 A x) f g) ( hom-eq ((x : X) \u2192 A x) f g) ( first (equiv-hom-eq-function-type-is-discrete X A is-discrete-A f g)) ( compute-hom-eq-function-type-is-discrete X A is-discrete-A f g) ( second (equiv-hom-eq-function-type-is-discrete X A is-discrete-A f g)) By extension extensionality, an extension type into a family of discrete types is discrete. Since equiv-extension-equiv-family considers total extension types only, extending from BOT , that's all we prove here for now. #def equiv-hom-eq-extension-type-is-discrete uses ( extext ) ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( A : \u03c8 \u2192 U) ( is-discrete-A : ( t : \u03c8) \u2192 is-discrete (A t)) ( f g : ( t : \u03c8) \u2192 A t) : Equiv (f = g) ( hom ((t : \u03c8) \u2192 A t) f g) := equiv-triple-comp ( f = g) ( (t : \u03c8) \u2192 f t = g t) ( (t : \u03c8) \u2192 hom (A t) (f t) (g t)) ( hom ((t : \u03c8) \u2192 A t) f g) ( equiv-ExtExt extext I \u03c8 ( \\ _ \u2192 BOT ) A ( \\ _ \u2192 recBOT ) f g) ( equiv-extension-equiv-family ( extext) ( I) ( \u03c8) ( \\ t \u2192 f t = g t) ( \\ t \u2192 hom (A t) (f t) (g t)) ( \\ t \u2192 (hom-eq (A t) (f t) (g t) , (is-discrete-A t (f t) (g t))))) ( fubini ( I) ( 2 ) ( \u03c8) ( \\ t \u2192 BOT ) ( \u0394\u00b9) ( \u2202\u0394\u00b9) ( \\ t s \u2192 A t) ( \\ (t , s) \u2192 recOR (s \u2261 0\u2082 \u21a6 f t , s \u2261 1\u2082 \u21a6 g t))) #def compute-hom-eq-extension-type-is-discrete uses ( extext ) ( I : CUBE) ( \u03c8 : ( t : I) \u2192 TOPE) ( A : \u03c8 \u2192 U) ( is-discrete-A : ( t : \u03c8) \u2192 is-discrete (A t)) ( f g : ( t : \u03c8) \u2192 A t) ( h : f = g) : ( hom-eq ((t : \u03c8) \u2192 A t) f g h) = ( first (equiv-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g)) h := ind-path ( (t : \u03c8) \u2192 A t) ( f) ( \\ g' h' \u2192 ( hom-eq ((t : \u03c8) \u2192 A t) f g' h') = ( first (equiv-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g') h')) ( refl ) ( g) ( h) RS17, Proposition 7.2, for extension types #def is-discrete-extension-type uses ( extext ) ( I : CUBE) ( \u03c8 : ( t : I) \u2192 TOPE) ( A : \u03c8 \u2192 U) ( is-discrete-A : ( t : \u03c8) \u2192 is-discrete (A t)) : is-discrete ( (t : \u03c8) \u2192 A t) := \\ f g \u2192 is-equiv-homotopy ( f = g) ( hom ((t : \u03c8) \u2192 A t) f g) ( hom-eq ((t : \u03c8) \u2192 A t) f g) ( first (equiv-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g)) ( compute-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g) ( second (equiv-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g)) For instance, the arrow type of a discrete type is discrete. #def is-discrete-arr uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) : is-discrete (arr A) := is-discrete-extension-type 2 \u0394\u00b9 ( \\ _ \u2192 A) ( \\ _ \u2192 is-discrete-A) Discrete types are Segal types \u00b6 Discrete types are automatically Segal types. #section discrete-arr-equivalences #variable A : U #variable is-discrete-A : is-discrete A #variables x y z w : A #variable f : hom A x y #variable g : hom A z w #def is-equiv-hom-eq-discrete uses ( extext x y z w ) : is-equiv (f =_{arr A} g) (hom (arr A) f g) (hom-eq (arr A) f g) := (is-discrete-arr A is-discrete-A) f g #def equiv-hom-eq-discrete uses ( extext x y z w ) : Equiv (f =_{arr A} g) (hom (arr A) f g) := (hom-eq (arr A) f g , (is-discrete-arr A is-discrete-A) f g) #def equiv-square-hom-arr : Equiv ( hom (arr A) f g) ( \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ t \u2261 0\u2082 \u2227 \u0394\u00b9 s \u21a6 f s , t \u2261 1\u2082 \u2227 \u0394\u00b9 s \u21a6 g s , \u0394\u00b9 t \u2227 s \u2261 0\u2082 \u21a6 h t , \u0394\u00b9 t \u2227 s \u2261 1\u2082 \u21a6 k t]))) := ( \\ \u03b1 \u2192 ( ( \\ t \u2192 \u03b1 t 0\u2082 ) , ( ( \\ t \u2192 \u03b1 t 1\u2082 ) , (\\ (t , s) \u2192 \u03b1 t s))) , ( ( ( \\ \u03c3 t s \u2192 ( second ( second \u03c3)) (t , s)) , ( \\ \u03b1 \u2192 refl )) , ( ( \\ \u03c3 t s \u2192 ( second ( second \u03c3)) (t , s)) , ( \\ \u03c3 \u2192 refl )))) The equivalence underlying equiv-arr-\u03a3-hom : #def fibered-arr-free-arr : (arr A) \u2192 ( \u03a3 (u : A) , ( \u03a3 (v : A) , hom A u v)) := \\ k \u2192 (k 0\u2082 , (k 1\u2082 , k)) #def is-equiv-fibered-arr-free-arr : is-equiv (arr A) ( \u03a3 (u : A) , ( \u03a3 (v : A) , hom A u v)) (fibered-arr-free-arr) := is-equiv-arr-\u03a3-hom A #def is-equiv-ap-fibered-arr-free-arr uses ( w x y z ) : is-equiv ( f =_{\u0394\u00b9 \u2192 A} g) ( fibered-arr-free-arr f = fibered-arr-free-arr g) ( ap ( arr A) ( \u03a3 (u : A) , ( \u03a3 (v : A) , (hom A u v))) ( f) ( g) ( fibered-arr-free-arr)) := is-emb-is-equiv ( arr A) ( \u03a3 (u : A) , ( \u03a3 (v : A) , (hom A u v))) ( fibered-arr-free-arr) ( is-equiv-fibered-arr-free-arr) ( f) ( g) #def equiv-eq-fibered-arr-eq-free-arr uses ( w x y z ) : Equiv (f =_{\u0394\u00b9 \u2192 A} g) (fibered-arr-free-arr f = fibered-arr-free-arr g) := equiv-ap-is-equiv ( arr A) ( \u03a3 (u : A) , ( \u03a3 (v : A) , (hom A u v))) ( fibered-arr-free-arr) ( is-equiv-fibered-arr-free-arr) ( f) ( g) #def equiv-sigma-over-product-hom-eq : Equiv ( fibered-arr-free-arr f = fibered-arr-free-arr g) ( \u03a3 ( p : x = z) , ( \u03a3 ( q : y = w) , ( product-transport A A (hom A) x z y w p q f = g))) := extensionality-\u03a3-over-product ( A) (A) ( hom A) ( fibered-arr-free-arr f) ( fibered-arr-free-arr g) #def equiv-square-sigma-over-product uses ( extext is-discrete-A ) : Equiv ( \u03a3 ( p : x = z) , ( \u03a3 (q : y = w) , ( product-transport A A (hom A) x z y w p q f = g))) ( \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ((t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k t]))) := equiv-left-cancel ( f =_{\u0394\u00b9 \u2192 A} g) ( \u03a3 ( p : x = z) , ( \u03a3 ( q : y = w) , ( product-transport A A (hom A) x z y w p q f = g))) ( \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ((t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k t]))) ( equiv-comp ( f =_{\u0394\u00b9 \u2192 A} g) ( fibered-arr-free-arr f = fibered-arr-free-arr g) ( \u03a3 ( p : x = z) , ( \u03a3 ( q : y = w) , ( product-transport A A (hom A) x z y w p q f = g))) equiv-eq-fibered-arr-eq-free-arr equiv-sigma-over-product-hom-eq) ( equiv-comp ( f =_{\u0394\u00b9 \u2192 A} g) ( hom (arr A) f g) ( \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k t]))) ( equiv-hom-eq-discrete) ( equiv-square-hom-arr)) We close the section so we can use path induction. #end discrete-arr-equivalences #def fibered-map-square-sigma-over-product ( A : U) ( x y z w : A) ( f : hom A x y) ( p : x = z) ( q : y = w) : ( g : hom A z w) \u2192 ( product-transport A A (hom A) x z y w p q f = g) \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 (hom-eq A x z p) t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 (hom-eq A y w q) t]) := ind-path ( A) ( x) ( \\ z' p' \u2192 ( g : hom A z' w) \u2192 ( product-transport A A (hom A) x z' y w p' q f = g) \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 (hom-eq A x z' p') t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 (hom-eq A y w q) t])) ( ind-path ( A) ( y) ( \\ w' q' \u2192 ( g : hom A x w') \u2192 ( product-transport A A (hom A) x x y w' refl q' f = g) \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 (hom-eq A y w' q') t])) ( ind-path ( hom A x y) ( f) ( \\ g' \u03c4' \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g' s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) ( \\ (t , s) \u2192 f s)) ( w) ( q)) ( z) ( p) #def square-sigma-over-product ( A : U) ( x y z w : A) ( f : hom A x y) ( g : hom A z w) ( ( p , (q , \u03c4)) : ( \u03a3 ( p : x = z) , ( \u03a3 ( q : y = w) , ( product-transport A A (hom A) x z y w p q f = g)))) : \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k t])) := ( ( hom-eq A x z p) , ( ( hom-eq A y w q) , ( fibered-map-square-sigma-over-product ( A) ( x) (y) (z) (w) ( f) (p) (q) (g) ( \u03c4)))) #def refl-refl-map-equiv-square-sigma-over-product uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y : A) ( f g : hom A x y) ( \u03c4 : product-transport A A (hom A) x x y y refl refl f = g) : ( first ( equiv-square-sigma-over-product A is-discrete-A x y x y f g) ( refl , ( refl , \u03c4))) = ( square-sigma-over-product ( A) ( x) (y) (x) (y) ( f) (g) ( refl , ( refl , \u03c4))) := ind-path ( hom A x y) ( f) ( \\ g' \u03c4' \u2192 ( first ( equiv-square-sigma-over-product A is-discrete-A x y x y f g') ( refl , ( refl , \u03c4'))) = ( square-sigma-over-product ( A) ( x) (y) (x) (y) ( f) (g') ( refl , ( refl , \u03c4')))) ( refl ) ( g) ( \u03c4) #def map-equiv-square-sigma-over-product uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y z w : A) ( f : hom A x y) ( p : x = z) ( q : y = w) : ( g : hom A z w) \u2192 ( \u03c4 : product-transport A A (hom A) x z y w p q f = g) \u2192 ( first ( equiv-square-sigma-over-product A is-discrete-A x y z w f g) ( p , (q , \u03c4))) = ( square-sigma-over-product A x y z w f g (p , (q , \u03c4))) := ind-path ( A) ( y) ( \\ w' q' \u2192 ( g : hom A z w') \u2192 ( \u03c4 : product-transport A A (hom A) x z y w' p q' f = g) \u2192 ( first ( equiv-square-sigma-over-product A is-discrete-A x y z w' f g)) ( p , (q' , \u03c4)) = ( square-sigma-over-product A x y z w' f g) ( p , (q' , \u03c4))) ( ind-path ( A) ( x) ( \\ z' p' \u2192 ( g : hom A z' y) \u2192 ( \u03c4 : product-transport A A (hom A) x z' y y p' refl f = g) \u2192 ( first ( equiv-square-sigma-over-product A is-discrete-A x y z' y f g) ( p' , ( refl , \u03c4))) = ( square-sigma-over-product A x y z' y f g (p' , ( refl , \u03c4)))) ( refl-refl-map-equiv-square-sigma-over-product ( A) (is-discrete-A) (x) (y) (f)) ( z) ( p)) ( w) ( q) #def is-equiv-square-sigma-over-product uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y z w : A) ( f : hom A x y) ( g : hom A z w) : is-equiv ( \u03a3 ( p : x = z) , ( \u03a3 ( q : y = w) , ( product-transport A A (hom A) x z y w p q f = g))) ( \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k t]))) ( square-sigma-over-product A x y z w f g) := is-equiv-rev-homotopy ( \u03a3 ( p : x = z) , ( \u03a3 ( q : y = w) , ( product-transport A A (hom A) x z y w p q f = g))) ( \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k t]))) ( first (equiv-square-sigma-over-product A is-discrete-A x y z w f g)) ( square-sigma-over-product A x y z w f g) ( \\ (p , (q , \u03c4)) \u2192 map-equiv-square-sigma-over-product A is-discrete-A x y z w f p q g \u03c4) ( second (equiv-square-sigma-over-product A is-discrete-A x y z w f g)) #def is-equiv-fibered-map-square-sigma-over-product uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y z w : A) ( f : hom A x y) ( g : hom A z w) ( p : x = z) ( q : y = w) : is-equiv ( product-transport A A (hom A) x z y w p q f = g) ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 (hom-eq A x z p) t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 (hom-eq A y w q) t]) ( fibered-map-square-sigma-over-product A x y z w f p q g) := fibered-map-is-equiv-bases-are-equiv-total-map-is-equiv ( x = z) ( hom A x z) ( y = w) ( hom A y w) ( \\ p' q' \u2192 (product-transport A A (hom A) x z y w p' q' f) = g) ( \\ h' k' \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h' t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k' t])) ( hom-eq A x z) ( hom-eq A y w) ( \\ p' q' \u2192 fibered-map-square-sigma-over-product ( A) ( x) (y) (z) (w) ( f) ( p') ( q') ( g)) ( is-equiv-square-sigma-over-product A is-discrete-A x y z w f g) ( is-discrete-A x z) ( is-discrete-A y w) ( p) ( q) #def is-equiv-fibered-map-square-sigma-over-product-refl-refl uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y : A) ( f : hom A x y) ( g : hom A x y) : is-equiv (f = g) ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) ( fibered-map-square-sigma-over-product A x y x y f refl refl g) := is-equiv-fibered-map-square-sigma-over-product A is-discrete-A x y x y f g refl refl The previous calculations allow us to establish a family of equivalences: #def is-equiv-sum-fibered-map-square-sigma-over-product-refl-refl uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y : A) ( f : hom A x y) : is-equiv ( \u03a3 ( g : hom A x y) , f = g) ( \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) ( total-map ( hom A x y) ( \\ g \u2192 f = g) ( \\ g \u2192 ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) ( fibered-map-square-sigma-over-product A x y x y f refl refl )) := family-of-equiv-total-equiv ( hom A x y) ( \\ g \u2192 f = g) ( \\ g \u2192 ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) ( fibered-map-square-sigma-over-product A x y x y f refl refl ) ( \\ g \u2192 is-equiv-fibered-map-square-sigma-over-product-refl-refl ( A) (is-discrete-A) ( x) (y) ( f) (g)) #def equiv-sum-fibered-map-square-sigma-over-product-refl-refl uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y : A) ( f : hom A x y) : Equiv ( \u03a3 (g : hom A x y) , f = g) ( \u03a3 (g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) := ( ( total-map ( hom A x y) ( \\ g \u2192 f = g) ( \\ g \u2192 ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) ( fibered-map-square-sigma-over-product A x y x y f refl refl )) , is-equiv-sum-fibered-map-square-sigma-over-product-refl-refl A is-discrete-A x y f) Now using the equivalence on total spaces and the contractibility of based path spaces, we conclude that the codomain extension type is contractible. #def is-contr-horn-refl-refl-extension-type uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y : A) ( f : hom A x y) : is-contr ( \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) := is-contr-equiv-is-contr ( \u03a3 ( g : hom A x y) , f = g) ( \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) ( equiv-sum-fibered-map-square-sigma-over-product-refl-refl A is-discrete-A x y f) ( is-contr-based-paths (hom A x y) f) The extension types that appear in the Segal condition are retracts of this type --- at least when the second arrow in the composable pair is an identity. #def triangle-to-square-section ( A : U) ( x y : A) ( f g : hom A x y) ( \u03b1 : hom2 A x y y f (id-hom A y) g) : ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y] := \\ (t , s) \u2192 recOR (t \u2264 s \u21a6 \u03b1 (s , t) , s \u2264 t \u21a6 g s) #def sigma-triangle-to-sigma-square-section ( A : U) ( x y : A) ( f : hom A x y) ( (d , \u03b1) : \u03a3 ( d : hom A x y) , hom2 A x y y f (id-hom A y) d) : \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) := ( d , triangle-to-square-section A x y f d \u03b1) #def sigma-square-to-sigma-triangle-retraction ( A : U) ( x y : A) ( f : hom A x y) ( (g , \u03c3) : \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) : \u03a3 ( d : hom A x y) , (hom2 A x y y f (id-hom A y) d) := ( ( \\ t \u2192 \u03c3 (t , t)) , (\\ (t , s) \u2192 \u03c3 (s , t))) #def sigma-triangle-to-sigma-square-retract ( A : U) ( x y : A) ( f : hom A x y) : is-retract-of ( \u03a3 (d : hom A x y) , (hom2 A x y y f (id-hom A y) d)) ( \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) := ( ( sigma-triangle-to-sigma-square-section A x y f) , ( ( sigma-square-to-sigma-triangle-retraction A x y f) , ( \\ d\u03b1 \u2192 refl ))) We can now verify the Segal condition in the case of composable pairs in which the second arrow is an identity. #def is-contr-hom2-with-id-is-discrete uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y : A) ( f : hom A x y) : is-contr ( \u03a3 (d : hom A x y) , (hom2 A x y y f (id-hom A y) d)) := is-contr-is-retract-of-is-contr ( \u03a3 ( d : hom A x y) , (hom2 A x y y f (id-hom A y) d)) ( \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) ( sigma-triangle-to-sigma-square-retract A x y f) ( is-contr-horn-refl-refl-extension-type A is-discrete-A x y f) But since A is discrete, its hom type family is equivalent to its identity type family, and we can use \"path induction\" over arrows to reduce the general case to the one just proven: #def is-contr-hom2-is-discrete uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : is-contr ( \u03a3 (h : hom A x z) , hom2 A x y z f g h) := ind-based-path ( A) ( y) ( \\ w \u2192 hom A y w) ( \\ w \u2192 hom-eq A y w) ( is-discrete-A y) ( \\ w d \u2192 is-contr ( \u03a3 (h : hom A x w) , hom2 A x y w f d h)) ( is-contr-hom2-with-id-is-discrete A is-discrete-A x y f) ( z) ( g) Finally, we conclude: RS17, Proposition 7.3 #def is-segal-is-discrete uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) : is-segal A := is-contr-hom2-is-discrete A is-discrete-A","title":"Discrete Types"},{"location":"simplicial-hott/07-discrete.rzk/#discrete-types","text":"These formalisations correspond to Section 7 of the RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Discrete types"},{"location":"simplicial-hott/07-discrete.rzk/#prerequisites","text":"hott/1-paths.md - We require basic path algebra. hott/4-equivalences.md - We require the notion of equivalence between types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use extension extensionality. 5-segal-types.md - We use the notion of hom types. Some of the definitions in this file rely on function extensionality and extension extensionality: #assume funext : FunExt #assume extext : ExtExt","title":"Prerequisites"},{"location":"simplicial-hott/07-discrete.rzk/#the-definition","text":"Discrete types are types in which the hom-types are canonically equivalent to identity types. RS17, Definition 7.1 #def hom-eq ( A : U) ( x y : A) ( p : x = y) : hom A x y := ind-path (A) (x) ( \\ y' p' \u2192 hom A x y') ((id-hom A x)) (y) (p) #def is-discrete ( A : U) : U := ( x : A) \u2192 ( y : A) \u2192 is-equiv (x = y) (hom A x y) (hom-eq A x y)","title":"The definition"},{"location":"simplicial-hott/07-discrete.rzk/#families-of-discrete-types","text":"By function extensionality, the dependent function type associated to a family of discrete types is discrete. #def equiv-hom-eq-function-type-is-discrete uses ( funext ) ( X : U) ( A : X \u2192 U) ( is-discrete-A : ( x : X) \u2192 is-discrete (A x)) ( f g : ( x : X) \u2192 A x) : Equiv (f = g) ( hom ((x : X) \u2192 A x) f g) := equiv-triple-comp ( f = g) ( (x : X) \u2192 f x = g x) ( (x : X) \u2192 hom (A x) (f x) (g x)) ( hom ((x : X) \u2192 A x) f g) ( equiv-FunExt funext X A f g) ( equiv-function-equiv-family funext X ( \\ x \u2192 (f x = g x)) ( \\ x \u2192 hom (A x) (f x) (g x)) ( \\ x \u2192 (hom-eq (A x) (f x) (g x) , (is-discrete-A x (f x) (g x))))) ( flip-ext-fun-inv ( 2 ) ( \u0394\u00b9) ( \u2202\u0394\u00b9) ( X) ( \\ t x \u2192 A x) ( \\ t x \u2192 recOR (t \u2261 0\u2082 \u21a6 f x , t \u2261 1\u2082 \u21a6 g x))) #def compute-hom-eq-function-type-is-discrete uses ( funext ) ( X : U) ( A : X \u2192 U) ( is-discrete-A : ( x : X) \u2192 is-discrete (A x)) ( f g : ( x : X) \u2192 A x) ( h : f = g) : ( hom-eq ((x : X) \u2192 A x) f g h) = ( first (equiv-hom-eq-function-type-is-discrete X A is-discrete-A f g)) h := ind-path ( (x : X) \u2192 A x) ( f) ( \\ g' h' \u2192 hom-eq ((x : X) \u2192 A x) f g' h' = ( first (equiv-hom-eq-function-type-is-discrete X A is-discrete-A f g')) h') ( refl ) ( g) ( h) RS17, Proposition 7.2 #def is-discrete-function-type uses ( funext ) ( X : U) ( A : X \u2192 U) ( is-discrete-A : ( x : X) \u2192 is-discrete (A x)) : is-discrete ( (x : X) \u2192 A x) := \\ f g \u2192 is-equiv-homotopy ( f = g) ( hom ((x : X) \u2192 A x) f g) ( hom-eq ((x : X) \u2192 A x) f g) ( first (equiv-hom-eq-function-type-is-discrete X A is-discrete-A f g)) ( compute-hom-eq-function-type-is-discrete X A is-discrete-A f g) ( second (equiv-hom-eq-function-type-is-discrete X A is-discrete-A f g)) By extension extensionality, an extension type into a family of discrete types is discrete. Since equiv-extension-equiv-family considers total extension types only, extending from BOT , that's all we prove here for now. #def equiv-hom-eq-extension-type-is-discrete uses ( extext ) ( I : CUBE) ( \u03c8 : I \u2192 TOPE) ( A : \u03c8 \u2192 U) ( is-discrete-A : ( t : \u03c8) \u2192 is-discrete (A t)) ( f g : ( t : \u03c8) \u2192 A t) : Equiv (f = g) ( hom ((t : \u03c8) \u2192 A t) f g) := equiv-triple-comp ( f = g) ( (t : \u03c8) \u2192 f t = g t) ( (t : \u03c8) \u2192 hom (A t) (f t) (g t)) ( hom ((t : \u03c8) \u2192 A t) f g) ( equiv-ExtExt extext I \u03c8 ( \\ _ \u2192 BOT ) A ( \\ _ \u2192 recBOT ) f g) ( equiv-extension-equiv-family ( extext) ( I) ( \u03c8) ( \\ t \u2192 f t = g t) ( \\ t \u2192 hom (A t) (f t) (g t)) ( \\ t \u2192 (hom-eq (A t) (f t) (g t) , (is-discrete-A t (f t) (g t))))) ( fubini ( I) ( 2 ) ( \u03c8) ( \\ t \u2192 BOT ) ( \u0394\u00b9) ( \u2202\u0394\u00b9) ( \\ t s \u2192 A t) ( \\ (t , s) \u2192 recOR (s \u2261 0\u2082 \u21a6 f t , s \u2261 1\u2082 \u21a6 g t))) #def compute-hom-eq-extension-type-is-discrete uses ( extext ) ( I : CUBE) ( \u03c8 : ( t : I) \u2192 TOPE) ( A : \u03c8 \u2192 U) ( is-discrete-A : ( t : \u03c8) \u2192 is-discrete (A t)) ( f g : ( t : \u03c8) \u2192 A t) ( h : f = g) : ( hom-eq ((t : \u03c8) \u2192 A t) f g h) = ( first (equiv-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g)) h := ind-path ( (t : \u03c8) \u2192 A t) ( f) ( \\ g' h' \u2192 ( hom-eq ((t : \u03c8) \u2192 A t) f g' h') = ( first (equiv-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g') h')) ( refl ) ( g) ( h) RS17, Proposition 7.2, for extension types #def is-discrete-extension-type uses ( extext ) ( I : CUBE) ( \u03c8 : ( t : I) \u2192 TOPE) ( A : \u03c8 \u2192 U) ( is-discrete-A : ( t : \u03c8) \u2192 is-discrete (A t)) : is-discrete ( (t : \u03c8) \u2192 A t) := \\ f g \u2192 is-equiv-homotopy ( f = g) ( hom ((t : \u03c8) \u2192 A t) f g) ( hom-eq ((t : \u03c8) \u2192 A t) f g) ( first (equiv-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g)) ( compute-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g) ( second (equiv-hom-eq-extension-type-is-discrete I \u03c8 A is-discrete-A f g)) For instance, the arrow type of a discrete type is discrete. #def is-discrete-arr uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) : is-discrete (arr A) := is-discrete-extension-type 2 \u0394\u00b9 ( \\ _ \u2192 A) ( \\ _ \u2192 is-discrete-A)","title":"Families of discrete types"},{"location":"simplicial-hott/07-discrete.rzk/#discrete-types-are-segal-types","text":"Discrete types are automatically Segal types. #section discrete-arr-equivalences #variable A : U #variable is-discrete-A : is-discrete A #variables x y z w : A #variable f : hom A x y #variable g : hom A z w #def is-equiv-hom-eq-discrete uses ( extext x y z w ) : is-equiv (f =_{arr A} g) (hom (arr A) f g) (hom-eq (arr A) f g) := (is-discrete-arr A is-discrete-A) f g #def equiv-hom-eq-discrete uses ( extext x y z w ) : Equiv (f =_{arr A} g) (hom (arr A) f g) := (hom-eq (arr A) f g , (is-discrete-arr A is-discrete-A) f g) #def equiv-square-hom-arr : Equiv ( hom (arr A) f g) ( \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ t \u2261 0\u2082 \u2227 \u0394\u00b9 s \u21a6 f s , t \u2261 1\u2082 \u2227 \u0394\u00b9 s \u21a6 g s , \u0394\u00b9 t \u2227 s \u2261 0\u2082 \u21a6 h t , \u0394\u00b9 t \u2227 s \u2261 1\u2082 \u21a6 k t]))) := ( \\ \u03b1 \u2192 ( ( \\ t \u2192 \u03b1 t 0\u2082 ) , ( ( \\ t \u2192 \u03b1 t 1\u2082 ) , (\\ (t , s) \u2192 \u03b1 t s))) , ( ( ( \\ \u03c3 t s \u2192 ( second ( second \u03c3)) (t , s)) , ( \\ \u03b1 \u2192 refl )) , ( ( \\ \u03c3 t s \u2192 ( second ( second \u03c3)) (t , s)) , ( \\ \u03c3 \u2192 refl )))) The equivalence underlying equiv-arr-\u03a3-hom : #def fibered-arr-free-arr : (arr A) \u2192 ( \u03a3 (u : A) , ( \u03a3 (v : A) , hom A u v)) := \\ k \u2192 (k 0\u2082 , (k 1\u2082 , k)) #def is-equiv-fibered-arr-free-arr : is-equiv (arr A) ( \u03a3 (u : A) , ( \u03a3 (v : A) , hom A u v)) (fibered-arr-free-arr) := is-equiv-arr-\u03a3-hom A #def is-equiv-ap-fibered-arr-free-arr uses ( w x y z ) : is-equiv ( f =_{\u0394\u00b9 \u2192 A} g) ( fibered-arr-free-arr f = fibered-arr-free-arr g) ( ap ( arr A) ( \u03a3 (u : A) , ( \u03a3 (v : A) , (hom A u v))) ( f) ( g) ( fibered-arr-free-arr)) := is-emb-is-equiv ( arr A) ( \u03a3 (u : A) , ( \u03a3 (v : A) , (hom A u v))) ( fibered-arr-free-arr) ( is-equiv-fibered-arr-free-arr) ( f) ( g) #def equiv-eq-fibered-arr-eq-free-arr uses ( w x y z ) : Equiv (f =_{\u0394\u00b9 \u2192 A} g) (fibered-arr-free-arr f = fibered-arr-free-arr g) := equiv-ap-is-equiv ( arr A) ( \u03a3 (u : A) , ( \u03a3 (v : A) , (hom A u v))) ( fibered-arr-free-arr) ( is-equiv-fibered-arr-free-arr) ( f) ( g) #def equiv-sigma-over-product-hom-eq : Equiv ( fibered-arr-free-arr f = fibered-arr-free-arr g) ( \u03a3 ( p : x = z) , ( \u03a3 ( q : y = w) , ( product-transport A A (hom A) x z y w p q f = g))) := extensionality-\u03a3-over-product ( A) (A) ( hom A) ( fibered-arr-free-arr f) ( fibered-arr-free-arr g) #def equiv-square-sigma-over-product uses ( extext is-discrete-A ) : Equiv ( \u03a3 ( p : x = z) , ( \u03a3 (q : y = w) , ( product-transport A A (hom A) x z y w p q f = g))) ( \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ((t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k t]))) := equiv-left-cancel ( f =_{\u0394\u00b9 \u2192 A} g) ( \u03a3 ( p : x = z) , ( \u03a3 ( q : y = w) , ( product-transport A A (hom A) x z y w p q f = g))) ( \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ((t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k t]))) ( equiv-comp ( f =_{\u0394\u00b9 \u2192 A} g) ( fibered-arr-free-arr f = fibered-arr-free-arr g) ( \u03a3 ( p : x = z) , ( \u03a3 ( q : y = w) , ( product-transport A A (hom A) x z y w p q f = g))) equiv-eq-fibered-arr-eq-free-arr equiv-sigma-over-product-hom-eq) ( equiv-comp ( f =_{\u0394\u00b9 \u2192 A} g) ( hom (arr A) f g) ( \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k t]))) ( equiv-hom-eq-discrete) ( equiv-square-hom-arr)) We close the section so we can use path induction. #end discrete-arr-equivalences #def fibered-map-square-sigma-over-product ( A : U) ( x y z w : A) ( f : hom A x y) ( p : x = z) ( q : y = w) : ( g : hom A z w) \u2192 ( product-transport A A (hom A) x z y w p q f = g) \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 (hom-eq A x z p) t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 (hom-eq A y w q) t]) := ind-path ( A) ( x) ( \\ z' p' \u2192 ( g : hom A z' w) \u2192 ( product-transport A A (hom A) x z' y w p' q f = g) \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 (hom-eq A x z' p') t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 (hom-eq A y w q) t])) ( ind-path ( A) ( y) ( \\ w' q' \u2192 ( g : hom A x w') \u2192 ( product-transport A A (hom A) x x y w' refl q' f = g) \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 (hom-eq A y w' q') t])) ( ind-path ( hom A x y) ( f) ( \\ g' \u03c4' \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g' s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) ( \\ (t , s) \u2192 f s)) ( w) ( q)) ( z) ( p) #def square-sigma-over-product ( A : U) ( x y z w : A) ( f : hom A x y) ( g : hom A z w) ( ( p , (q , \u03c4)) : ( \u03a3 ( p : x = z) , ( \u03a3 ( q : y = w) , ( product-transport A A (hom A) x z y w p q f = g)))) : \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k t])) := ( ( hom-eq A x z p) , ( ( hom-eq A y w q) , ( fibered-map-square-sigma-over-product ( A) ( x) (y) (z) (w) ( f) (p) (q) (g) ( \u03c4)))) #def refl-refl-map-equiv-square-sigma-over-product uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y : A) ( f g : hom A x y) ( \u03c4 : product-transport A A (hom A) x x y y refl refl f = g) : ( first ( equiv-square-sigma-over-product A is-discrete-A x y x y f g) ( refl , ( refl , \u03c4))) = ( square-sigma-over-product ( A) ( x) (y) (x) (y) ( f) (g) ( refl , ( refl , \u03c4))) := ind-path ( hom A x y) ( f) ( \\ g' \u03c4' \u2192 ( first ( equiv-square-sigma-over-product A is-discrete-A x y x y f g') ( refl , ( refl , \u03c4'))) = ( square-sigma-over-product ( A) ( x) (y) (x) (y) ( f) (g') ( refl , ( refl , \u03c4')))) ( refl ) ( g) ( \u03c4) #def map-equiv-square-sigma-over-product uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y z w : A) ( f : hom A x y) ( p : x = z) ( q : y = w) : ( g : hom A z w) \u2192 ( \u03c4 : product-transport A A (hom A) x z y w p q f = g) \u2192 ( first ( equiv-square-sigma-over-product A is-discrete-A x y z w f g) ( p , (q , \u03c4))) = ( square-sigma-over-product A x y z w f g (p , (q , \u03c4))) := ind-path ( A) ( y) ( \\ w' q' \u2192 ( g : hom A z w') \u2192 ( \u03c4 : product-transport A A (hom A) x z y w' p q' f = g) \u2192 ( first ( equiv-square-sigma-over-product A is-discrete-A x y z w' f g)) ( p , (q' , \u03c4)) = ( square-sigma-over-product A x y z w' f g) ( p , (q' , \u03c4))) ( ind-path ( A) ( x) ( \\ z' p' \u2192 ( g : hom A z' y) \u2192 ( \u03c4 : product-transport A A (hom A) x z' y y p' refl f = g) \u2192 ( first ( equiv-square-sigma-over-product A is-discrete-A x y z' y f g) ( p' , ( refl , \u03c4))) = ( square-sigma-over-product A x y z' y f g (p' , ( refl , \u03c4)))) ( refl-refl-map-equiv-square-sigma-over-product ( A) (is-discrete-A) (x) (y) (f)) ( z) ( p)) ( w) ( q) #def is-equiv-square-sigma-over-product uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y z w : A) ( f : hom A x y) ( g : hom A z w) : is-equiv ( \u03a3 ( p : x = z) , ( \u03a3 ( q : y = w) , ( product-transport A A (hom A) x z y w p q f = g))) ( \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k t]))) ( square-sigma-over-product A x y z w f g) := is-equiv-rev-homotopy ( \u03a3 ( p : x = z) , ( \u03a3 ( q : y = w) , ( product-transport A A (hom A) x z y w p q f = g))) ( \u03a3 ( h : hom A x z) , ( \u03a3 ( k : hom A y w) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k t]))) ( first (equiv-square-sigma-over-product A is-discrete-A x y z w f g)) ( square-sigma-over-product A x y z w f g) ( \\ (p , (q , \u03c4)) \u2192 map-equiv-square-sigma-over-product A is-discrete-A x y z w f p q g \u03c4) ( second (equiv-square-sigma-over-product A is-discrete-A x y z w f g)) #def is-equiv-fibered-map-square-sigma-over-product uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y z w : A) ( f : hom A x y) ( g : hom A z w) ( p : x = z) ( q : y = w) : is-equiv ( product-transport A A (hom A) x z y w p q f = g) ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 (hom-eq A x z p) t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 (hom-eq A y w q) t]) ( fibered-map-square-sigma-over-product A x y z w f p q g) := fibered-map-is-equiv-bases-are-equiv-total-map-is-equiv ( x = z) ( hom A x z) ( y = w) ( hom A y w) ( \\ p' q' \u2192 (product-transport A A (hom A) x z y w p' q' f) = g) ( \\ h' k' \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 h' t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 k' t])) ( hom-eq A x z) ( hom-eq A y w) ( \\ p' q' \u2192 fibered-map-square-sigma-over-product ( A) ( x) (y) (z) (w) ( f) ( p') ( q') ( g)) ( is-equiv-square-sigma-over-product A is-discrete-A x y z w f g) ( is-discrete-A x z) ( is-discrete-A y w) ( p) ( q) #def is-equiv-fibered-map-square-sigma-over-product-refl-refl uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y : A) ( f : hom A x y) ( g : hom A x y) : is-equiv (f = g) ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) ( fibered-map-square-sigma-over-product A x y x y f refl refl g) := is-equiv-fibered-map-square-sigma-over-product A is-discrete-A x y x y f g refl refl The previous calculations allow us to establish a family of equivalences: #def is-equiv-sum-fibered-map-square-sigma-over-product-refl-refl uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y : A) ( f : hom A x y) : is-equiv ( \u03a3 ( g : hom A x y) , f = g) ( \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) ( total-map ( hom A x y) ( \\ g \u2192 f = g) ( \\ g \u2192 ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) ( fibered-map-square-sigma-over-product A x y x y f refl refl )) := family-of-equiv-total-equiv ( hom A x y) ( \\ g \u2192 f = g) ( \\ g \u2192 ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) ( fibered-map-square-sigma-over-product A x y x y f refl refl ) ( \\ g \u2192 is-equiv-fibered-map-square-sigma-over-product-refl-refl ( A) (is-discrete-A) ( x) (y) ( f) (g)) #def equiv-sum-fibered-map-square-sigma-over-product-refl-refl uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y : A) ( f : hom A x y) : Equiv ( \u03a3 (g : hom A x y) , f = g) ( \u03a3 (g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) := ( ( total-map ( hom A x y) ( \\ g \u2192 f = g) ( \\ g \u2192 ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) ( fibered-map-square-sigma-over-product A x y x y f refl refl )) , is-equiv-sum-fibered-map-square-sigma-over-product-refl-refl A is-discrete-A x y f) Now using the equivalence on total spaces and the contractibility of based path spaces, we conclude that the codomain extension type is contractible. #def is-contr-horn-refl-refl-extension-type uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y : A) ( f : hom A x y) : is-contr ( \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) := is-contr-equiv-is-contr ( \u03a3 ( g : hom A x y) , f = g) ( \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) ( equiv-sum-fibered-map-square-sigma-over-product-refl-refl A is-discrete-A x y f) ( is-contr-based-paths (hom A x y) f) The extension types that appear in the Segal condition are retracts of this type --- at least when the second arrow in the composable pair is an identity. #def triangle-to-square-section ( A : U) ( x y : A) ( f g : hom A x y) ( \u03b1 : hom2 A x y y f (id-hom A y) g) : ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y] := \\ (t , s) \u2192 recOR (t \u2264 s \u21a6 \u03b1 (s , t) , s \u2264 t \u21a6 g s) #def sigma-triangle-to-sigma-square-section ( A : U) ( x y : A) ( f : hom A x y) ( (d , \u03b1) : \u03a3 ( d : hom A x y) , hom2 A x y y f (id-hom A y) d) : \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) := ( d , triangle-to-square-section A x y f d \u03b1) #def sigma-square-to-sigma-triangle-retraction ( A : U) ( x y : A) ( f : hom A x y) ( (g , \u03c3) : \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) : \u03a3 ( d : hom A x y) , (hom2 A x y y f (id-hom A y) d) := ( ( \\ t \u2192 \u03c3 (t , t)) , (\\ (t , s) \u2192 \u03c3 (s , t))) #def sigma-triangle-to-sigma-square-retract ( A : U) ( x y : A) ( f : hom A x y) : is-retract-of ( \u03a3 (d : hom A x y) , (hom2 A x y y f (id-hom A y) d)) ( \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) := ( ( sigma-triangle-to-sigma-square-section A x y f) , ( ( sigma-square-to-sigma-triangle-retraction A x y f) , ( \\ d\u03b1 \u2192 refl ))) We can now verify the Segal condition in the case of composable pairs in which the second arrow is an identity. #def is-contr-hom2-with-id-is-discrete uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y : A) ( f : hom A x y) : is-contr ( \u03a3 (d : hom A x y) , (hom2 A x y y f (id-hom A y) d)) := is-contr-is-retract-of-is-contr ( \u03a3 ( d : hom A x y) , (hom2 A x y y f (id-hom A y) d)) ( \u03a3 ( g : hom A x y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 f s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 g s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 x , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 y])) ( sigma-triangle-to-sigma-square-retract A x y f) ( is-contr-horn-refl-refl-extension-type A is-discrete-A x y f) But since A is discrete, its hom type family is equivalent to its identity type family, and we can use \"path induction\" over arrows to reduce the general case to the one just proven: #def is-contr-hom2-is-discrete uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) ( x y z : A) ( f : hom A x y) ( g : hom A y z) : is-contr ( \u03a3 (h : hom A x z) , hom2 A x y z f g h) := ind-based-path ( A) ( y) ( \\ w \u2192 hom A y w) ( \\ w \u2192 hom-eq A y w) ( is-discrete-A y) ( \\ w d \u2192 is-contr ( \u03a3 (h : hom A x w) , hom2 A x y w f d h)) ( is-contr-hom2-with-id-is-discrete A is-discrete-A x y f) ( z) ( g) Finally, we conclude: RS17, Proposition 7.3 #def is-segal-is-discrete uses ( extext ) ( A : U) ( is-discrete-A : is-discrete A) : is-segal A := is-contr-hom2-is-discrete A is-discrete-A","title":"Discrete types are Segal types"},{"location":"simplicial-hott/08-covariant.rzk/","text":"Covariantly functorial type families \u00b6 These formalisations correspond to Section 8 of the RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 hott/* - We require various prerequisites from homotopy type theory, for instance the notion of contractible types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 5-segal-types.md - We make use of the notion of Segal types and their structures. Some of the definitions in this file rely on extension extensionality: #assume extext : ExtExt Dependent hom types \u00b6 In a type family over a base type, there is a dependent hom type of arrows that live over a specified arrow in the base type. RS17, Section 8 Prelim #def dhom ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( u : C x) ( v : C y) : U := ( t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u , t \u2261 1\u2082 \u21a6 v] It will be convenient to collect together dependent hom types with fixed domain but varying codomain. #def dhom-from ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( u : C x) : U := ( \u03a3 (v : C y) , dhom A x y f C u v) There is also a type of dependent commutative triangles over a base commutative triangle. #def dhom2 ( A : U) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) ( \u03b1 : hom2 A x y z f g h) ( C : A \u2192 U) ( u : C x) ( v : C y) ( w : C z) ( ff : dhom A x y f C u v) ( gg : dhom A y z g C v w) ( hh : dhom A x z h C u w) : U := ( (t1 , t2) : \u0394\u00b2) \u2192 C (\u03b1 (t1 , t2)) [ t2 \u2261 0\u2082 \u21a6 ff t1 , t1 \u2261 1\u2082 \u21a6 gg t2 , t2 \u2261 t1 \u21a6 hh t2 ] Covariant families \u00b6 A family of types over a base type is covariant if every arrow in the base has a unique lift with specified domain. RS17, Definition 8.2 #def is-covariant ( A : U) ( C : A \u2192 U) : U := ( x : A) \u2192 ( y : A) \u2192 ( f : hom A x y) \u2192 ( u : C x) \u2192 is-contr (dhom-from A x y f C u) The type of covariant families over a fixed type #def covariant-family ( A : U) : U := ( \u03a3 (C : (A \u2192 U)) , is-covariant A C) The notion of having a unique lift with a fixed domain may also be expressed by contractibility of the type of extensions along the domain inclusion into the 1-simplex. #def has-unique-fixed-domain-lifts ( A : U) ( C : A \u2192 U) : U := ( x : A) \u2192 ( y : A) \u2192 ( f : hom A x y) \u2192 ( u : C x) \u2192 is-contr ( (t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u]) These two notions of covariance are equivalent because the two types of lifts of a base arrow with fixed domain are equivalent. Note that this is not quite an instance of Theorem 4.4 but its proof, with a very small modification, works here. #def equiv-lifts-with-fixed-domain ( A : U) ( C : A \u2192 U) ( x y : A) ( f : hom A x y) ( u : C x) : Equiv ( (t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u]) (dhom-from A x y f C u) := ( \\ h \u2192 (h 1\u2082 , \\ t \u2192 h t) , ( ( \\ fg t \u2192 ( second fg) t , \\ h \u2192 refl ) , ( ( \\ fg t \u2192 ( second fg) t , \\ h \u2192 refl )))) By the equivalence-invariance of contractibility, this proves the desired logical equivalence RS17, Proposition 8.4 #def has-unique-fixed-domain-lifts-iff-is-covariant ( A : U) ( C : A \u2192 U) : iff ( has-unique-fixed-domain-lifts A C) ( is-covariant A C) := ( ( \\ C-has-unique-lifts x y f u \u2192 is-contr-equiv-is-contr ( (t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u]) ( dhom-from A x y f C u) ( equiv-lifts-with-fixed-domain A C x y f u) ( C-has-unique-lifts x y f u)) , ( \\ C-is-covariant x y f u \u2192 is-contr-equiv-is-contr' ( (t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u]) ( dhom-from A x y f C u) ( equiv-lifts-with-fixed-domain A C x y f u) ( C-is-covariant x y f u))) Representable covariant families \u00b6 If A is a Segal type and a : A is any term, then hom A a defines a covariant family over A, and conversely if this family is covariant for every a : A, then A must be a Segal type. The proof involves a rather lengthy composition of equivalences. #def dhom-representable ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) ( v : hom A a y) : U := dhom A x y f ( \\ z \u2192 hom A a z) u v By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhom-representable ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) ( v : hom A a y) : Equiv ( dhom-representable A a x y f u v) ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) := curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 ( \\ t s \u2192 A) ( \\ (t , s) \u2192 recOR ( (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t)) #def dhom-from-representable ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : U := dhom-from A x y f ( \\ z \u2192 hom A a z) u By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhom-from-representable ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( \u03a3 ( v : hom A a y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) := total-equiv-family-equiv ( hom A a y) ( \\ v \u2192 dhom-representable A a x y f u v) ( \\ v \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( \\ v \u2192 uncurried-dhom-representable A a x y f u v) #def square-to-hom2-pushout ( A : U) ( w x y z : A) ( u : hom A w x) ( f : hom A x z) ( g : hom A w y) ( v : hom A y z) : ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 g t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) \u2192 ( \u03a3 (d : hom A w z) , product (hom2 A w x z u f d) (hom2 A w y z g v d)) := \\ sq \u2192 ( ( \\ t \u2192 sq (t , t)) , (\\ (t , s) \u2192 sq (s , t) , \\ (t , s) \u2192 sq (t , s))) #def hom2-pushout-to-square ( A : U) ( w x y z : A) ( u : hom A w x) ( f : hom A x z) ( g : hom A w y) ( v : hom A y z) : ( \u03a3 ( d : hom A w z) , ( product (hom2 A w x z u f d) (hom2 A w y z g v d))) \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 g t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) := \\ (d , (\u03b11 , \u03b12)) (t , s) \u2192 recOR ( t \u2264 s \u21a6 \u03b11 (s , t) , s \u2264 t \u21a6 \u03b12 (t , s)) #def equiv-square-hom2-pushout ( A : U) ( w x y z : A) ( u : hom A w x) ( f : hom A x z) ( g : hom A w y) ( v : hom A y z) : Equiv ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 g t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( \u03a3 (d : hom A w z) , (product (hom2 A w x z u f d) (hom2 A w y z g v d))) := ( ( square-to-hom2-pushout A w x y z u f g v) , ( ( hom2-pushout-to-square A w x y z u f g v , \\ sq \u2192 refl ) , ( hom2-pushout-to-square A w x y z u f g v , \\ \u03b1s \u2192 refl ))) #def representable-dhom-from-uncurry-hom2 ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( \u03a3 (v : hom A a y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( \u03a3 ( v : hom A a y) , ( \u03a3 ( d : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) := total-equiv-family-equiv ( hom A a y) ( \\ v \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( \\ v \u2192 ( \u03a3 ( d : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) ( \\ v \u2192 equiv-square-hom2-pushout A a x a y u f (id-hom A a) v) #def representable-dhom-from-hom2 ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( \u03a3 ( d : hom A a y) , ( \u03a3 ( v : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) := equiv-triple-comp ( dhom-from-representable A a x y f u) ( \u03a3 ( v : hom A a y) , ( ((t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( \u03a3 ( v : hom A a y) , ( \u03a3 ( d : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) ( \u03a3 ( d : hom A a y) , ( \u03a3 ( v : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) ( uncurried-dhom-from-representable A a x y f u) ( representable-dhom-from-uncurry-hom2 A a x y f u) ( fubini-\u03a3 (hom A a y) (hom A a y) ( \\ v d \u2192 product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))) #def representable-dhom-from-hom2-dist ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( \u03a3 ( d : hom A a y) , ( product ( hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (hom2 A a a y (id-hom A a) v d)))) := equiv-right-cancel ( dhom-from-representable A a x y f u) ( \u03a3 ( d : hom A a y) , ( product ( hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d))) ( \u03a3 ( d : hom A a y) , ( \u03a3 ( v : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) ( representable-dhom-from-hom2 A a x y f u) ( total-equiv-family-equiv ( hom A a y) ( \\ d \u2192 ( product ( hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (hom2 A a a y (id-hom A a) v d)))) ( \\ d \u2192 ( \u03a3 ( v : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) ( \\ d \u2192 ( distributive-product-\u03a3 ( hom2 A a x y u f d) ( hom A a y) ( \\ v \u2192 hom2 A a a y (id-hom A a) v d)))) Now we introduce the hypothesis that A is Segal type. #def representable-dhom-from-path-space-is-segal ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( \u03a3 ( d : hom A a y) , ( product (hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (v = d)))) := equiv-right-cancel ( dhom-from-representable A a x y f u) ( \u03a3 ( d : hom A a y) , ( product (hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (v = d)))) ( \u03a3 ( d : hom A a y) , ( product ( hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d))) ( representable-dhom-from-hom2-dist A a x y f u) ( total-equiv-family-equiv ( hom A a y) ( \\ d \u2192 product (hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (v = d))) ( \\ d \u2192 ( product ( hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d))) ( \\ d \u2192 ( total-equiv-family-equiv ( hom2 A a x y u f d) ( \\ \u03b1 \u2192 (\u03a3 (v : hom A a y) , (v = d))) ( \\ \u03b1 \u2192 (\u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d)) ( \\ \u03b1 \u2192 ( total-equiv-family-equiv ( hom A a y) ( \\ v \u2192 (v = d)) ( \\ v \u2192 hom2 A a a y (id-hom A a) v d) ( \\ v \u2192 (equiv-homotopy-hom2-is-segal A is-segal-A a y v d))))))) #def codomain-based-paths-contraction ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) ( d : hom A a y) : Equiv ( product (hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (v = d))) ( hom2 A a x y u f d) := equiv-projection-contractible-fibers ( hom2 A a x y u f d) ( \\ \u03b1 \u2192 (\u03a3 (v : hom A a y) , (v = d))) ( \\ \u03b1 \u2192 is-contr-codomain-based-paths (hom A a y) d) #def is-segal-representable-dhom-from-hom2 ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( \u03a3 (d : hom A a y) , (hom2 A a x y u f d)) := equiv-comp ( dhom-from-representable A a x y f u) ( \u03a3 (d : hom A a y) , ( product (hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (v = d)))) ( \u03a3 (d : hom A a y) , (hom2 A a x y u f d)) ( representable-dhom-from-path-space-is-segal A is-segal-A a x y f u) ( total-equiv-family-equiv ( hom A a y) ( \\ d \u2192 product (hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (v = d))) ( \\ d \u2192 hom2 A a x y u f d) ( \\ d \u2192 codomain-based-paths-contraction A a x y f u d)) #def is-segal-representable-dhom-from-contractible ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : is-contr (dhom-from-representable A a x y f u) := is-contr-equiv-is-contr' ( dhom-from-representable A a x y f u) ( \u03a3 (d : hom A a y) , (hom2 A a x y u f d)) ( is-segal-representable-dhom-from-hom2 A is-segal-A a x y f u) ( is-segal-A a x y u f) Finally, we see that covariant hom families in a Segal type are covariant. RS17, Proposition 8.13( < -) #def is-covariant-representable-is-segal ( A : U) ( is-segal-A : is-segal A) ( a : A) : is-covariant A ( \\ x \u2192 hom A a x) := is-segal-representable-dhom-from-contractible A is-segal-A a The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for Segal types - so instead we argue as follows: RS17, Proposition 8.13(\u2192) #def is-segal-is-covariant-representable ( A : U) ( corepresentable-family-is-covariant : ( a : A) \u2192 is-covariant A ( \\ x \u2192 hom A a x)) : is-segal A := \\ x y z f g \u2192 is-contr-base-is-contr-\u03a3 ( \u03a3 (h : hom A x z) , hom2 A x y z f g h) ( \\ hk \u2192 \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v ( first hk)) ( \\ hk \u2192 ( first hk , \\ (t , s) \u2192 first hk s)) ( is-contr-equiv-is-contr' ( \u03a3 ( hk : \u03a3 ( h : hom A x z) , hom2 A x y z f g h) , ( \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v ( first hk))) ( dhom-from-representable A x y z g f) ( inv-equiv ( dhom-from-representable A x y z g f) ( \u03a3 ( hk : \u03a3 ( h : hom A x z) , hom2 A x y z f g h) , ( \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v ( first hk))) ( equiv-comp ( dhom-from-representable A x y z g f) ( \u03a3 ( h : hom A x z) , ( product ( hom2 A x y z f g h) ( \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v h))) ( \u03a3 ( hk : \u03a3 ( h : hom A x z) , hom2 A x y z f g h) , ( \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v ( first hk))) ( representable-dhom-from-hom2-dist A x y z g f) ( associative-\u03a3 ( hom A x z) ( \\ h \u2192 hom2 A x y z f g h) ( \\ h _ \u2192 \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v h)))) ( corepresentable-family-is-covariant x y z g f)) While not needed to prove Proposition 8.13, it is interesting to observe that the dependent hom types in a representable family can be understood as extension types as follows. #def cofibration-union-test ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( ( (t , s) : 2 \u00d7 2 | (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s)) \u2192 A [ (t \u2261 1\u2082 ) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (t \u2261 1\u2082 ) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) := cofibration-union ( 2 \u00d7 2 ) ( \\ (t , s) \u2192 (t \u2261 1\u2082 ) \u2227 \u0394\u00b9 s) ( \\ (t , s) \u2192 ((t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s)) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 )) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ))) ( \\ (t , s) \u2192 A) ( \\ (t , s) \u2192 recOR ( (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t)) #def base-hom-rewriting ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( ( (t , s) : 2 \u00d7 2 | (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s)) \u2192 A [ (t \u2261 1\u2082 ) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (t \u2261 1\u2082 ) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) ( hom A a y) := ( ( \\ v \u2192 ( \\ r \u2192 v (( 1\u2082 , r)))) , ( ( \\ v (t , s) \u2192 v s , \\ _ \u2192 refl ) , ( \\ v (_ , s) \u2192 v s , \\ _ \u2192 refl ))) #def base-hom-expansion ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( hom A a y) := equiv-comp ( ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( ( (t , s) : 2 \u00d7 2 | (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s)) \u2192 A [ (t \u2261 1\u2082 ) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (t \u2261 1\u2082 ) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) ( hom A a y) ( cofibration-union-test A a x y f u) ( base-hom-rewriting A a x y f u) #def representable-dhom-from-expansion ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( \u03a3 ( sq : ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 (sq ( 1\u2082 , s)) , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( \u03a3 ( v : hom A a y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) := total-equiv-pullback-is-equiv ( ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( hom A a y) ( first (base-hom-expansion A a x y f u)) ( second (base-hom-expansion A a x y f u)) ( \\ v \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) #def representable-dhom-from-composite-expansion ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( \u03a3 ( sq : ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 (sq ( 1\u2082 , s)) , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) := equiv-right-cancel ( dhom-from-representable A a x y f u) ( \u03a3 ( sq : ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 (sq ( 1\u2082 , s)) , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( \u03a3 ( v : hom A a y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( uncurried-dhom-from-representable A a x y f u) ( representable-dhom-from-expansion A a x y f u) #def representable-dhom-from-cofibration-composition ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( \u03a3 ( sq : ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 (sq ( 1\u2082 , s)) , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) := cofibration-composition ( 2 \u00d7 2 ) \u0394\u00b9\u00d7\u0394\u00b9 \u2202\u25a1 ( \\ (t , s) \u2192 ( (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s)) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 )) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ))) ( \\ ts \u2192 A) ( \\ (t , s) \u2192 recOR ( (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t)) #def representable-dhom-from-as-extension-type ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) := equiv-right-cancel ( dhom-from-representable A a x y f u) ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( \u03a3 ( sq : ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 (sq ( 1\u2082 , s)) , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( representable-dhom-from-composite-expansion A a x y f u) ( representable-dhom-from-cofibration-composition A a x y f u) Covariant lifts, transport, and uniqueness \u00b6 In a covariant family C over a base type A , a term u : C x may be transported along an arrow f : hom A x y to give a term in C y. RS17, covariant transport from beginning of Section 8.2 #def covariant-transport ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) ( u : C x) : C y := first (center-contraction (dhom-from A x y f C u) (is-covariant-C x y f u)) RS17, covariant lift from beginning of Section 8.2 #def covariant-lift ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) ( u : C x) : ( dhom A x y f C u (covariant-transport A x y f C is-covariant-C u)) := second (center-contraction (dhom-from A x y f C u) (is-covariant-C x y f u)) #def covariant-uniqueness ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) ( u : C x) ( lift : dhom-from A x y f C u) : ( covariant-transport A x y f C is-covariant-C u) = ( first lift) := first-path-\u03a3 ( C y) ( \\ v \u2192 dhom A x y f C u v) ( center-contraction (dhom-from A x y f C u) (is-covariant-C x y f u)) ( lift) ( homotopy-contraction (dhom-from A x y f C u) (is-covariant-C x y f u) lift) Covariant functoriality \u00b6 The covariant transport operation defines a covariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law. #def id-dhom ( A : U) ( x : A) ( C : A \u2192 U) ( u : C x) : dhom A x x (id-hom A x) C u u := \\ t \u2192 u RS17, Proposition 8.16, Part 2, Covariant families preserve identities #def id-arr-covariant-transport ( A : U) ( x : A) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) ( u : C x) : ( covariant-transport A x x (id-hom A x) C is-covariant-C u) = u := covariant-uniqueness A x x (id-hom A x) C is-covariant-C u (u , id-dhom A x C u) Natural transformations \u00b6 A fiberwise map between covariant families is automatically \"natural\" commuting with the covariant lifts. RS17, Proposition 8.17, Covariant naturality #def covariant-fiberwise-transformation-application ( A : U) ( x y : A) ( f : hom A x y) ( C D : A \u2192 U) ( is-covariant-C : is-covariant A C) ( \u03d5 : ( z : A) \u2192 C z \u2192 D z) ( u : C x) : dhom-from A x y f D (\u03d5 x u) := ( ( \u03d5 y (covariant-transport A x y f C is-covariant-C u)) , ( \\ t \u2192 \u03d5 (f t) (covariant-lift A x y f C is-covariant-C u t))) #def naturality-covariant-fiberwise-transformation ( A : U) ( x y : A) ( f : hom A x y) ( C D : A \u2192 U) ( is-covariant-C : is-covariant A C) ( is-covariant-D : is-covariant A D) ( \u03d5 : ( z : A) \u2192 C z \u2192 D z) ( u : C x) : ( covariant-transport A x y f D is-covariant-D (\u03d5 x u)) = ( \u03d5 y (covariant-transport A x y f C is-covariant-C u)) := covariant-uniqueness A x y f D is-covariant-D (\u03d5 x u) ( covariant-fiberwise-transformation-application A x y f C D is-covariant-C \u03d5 u) Covariant equivalence \u00b6 A family of types that is equivalent to a covariant family is itself covariant. To prove this we first show that the corresponding types of lifts with fixed domain are equivalent: #def equiv-covariant-total-dhom ( A : U) ( C : A \u2192 U) ( x y : A) ( f : hom A x y) : Equiv ( (t : \u0394\u00b9) \u2192 C (f t)) ( \u03a3 (u : C x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u])) := ( ( \\ h \u2192 (h 0\u2082 , \\ t \u2192 h t)) , ( ( \\ k t \u2192 ( second k) t , \\ h \u2192 refl ) , ( ( \\ k t \u2192 ( second k) t , \\ h \u2192 refl )))) #section dhom-from-equivalence #variable A : U #variables B C : A \u2192 U #variable equiv-BC : ( a : A) \u2192 Equiv (B a) (C a) #variables x y : A #variable f : hom A x y #def equiv-total-dhom-equiv uses ( A x y ) : Equiv ( (t : \u0394\u00b9) \u2192 B (f t)) ( (t : \u0394\u00b9) \u2192 C (f t)) := equiv-extension-equiv-family ( extext) ( 2 ) ( \u0394\u00b9) ( \\ t \u2192 B (f t)) ( \\ t \u2192 C (f t)) ( \\ t \u2192 equiv-BC (f t)) #def equiv-total-covariant-dhom-equiv uses ( extext equiv-BC ) : Equiv ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])) ( \u03a3 (u : C x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u])) := equiv-triple-comp ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])) ( (t : \u0394\u00b9) \u2192 B (f t)) ( (t : \u0394\u00b9) \u2192 C (f t)) ( \u03a3 (u : C x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u])) ( inv-equiv ( (t : \u0394\u00b9) \u2192 B (f t)) ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])) ( equiv-covariant-total-dhom A B x y f)) ( equiv-total-dhom-equiv) ( equiv-covariant-total-dhom A C x y f) #def equiv-pullback-total-covariant-dhom-equiv uses ( A y ) : Equiv ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) i])) ( \u03a3 (u : C x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u])) := total-equiv-pullback-is-equiv ( B x) ( C x) ( first (equiv-BC x)) ( second (equiv-BC x)) ( \\ u \u2192 ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u])) #def is-equiv-to-pullback-total-covariant-dhom-equiv uses ( extext A y ) : is-equiv ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])) ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) i])) ( \\ (i , h) \u2192 (i , \\ t \u2192 ( first (equiv-BC (f t))) (h t))) := is-equiv-right-factor ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])) ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) i])) ( \u03a3 (u : C x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u])) ( \\ (i , h) \u2192 (i , \\ t \u2192 ( first (equiv-BC (f t))) (h t))) ( first (equiv-pullback-total-covariant-dhom-equiv)) ( second (equiv-pullback-total-covariant-dhom-equiv)) ( second (equiv-total-covariant-dhom-equiv)) #def equiv-to-pullback-total-covariant-dhom-equiv uses ( extext A y ) : Equiv ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])) ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) i])) := ( \\ (i , h) \u2192 (i , \\ t \u2192 ( first (equiv-BC (f t))) (h t)) , is-equiv-to-pullback-total-covariant-dhom-equiv) #def family-equiv-dhom-family-equiv uses ( extext A y ) ( i : B x) : Equiv ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]) ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) i]) := family-equiv-total-equiv ( B x) ( \\ ii \u2192 ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 ii])) ( \\ ii \u2192 ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) ii])) ( \\ ii h t \u2192 ( first (equiv-BC (f t))) (h t)) ( is-equiv-to-pullback-total-covariant-dhom-equiv) ( i) #end dhom-from-equivalence Now we introduce the hypothesis that \\(C\\) is covariant in the form of has-unique-fixed-domain-lifts . #def equiv-has-unique-fixed-domain-lifts uses ( extext ) ( A : U) ( B C : A \u2192 U) ( equiv-BC : ( a : A) \u2192 Equiv (B a) (C a)) ( has-unique-fixed-domain-lifts-C : has-unique-fixed-domain-lifts A C) : has-unique-fixed-domain-lifts A B := \\ x y f i \u2192 is-contr-equiv-is-contr' ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]) ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) i]) ( family-equiv-dhom-family-equiv A B C equiv-BC x y f i) ( has-unique-fixed-domain-lifts-C x y f (( first (equiv-BC x)) i)) #def equiv-is-covariant uses ( extext ) ( A : U) ( B C : A \u2192 U) ( equiv-BC : ( a : A) \u2192 Equiv (B a) (C a)) ( is-covariant-C : is-covariant A C) : is-covariant A B := ( first (has-unique-fixed-domain-lifts-iff-is-covariant A B)) ( equiv-has-unique-fixed-domain-lifts A B C equiv-BC ( ( second (has-unique-fixed-domain-lifts-iff-is-covariant A C)) is-covariant-C)) Contravariant families \u00b6 A family of types over a base type is contravariant if every arrow in the base has a unique lift with specified codomain. #def dhom-to ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( v : C y) : U := ( \u03a3 (u : C x) , dhom A x y f C u v) RS17, Definition 8.2, dual form #def is-contravariant ( A : U) ( C : A \u2192 U) : U := ( x : A) \u2192 ( y : A) \u2192 ( f : hom A x y) \u2192 ( v : C y) \u2192 is-contr (dhom-to A x y f C v) The type of contravariant families over a fixed type #def contravariant-family ( A : U) : U := ( \u03a3 (C : A \u2192 U) , is-contravariant A C) The notion of having a unique lift with a fixed codomain may also be expressed by contractibility of the type of extensions along the codomain inclusion into the 1-simplex. #def has-unique-fixed-codomain-lifts ( A : U) ( C : A \u2192 U) : U := ( x : A) \u2192 ( y : A) \u2192 ( f : hom A x y) \u2192 ( v : C y) \u2192 is-contr ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v]) These two notions of covariance are equivalent because the two types of lifts of a base arrow with fixed codomain are equivalent. Note that this is not quite an instance of Theorem 4.4 but its proof, with a very small modification, works here. #def equiv-lifts-with-fixed-codomain ( A : U) ( C : A \u2192 U) ( x y : A) ( f : hom A x y) ( v : C y) : Equiv ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v]) ( dhom-to A x y f C v) := ( ( \\ h \u2192 (h 0\u2082 , \\ t \u2192 h t)) , ( ( \\ fg t \u2192 ( second fg) t , \\ h \u2192 refl ) , ( ( \\ fg t \u2192 ( second fg) t , \\ h \u2192 refl )))) By the equivalence-invariance of contractibility, this proves the desired logical equivalence RS17, Proposition 8.4 #def has-unique-fixed-codomain-lifts-iff-is-contravariant ( A : U) ( C : A \u2192 U) : iff ( has-unique-fixed-codomain-lifts A C) ( is-contravariant A C) := ( ( \\ C-has-unique-lifts x y f v \u2192 is-contr-equiv-is-contr ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v]) ( dhom-to A x y f C v) ( equiv-lifts-with-fixed-codomain A C x y f v) ( C-has-unique-lifts x y f v)) , ( \\ is-contravariant-C x y f v \u2192 is-contr-equiv-is-contr' ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v]) ( dhom-to A x y f C v) ( equiv-lifts-with-fixed-codomain A C x y f v) ( is-contravariant-C x y f v))) Representable contravariant families \u00b6 If A is a Segal type and a : A is any term, then the family \\ x \u2192 hom A x a defines a contravariant family over A , and conversely if this family is contravariant for every a : A , then A must be a Segal type. The proof involves a rather lengthy composition of equivalences. #def dhom-contra-representable ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A x a) ( v : hom A y a) : U := dhom A x y f ( \\ z \u2192 hom A z a) u v By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhom-contra-representable ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A x a) ( v : hom A y a) : Equiv ( dhom-contra-representable A a x y f u v) ( ((t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a]) := curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 ( \\ t s \u2192 A) ( \\ (t , s) \u2192 recOR ( (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a)) #def dhom-to-representable ( A : U) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : U := dhom-to A x y f ( \\ z \u2192 hom A z a) v By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhom-to-representable ( A : U) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( dhom-to-representable A a x y f v) ( \u03a3 (u : hom A x a) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a])) := total-equiv-family-equiv ( hom A x a) ( \\ u \u2192 dhom-contra-representable A a x y f u v) ( \\ u \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a])) ( \\ u \u2192 uncurried-dhom-contra-representable A a x y f u v) #def representable-dhom-to-uncurry-hom2 ( A : U) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( \u03a3 ( u : hom A x a) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a])) ( \u03a3 (u : hom A x a) , ( \u03a3 (d : hom A x a) , product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))) := total-equiv-family-equiv (hom A x a) ( \\ u \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a])) ( \\ u \u2192 \u03a3 ( d : hom A x a) , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))) ( \\ u \u2192 equiv-square-hom2-pushout A x a y a u (id-hom A a) f v) #def representable-dhom-to-hom2 ( A : U) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( dhom-to-representable A a x y f v) ( \u03a3 (d : hom A x a) , ( \u03a3 (u : hom A x a) , product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))) := equiv-triple-comp ( dhom-to-representable A a x y f v) ( \u03a3 ( u : hom A x a) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a])) ( \u03a3 ( u : hom A x a) , ( \u03a3 ( d : hom A x a) , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))) ( \u03a3 ( d : hom A x a) , ( \u03a3 ( u : hom A x a) , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))) ( uncurried-dhom-to-representable A a x y f v) ( representable-dhom-to-uncurry-hom2 A a x y f v) ( fubini-\u03a3 (hom A x a) (hom A x a) ( \\ u d \u2192 product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))) #def representable-dhom-to-hom2-swap ( A : U) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( dhom-to-representable A a x y f v) ( \u03a3 ( d : hom A x a) , ( \u03a3 ( u : hom A x a) , ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d)))) := equiv-comp ( dhom-to-representable A a x y f v) ( \u03a3 ( d : hom A x a) , ( \u03a3 ( u : hom A x a) , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))) ( \u03a3 ( d : hom A x a) , ( \u03a3 ( u : hom A x a) , ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d)))) ( representable-dhom-to-hom2 A a x y f v) ( total-equiv-family-equiv (hom A x a) ( \\ d \u2192 \u03a3 ( u : hom A x a) , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))) ( \\ d \u2192 \u03a3 ( u : hom A x a) , ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d))) ( \\ d \u2192 total-equiv-family-equiv (hom A x a) ( \\ u \u2192 product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)) ( \\ u \u2192 product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d)) ( \\ u \u2192 sym-product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))) #def representable-dhom-to-hom2-dist ( A : U) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( dhom-to-representable A a x y f v) ( \u03a3 ( d : hom A x a) , ( product ( hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d))) := equiv-right-cancel ( dhom-to-representable A a x y f v) ( \u03a3 (d : hom A x a) , ( product ( hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d))) ( \u03a3 ( d : hom A x a) , ( \u03a3 (u : hom A x a) , product ( hom2 A x y a f v d) ( hom2 A x a a u (id-hom A a) d))) ( representable-dhom-to-hom2-swap A a x y f v) ( total-equiv-family-equiv (hom A x a) ( \\ d \u2192 ( product ( hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d))) ( \\ d \u2192 ( \u03a3 ( u : hom A x a) , ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d)))) ( \\ d \u2192 ( distributive-product-\u03a3 ( hom2 A x y a f v d) ( hom A x a) ( \\ u \u2192 hom2 A x a a u (id-hom A a) d)))) Now we introduce the hypothesis that A is Segal type. #def representable-dhom-to-path-space-is-segal ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( dhom-to-representable A a x y f v) ( \u03a3 ( d : hom A x a) , ( product (hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , (u = d)))) := equiv-right-cancel ( dhom-to-representable A a x y f v) ( \u03a3 ( d : hom A x a) , ( product (hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , (u = d)))) ( \u03a3 ( d : hom A x a) , ( product ( hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , (hom2 A x a a u (id-hom A a) d)))) ( representable-dhom-to-hom2-dist A a x y f v) ( total-equiv-family-equiv (hom A x a) ( \\ d \u2192 product (hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , (u = d))) ( \\ d \u2192 product ( hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d)) ( \\ d \u2192 total-equiv-family-equiv ( hom2 A x y a f v d) ( \\ \u03b1 \u2192 (\u03a3 (u : hom A x a) , (u = d))) ( \\ \u03b1 \u2192 (\u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d)) ( \\ \u03b1 \u2192 ( total-equiv-family-equiv ( hom A x a) ( \\ u \u2192 (u = d)) ( \\ u \u2192 hom2 A x a a u (id-hom A a) d) ( \\ u \u2192 equiv-homotopy-hom2'-is-segal A is-segal-A x a u d))))) #def is-segal-representable-dhom-to-hom2 ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( dhom-to-representable A a x y f v) ( \u03a3 (d : hom A x a) , (hom2 A x y a f v d)) := equiv-comp ( dhom-to-representable A a x y f v) ( \u03a3 ( d : hom A x a) , ( product (hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , (u = d)))) ( \u03a3 (d : hom A x a) , (hom2 A x y a f v d)) ( representable-dhom-to-path-space-is-segal A is-segal-A a x y f v) ( total-equiv-family-equiv ( hom A x a) ( \\ d \u2192 product (hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , (u = d))) ( \\ d \u2192 hom2 A x y a f v d) ( \\ d \u2192 codomain-based-paths-contraction A x y a v f d)) #def is-segal-representable-dhom-to-contractible ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : is-contr (dhom-to-representable A a x y f v) := is-contr-equiv-is-contr' ( dhom-to-representable A a x y f v) ( \u03a3 (d : hom A x a) , (hom2 A x y a f v d)) ( is-segal-representable-dhom-to-hom2 A is-segal-A a x y f v) ( is-segal-A x y a f v) Finally, we see that contravariant hom families in a Segal type are contravariant. RS17, Proposition 8.13( < -), dual #def is-contravariant-representable-is-segal ( A : U) ( is-segal-A : is-segal A) ( a : A) : is-contravariant A ( \\ x \u2192 hom A x a) := is-segal-representable-dhom-to-contractible A is-segal-A a The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for Segal types - so instead we argue as follows: RS17, Proposition 8.13(\u2192), dual #def is-segal-is-contravariant-representable ( A : U) ( representable-family-is-contravariant : ( a : A) \u2192 is-contravariant A ( \\ x \u2192 hom A x a)) : is-segal A := \\ x y z f g \u2192 is-contr-base-is-contr-\u03a3 ( \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) ( \\ hk \u2192 \u03a3 (u : hom A x z) , (hom2 A x z z u (id-hom A z) ( first hk))) ( \\ hk \u2192 ( first hk , \\ (t , s) \u2192 first hk t)) ( is-contr-equiv-is-contr' ( \u03a3 ( hk : \u03a3 ( h : hom A x z) , (hom2 A x y z f g h)) , ( \u03a3 (u : hom A x z) , hom2 A x z z u (id-hom A z) ( first hk))) ( dhom-to-representable A z x y f g) ( inv-equiv ( dhom-to-representable A z x y f g) ( \u03a3 ( hk : \u03a3 ( h : hom A x z) , (hom2 A x y z f g h)) , ( \u03a3 (u : hom A x z) , hom2 A x z z u (id-hom A z) ( first hk))) ( equiv-comp ( dhom-to-representable A z x y f g) ( \u03a3 ( h : hom A x z) , ( product ( hom2 A x y z f g h) ( \u03a3 (u : hom A x z) , hom2 A x z z u (id-hom A z) h))) ( \u03a3 ( hk : \u03a3 ( h : hom A x z) , (hom2 A x y z f g h)) , ( \u03a3 (u : hom A x z) , hom2 A x z z u (id-hom A z) ( first hk))) ( representable-dhom-to-hom2-dist A z x y f g) ( associative-\u03a3 ( hom A x z) ( \\ h \u2192 hom2 A x y z f g h) ( \\ h _ \u2192 \u03a3 (u : hom A x z) , (hom2 A x z z u (id-hom A z) h))))) ( representable-family-is-contravariant z x y f g)) Contravariant lifts, transport, and uniqueness \u00b6 In a contravariant family C over a base type A, a term v : C y may be transported along an arrow f : hom A x y to give a term in C x. RS17, contravariant transport from beginning of Section 8.2 #def contravariant-transport ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( v : C y) : C x := first ( center-contraction (dhom-to A x y f C v) (is-contravariant-C x y f v)) RS17, contravariant lift from beginning of Section 8.2 #def contravariant-lift ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( v : C y) : ( dhom A x y f C (contravariant-transport A x y f C is-contravariant-C v) v) := second ( center-contraction (dhom-to A x y f C v) (is-contravariant-C x y f v)) #def contravariant-uniqueness ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( v : C y) ( lift : dhom-to A x y f C v) : ( contravariant-transport A x y f C is-contravariant-C v) = ( first lift) := first-path-\u03a3 ( C x) ( \\ u \u2192 dhom A x y f C u v) ( center-contraction ( dhom-to A x y f C v) ( is-contravariant-C x y f v)) ( lift) ( homotopy-contraction ( dhom-to A x y f C v) ( is-contravariant-C x y f v) ( lift)) Contravariant functoriality \u00b6 The contravariant transport operation defines a comtravariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law. RS17, Proposition 8.16, Part 2, dual, Contravariant families preserve identities #def id-arr-contravariant-transport ( A : U) ( x : A) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( u : C x) : ( contravariant-transport A x x (id-hom A x) C is-contravariant-C u) = u := contravariant-uniqueness A x x (id-hom A x) C is-contravariant-C u ( u , id-dhom A x C u) Contravariant natural transformations \u00b6 A fiberwise map between contrvariant families is automatically \"natural\" commuting with the contravariant lifts. RS17, Proposition 8.17, dual, Contravariant naturality #def contravariant-fiberwise-transformation-application ( A : U) ( x y : A) ( f : hom A x y) ( C D : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( \u03d5 : ( z : A) \u2192 C z \u2192 D z) ( v : C y) : dhom-to A x y f D (\u03d5 y v) := ( \u03d5 x (contravariant-transport A x y f C is-contravariant-C v) , \\ t \u2192 \u03d5 (f t) (contravariant-lift A x y f C is-contravariant-C v t)) #def naturality-contravariant-fiberwise-transformation ( A : U) ( x y : A) ( f : hom A x y) ( C D : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( is-contravariant-D : is-contravariant A D) ( \u03d5 : ( z : A) \u2192 C z \u2192 D z) ( v : C y) : ( contravariant-transport A x y f D is-contravariant-D (\u03d5 y v)) = ( \u03d5 x (contravariant-transport A x y f C is-contravariant-C v)) := contravariant-uniqueness A x y f D is-contravariant-D (\u03d5 y v) ( contravariant-fiberwise-transformation-application A x y f C D is-contravariant-C \u03d5 v)","title":"Covariantly Functorial Type Families"},{"location":"simplicial-hott/08-covariant.rzk/#covariantly-functorial-type-families","text":"These formalisations correspond to Section 8 of the RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Covariantly functorial type families"},{"location":"simplicial-hott/08-covariant.rzk/#prerequisites","text":"hott/* - We require various prerequisites from homotopy type theory, for instance the notion of contractible types. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 5-segal-types.md - We make use of the notion of Segal types and their structures. Some of the definitions in this file rely on extension extensionality: #assume extext : ExtExt","title":"Prerequisites"},{"location":"simplicial-hott/08-covariant.rzk/#dependent-hom-types","text":"In a type family over a base type, there is a dependent hom type of arrows that live over a specified arrow in the base type. RS17, Section 8 Prelim #def dhom ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( u : C x) ( v : C y) : U := ( t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u , t \u2261 1\u2082 \u21a6 v] It will be convenient to collect together dependent hom types with fixed domain but varying codomain. #def dhom-from ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( u : C x) : U := ( \u03a3 (v : C y) , dhom A x y f C u v) There is also a type of dependent commutative triangles over a base commutative triangle. #def dhom2 ( A : U) ( x y z : A) ( f : hom A x y) ( g : hom A y z) ( h : hom A x z) ( \u03b1 : hom2 A x y z f g h) ( C : A \u2192 U) ( u : C x) ( v : C y) ( w : C z) ( ff : dhom A x y f C u v) ( gg : dhom A y z g C v w) ( hh : dhom A x z h C u w) : U := ( (t1 , t2) : \u0394\u00b2) \u2192 C (\u03b1 (t1 , t2)) [ t2 \u2261 0\u2082 \u21a6 ff t1 , t1 \u2261 1\u2082 \u21a6 gg t2 , t2 \u2261 t1 \u21a6 hh t2 ]","title":"Dependent hom types"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-families","text":"A family of types over a base type is covariant if every arrow in the base has a unique lift with specified domain. RS17, Definition 8.2 #def is-covariant ( A : U) ( C : A \u2192 U) : U := ( x : A) \u2192 ( y : A) \u2192 ( f : hom A x y) \u2192 ( u : C x) \u2192 is-contr (dhom-from A x y f C u) The type of covariant families over a fixed type #def covariant-family ( A : U) : U := ( \u03a3 (C : (A \u2192 U)) , is-covariant A C) The notion of having a unique lift with a fixed domain may also be expressed by contractibility of the type of extensions along the domain inclusion into the 1-simplex. #def has-unique-fixed-domain-lifts ( A : U) ( C : A \u2192 U) : U := ( x : A) \u2192 ( y : A) \u2192 ( f : hom A x y) \u2192 ( u : C x) \u2192 is-contr ( (t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u]) These two notions of covariance are equivalent because the two types of lifts of a base arrow with fixed domain are equivalent. Note that this is not quite an instance of Theorem 4.4 but its proof, with a very small modification, works here. #def equiv-lifts-with-fixed-domain ( A : U) ( C : A \u2192 U) ( x y : A) ( f : hom A x y) ( u : C x) : Equiv ( (t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u]) (dhom-from A x y f C u) := ( \\ h \u2192 (h 1\u2082 , \\ t \u2192 h t) , ( ( \\ fg t \u2192 ( second fg) t , \\ h \u2192 refl ) , ( ( \\ fg t \u2192 ( second fg) t , \\ h \u2192 refl )))) By the equivalence-invariance of contractibility, this proves the desired logical equivalence RS17, Proposition 8.4 #def has-unique-fixed-domain-lifts-iff-is-covariant ( A : U) ( C : A \u2192 U) : iff ( has-unique-fixed-domain-lifts A C) ( is-covariant A C) := ( ( \\ C-has-unique-lifts x y f u \u2192 is-contr-equiv-is-contr ( (t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u]) ( dhom-from A x y f C u) ( equiv-lifts-with-fixed-domain A C x y f u) ( C-has-unique-lifts x y f u)) , ( \\ C-is-covariant x y f u \u2192 is-contr-equiv-is-contr' ( (t : \u0394\u00b9) \u2192 C (f t) [ t \u2261 0\u2082 \u21a6 u]) ( dhom-from A x y f C u) ( equiv-lifts-with-fixed-domain A C x y f u) ( C-is-covariant x y f u)))","title":"Covariant families"},{"location":"simplicial-hott/08-covariant.rzk/#representable-covariant-families","text":"If A is a Segal type and a : A is any term, then hom A a defines a covariant family over A, and conversely if this family is covariant for every a : A, then A must be a Segal type. The proof involves a rather lengthy composition of equivalences. #def dhom-representable ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) ( v : hom A a y) : U := dhom A x y f ( \\ z \u2192 hom A a z) u v By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhom-representable ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) ( v : hom A a y) : Equiv ( dhom-representable A a x y f u v) ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) := curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 ( \\ t s \u2192 A) ( \\ (t , s) \u2192 recOR ( (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t)) #def dhom-from-representable ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : U := dhom-from A x y f ( \\ z \u2192 hom A a z) u By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhom-from-representable ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( \u03a3 ( v : hom A a y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) := total-equiv-family-equiv ( hom A a y) ( \\ v \u2192 dhom-representable A a x y f u v) ( \\ v \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( \\ v \u2192 uncurried-dhom-representable A a x y f u v) #def square-to-hom2-pushout ( A : U) ( w x y z : A) ( u : hom A w x) ( f : hom A x z) ( g : hom A w y) ( v : hom A y z) : ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 g t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) \u2192 ( \u03a3 (d : hom A w z) , product (hom2 A w x z u f d) (hom2 A w y z g v d)) := \\ sq \u2192 ( ( \\ t \u2192 sq (t , t)) , (\\ (t , s) \u2192 sq (s , t) , \\ (t , s) \u2192 sq (t , s))) #def hom2-pushout-to-square ( A : U) ( w x y z : A) ( u : hom A w x) ( f : hom A x z) ( g : hom A w y) ( v : hom A y z) : ( \u03a3 ( d : hom A w z) , ( product (hom2 A w x z u f d) (hom2 A w y z g v d))) \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 g t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) := \\ (d , (\u03b11 , \u03b12)) (t , s) \u2192 recOR ( t \u2264 s \u21a6 \u03b11 (s , t) , s \u2264 t \u21a6 \u03b12 (t , s)) #def equiv-square-hom2-pushout ( A : U) ( w x y z : A) ( u : hom A w x) ( f : hom A x z) ( g : hom A w y) ( v : hom A y z) : Equiv ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 g t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( \u03a3 (d : hom A w z) , (product (hom2 A w x z u f d) (hom2 A w y z g v d))) := ( ( square-to-hom2-pushout A w x y z u f g v) , ( ( hom2-pushout-to-square A w x y z u f g v , \\ sq \u2192 refl ) , ( hom2-pushout-to-square A w x y z u f g v , \\ \u03b1s \u2192 refl ))) #def representable-dhom-from-uncurry-hom2 ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( \u03a3 (v : hom A a y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( \u03a3 ( v : hom A a y) , ( \u03a3 ( d : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) := total-equiv-family-equiv ( hom A a y) ( \\ v \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( \\ v \u2192 ( \u03a3 ( d : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) ( \\ v \u2192 equiv-square-hom2-pushout A a x a y u f (id-hom A a) v) #def representable-dhom-from-hom2 ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( \u03a3 ( d : hom A a y) , ( \u03a3 ( v : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) := equiv-triple-comp ( dhom-from-representable A a x y f u) ( \u03a3 ( v : hom A a y) , ( ((t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( \u03a3 ( v : hom A a y) , ( \u03a3 ( d : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) ( \u03a3 ( d : hom A a y) , ( \u03a3 ( v : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) ( uncurried-dhom-from-representable A a x y f u) ( representable-dhom-from-uncurry-hom2 A a x y f u) ( fubini-\u03a3 (hom A a y) (hom A a y) ( \\ v d \u2192 product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d))) #def representable-dhom-from-hom2-dist ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( \u03a3 ( d : hom A a y) , ( product ( hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (hom2 A a a y (id-hom A a) v d)))) := equiv-right-cancel ( dhom-from-representable A a x y f u) ( \u03a3 ( d : hom A a y) , ( product ( hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d))) ( \u03a3 ( d : hom A a y) , ( \u03a3 ( v : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) ( representable-dhom-from-hom2 A a x y f u) ( total-equiv-family-equiv ( hom A a y) ( \\ d \u2192 ( product ( hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (hom2 A a a y (id-hom A a) v d)))) ( \\ d \u2192 ( \u03a3 ( v : hom A a y) , ( product (hom2 A a x y u f d) (hom2 A a a y (id-hom A a) v d)))) ( \\ d \u2192 ( distributive-product-\u03a3 ( hom2 A a x y u f d) ( hom A a y) ( \\ v \u2192 hom2 A a a y (id-hom A a) v d)))) Now we introduce the hypothesis that A is Segal type. #def representable-dhom-from-path-space-is-segal ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( \u03a3 ( d : hom A a y) , ( product (hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (v = d)))) := equiv-right-cancel ( dhom-from-representable A a x y f u) ( \u03a3 ( d : hom A a y) , ( product (hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (v = d)))) ( \u03a3 ( d : hom A a y) , ( product ( hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d))) ( representable-dhom-from-hom2-dist A a x y f u) ( total-equiv-family-equiv ( hom A a y) ( \\ d \u2192 product (hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (v = d))) ( \\ d \u2192 ( product ( hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d))) ( \\ d \u2192 ( total-equiv-family-equiv ( hom2 A a x y u f d) ( \\ \u03b1 \u2192 (\u03a3 (v : hom A a y) , (v = d))) ( \\ \u03b1 \u2192 (\u03a3 (v : hom A a y) , hom2 A a a y (id-hom A a) v d)) ( \\ \u03b1 \u2192 ( total-equiv-family-equiv ( hom A a y) ( \\ v \u2192 (v = d)) ( \\ v \u2192 hom2 A a a y (id-hom A a) v d) ( \\ v \u2192 (equiv-homotopy-hom2-is-segal A is-segal-A a y v d))))))) #def codomain-based-paths-contraction ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) ( d : hom A a y) : Equiv ( product (hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (v = d))) ( hom2 A a x y u f d) := equiv-projection-contractible-fibers ( hom2 A a x y u f d) ( \\ \u03b1 \u2192 (\u03a3 (v : hom A a y) , (v = d))) ( \\ \u03b1 \u2192 is-contr-codomain-based-paths (hom A a y) d) #def is-segal-representable-dhom-from-hom2 ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( \u03a3 (d : hom A a y) , (hom2 A a x y u f d)) := equiv-comp ( dhom-from-representable A a x y f u) ( \u03a3 (d : hom A a y) , ( product (hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (v = d)))) ( \u03a3 (d : hom A a y) , (hom2 A a x y u f d)) ( representable-dhom-from-path-space-is-segal A is-segal-A a x y f u) ( total-equiv-family-equiv ( hom A a y) ( \\ d \u2192 product (hom2 A a x y u f d) ( \u03a3 (v : hom A a y) , (v = d))) ( \\ d \u2192 hom2 A a x y u f d) ( \\ d \u2192 codomain-based-paths-contraction A a x y f u d)) #def is-segal-representable-dhom-from-contractible ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : is-contr (dhom-from-representable A a x y f u) := is-contr-equiv-is-contr' ( dhom-from-representable A a x y f u) ( \u03a3 (d : hom A a y) , (hom2 A a x y u f d)) ( is-segal-representable-dhom-from-hom2 A is-segal-A a x y f u) ( is-segal-A a x y u f) Finally, we see that covariant hom families in a Segal type are covariant. RS17, Proposition 8.13( < -) #def is-covariant-representable-is-segal ( A : U) ( is-segal-A : is-segal A) ( a : A) : is-covariant A ( \\ x \u2192 hom A a x) := is-segal-representable-dhom-from-contractible A is-segal-A a The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for Segal types - so instead we argue as follows: RS17, Proposition 8.13(\u2192) #def is-segal-is-covariant-representable ( A : U) ( corepresentable-family-is-covariant : ( a : A) \u2192 is-covariant A ( \\ x \u2192 hom A a x)) : is-segal A := \\ x y z f g \u2192 is-contr-base-is-contr-\u03a3 ( \u03a3 (h : hom A x z) , hom2 A x y z f g h) ( \\ hk \u2192 \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v ( first hk)) ( \\ hk \u2192 ( first hk , \\ (t , s) \u2192 first hk s)) ( is-contr-equiv-is-contr' ( \u03a3 ( hk : \u03a3 ( h : hom A x z) , hom2 A x y z f g h) , ( \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v ( first hk))) ( dhom-from-representable A x y z g f) ( inv-equiv ( dhom-from-representable A x y z g f) ( \u03a3 ( hk : \u03a3 ( h : hom A x z) , hom2 A x y z f g h) , ( \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v ( first hk))) ( equiv-comp ( dhom-from-representable A x y z g f) ( \u03a3 ( h : hom A x z) , ( product ( hom2 A x y z f g h) ( \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v h))) ( \u03a3 ( hk : \u03a3 ( h : hom A x z) , hom2 A x y z f g h) , ( \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v ( first hk))) ( representable-dhom-from-hom2-dist A x y z g f) ( associative-\u03a3 ( hom A x z) ( \\ h \u2192 hom2 A x y z f g h) ( \\ h _ \u2192 \u03a3 (v : hom A x z) , hom2 A x x z (id-hom A x) v h)))) ( corepresentable-family-is-covariant x y z g f)) While not needed to prove Proposition 8.13, it is interesting to observe that the dependent hom types in a representable family can be understood as extension types as follows. #def cofibration-union-test ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( ( (t , s) : 2 \u00d7 2 | (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s)) \u2192 A [ (t \u2261 1\u2082 ) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (t \u2261 1\u2082 ) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) := cofibration-union ( 2 \u00d7 2 ) ( \\ (t , s) \u2192 (t \u2261 1\u2082 ) \u2227 \u0394\u00b9 s) ( \\ (t , s) \u2192 ((t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s)) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 )) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ))) ( \\ (t , s) \u2192 A) ( \\ (t , s) \u2192 recOR ( (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t)) #def base-hom-rewriting ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( ( (t , s) : 2 \u00d7 2 | (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s)) \u2192 A [ (t \u2261 1\u2082 ) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (t \u2261 1\u2082 ) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) ( hom A a y) := ( ( \\ v \u2192 ( \\ r \u2192 v (( 1\u2082 , r)))) , ( ( \\ v (t , s) \u2192 v s , \\ _ \u2192 refl ) , ( \\ v (_ , s) \u2192 v s , \\ _ \u2192 refl ))) #def base-hom-expansion ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( hom A a y) := equiv-comp ( ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( ( (t , s) : 2 \u00d7 2 | (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s)) \u2192 A [ (t \u2261 1\u2082 ) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (t \u2261 1\u2082 ) \u2227 (s \u2261 1\u2082 ) \u21a6 y]) ( hom A a y) ( cofibration-union-test A a x y f u) ( base-hom-rewriting A a x y f u) #def representable-dhom-from-expansion ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( \u03a3 ( sq : ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 (sq ( 1\u2082 , s)) , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( \u03a3 ( v : hom A a y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) := total-equiv-pullback-is-equiv ( ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( hom A a y) ( first (base-hom-expansion A a x y f u)) ( second (base-hom-expansion A a x y f u)) ( \\ v \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) #def representable-dhom-from-composite-expansion ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( \u03a3 ( sq : ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 (sq ( 1\u2082 , s)) , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) := equiv-right-cancel ( dhom-from-representable A a x y f u) ( \u03a3 ( sq : ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 (sq ( 1\u2082 , s)) , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( \u03a3 ( v : hom A a y) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( uncurried-dhom-from-representable A a x y f u) ( representable-dhom-from-expansion A a x y f u) #def representable-dhom-from-cofibration-composition ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( \u03a3 ( sq : ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 (sq ( 1\u2082 , s)) , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) := cofibration-composition ( 2 \u00d7 2 ) \u0394\u00b9\u00d7\u0394\u00b9 \u2202\u25a1 ( \\ (t , s) \u2192 ( (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s)) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 )) \u2228 ((\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ))) ( \\ ts \u2192 A) ( \\ (t , s) \u2192 recOR ( (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t)) #def representable-dhom-from-as-extension-type ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A a x) : Equiv ( dhom-from-representable A a x y f u) ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) := equiv-right-cancel ( dhom-from-representable A a x y f u) ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) ( \u03a3 ( sq : ( (t , s) : \u2202\u25a1) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t]) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 (sq ( 1\u2082 , s)) , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 a , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 f t])) ( representable-dhom-from-composite-expansion A a x y f u) ( representable-dhom-from-cofibration-composition A a x y f u)","title":"Representable covariant families"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-lifts-transport-and-uniqueness","text":"In a covariant family C over a base type A , a term u : C x may be transported along an arrow f : hom A x y to give a term in C y. RS17, covariant transport from beginning of Section 8.2 #def covariant-transport ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) ( u : C x) : C y := first (center-contraction (dhom-from A x y f C u) (is-covariant-C x y f u)) RS17, covariant lift from beginning of Section 8.2 #def covariant-lift ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) ( u : C x) : ( dhom A x y f C u (covariant-transport A x y f C is-covariant-C u)) := second (center-contraction (dhom-from A x y f C u) (is-covariant-C x y f u)) #def covariant-uniqueness ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) ( u : C x) ( lift : dhom-from A x y f C u) : ( covariant-transport A x y f C is-covariant-C u) = ( first lift) := first-path-\u03a3 ( C y) ( \\ v \u2192 dhom A x y f C u v) ( center-contraction (dhom-from A x y f C u) (is-covariant-C x y f u)) ( lift) ( homotopy-contraction (dhom-from A x y f C u) (is-covariant-C x y f u) lift)","title":"Covariant lifts, transport, and uniqueness"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-functoriality","text":"The covariant transport operation defines a covariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law. #def id-dhom ( A : U) ( x : A) ( C : A \u2192 U) ( u : C x) : dhom A x x (id-hom A x) C u u := \\ t \u2192 u RS17, Proposition 8.16, Part 2, Covariant families preserve identities #def id-arr-covariant-transport ( A : U) ( x : A) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) ( u : C x) : ( covariant-transport A x x (id-hom A x) C is-covariant-C u) = u := covariant-uniqueness A x x (id-hom A x) C is-covariant-C u (u , id-dhom A x C u)","title":"Covariant functoriality"},{"location":"simplicial-hott/08-covariant.rzk/#natural-transformations","text":"A fiberwise map between covariant families is automatically \"natural\" commuting with the covariant lifts. RS17, Proposition 8.17, Covariant naturality #def covariant-fiberwise-transformation-application ( A : U) ( x y : A) ( f : hom A x y) ( C D : A \u2192 U) ( is-covariant-C : is-covariant A C) ( \u03d5 : ( z : A) \u2192 C z \u2192 D z) ( u : C x) : dhom-from A x y f D (\u03d5 x u) := ( ( \u03d5 y (covariant-transport A x y f C is-covariant-C u)) , ( \\ t \u2192 \u03d5 (f t) (covariant-lift A x y f C is-covariant-C u t))) #def naturality-covariant-fiberwise-transformation ( A : U) ( x y : A) ( f : hom A x y) ( C D : A \u2192 U) ( is-covariant-C : is-covariant A C) ( is-covariant-D : is-covariant A D) ( \u03d5 : ( z : A) \u2192 C z \u2192 D z) ( u : C x) : ( covariant-transport A x y f D is-covariant-D (\u03d5 x u)) = ( \u03d5 y (covariant-transport A x y f C is-covariant-C u)) := covariant-uniqueness A x y f D is-covariant-D (\u03d5 x u) ( covariant-fiberwise-transformation-application A x y f C D is-covariant-C \u03d5 u)","title":"Natural transformations"},{"location":"simplicial-hott/08-covariant.rzk/#covariant-equivalence","text":"A family of types that is equivalent to a covariant family is itself covariant. To prove this we first show that the corresponding types of lifts with fixed domain are equivalent: #def equiv-covariant-total-dhom ( A : U) ( C : A \u2192 U) ( x y : A) ( f : hom A x y) : Equiv ( (t : \u0394\u00b9) \u2192 C (f t)) ( \u03a3 (u : C x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u])) := ( ( \\ h \u2192 (h 0\u2082 , \\ t \u2192 h t)) , ( ( \\ k t \u2192 ( second k) t , \\ h \u2192 refl ) , ( ( \\ k t \u2192 ( second k) t , \\ h \u2192 refl )))) #section dhom-from-equivalence #variable A : U #variables B C : A \u2192 U #variable equiv-BC : ( a : A) \u2192 Equiv (B a) (C a) #variables x y : A #variable f : hom A x y #def equiv-total-dhom-equiv uses ( A x y ) : Equiv ( (t : \u0394\u00b9) \u2192 B (f t)) ( (t : \u0394\u00b9) \u2192 C (f t)) := equiv-extension-equiv-family ( extext) ( 2 ) ( \u0394\u00b9) ( \\ t \u2192 B (f t)) ( \\ t \u2192 C (f t)) ( \\ t \u2192 equiv-BC (f t)) #def equiv-total-covariant-dhom-equiv uses ( extext equiv-BC ) : Equiv ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])) ( \u03a3 (u : C x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u])) := equiv-triple-comp ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])) ( (t : \u0394\u00b9) \u2192 B (f t)) ( (t : \u0394\u00b9) \u2192 C (f t)) ( \u03a3 (u : C x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u])) ( inv-equiv ( (t : \u0394\u00b9) \u2192 B (f t)) ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])) ( equiv-covariant-total-dhom A B x y f)) ( equiv-total-dhom-equiv) ( equiv-covariant-total-dhom A C x y f) #def equiv-pullback-total-covariant-dhom-equiv uses ( A y ) : Equiv ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) i])) ( \u03a3 (u : C x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u])) := total-equiv-pullback-is-equiv ( B x) ( C x) ( first (equiv-BC x)) ( second (equiv-BC x)) ( \\ u \u2192 ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u])) #def is-equiv-to-pullback-total-covariant-dhom-equiv uses ( extext A y ) : is-equiv ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])) ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) i])) ( \\ (i , h) \u2192 (i , \\ t \u2192 ( first (equiv-BC (f t))) (h t))) := is-equiv-right-factor ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])) ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) i])) ( \u03a3 (u : C x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 u])) ( \\ (i , h) \u2192 (i , \\ t \u2192 ( first (equiv-BC (f t))) (h t))) ( first (equiv-pullback-total-covariant-dhom-equiv)) ( second (equiv-pullback-total-covariant-dhom-equiv)) ( second (equiv-total-covariant-dhom-equiv)) #def equiv-to-pullback-total-covariant-dhom-equiv uses ( extext A y ) : Equiv ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i])) ( \u03a3 (i : B x) , ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) i])) := ( \\ (i , h) \u2192 (i , \\ t \u2192 ( first (equiv-BC (f t))) (h t)) , is-equiv-to-pullback-total-covariant-dhom-equiv) #def family-equiv-dhom-family-equiv uses ( extext A y ) ( i : B x) : Equiv ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]) ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) i]) := family-equiv-total-equiv ( B x) ( \\ ii \u2192 ((t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 ii])) ( \\ ii \u2192 ((t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) ii])) ( \\ ii h t \u2192 ( first (equiv-BC (f t))) (h t)) ( is-equiv-to-pullback-total-covariant-dhom-equiv) ( i) #end dhom-from-equivalence Now we introduce the hypothesis that \\(C\\) is covariant in the form of has-unique-fixed-domain-lifts . #def equiv-has-unique-fixed-domain-lifts uses ( extext ) ( A : U) ( B C : A \u2192 U) ( equiv-BC : ( a : A) \u2192 Equiv (B a) (C a)) ( has-unique-fixed-domain-lifts-C : has-unique-fixed-domain-lifts A C) : has-unique-fixed-domain-lifts A B := \\ x y f i \u2192 is-contr-equiv-is-contr' ( (t : \u0394\u00b9) \u2192 B (f t) [t \u2261 0\u2082 \u21a6 i]) ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 0\u2082 \u21a6 ( first (equiv-BC x)) i]) ( family-equiv-dhom-family-equiv A B C equiv-BC x y f i) ( has-unique-fixed-domain-lifts-C x y f (( first (equiv-BC x)) i)) #def equiv-is-covariant uses ( extext ) ( A : U) ( B C : A \u2192 U) ( equiv-BC : ( a : A) \u2192 Equiv (B a) (C a)) ( is-covariant-C : is-covariant A C) : is-covariant A B := ( first (has-unique-fixed-domain-lifts-iff-is-covariant A B)) ( equiv-has-unique-fixed-domain-lifts A B C equiv-BC ( ( second (has-unique-fixed-domain-lifts-iff-is-covariant A C)) is-covariant-C))","title":"Covariant equivalence"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-families","text":"A family of types over a base type is contravariant if every arrow in the base has a unique lift with specified codomain. #def dhom-to ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( v : C y) : U := ( \u03a3 (u : C x) , dhom A x y f C u v) RS17, Definition 8.2, dual form #def is-contravariant ( A : U) ( C : A \u2192 U) : U := ( x : A) \u2192 ( y : A) \u2192 ( f : hom A x y) \u2192 ( v : C y) \u2192 is-contr (dhom-to A x y f C v) The type of contravariant families over a fixed type #def contravariant-family ( A : U) : U := ( \u03a3 (C : A \u2192 U) , is-contravariant A C) The notion of having a unique lift with a fixed codomain may also be expressed by contractibility of the type of extensions along the codomain inclusion into the 1-simplex. #def has-unique-fixed-codomain-lifts ( A : U) ( C : A \u2192 U) : U := ( x : A) \u2192 ( y : A) \u2192 ( f : hom A x y) \u2192 ( v : C y) \u2192 is-contr ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v]) These two notions of covariance are equivalent because the two types of lifts of a base arrow with fixed codomain are equivalent. Note that this is not quite an instance of Theorem 4.4 but its proof, with a very small modification, works here. #def equiv-lifts-with-fixed-codomain ( A : U) ( C : A \u2192 U) ( x y : A) ( f : hom A x y) ( v : C y) : Equiv ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v]) ( dhom-to A x y f C v) := ( ( \\ h \u2192 (h 0\u2082 , \\ t \u2192 h t)) , ( ( \\ fg t \u2192 ( second fg) t , \\ h \u2192 refl ) , ( ( \\ fg t \u2192 ( second fg) t , \\ h \u2192 refl )))) By the equivalence-invariance of contractibility, this proves the desired logical equivalence RS17, Proposition 8.4 #def has-unique-fixed-codomain-lifts-iff-is-contravariant ( A : U) ( C : A \u2192 U) : iff ( has-unique-fixed-codomain-lifts A C) ( is-contravariant A C) := ( ( \\ C-has-unique-lifts x y f v \u2192 is-contr-equiv-is-contr ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v]) ( dhom-to A x y f C v) ( equiv-lifts-with-fixed-codomain A C x y f v) ( C-has-unique-lifts x y f v)) , ( \\ is-contravariant-C x y f v \u2192 is-contr-equiv-is-contr' ( (t : \u0394\u00b9) \u2192 C (f t) [t \u2261 1\u2082 \u21a6 v]) ( dhom-to A x y f C v) ( equiv-lifts-with-fixed-codomain A C x y f v) ( is-contravariant-C x y f v)))","title":"Contravariant families"},{"location":"simplicial-hott/08-covariant.rzk/#representable-contravariant-families","text":"If A is a Segal type and a : A is any term, then the family \\ x \u2192 hom A x a defines a contravariant family over A , and conversely if this family is contravariant for every a : A , then A must be a Segal type. The proof involves a rather lengthy composition of equivalences. #def dhom-contra-representable ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A x a) ( v : hom A y a) : U := dhom A x y f ( \\ z \u2192 hom A z a) u v By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhom-contra-representable ( A : U) ( a x y : A) ( f : hom A x y) ( u : hom A x a) ( v : hom A y a) : Equiv ( dhom-contra-representable A a x y f u v) ( ((t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a]) := curry-uncurry 2 2 \u0394\u00b9 \u2202\u0394\u00b9 \u0394\u00b9 \u2202\u0394\u00b9 ( \\ t s \u2192 A) ( \\ (t , s) \u2192 recOR ( (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a)) #def dhom-to-representable ( A : U) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : U := dhom-to A x y f ( \\ z \u2192 hom A z a) v By uncurrying (RS 4.2) we have an equivalence: #def uncurried-dhom-to-representable ( A : U) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( dhom-to-representable A a x y f v) ( \u03a3 (u : hom A x a) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a])) := total-equiv-family-equiv ( hom A x a) ( \\ u \u2192 dhom-contra-representable A a x y f u v) ( \\ u \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a])) ( \\ u \u2192 uncurried-dhom-contra-representable A a x y f u v) #def representable-dhom-to-uncurry-hom2 ( A : U) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( \u03a3 ( u : hom A x a) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a])) ( \u03a3 (u : hom A x a) , ( \u03a3 (d : hom A x a) , product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))) := total-equiv-family-equiv (hom A x a) ( \\ u \u2192 ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a])) ( \\ u \u2192 \u03a3 ( d : hom A x a) , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))) ( \\ u \u2192 equiv-square-hom2-pushout A x a y a u (id-hom A a) f v) #def representable-dhom-to-hom2 ( A : U) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( dhom-to-representable A a x y f v) ( \u03a3 (d : hom A x a) , ( \u03a3 (u : hom A x a) , product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))) := equiv-triple-comp ( dhom-to-representable A a x y f v) ( \u03a3 ( u : hom A x a) , ( ( (t , s) : \u0394\u00b9\u00d7\u0394\u00b9) \u2192 A [ (t \u2261 0\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 u s , (t \u2261 1\u2082 ) \u2227 (\u0394\u00b9 s) \u21a6 v s , (\u0394\u00b9 t) \u2227 (s \u2261 0\u2082 ) \u21a6 f t , (\u0394\u00b9 t) \u2227 (s \u2261 1\u2082 ) \u21a6 a])) ( \u03a3 ( u : hom A x a) , ( \u03a3 ( d : hom A x a) , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))) ( \u03a3 ( d : hom A x a) , ( \u03a3 ( u : hom A x a) , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))) ( uncurried-dhom-to-representable A a x y f v) ( representable-dhom-to-uncurry-hom2 A a x y f v) ( fubini-\u03a3 (hom A x a) (hom A x a) ( \\ u d \u2192 product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))) #def representable-dhom-to-hom2-swap ( A : U) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( dhom-to-representable A a x y f v) ( \u03a3 ( d : hom A x a) , ( \u03a3 ( u : hom A x a) , ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d)))) := equiv-comp ( dhom-to-representable A a x y f v) ( \u03a3 ( d : hom A x a) , ( \u03a3 ( u : hom A x a) , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))) ( \u03a3 ( d : hom A x a) , ( \u03a3 ( u : hom A x a) , ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d)))) ( representable-dhom-to-hom2 A a x y f v) ( total-equiv-family-equiv (hom A x a) ( \\ d \u2192 \u03a3 ( u : hom A x a) , ( product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d))) ( \\ d \u2192 \u03a3 ( u : hom A x a) , ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d))) ( \\ d \u2192 total-equiv-family-equiv (hom A x a) ( \\ u \u2192 product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)) ( \\ u \u2192 product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d)) ( \\ u \u2192 sym-product (hom2 A x a a u (id-hom A a) d) (hom2 A x y a f v d)))) #def representable-dhom-to-hom2-dist ( A : U) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( dhom-to-representable A a x y f v) ( \u03a3 ( d : hom A x a) , ( product ( hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d))) := equiv-right-cancel ( dhom-to-representable A a x y f v) ( \u03a3 (d : hom A x a) , ( product ( hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d))) ( \u03a3 ( d : hom A x a) , ( \u03a3 (u : hom A x a) , product ( hom2 A x y a f v d) ( hom2 A x a a u (id-hom A a) d))) ( representable-dhom-to-hom2-swap A a x y f v) ( total-equiv-family-equiv (hom A x a) ( \\ d \u2192 ( product ( hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d))) ( \\ d \u2192 ( \u03a3 ( u : hom A x a) , ( product (hom2 A x y a f v d) (hom2 A x a a u (id-hom A a) d)))) ( \\ d \u2192 ( distributive-product-\u03a3 ( hom2 A x y a f v d) ( hom A x a) ( \\ u \u2192 hom2 A x a a u (id-hom A a) d)))) Now we introduce the hypothesis that A is Segal type. #def representable-dhom-to-path-space-is-segal ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( dhom-to-representable A a x y f v) ( \u03a3 ( d : hom A x a) , ( product (hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , (u = d)))) := equiv-right-cancel ( dhom-to-representable A a x y f v) ( \u03a3 ( d : hom A x a) , ( product (hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , (u = d)))) ( \u03a3 ( d : hom A x a) , ( product ( hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , (hom2 A x a a u (id-hom A a) d)))) ( representable-dhom-to-hom2-dist A a x y f v) ( total-equiv-family-equiv (hom A x a) ( \\ d \u2192 product (hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , (u = d))) ( \\ d \u2192 product ( hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d)) ( \\ d \u2192 total-equiv-family-equiv ( hom2 A x y a f v d) ( \\ \u03b1 \u2192 (\u03a3 (u : hom A x a) , (u = d))) ( \\ \u03b1 \u2192 (\u03a3 (u : hom A x a) , hom2 A x a a u (id-hom A a) d)) ( \\ \u03b1 \u2192 ( total-equiv-family-equiv ( hom A x a) ( \\ u \u2192 (u = d)) ( \\ u \u2192 hom2 A x a a u (id-hom A a) d) ( \\ u \u2192 equiv-homotopy-hom2'-is-segal A is-segal-A x a u d))))) #def is-segal-representable-dhom-to-hom2 ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : Equiv ( dhom-to-representable A a x y f v) ( \u03a3 (d : hom A x a) , (hom2 A x y a f v d)) := equiv-comp ( dhom-to-representable A a x y f v) ( \u03a3 ( d : hom A x a) , ( product (hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , (u = d)))) ( \u03a3 (d : hom A x a) , (hom2 A x y a f v d)) ( representable-dhom-to-path-space-is-segal A is-segal-A a x y f v) ( total-equiv-family-equiv ( hom A x a) ( \\ d \u2192 product (hom2 A x y a f v d) ( \u03a3 (u : hom A x a) , (u = d))) ( \\ d \u2192 hom2 A x y a f v d) ( \\ d \u2192 codomain-based-paths-contraction A x y a v f d)) #def is-segal-representable-dhom-to-contractible ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A x y) ( v : hom A y a) : is-contr (dhom-to-representable A a x y f v) := is-contr-equiv-is-contr' ( dhom-to-representable A a x y f v) ( \u03a3 (d : hom A x a) , (hom2 A x y a f v d)) ( is-segal-representable-dhom-to-hom2 A is-segal-A a x y f v) ( is-segal-A x y a f v) Finally, we see that contravariant hom families in a Segal type are contravariant. RS17, Proposition 8.13( < -), dual #def is-contravariant-representable-is-segal ( A : U) ( is-segal-A : is-segal A) ( a : A) : is-contravariant A ( \\ x \u2192 hom A x a) := is-segal-representable-dhom-to-contractible A is-segal-A a The proof of the claimed converse result given in the original source is circular - using Proposition 5.10, which holds only for Segal types - so instead we argue as follows: RS17, Proposition 8.13(\u2192), dual #def is-segal-is-contravariant-representable ( A : U) ( representable-family-is-contravariant : ( a : A) \u2192 is-contravariant A ( \\ x \u2192 hom A x a)) : is-segal A := \\ x y z f g \u2192 is-contr-base-is-contr-\u03a3 ( \u03a3 (h : hom A x z) , (hom2 A x y z f g h)) ( \\ hk \u2192 \u03a3 (u : hom A x z) , (hom2 A x z z u (id-hom A z) ( first hk))) ( \\ hk \u2192 ( first hk , \\ (t , s) \u2192 first hk t)) ( is-contr-equiv-is-contr' ( \u03a3 ( hk : \u03a3 ( h : hom A x z) , (hom2 A x y z f g h)) , ( \u03a3 (u : hom A x z) , hom2 A x z z u (id-hom A z) ( first hk))) ( dhom-to-representable A z x y f g) ( inv-equiv ( dhom-to-representable A z x y f g) ( \u03a3 ( hk : \u03a3 ( h : hom A x z) , (hom2 A x y z f g h)) , ( \u03a3 (u : hom A x z) , hom2 A x z z u (id-hom A z) ( first hk))) ( equiv-comp ( dhom-to-representable A z x y f g) ( \u03a3 ( h : hom A x z) , ( product ( hom2 A x y z f g h) ( \u03a3 (u : hom A x z) , hom2 A x z z u (id-hom A z) h))) ( \u03a3 ( hk : \u03a3 ( h : hom A x z) , (hom2 A x y z f g h)) , ( \u03a3 (u : hom A x z) , hom2 A x z z u (id-hom A z) ( first hk))) ( representable-dhom-to-hom2-dist A z x y f g) ( associative-\u03a3 ( hom A x z) ( \\ h \u2192 hom2 A x y z f g h) ( \\ h _ \u2192 \u03a3 (u : hom A x z) , (hom2 A x z z u (id-hom A z) h))))) ( representable-family-is-contravariant z x y f g))","title":"Representable contravariant families"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-lifts-transport-and-uniqueness","text":"In a contravariant family C over a base type A, a term v : C y may be transported along an arrow f : hom A x y to give a term in C x. RS17, contravariant transport from beginning of Section 8.2 #def contravariant-transport ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( v : C y) : C x := first ( center-contraction (dhom-to A x y f C v) (is-contravariant-C x y f v)) RS17, contravariant lift from beginning of Section 8.2 #def contravariant-lift ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( v : C y) : ( dhom A x y f C (contravariant-transport A x y f C is-contravariant-C v) v) := second ( center-contraction (dhom-to A x y f C v) (is-contravariant-C x y f v)) #def contravariant-uniqueness ( A : U) ( x y : A) ( f : hom A x y) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( v : C y) ( lift : dhom-to A x y f C v) : ( contravariant-transport A x y f C is-contravariant-C v) = ( first lift) := first-path-\u03a3 ( C x) ( \\ u \u2192 dhom A x y f C u v) ( center-contraction ( dhom-to A x y f C v) ( is-contravariant-C x y f v)) ( lift) ( homotopy-contraction ( dhom-to A x y f C v) ( is-contravariant-C x y f v) ( lift))","title":"Contravariant lifts, transport, and uniqueness"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-functoriality","text":"The contravariant transport operation defines a comtravariantly functorial action of arrows in the base on terms in the fibers. In particular, there is an identity transport law. RS17, Proposition 8.16, Part 2, dual, Contravariant families preserve identities #def id-arr-contravariant-transport ( A : U) ( x : A) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( u : C x) : ( contravariant-transport A x x (id-hom A x) C is-contravariant-C u) = u := contravariant-uniqueness A x x (id-hom A x) C is-contravariant-C u ( u , id-dhom A x C u)","title":"Contravariant functoriality"},{"location":"simplicial-hott/08-covariant.rzk/#contravariant-natural-transformations","text":"A fiberwise map between contrvariant families is automatically \"natural\" commuting with the contravariant lifts. RS17, Proposition 8.17, dual, Contravariant naturality #def contravariant-fiberwise-transformation-application ( A : U) ( x y : A) ( f : hom A x y) ( C D : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( \u03d5 : ( z : A) \u2192 C z \u2192 D z) ( v : C y) : dhom-to A x y f D (\u03d5 y v) := ( \u03d5 x (contravariant-transport A x y f C is-contravariant-C v) , \\ t \u2192 \u03d5 (f t) (contravariant-lift A x y f C is-contravariant-C v t)) #def naturality-contravariant-fiberwise-transformation ( A : U) ( x y : A) ( f : hom A x y) ( C D : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( is-contravariant-D : is-contravariant A D) ( \u03d5 : ( z : A) \u2192 C z \u2192 D z) ( v : C y) : ( contravariant-transport A x y f D is-contravariant-D (\u03d5 y v)) = ( \u03d5 x (contravariant-transport A x y f C is-contravariant-C v)) := contravariant-uniqueness A x y f D is-contravariant-D (\u03d5 y v) ( contravariant-fiberwise-transformation-application A x y f C D is-contravariant-C \u03d5 v)","title":"Contravariant natural transformations"},{"location":"simplicial-hott/09-yoneda.rzk/","text":"The Yoneda lemma \u00b6 These formalisations correspond to Section 9 of the RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 8-covariant.md - We use covariant type families. Some of the definitions in this file rely on function extensionality and extension extensionality: #assume funext : FunExt #assume extext : ExtExt Natural transformations involving a representable functor \u00b6 Fix a Segal type \\(A\\) and a term \\(a : A\\) . The Yoneda lemma characterizes natural transformations from the representable type family hom A a : A \u2192 U to a covariant type family C : A \u2192 U . Ordinarily, such a natural transformation would involve a family of maps \u03d5 : ( z : A) \u2192 hom A a z \u2192 C z together with a proof of naturality of these components, but by naturality-covariant-fiberwise-transformation naturality is automatic. #def naturality-covariant-fiberwise-representable-transformation ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A a x) ( g : hom A x y) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) ( \u03d5 : ( z : A) \u2192 hom A a z \u2192 C z) : (covariant-transport A x y g C is-covariant-C (\u03d5 x f)) = (\u03d5 y (comp-is-segal A is-segal-A a x y f g)) := naturality-covariant-fiberwise-transformation A x y g ( \\ z \u2192 hom A a z) ( C) ( is-covariant-representable-is-segal A is-segal-A a) ( is-covariant-C) ( \u03d5) ( f) The Yoneda maps \u00b6 For any Segal type \\(A\\) and term \\(a : A\\) , the Yoneda lemma provides an equivalence between the type ( z : A) \u2192 hom A a z \u2192 C z of natural transformations out of the functor hom A a and values in an arbitrary covariant family \\(C\\) and the type \\(C a\\) . One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the covariant transport operation. The following map, evid , evaluates a natural transformation out of a representable functor at the identity arrow. #def evid ( A : U) ( a : A) ( C : A \u2192 U) : ( (z : A) \u2192 hom A a z \u2192 C z) \u2192 C a := \\ \u03d5 \u2192 \u03d5 a (id-hom A a) The inverse map only exists for Segal types. #def yon ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) : C a \u2192 ( (z : A) \u2192 hom A a z \u2192 C z) := \\ u x f \u2192 covariant-transport A a x f C is-covariant-C u The Yoneda composites \u00b6 It remains to show that the Yoneda maps are inverses. One retraction is straightforward: #def evid-yon ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) ( u : C a) : ( evid A a C) ((yon A is-segal-A a C is-covariant-C) u) = u := id-arr-covariant-transport A a C is-covariant-C u The other composite carries \\(\u03d5\\) to an a priori distinct natural transformation. We first show that these are pointwise equal at all x : A and f : hom A a x in two steps. #section yon-evid #variable A : U #variable is-segal-A : is-segal A #variable a : A #variable C : A \u2192 U #variable is-covariant-C : is-covariant A C The composite yon-evid of \u03d5 equals \u03d5 at all x : A and f : hom A a x . #def yon-evid-twice-pointwise ( \u03d5 : ( z : A) \u2192 hom A a z \u2192 C z) ( x : A) ( f : hom A a x) : ( (yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x f = \u03d5 x f := concat ( C x) ( ((yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x f) ( \u03d5 x (comp-is-segal A is-segal-A a a x (id-hom A a) f)) ( \u03d5 x f) ( naturality-covariant-fiberwise-representable-transformation A is-segal-A a a x (id-hom A a) f C is-covariant-C \u03d5) ( ap ( hom A a x) ( C x) ( comp-is-segal A is-segal-A a a x (id-hom A a) f) ( f) ( \u03d5 x) ( id-comp-is-segal A is-segal-A a x f)) By funext , these are equals as functions of f pointwise in x . #def yon-evid-once-pointwise uses ( funext ) ( \u03d5 : ( z : A) \u2192 hom A a z \u2192 C z) ( x : A) : ( (yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x = \u03d5 x := eq-htpy funext ( hom A a x) ( \\ f \u2192 C x) ( \\ f \u2192 ((yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x f) ( \\ f \u2192 (\u03d5 x f)) ( \\ f \u2192 yon-evid-twice-pointwise \u03d5 x f) By funext again, these are equal as functions of x and f . #def yon-evid uses ( funext ) ( \u03d5 : ( z : A) \u2192 hom A a z \u2192 C z) : ( (yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) = \u03d5 := eq-htpy funext ( A) ( \\ x \u2192 (hom A a x \u2192 C x)) ( \\ x \u2192 ((yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x) ( \\ x \u2192 (\u03d5 x)) ( \\ x \u2192 yon-evid-once-pointwise \u03d5 x) #end yon-evid The Yoneda lemma \u00b6 The Yoneda lemma says that evaluation at the identity defines an equivalence. This is proven combining the previous steps. RS17, Theorem 9.1 #def yoneda-lemma uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) : is-equiv ( (z : A) \u2192 hom A a z \u2192 C z) (C a) (evid A a C) := ( ( ( yon A is-segal-A a C is-covariant-C) , ( yon-evid A is-segal-A a C is-covariant-C)) , ( ( yon A is-segal-A a C is-covariant-C) , ( evid-yon A is-segal-A a C is-covariant-C))) Naturality \u00b6 The equivalence of the Yoneda lemma is natural in both \\(a : A\\) and \\(C : A \u2192 U\\) . Naturality in \\(a\\) follows from the fact that the maps evid and yon are fiberwise equivalences between covariant families over \\(A\\) , though it requires some work to prove that the domain is covariant. #def is-covariant-yoneda-domain uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) : is-covariant A ( \\ a \u2192 (z : A) \u2192 hom A a z \u2192 C z) := equiv-is-covariant ( extext) ( A) ( \\ a -> (z : A) \u2192 hom A a z \u2192 C z) ( C) ( \\ a -> (evid A a C , yoneda-lemma A is-segal-A a C is-covariant-C)) ( is-covariant-C) #def is-natural-in-object-evid uses ( funext extext ) ( A : U) ( is-segal-A : is-segal A) ( a b : A) ( f : hom A a b) ( C : A -> U) ( is-covariant-C : is-covariant A C) ( \u03d5 : ( z : A) \u2192 hom A a z \u2192 C z) : ( covariant-transport A a b f C is-covariant-C (evid A a C \u03d5)) = ( evid A b C ( covariant-transport A a b f ( \\ x -> (z : A) \u2192 hom A x z \u2192 C z) ( is-covariant-yoneda-domain A is-segal-A C is-covariant-C) \u03d5)) := naturality-covariant-fiberwise-transformation ( A) ( a) ( b) ( f) ( \\ x -> (z : A) \u2192 hom A x z \u2192 C z) ( C) ( is-covariant-yoneda-domain A is-segal-A C is-covariant-C) ( is-covariant-C) ( \\ x -> evid A x C) ( \u03d5) #def is-natural-in-object-yon uses ( funext extext ) ( A : U) ( is-segal-A : is-segal A) ( a b : A) ( f : hom A a b) ( C : A -> U) ( is-covariant-C : is-covariant A C) ( u : C a) : ( covariant-transport A a b f ( \\ x -> (z : A) \u2192 hom A x z \u2192 C z) ( is-covariant-yoneda-domain A is-segal-A C is-covariant-C) ( yon A is-segal-A a C is-covariant-C u)) = ( yon A is-segal-A b C is-covariant-C ( covariant-transport A a b f C is-covariant-C u)) := naturality-covariant-fiberwise-transformation ( A) ( a) ( b) ( f) ( C) ( \\ x -> (z : A) \u2192 hom A x z \u2192 C z) ( is-covariant-C) ( is-covariant-yoneda-domain A is-segal-A C is-covariant-C) ( \\ x -> yon A is-segal-A x C is-covariant-C) ( u) Naturality in \\(C\\) is not automatic but can be proven easily: RS17, Lemma 9.2(i) #def is-natural-in-family-evid ( A : U) ( a : A) ( C D : A \u2192 U) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( \u03c6 : ( z : A) \u2192 hom A a z \u2192 C z) : ( comp ((z : A) \u2192 hom A a z \u2192 C z) (C a) (D a) (\u03c8 a) (evid A a C)) \u03c6 = ( comp ((z : A) \u2192 hom A a z \u2192 C z) ( (z : A) \u2192 hom A a z \u2192 D z) (D a) ( evid A a D) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))) \u03c6 := refl RS17, Lemma 9.2(ii) #def is-natural-in-family-yon-twice-pointwise ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C D : A \u2192 U) ( is-covariant-C : is-covariant A C) ( is-covariant-D : is-covariant A D) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( u : C a) ( x : A) ( f : hom A a x) : ( comp (C a) (D a) ( (z : A) \u2192 hom A a z \u2192 D z) ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u x f = ( comp (C a) ( (z : A) \u2192 hom A a z \u2192 C z) ( (z : A) \u2192 hom A a z \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u x f := naturality-covariant-fiberwise-transformation A a x f C D is-covariant-C is-covariant-D \u03c8 u #def is-natural-in-family-yon-once-pointwise uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C D : A \u2192 U) ( is-covariant-C : is-covariant A C) ( is-covariant-D : is-covariant A D) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( u : C a) ( x : A) : ( comp (C a) (D a) ( (z : A) \u2192 hom A a z \u2192 D z) ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u x = ( comp (C a) ( (z : A) \u2192 hom A a z \u2192 C z) ( (z : A) \u2192 hom A a z \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u x := eq-htpy funext ( hom A a x) ( \\ f \u2192 D x) ( \\ f \u2192 ( comp (C a) (D a) ( (z : A) \u2192 hom A a z \u2192 D z) ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u x f) ( \\ f \u2192 ( comp (C a) ( (z : A) \u2192 hom A a z \u2192 C z) ( (z : A) \u2192 hom A a z \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u x f) ( \\ f \u2192 is-natural-in-family-yon-twice-pointwise A is-segal-A a C D is-covariant-C is-covariant-D \u03c8 u x f) #def is-natural-in-family-yon uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C D : A \u2192 U) ( is-covariant-C : is-covariant A C) ( is-covariant-D : is-covariant A D) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( u : C a) : ( comp (C a) (D a) ( (z : A) \u2192 hom A a z \u2192 D z) ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u = ( comp (C a) ( (z : A) \u2192 hom A a z \u2192 C z) ( (z : A) \u2192 hom A a z \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u := eq-htpy funext ( A) ( \\ x \u2192 hom A a x \u2192 D x) ( \\ x \u2192 ( comp (C a) (D a) ( (z : A) \u2192 hom A a z \u2192 D z) ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u x) ( \\ x \u2192 ( comp (C a) ( (z : A) \u2192 hom A a z \u2192 C z) ( (z : A) \u2192 hom A a z \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u x) ( \\ x \u2192 is-natural-in-family-yon-once-pointwise A is-segal-A a C D is-covariant-C is-covariant-D \u03c8 u x) Yoneda for contravariant families \u00b6 Dually, the Yoneda lemma for contravariant type families characterizes natural transformations from the contravariant family represented by a term \\(a : A\\) in a Segal type to a contravariant type family \\(C : A \u2192 U\\) . By naturality-contravariant-fiberwise-transformation naturality is again automatic. #def naturality-contravariant-fiberwise-representable-transformation ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A y a) ( g : hom A x y) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( \u03d5 : ( z : A) \u2192 hom A z a \u2192 C z) : ( contravariant-transport A x y g C is-contravariant-C (\u03d5 y f)) = ( \u03d5 x (comp-is-segal A is-segal-A x y a g f)) := naturality-contravariant-fiberwise-transformation A x y g ( \\ z \u2192 hom A z a) C ( is-contravariant-representable-is-segal A is-segal-A a) ( is-contravariant-C) ( \u03d5) ( f) For any Segal type \\(A\\) and term \\(a : A\\) , the contravariant Yoneda lemma provides an equivalence between the type ( z : A) \u2192 hom A z a \u2192 C z of natural transformations out of the functor \\ z \u2192 hom A z a and valued in an arbitrary contravariant family \\(C\\) and the type \\(C a\\) . One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the contravariant transport operation. The following map, contra-evid evaluates a natural transformation out of a representable functor at the identity arrow. #def contra-evid ( A : U) ( a : A) ( C : A \u2192 U) : ( (z : A) \u2192 hom A z a \u2192 C z) \u2192 C a := \\ \u03d5 \u2192 \u03d5 a (id-hom A a) The inverse map only exists for Segal types and contravariant families. #def contra-yon ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) : C a \u2192 ( (z : A) \u2192 hom A z a \u2192 C z) := \\ v z f \u2192 contravariant-transport A z a f C is-contravariant-C v It remains to show that the Yoneda maps are inverses. One retraction is straightforward: #def contra-evid-yon ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( v : C a) : contra-evid A a C ((contra-yon A is-segal-A a C is-contravariant-C) v) = v := id-arr-contravariant-transport A a C is-contravariant-C v The other composite carries \\(\u03d5\\) to an a priori distinct natural transformation. We first show that these are pointwise equal at all x : A and f : hom A x a in two steps. #section contra-yon-evid #variable A : U #variable is-segal-A : is-segal A #variable a : A #variable C : A \u2192 U #variable is-contravariant-C : is-contravariant A C The composite contra-yon-evid of \u03d5 equals \u03d5 at all x : A and f : hom A x a . #def contra-yon-evid-twice-pointwise ( \u03d5 : ( z : A) \u2192 hom A z a \u2192 C z) ( x : A) ( f : hom A x a) : ( (contra-yon A is-segal-A a C is-contravariant-C) ((contra-evid A a C) \u03d5)) x f = \u03d5 x f := concat ( C x) ( ((contra-yon A is-segal-A a C is-contravariant-C) ((contra-evid A a C) \u03d5)) x f) ( \u03d5 x (comp-is-segal A is-segal-A x a a f (id-hom A a))) ( \u03d5 x f) ( naturality-contravariant-fiberwise-representable-transformation A is-segal-A a x a (id-hom A a) f C is-contravariant-C \u03d5) ( ap ( hom A x a) ( C x) ( comp-is-segal A is-segal-A x a a f (id-hom A a)) ( f) ( \u03d5 x) ( comp-id-is-segal A is-segal-A x a f)) By funext , these are equals as functions of f pointwise in x . #def contra-yon-evid-once-pointwise uses ( funext ) ( \u03d5 : ( z : A) \u2192 hom A z a \u2192 C z) ( x : A) : ( (contra-yon A is-segal-A a C is-contravariant-C) ( (contra-evid A a C) \u03d5)) x = \u03d5 x := eq-htpy funext ( hom A x a) ( \\ f \u2192 C x) ( \\ f \u2192 ( (contra-yon A is-segal-A a C is-contravariant-C) ( (contra-evid A a C) \u03d5)) x f) ( \\ f \u2192 (\u03d5 x f)) ( \\ f \u2192 contra-yon-evid-twice-pointwise \u03d5 x f) By funext again, these are equal as functions of x and f . #def contra-yon-evid uses ( funext ) ( \u03d5 : ( z : A) \u2192 hom A z a \u2192 C z) : contra-yon A is-segal-A a C is-contravariant-C (contra-evid A a C \u03d5) = \u03d5 := eq-htpy funext ( A) ( \\ x \u2192 (hom A x a \u2192 C x)) ( contra-yon A is-segal-A a C is-contravariant-C (contra-evid A a C \u03d5)) ( \u03d5) ( contra-yon-evid-once-pointwise \u03d5) #end contra-yon-evid The contravariant Yoneda lemma says that evaluation at the identity defines an equivalence. #def contra-yoneda-lemma uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) : is-equiv ( (z : A) \u2192 hom A z a \u2192 C z) (C a) (contra-evid A a C) := ( ( ( contra-yon A is-segal-A a C is-contravariant-C) , ( contra-yon-evid A is-segal-A a C is-contravariant-C)) , ( ( contra-yon A is-segal-A a C is-contravariant-C) , ( contra-evid-yon A is-segal-A a C is-contravariant-C))) Contravariant Naturality \u00b6 The equivalence of the Yoneda lemma is natural in both \\(a : A\\) and \\(C : A \u2192 U\\) . Naturality in \\(a\\) follows from the fact that the maps evid and yon are fiberwise equivalences between contravariant families over \\(A\\) , though it requires some work, which has not yet been formalized, to prove that the domain is contravariant. Naturality in \\(C\\) is not automatic but can be proven easily: RS17, Lemma 9.2(i), dual #def is-natural-in-family-contra-evid ( A : U) ( a : A) ( C D : A \u2192 U) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( \u03c6 : ( z : A) \u2192 hom A z a \u2192 C z) : ( comp ((z : A) \u2192 hom A z a \u2192 C z) (C a) (D a) ( \u03c8 a) (contra-evid A a C)) \u03c6 = ( comp ((z : A) \u2192 hom A z a \u2192 C z) ( (z : A) \u2192 hom A z a \u2192 D z) (D a) ( contra-evid A a D) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))) \u03c6 := refl RS17, Lemma 9.2(ii), dual #def is-natural-in-family-contra-yon-twice-pointwise ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C D : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( is-contravariant-D : is-contravariant A D) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( u : C a) ( x : A) ( f : hom A x a) : ( comp (C a) (D a) ( (z : A) \u2192 hom A z a \u2192 D z) ( contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u x f = ( comp (C a) ( (z : A) \u2192 hom A z a \u2192 C z) ( (z : A) \u2192 hom A z a \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) ( contra-yon A is-segal-A a C is-contravariant-C)) u x f := naturality-contravariant-fiberwise-transformation A x a f C D is-contravariant-C is-contravariant-D \u03c8 u #def is-natural-in-family-contra-yon-once-pointwise uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C D : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( is-contravariant-D : is-contravariant A D) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( u : C a) ( x : A) : ( comp (C a) (D a) ( (z : A) \u2192 hom A z a \u2192 D z) (contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u x = ( comp (C a) ( (z : A) \u2192 hom A z a \u2192 C z) ( (z : A) \u2192 hom A z a \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (contra-yon A is-segal-A a C is-contravariant-C)) u x := eq-htpy funext ( hom A x a) ( \\ f \u2192 D x) ( \\ f \u2192 ( comp (C a) (D a) ( (z : A) \u2192 hom A z a \u2192 D z) ( contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u x f) ( \\ f \u2192 ( comp (C a) ( (z : A) \u2192 hom A z a \u2192 C z) ( (z : A) \u2192 hom A z a \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) ( contra-yon A is-segal-A a C is-contravariant-C)) u x f) ( \\ f \u2192 is-natural-in-family-contra-yon-twice-pointwise A is-segal-A a C D is-contravariant-C is-contravariant-D \u03c8 u x f) #def is-natural-in-family-contra-yon uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C D : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( is-contravariant-D : is-contravariant A D) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( u : C a) : ( comp (C a) (D a) ( (z : A) \u2192 hom A z a \u2192 D z) ( contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u = ( comp (C a) ( (z : A) \u2192 hom A z a \u2192 C z) ( (z : A) \u2192 hom A z a \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) ( contra-yon A is-segal-A a C is-contravariant-C)) u := eq-htpy funext ( A) ( \\ x \u2192 hom A x a \u2192 D x) ( \\ x \u2192 ( comp (C a) (D a) ( (z : A) \u2192 hom A z a \u2192 D z) ( contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u x) ( \\ x \u2192 ( comp (C a) ( (z : A) \u2192 hom A z a \u2192 C z) ( (z : A) \u2192 hom A z a \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) ( contra-yon A is-segal-A a C is-contravariant-C)) u x) ( \\ x \u2192 is-natural-in-family-contra-yon-once-pointwise A is-segal-A a C D is-contravariant-C is-contravariant-D \u03c8 u x) From a type-theoretic perspective, the Yoneda lemma is a \u201cdirected\u201d version of the \u201ctransport\u201d operation for identity types. This suggests a \u201cdependently typed\u201d generalization of the Yoneda lemma, analogous to the full induction principle for identity types. We prove this as a special case of a result about covariant families over a type with an initial object. Initial objects \u00b6 A term \\(a\\) in a type \\(A\\) is initial if all of its mapping-out hom types are contractible. RS17, Definition 9.6 #def is-initial ( A : U) ( a : A) : U := ( x : A) \u2192 is-contr (hom A a x) Initial objects satisfy an induction principle relative to covariant families. #section initial-evaluation-equivalence #variable A : U #variable a : A #variable is-initial-a : is-initial A a #variable C : A \u2192 U #variable is-covariant-C : is-covariant A C #def arrows-from-initial ( x : A) : hom A a x := center-contraction (hom A a x) (is-initial-a x) #def identity-component-arrows-from-initial : arrows-from-initial a = id-hom A a := homotopy-contraction (hom A a a) (is-initial-a a) (id-hom A a) #def ind-initial uses ( is-initial-a ) ( u : C a) : ( x : A) \u2192 C x := \\ x \u2192 covariant-transport A a x (arrows-from-initial x) C is-covariant-C u #def has-cov-section-ev-pt uses ( is-initial-a ) : has-section ( (x : A) \u2192 C x) (C a) (ev-pt A a C) := ( ( ind-initial) , ( \\ u \u2192 concat ( C a) ( covariant-transport A a a ( arrows-from-initial a) C is-covariant-C u) ( covariant-transport A a a ( id-hom A a) C is-covariant-C u) ( u) ( ap ( hom A a a) ( C a) ( arrows-from-initial a) ( id-hom A a) ( \\ f \u2192 covariant-transport A a a f C is-covariant-C u) ( identity-component-arrows-from-initial)) ( id-arr-covariant-transport A a C is-covariant-C u))) #def ind-initial-ev-pt-pointwise uses ( is-initial-a ) ( s : ( x : A) \u2192 C x) ( b : A) : ind-initial (ev-pt A a C s) b = s b := covariant-uniqueness ( A) ( a) ( b) ( arrows-from-initial b) ( C) ( is-covariant-C) ( ev-pt A a C s) ( ( s b , \\ t \u2192 s (arrows-from-initial b t))) #end initial-evaluation-equivalence We now prove that induction from an initial element in the base of a covariant family defines an inverse equivalence to evaluation at the element. RS17, Theorem 9.7 #def is-equiv-covariant-ev-initial uses ( funext ) ( A : U) ( a : A) ( is-initial-a : is-initial A a) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) : is-equiv ( (x : A) \u2192 C x) (C a) (ev-pt A a C) := ( ( ( ind-initial A a is-initial-a C is-covariant-C) , ( \\ s \u2192 eq-htpy funext ( A) ( C) ( ind-initial A a is-initial-a C is-covariant-C (ev-pt A a C s)) ( s) ( ind-initial-ev-pt-pointwise A a is-initial-a C is-covariant-C s))) , ( has-cov-section-ev-pt A a is-initial-a C is-covariant-C)) Initial objects in slice categories \u00b6 The type coslice A a is the type of arrows in \\(A\\) with domain \\(a\\) . #def coslice ( A : U) ( a : A) : U := \u03a3 ( z : A) , (hom A a z) We now show that the coslice under \\(a\\) in a Segal type \\(A\\) has an initial object given by the identity arrow at \\(a\\) . This makes use of the following equivalence. #def equiv-hom-in-coslice ( A : U) ( a x : A) ( f : hom A a x) : Equiv ( hom (coslice A a) (a , id-hom A a) (x , f)) ( (t : \u0394\u00b9) \u2192 hom A a (f t) [t \u2261 0\u2082 \u21a6 id-hom A a]) := ( \\ h t s \u2192 ( second (h s)) t , (( \\ k s \u2192 ( k 1\u2082 s , \\ t \u2192 k t s) , \\ h \u2192 refl ) , ( \\ k s \u2192 ( k 1\u2082 s , \\ t \u2192 k t s) , \\ k \u2192 refl ))) Since \\(hom A a\\) is covariant when \\(A\\) is Segal, this latter type is contractible. #def is-contr-is-segal-hom-in-coslice ( A : U) ( is-segal-A : is-segal A) ( a x : A) ( f : hom A a x) : is-contr ( (t : \u0394\u00b9) \u2192 hom A a (f t) [t \u2261 0\u2082 \u21a6 id-hom A a]) := ( second (has-unique-fixed-domain-lifts-iff-is-covariant A ( \\ z \u2192 hom A a z))) ( is-covariant-representable-is-segal A is-segal-A a) ( a) ( x) ( f) ( id-hom A a) This proves the initiality of identity arrows in the coslice of a Segal type. RS17, Lemma 9.8 #def is-initial-id-hom-is-segal ( A : U) ( is-segal-A : is-segal A) ( a : A) : is-initial (coslice A a) (a , id-hom A a) := \\ (x , f) \u2192 is-contr-equiv-is-contr' ( hom (coslice A a) (a , id-hom A a) (x , f)) ( (t : \u0394\u00b9) \u2192 hom A a (f t) [t \u2261 0\u2082 \u21a6 id-hom A a]) ( equiv-hom-in-coslice A a x f) ( is-contr-is-segal-hom-in-coslice A is-segal-A a x f) Dependent Yoneda lemma \u00b6 The dependent Yoneda lemma now follows by specializing these results. #def dependent-evid ( A : U) ( a : A) ( C : (coslice A a) \u2192 U) : ( (p : coslice A a) \u2192 C p) \u2192 C (a , id-hom A a) := \\ s \u2192 s (a , id-hom A a) #def dependent-yoneda-lemma' uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : (coslice A a) \u2192 U) ( is-covariant-C : is-covariant (coslice A a) C) : is-equiv ( (p : coslice A a) \u2192 C p) ( C (a , id-hom A a)) ( dependent-evid A a C) := is-equiv-covariant-ev-initial ( coslice A a) ( (a , id-hom A a)) ( is-initial-id-hom-is-segal A is-segal-A a) ( C) ( is-covariant-C) The actual dependent Yoneda is equivalent to the result just proven, just with an equivalent type in the domain of the evaluation map. RS17, Theorem 9.5 #def dependent-yoneda-lemma uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : (coslice A a) \u2192 U) ( is-covariant-C : is-covariant (coslice A a) C) : is-equiv ( (x : A) \u2192 ( f : hom A a x) \u2192 C (x , f)) ( C (a , id-hom A a)) ( \\ s \u2192 s a (id-hom A a)) := is-equiv-left-factor ( (p : coslice A a) \u2192 C p) ( (x : A) \u2192 ( f : hom A a x) \u2192 C (x , f)) ( C (a , id-hom A a)) ( first (equiv-dependent-curry A ( \\ z \u2192 hom A a z) ( \\ x f \u2192 C (x , f)))) ( second (equiv-dependent-curry A ( \\ z \u2192 hom A a z) ( \\ x f \u2192 C (x , f)))) ( \\ s \u2192 s a (id-hom A a)) ( dependent-yoneda-lemma' A is-segal-A a C is-covariant-C) Final objects \u00b6 A term \\(a\\) in a type \\(A\\) is initial if all of its mapping-out hom types are contractible. #def is-final ( A : U) ( a : A) : U := ( x : A) \u2192 is-contr (hom A x a) Final objects satisfy an induction principle relative to contravariant families. #section final-evaluation-equivalence #variable A : U #variable a : A #variable is-final-a : is-final A a #variable C : A \u2192 U #variable is-contravariant-C : is-contravariant A C #def arrows-to-final ( x : A) : hom A x a := center-contraction (hom A x a) (is-final-a x) #def identity-component-arrows-to-final : arrows-to-final a = id-hom A a := homotopy-contraction (hom A a a) (is-final-a a) (id-hom A a) #def ind-final uses ( is-final-a ) ( u : C a) : ( x : A) \u2192 C x := \\ x \u2192 contravariant-transport A x a (arrows-to-final x) C is-contravariant-C u #def has-contra-section-ev-pt uses ( is-final-a ) : has-section ( (x : A) \u2192 C x) (C a) (ev-pt A a C) := ( ( ind-final) , ( \\ u \u2192 concat ( C a) ( contravariant-transport A a a ( arrows-to-final a) C is-contravariant-C u) ( contravariant-transport A a a ( id-hom A a) C is-contravariant-C u) ( u) ( ap ( hom A a a) ( C a) ( arrows-to-final a) ( id-hom A a) ( \\ f \u2192 contravariant-transport A a a f C is-contravariant-C u) ( identity-component-arrows-to-final)) ( id-arr-contravariant-transport A a C is-contravariant-C u))) #def ind-final-ev-pt-pointwise uses ( is-final-a ) ( s : ( x : A) \u2192 C x) ( b : A) : ind-final (ev-pt A a C s) b = s b := contravariant-uniqueness ( A) ( b) ( a) ( arrows-to-final b) ( C) ( is-contravariant-C) ( ev-pt A a C s) ( ( s b , \\ t \u2192 s (arrows-to-final b t))) #end final-evaluation-equivalence We now prove that induction from a final element in the base of a contravariant family defines an inverse equivalence to evaluation at the element. RS17, Theorem 9.7, dual #def is-equiv-contravariant-ev-final uses ( funext ) ( A : U) ( a : A) ( is-final-a : is-final A a) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) : is-equiv ( (x : A) \u2192 C x) (C a) (ev-pt A a C) := ( ( ( ind-final A a is-final-a C is-contravariant-C) , ( \\ s \u2192 eq-htpy funext ( A) ( C) ( ind-final A a is-final-a C is-contravariant-C (ev-pt A a C s)) ( s) ( ind-final-ev-pt-pointwise A a is-final-a C is-contravariant-C s))) , ( has-contra-section-ev-pt A a is-final-a C is-contravariant-C)) Final objects in slice categories \u00b6 The type slice A a is the type of arrows in \\(A\\) with codomain \\(a\\) . #def slice ( A : U) ( a : A) : U := \u03a3 ( z : A) , (hom A z a) We now show that the slice over \\(a\\) in a Segal type \\(A\\) has a final object given by the identity arrow at \\(a\\) . This makes use of the following equivalence. #def equiv-hom-in-slice ( A : U) ( a x : A) ( f : hom A x a) : Equiv ( hom (slice A a) (x , f) (a , id-hom A a)) ( (t : \u0394\u00b9) \u2192 hom A (f t) a [t \u2261 1\u2082 \u21a6 id-hom A a]) := ( \\ h t s \u2192 ( second (h s)) t , (( \\ k s \u2192 ( k 0\u2082 s , \\ t \u2192 k t s) , \\ h \u2192 refl ) , ( \\ k s \u2192 ( k 0\u2082 s , \\ t \u2192 k t s) , \\ k \u2192 refl ))) Since \\(\\ z \u2192 hom A z a\\) is contravariant when \\(A\\) is Segal, this latter type is contractible. #def is-contr-is-segal-hom-in-slice ( A : U) ( is-segal-A : is-segal A) ( a x : A) ( f : hom A x a) : is-contr ( (t : \u0394\u00b9) \u2192 hom A (f t) a [t \u2261 1\u2082 \u21a6 id-hom A a]) := ( second (has-unique-fixed-codomain-lifts-iff-is-contravariant A ( \\ z \u2192 hom A z a))) ( is-contravariant-representable-is-segal A is-segal-A a) ( x) ( a) ( f) ( id-hom A a) This proves the finality of identity arrows in the slice of a Segal type. RS17, Lemma 9.8, dual #def is-final-id-hom-is-segal ( A : U) ( is-segal-A : is-segal A) ( a : A) : is-final (slice A a) (a , id-hom A a) := \\ (x , f) \u2192 is-contr-equiv-is-contr' ( hom (slice A a) (x , f) (a , id-hom A a)) ( (t : \u0394\u00b9) \u2192 hom A (f t) a [t \u2261 1\u2082 \u21a6 id-hom A a]) ( equiv-hom-in-slice A a x f) ( is-contr-is-segal-hom-in-slice A is-segal-A a x f) Contravariant Dependent Yoneda lemma \u00b6 The contravariant version of the dependent Yoneda lemma now follows by specializing these results. #def contra-dependent-evid ( A : U) ( a : A) ( C : (slice A a) \u2192 U) : ( (p : slice A a) \u2192 C p) \u2192 C (a , id-hom A a) := \\ s \u2192 s (a , id-hom A a) #def contra-dependent-yoneda-lemma' uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : (slice A a) \u2192 U) ( is-contravariant-C : is-contravariant (slice A a) C) : is-equiv ( (p : slice A a) \u2192 C p) ( C (a , id-hom A a)) ( contra-dependent-evid A a C) := is-equiv-contravariant-ev-final ( slice A a) ( (a , id-hom A a)) ( is-final-id-hom-is-segal A is-segal-A a) ( C) ( is-contravariant-C) The actual contravariant dependent Yoneda is equivalent to the result just proven, just with an equivalent type in the domain of the evaluation map. RS17, Theorem 9.5, dual #def contra-dependent-yoneda-lemma uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : (slice A a) \u2192 U) ( is-contravariant-C : is-contravariant (slice A a) C) : is-equiv ( (x : A) \u2192 ( f : hom A x a) \u2192 C (x , f)) ( C (a , id-hom A a)) ( \\ s \u2192 s a (id-hom A a)) := is-equiv-left-factor ( (p : slice A a) \u2192 C p) ( (x : A) \u2192 ( f : hom A x a) \u2192 C (x , f)) ( C (a , id-hom A a)) ( first (equiv-dependent-curry A ( \\ z \u2192 hom A z a) ( \\ x f \u2192 C (x , f)))) ( second (equiv-dependent-curry A ( \\ z \u2192 hom A z a) ( \\ x f \u2192 C (x , f)))) ( \\ s \u2192 s a (id-hom A a)) ( contra-dependent-yoneda-lemma' A is-segal-A a C is-contravariant-C)","title":"The Yoneda Lemma"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-lemma","text":"These formalisations correspond to Section 9 of the RS17 paper. This is a literate rzk file: #lang rzk-1","title":"The Yoneda lemma"},{"location":"simplicial-hott/09-yoneda.rzk/#prerequisites","text":"hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 8-covariant.md - We use covariant type families. Some of the definitions in this file rely on function extensionality and extension extensionality: #assume funext : FunExt #assume extext : ExtExt","title":"Prerequisites"},{"location":"simplicial-hott/09-yoneda.rzk/#natural-transformations-involving-a-representable-functor","text":"Fix a Segal type \\(A\\) and a term \\(a : A\\) . The Yoneda lemma characterizes natural transformations from the representable type family hom A a : A \u2192 U to a covariant type family C : A \u2192 U . Ordinarily, such a natural transformation would involve a family of maps \u03d5 : ( z : A) \u2192 hom A a z \u2192 C z together with a proof of naturality of these components, but by naturality-covariant-fiberwise-transformation naturality is automatic. #def naturality-covariant-fiberwise-representable-transformation ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A a x) ( g : hom A x y) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) ( \u03d5 : ( z : A) \u2192 hom A a z \u2192 C z) : (covariant-transport A x y g C is-covariant-C (\u03d5 x f)) = (\u03d5 y (comp-is-segal A is-segal-A a x y f g)) := naturality-covariant-fiberwise-transformation A x y g ( \\ z \u2192 hom A a z) ( C) ( is-covariant-representable-is-segal A is-segal-A a) ( is-covariant-C) ( \u03d5) ( f)","title":"Natural transformations involving a representable functor"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-maps","text":"For any Segal type \\(A\\) and term \\(a : A\\) , the Yoneda lemma provides an equivalence between the type ( z : A) \u2192 hom A a z \u2192 C z of natural transformations out of the functor hom A a and values in an arbitrary covariant family \\(C\\) and the type \\(C a\\) . One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the covariant transport operation. The following map, evid , evaluates a natural transformation out of a representable functor at the identity arrow. #def evid ( A : U) ( a : A) ( C : A \u2192 U) : ( (z : A) \u2192 hom A a z \u2192 C z) \u2192 C a := \\ \u03d5 \u2192 \u03d5 a (id-hom A a) The inverse map only exists for Segal types. #def yon ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) : C a \u2192 ( (z : A) \u2192 hom A a z \u2192 C z) := \\ u x f \u2192 covariant-transport A a x f C is-covariant-C u","title":"The Yoneda maps"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-composites","text":"It remains to show that the Yoneda maps are inverses. One retraction is straightforward: #def evid-yon ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) ( u : C a) : ( evid A a C) ((yon A is-segal-A a C is-covariant-C) u) = u := id-arr-covariant-transport A a C is-covariant-C u The other composite carries \\(\u03d5\\) to an a priori distinct natural transformation. We first show that these are pointwise equal at all x : A and f : hom A a x in two steps. #section yon-evid #variable A : U #variable is-segal-A : is-segal A #variable a : A #variable C : A \u2192 U #variable is-covariant-C : is-covariant A C The composite yon-evid of \u03d5 equals \u03d5 at all x : A and f : hom A a x . #def yon-evid-twice-pointwise ( \u03d5 : ( z : A) \u2192 hom A a z \u2192 C z) ( x : A) ( f : hom A a x) : ( (yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x f = \u03d5 x f := concat ( C x) ( ((yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x f) ( \u03d5 x (comp-is-segal A is-segal-A a a x (id-hom A a) f)) ( \u03d5 x f) ( naturality-covariant-fiberwise-representable-transformation A is-segal-A a a x (id-hom A a) f C is-covariant-C \u03d5) ( ap ( hom A a x) ( C x) ( comp-is-segal A is-segal-A a a x (id-hom A a) f) ( f) ( \u03d5 x) ( id-comp-is-segal A is-segal-A a x f)) By funext , these are equals as functions of f pointwise in x . #def yon-evid-once-pointwise uses ( funext ) ( \u03d5 : ( z : A) \u2192 hom A a z \u2192 C z) ( x : A) : ( (yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x = \u03d5 x := eq-htpy funext ( hom A a x) ( \\ f \u2192 C x) ( \\ f \u2192 ((yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x f) ( \\ f \u2192 (\u03d5 x f)) ( \\ f \u2192 yon-evid-twice-pointwise \u03d5 x f) By funext again, these are equal as functions of x and f . #def yon-evid uses ( funext ) ( \u03d5 : ( z : A) \u2192 hom A a z \u2192 C z) : ( (yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) = \u03d5 := eq-htpy funext ( A) ( \\ x \u2192 (hom A a x \u2192 C x)) ( \\ x \u2192 ((yon A is-segal-A a C is-covariant-C) ((evid A a C) \u03d5)) x) ( \\ x \u2192 (\u03d5 x)) ( \\ x \u2192 yon-evid-once-pointwise \u03d5 x) #end yon-evid","title":"The Yoneda composites"},{"location":"simplicial-hott/09-yoneda.rzk/#the-yoneda-lemma_1","text":"The Yoneda lemma says that evaluation at the identity defines an equivalence. This is proven combining the previous steps. RS17, Theorem 9.1 #def yoneda-lemma uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) : is-equiv ( (z : A) \u2192 hom A a z \u2192 C z) (C a) (evid A a C) := ( ( ( yon A is-segal-A a C is-covariant-C) , ( yon-evid A is-segal-A a C is-covariant-C)) , ( ( yon A is-segal-A a C is-covariant-C) , ( evid-yon A is-segal-A a C is-covariant-C)))","title":"The Yoneda lemma"},{"location":"simplicial-hott/09-yoneda.rzk/#naturality","text":"The equivalence of the Yoneda lemma is natural in both \\(a : A\\) and \\(C : A \u2192 U\\) . Naturality in \\(a\\) follows from the fact that the maps evid and yon are fiberwise equivalences between covariant families over \\(A\\) , though it requires some work to prove that the domain is covariant. #def is-covariant-yoneda-domain uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) : is-covariant A ( \\ a \u2192 (z : A) \u2192 hom A a z \u2192 C z) := equiv-is-covariant ( extext) ( A) ( \\ a -> (z : A) \u2192 hom A a z \u2192 C z) ( C) ( \\ a -> (evid A a C , yoneda-lemma A is-segal-A a C is-covariant-C)) ( is-covariant-C) #def is-natural-in-object-evid uses ( funext extext ) ( A : U) ( is-segal-A : is-segal A) ( a b : A) ( f : hom A a b) ( C : A -> U) ( is-covariant-C : is-covariant A C) ( \u03d5 : ( z : A) \u2192 hom A a z \u2192 C z) : ( covariant-transport A a b f C is-covariant-C (evid A a C \u03d5)) = ( evid A b C ( covariant-transport A a b f ( \\ x -> (z : A) \u2192 hom A x z \u2192 C z) ( is-covariant-yoneda-domain A is-segal-A C is-covariant-C) \u03d5)) := naturality-covariant-fiberwise-transformation ( A) ( a) ( b) ( f) ( \\ x -> (z : A) \u2192 hom A x z \u2192 C z) ( C) ( is-covariant-yoneda-domain A is-segal-A C is-covariant-C) ( is-covariant-C) ( \\ x -> evid A x C) ( \u03d5) #def is-natural-in-object-yon uses ( funext extext ) ( A : U) ( is-segal-A : is-segal A) ( a b : A) ( f : hom A a b) ( C : A -> U) ( is-covariant-C : is-covariant A C) ( u : C a) : ( covariant-transport A a b f ( \\ x -> (z : A) \u2192 hom A x z \u2192 C z) ( is-covariant-yoneda-domain A is-segal-A C is-covariant-C) ( yon A is-segal-A a C is-covariant-C u)) = ( yon A is-segal-A b C is-covariant-C ( covariant-transport A a b f C is-covariant-C u)) := naturality-covariant-fiberwise-transformation ( A) ( a) ( b) ( f) ( C) ( \\ x -> (z : A) \u2192 hom A x z \u2192 C z) ( is-covariant-C) ( is-covariant-yoneda-domain A is-segal-A C is-covariant-C) ( \\ x -> yon A is-segal-A x C is-covariant-C) ( u) Naturality in \\(C\\) is not automatic but can be proven easily: RS17, Lemma 9.2(i) #def is-natural-in-family-evid ( A : U) ( a : A) ( C D : A \u2192 U) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( \u03c6 : ( z : A) \u2192 hom A a z \u2192 C z) : ( comp ((z : A) \u2192 hom A a z \u2192 C z) (C a) (D a) (\u03c8 a) (evid A a C)) \u03c6 = ( comp ((z : A) \u2192 hom A a z \u2192 C z) ( (z : A) \u2192 hom A a z \u2192 D z) (D a) ( evid A a D) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))) \u03c6 := refl RS17, Lemma 9.2(ii) #def is-natural-in-family-yon-twice-pointwise ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C D : A \u2192 U) ( is-covariant-C : is-covariant A C) ( is-covariant-D : is-covariant A D) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( u : C a) ( x : A) ( f : hom A a x) : ( comp (C a) (D a) ( (z : A) \u2192 hom A a z \u2192 D z) ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u x f = ( comp (C a) ( (z : A) \u2192 hom A a z \u2192 C z) ( (z : A) \u2192 hom A a z \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u x f := naturality-covariant-fiberwise-transformation A a x f C D is-covariant-C is-covariant-D \u03c8 u #def is-natural-in-family-yon-once-pointwise uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C D : A \u2192 U) ( is-covariant-C : is-covariant A C) ( is-covariant-D : is-covariant A D) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( u : C a) ( x : A) : ( comp (C a) (D a) ( (z : A) \u2192 hom A a z \u2192 D z) ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u x = ( comp (C a) ( (z : A) \u2192 hom A a z \u2192 C z) ( (z : A) \u2192 hom A a z \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u x := eq-htpy funext ( hom A a x) ( \\ f \u2192 D x) ( \\ f \u2192 ( comp (C a) (D a) ( (z : A) \u2192 hom A a z \u2192 D z) ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u x f) ( \\ f \u2192 ( comp (C a) ( (z : A) \u2192 hom A a z \u2192 C z) ( (z : A) \u2192 hom A a z \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u x f) ( \\ f \u2192 is-natural-in-family-yon-twice-pointwise A is-segal-A a C D is-covariant-C is-covariant-D \u03c8 u x f) #def is-natural-in-family-yon uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C D : A \u2192 U) ( is-covariant-C : is-covariant A C) ( is-covariant-D : is-covariant A D) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( u : C a) : ( comp (C a) (D a) ( (z : A) \u2192 hom A a z \u2192 D z) ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u = ( comp (C a) ( (z : A) \u2192 hom A a z \u2192 C z) ( (z : A) \u2192 hom A a z \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u := eq-htpy funext ( A) ( \\ x \u2192 hom A a x \u2192 D x) ( \\ x \u2192 ( comp (C a) (D a) ( (z : A) \u2192 hom A a z \u2192 D z) ( yon A is-segal-A a D is-covariant-D) (\u03c8 a)) u x) ( \\ x \u2192 ( comp (C a) ( (z : A) \u2192 hom A a z \u2192 C z) ( (z : A) \u2192 hom A a z \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (yon A is-segal-A a C is-covariant-C)) u x) ( \\ x \u2192 is-natural-in-family-yon-once-pointwise A is-segal-A a C D is-covariant-C is-covariant-D \u03c8 u x)","title":"Naturality"},{"location":"simplicial-hott/09-yoneda.rzk/#yoneda-for-contravariant-families","text":"Dually, the Yoneda lemma for contravariant type families characterizes natural transformations from the contravariant family represented by a term \\(a : A\\) in a Segal type to a contravariant type family \\(C : A \u2192 U\\) . By naturality-contravariant-fiberwise-transformation naturality is again automatic. #def naturality-contravariant-fiberwise-representable-transformation ( A : U) ( is-segal-A : is-segal A) ( a x y : A) ( f : hom A y a) ( g : hom A x y) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( \u03d5 : ( z : A) \u2192 hom A z a \u2192 C z) : ( contravariant-transport A x y g C is-contravariant-C (\u03d5 y f)) = ( \u03d5 x (comp-is-segal A is-segal-A x y a g f)) := naturality-contravariant-fiberwise-transformation A x y g ( \\ z \u2192 hom A z a) C ( is-contravariant-representable-is-segal A is-segal-A a) ( is-contravariant-C) ( \u03d5) ( f) For any Segal type \\(A\\) and term \\(a : A\\) , the contravariant Yoneda lemma provides an equivalence between the type ( z : A) \u2192 hom A z a \u2192 C z of natural transformations out of the functor \\ z \u2192 hom A z a and valued in an arbitrary contravariant family \\(C\\) and the type \\(C a\\) . One of the maps in this equivalence is evaluation at the identity. The inverse map makes use of the contravariant transport operation. The following map, contra-evid evaluates a natural transformation out of a representable functor at the identity arrow. #def contra-evid ( A : U) ( a : A) ( C : A \u2192 U) : ( (z : A) \u2192 hom A z a \u2192 C z) \u2192 C a := \\ \u03d5 \u2192 \u03d5 a (id-hom A a) The inverse map only exists for Segal types and contravariant families. #def contra-yon ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) : C a \u2192 ( (z : A) \u2192 hom A z a \u2192 C z) := \\ v z f \u2192 contravariant-transport A z a f C is-contravariant-C v It remains to show that the Yoneda maps are inverses. One retraction is straightforward: #def contra-evid-yon ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( v : C a) : contra-evid A a C ((contra-yon A is-segal-A a C is-contravariant-C) v) = v := id-arr-contravariant-transport A a C is-contravariant-C v The other composite carries \\(\u03d5\\) to an a priori distinct natural transformation. We first show that these are pointwise equal at all x : A and f : hom A x a in two steps. #section contra-yon-evid #variable A : U #variable is-segal-A : is-segal A #variable a : A #variable C : A \u2192 U #variable is-contravariant-C : is-contravariant A C The composite contra-yon-evid of \u03d5 equals \u03d5 at all x : A and f : hom A x a . #def contra-yon-evid-twice-pointwise ( \u03d5 : ( z : A) \u2192 hom A z a \u2192 C z) ( x : A) ( f : hom A x a) : ( (contra-yon A is-segal-A a C is-contravariant-C) ((contra-evid A a C) \u03d5)) x f = \u03d5 x f := concat ( C x) ( ((contra-yon A is-segal-A a C is-contravariant-C) ((contra-evid A a C) \u03d5)) x f) ( \u03d5 x (comp-is-segal A is-segal-A x a a f (id-hom A a))) ( \u03d5 x f) ( naturality-contravariant-fiberwise-representable-transformation A is-segal-A a x a (id-hom A a) f C is-contravariant-C \u03d5) ( ap ( hom A x a) ( C x) ( comp-is-segal A is-segal-A x a a f (id-hom A a)) ( f) ( \u03d5 x) ( comp-id-is-segal A is-segal-A x a f)) By funext , these are equals as functions of f pointwise in x . #def contra-yon-evid-once-pointwise uses ( funext ) ( \u03d5 : ( z : A) \u2192 hom A z a \u2192 C z) ( x : A) : ( (contra-yon A is-segal-A a C is-contravariant-C) ( (contra-evid A a C) \u03d5)) x = \u03d5 x := eq-htpy funext ( hom A x a) ( \\ f \u2192 C x) ( \\ f \u2192 ( (contra-yon A is-segal-A a C is-contravariant-C) ( (contra-evid A a C) \u03d5)) x f) ( \\ f \u2192 (\u03d5 x f)) ( \\ f \u2192 contra-yon-evid-twice-pointwise \u03d5 x f) By funext again, these are equal as functions of x and f . #def contra-yon-evid uses ( funext ) ( \u03d5 : ( z : A) \u2192 hom A z a \u2192 C z) : contra-yon A is-segal-A a C is-contravariant-C (contra-evid A a C \u03d5) = \u03d5 := eq-htpy funext ( A) ( \\ x \u2192 (hom A x a \u2192 C x)) ( contra-yon A is-segal-A a C is-contravariant-C (contra-evid A a C \u03d5)) ( \u03d5) ( contra-yon-evid-once-pointwise \u03d5) #end contra-yon-evid The contravariant Yoneda lemma says that evaluation at the identity defines an equivalence. #def contra-yoneda-lemma uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) : is-equiv ( (z : A) \u2192 hom A z a \u2192 C z) (C a) (contra-evid A a C) := ( ( ( contra-yon A is-segal-A a C is-contravariant-C) , ( contra-yon-evid A is-segal-A a C is-contravariant-C)) , ( ( contra-yon A is-segal-A a C is-contravariant-C) , ( contra-evid-yon A is-segal-A a C is-contravariant-C)))","title":"Yoneda for contravariant families"},{"location":"simplicial-hott/09-yoneda.rzk/#contravariant-naturality","text":"The equivalence of the Yoneda lemma is natural in both \\(a : A\\) and \\(C : A \u2192 U\\) . Naturality in \\(a\\) follows from the fact that the maps evid and yon are fiberwise equivalences between contravariant families over \\(A\\) , though it requires some work, which has not yet been formalized, to prove that the domain is contravariant. Naturality in \\(C\\) is not automatic but can be proven easily: RS17, Lemma 9.2(i), dual #def is-natural-in-family-contra-evid ( A : U) ( a : A) ( C D : A \u2192 U) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( \u03c6 : ( z : A) \u2192 hom A z a \u2192 C z) : ( comp ((z : A) \u2192 hom A z a \u2192 C z) (C a) (D a) ( \u03c8 a) (contra-evid A a C)) \u03c6 = ( comp ((z : A) \u2192 hom A z a \u2192 C z) ( (z : A) \u2192 hom A z a \u2192 D z) (D a) ( contra-evid A a D) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g))) \u03c6 := refl RS17, Lemma 9.2(ii), dual #def is-natural-in-family-contra-yon-twice-pointwise ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C D : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( is-contravariant-D : is-contravariant A D) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( u : C a) ( x : A) ( f : hom A x a) : ( comp (C a) (D a) ( (z : A) \u2192 hom A z a \u2192 D z) ( contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u x f = ( comp (C a) ( (z : A) \u2192 hom A z a \u2192 C z) ( (z : A) \u2192 hom A z a \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) ( contra-yon A is-segal-A a C is-contravariant-C)) u x f := naturality-contravariant-fiberwise-transformation A x a f C D is-contravariant-C is-contravariant-D \u03c8 u #def is-natural-in-family-contra-yon-once-pointwise uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C D : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( is-contravariant-D : is-contravariant A D) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( u : C a) ( x : A) : ( comp (C a) (D a) ( (z : A) \u2192 hom A z a \u2192 D z) (contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u x = ( comp (C a) ( (z : A) \u2192 hom A z a \u2192 C z) ( (z : A) \u2192 hom A z a \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) (contra-yon A is-segal-A a C is-contravariant-C)) u x := eq-htpy funext ( hom A x a) ( \\ f \u2192 D x) ( \\ f \u2192 ( comp (C a) (D a) ( (z : A) \u2192 hom A z a \u2192 D z) ( contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u x f) ( \\ f \u2192 ( comp (C a) ( (z : A) \u2192 hom A z a \u2192 C z) ( (z : A) \u2192 hom A z a \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) ( contra-yon A is-segal-A a C is-contravariant-C)) u x f) ( \\ f \u2192 is-natural-in-family-contra-yon-twice-pointwise A is-segal-A a C D is-contravariant-C is-contravariant-D \u03c8 u x f) #def is-natural-in-family-contra-yon uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C D : A \u2192 U) ( is-contravariant-C : is-contravariant A C) ( is-contravariant-D : is-contravariant A D) ( \u03c8 : ( z : A) \u2192 C z \u2192 D z) ( u : C a) : ( comp (C a) (D a) ( (z : A) \u2192 hom A z a \u2192 D z) ( contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u = ( comp (C a) ( (z : A) \u2192 hom A z a \u2192 C z) ( (z : A) \u2192 hom A z a \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) ( contra-yon A is-segal-A a C is-contravariant-C)) u := eq-htpy funext ( A) ( \\ x \u2192 hom A x a \u2192 D x) ( \\ x \u2192 ( comp (C a) (D a) ( (z : A) \u2192 hom A z a \u2192 D z) ( contra-yon A is-segal-A a D is-contravariant-D) (\u03c8 a)) u x) ( \\ x \u2192 ( comp (C a) ( (z : A) \u2192 hom A z a \u2192 C z) ( (z : A) \u2192 hom A z a \u2192 D z) ( \\ \u03b1 z g \u2192 \u03c8 z (\u03b1 z g)) ( contra-yon A is-segal-A a C is-contravariant-C)) u x) ( \\ x \u2192 is-natural-in-family-contra-yon-once-pointwise A is-segal-A a C D is-contravariant-C is-contravariant-D \u03c8 u x) From a type-theoretic perspective, the Yoneda lemma is a \u201cdirected\u201d version of the \u201ctransport\u201d operation for identity types. This suggests a \u201cdependently typed\u201d generalization of the Yoneda lemma, analogous to the full induction principle for identity types. We prove this as a special case of a result about covariant families over a type with an initial object.","title":"Contravariant Naturality"},{"location":"simplicial-hott/09-yoneda.rzk/#initial-objects","text":"A term \\(a\\) in a type \\(A\\) is initial if all of its mapping-out hom types are contractible. RS17, Definition 9.6 #def is-initial ( A : U) ( a : A) : U := ( x : A) \u2192 is-contr (hom A a x) Initial objects satisfy an induction principle relative to covariant families. #section initial-evaluation-equivalence #variable A : U #variable a : A #variable is-initial-a : is-initial A a #variable C : A \u2192 U #variable is-covariant-C : is-covariant A C #def arrows-from-initial ( x : A) : hom A a x := center-contraction (hom A a x) (is-initial-a x) #def identity-component-arrows-from-initial : arrows-from-initial a = id-hom A a := homotopy-contraction (hom A a a) (is-initial-a a) (id-hom A a) #def ind-initial uses ( is-initial-a ) ( u : C a) : ( x : A) \u2192 C x := \\ x \u2192 covariant-transport A a x (arrows-from-initial x) C is-covariant-C u #def has-cov-section-ev-pt uses ( is-initial-a ) : has-section ( (x : A) \u2192 C x) (C a) (ev-pt A a C) := ( ( ind-initial) , ( \\ u \u2192 concat ( C a) ( covariant-transport A a a ( arrows-from-initial a) C is-covariant-C u) ( covariant-transport A a a ( id-hom A a) C is-covariant-C u) ( u) ( ap ( hom A a a) ( C a) ( arrows-from-initial a) ( id-hom A a) ( \\ f \u2192 covariant-transport A a a f C is-covariant-C u) ( identity-component-arrows-from-initial)) ( id-arr-covariant-transport A a C is-covariant-C u))) #def ind-initial-ev-pt-pointwise uses ( is-initial-a ) ( s : ( x : A) \u2192 C x) ( b : A) : ind-initial (ev-pt A a C s) b = s b := covariant-uniqueness ( A) ( a) ( b) ( arrows-from-initial b) ( C) ( is-covariant-C) ( ev-pt A a C s) ( ( s b , \\ t \u2192 s (arrows-from-initial b t))) #end initial-evaluation-equivalence We now prove that induction from an initial element in the base of a covariant family defines an inverse equivalence to evaluation at the element. RS17, Theorem 9.7 #def is-equiv-covariant-ev-initial uses ( funext ) ( A : U) ( a : A) ( is-initial-a : is-initial A a) ( C : A \u2192 U) ( is-covariant-C : is-covariant A C) : is-equiv ( (x : A) \u2192 C x) (C a) (ev-pt A a C) := ( ( ( ind-initial A a is-initial-a C is-covariant-C) , ( \\ s \u2192 eq-htpy funext ( A) ( C) ( ind-initial A a is-initial-a C is-covariant-C (ev-pt A a C s)) ( s) ( ind-initial-ev-pt-pointwise A a is-initial-a C is-covariant-C s))) , ( has-cov-section-ev-pt A a is-initial-a C is-covariant-C))","title":"Initial objects"},{"location":"simplicial-hott/09-yoneda.rzk/#initial-objects-in-slice-categories","text":"The type coslice A a is the type of arrows in \\(A\\) with domain \\(a\\) . #def coslice ( A : U) ( a : A) : U := \u03a3 ( z : A) , (hom A a z) We now show that the coslice under \\(a\\) in a Segal type \\(A\\) has an initial object given by the identity arrow at \\(a\\) . This makes use of the following equivalence. #def equiv-hom-in-coslice ( A : U) ( a x : A) ( f : hom A a x) : Equiv ( hom (coslice A a) (a , id-hom A a) (x , f)) ( (t : \u0394\u00b9) \u2192 hom A a (f t) [t \u2261 0\u2082 \u21a6 id-hom A a]) := ( \\ h t s \u2192 ( second (h s)) t , (( \\ k s \u2192 ( k 1\u2082 s , \\ t \u2192 k t s) , \\ h \u2192 refl ) , ( \\ k s \u2192 ( k 1\u2082 s , \\ t \u2192 k t s) , \\ k \u2192 refl ))) Since \\(hom A a\\) is covariant when \\(A\\) is Segal, this latter type is contractible. #def is-contr-is-segal-hom-in-coslice ( A : U) ( is-segal-A : is-segal A) ( a x : A) ( f : hom A a x) : is-contr ( (t : \u0394\u00b9) \u2192 hom A a (f t) [t \u2261 0\u2082 \u21a6 id-hom A a]) := ( second (has-unique-fixed-domain-lifts-iff-is-covariant A ( \\ z \u2192 hom A a z))) ( is-covariant-representable-is-segal A is-segal-A a) ( a) ( x) ( f) ( id-hom A a) This proves the initiality of identity arrows in the coslice of a Segal type. RS17, Lemma 9.8 #def is-initial-id-hom-is-segal ( A : U) ( is-segal-A : is-segal A) ( a : A) : is-initial (coslice A a) (a , id-hom A a) := \\ (x , f) \u2192 is-contr-equiv-is-contr' ( hom (coslice A a) (a , id-hom A a) (x , f)) ( (t : \u0394\u00b9) \u2192 hom A a (f t) [t \u2261 0\u2082 \u21a6 id-hom A a]) ( equiv-hom-in-coslice A a x f) ( is-contr-is-segal-hom-in-coslice A is-segal-A a x f)","title":"Initial objects in slice categories"},{"location":"simplicial-hott/09-yoneda.rzk/#dependent-yoneda-lemma","text":"The dependent Yoneda lemma now follows by specializing these results. #def dependent-evid ( A : U) ( a : A) ( C : (coslice A a) \u2192 U) : ( (p : coslice A a) \u2192 C p) \u2192 C (a , id-hom A a) := \\ s \u2192 s (a , id-hom A a) #def dependent-yoneda-lemma' uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : (coslice A a) \u2192 U) ( is-covariant-C : is-covariant (coslice A a) C) : is-equiv ( (p : coslice A a) \u2192 C p) ( C (a , id-hom A a)) ( dependent-evid A a C) := is-equiv-covariant-ev-initial ( coslice A a) ( (a , id-hom A a)) ( is-initial-id-hom-is-segal A is-segal-A a) ( C) ( is-covariant-C) The actual dependent Yoneda is equivalent to the result just proven, just with an equivalent type in the domain of the evaluation map. RS17, Theorem 9.5 #def dependent-yoneda-lemma uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : (coslice A a) \u2192 U) ( is-covariant-C : is-covariant (coslice A a) C) : is-equiv ( (x : A) \u2192 ( f : hom A a x) \u2192 C (x , f)) ( C (a , id-hom A a)) ( \\ s \u2192 s a (id-hom A a)) := is-equiv-left-factor ( (p : coslice A a) \u2192 C p) ( (x : A) \u2192 ( f : hom A a x) \u2192 C (x , f)) ( C (a , id-hom A a)) ( first (equiv-dependent-curry A ( \\ z \u2192 hom A a z) ( \\ x f \u2192 C (x , f)))) ( second (equiv-dependent-curry A ( \\ z \u2192 hom A a z) ( \\ x f \u2192 C (x , f)))) ( \\ s \u2192 s a (id-hom A a)) ( dependent-yoneda-lemma' A is-segal-A a C is-covariant-C)","title":"Dependent Yoneda lemma"},{"location":"simplicial-hott/09-yoneda.rzk/#final-objects","text":"A term \\(a\\) in a type \\(A\\) is initial if all of its mapping-out hom types are contractible. #def is-final ( A : U) ( a : A) : U := ( x : A) \u2192 is-contr (hom A x a) Final objects satisfy an induction principle relative to contravariant families. #section final-evaluation-equivalence #variable A : U #variable a : A #variable is-final-a : is-final A a #variable C : A \u2192 U #variable is-contravariant-C : is-contravariant A C #def arrows-to-final ( x : A) : hom A x a := center-contraction (hom A x a) (is-final-a x) #def identity-component-arrows-to-final : arrows-to-final a = id-hom A a := homotopy-contraction (hom A a a) (is-final-a a) (id-hom A a) #def ind-final uses ( is-final-a ) ( u : C a) : ( x : A) \u2192 C x := \\ x \u2192 contravariant-transport A x a (arrows-to-final x) C is-contravariant-C u #def has-contra-section-ev-pt uses ( is-final-a ) : has-section ( (x : A) \u2192 C x) (C a) (ev-pt A a C) := ( ( ind-final) , ( \\ u \u2192 concat ( C a) ( contravariant-transport A a a ( arrows-to-final a) C is-contravariant-C u) ( contravariant-transport A a a ( id-hom A a) C is-contravariant-C u) ( u) ( ap ( hom A a a) ( C a) ( arrows-to-final a) ( id-hom A a) ( \\ f \u2192 contravariant-transport A a a f C is-contravariant-C u) ( identity-component-arrows-to-final)) ( id-arr-contravariant-transport A a C is-contravariant-C u))) #def ind-final-ev-pt-pointwise uses ( is-final-a ) ( s : ( x : A) \u2192 C x) ( b : A) : ind-final (ev-pt A a C s) b = s b := contravariant-uniqueness ( A) ( b) ( a) ( arrows-to-final b) ( C) ( is-contravariant-C) ( ev-pt A a C s) ( ( s b , \\ t \u2192 s (arrows-to-final b t))) #end final-evaluation-equivalence We now prove that induction from a final element in the base of a contravariant family defines an inverse equivalence to evaluation at the element. RS17, Theorem 9.7, dual #def is-equiv-contravariant-ev-final uses ( funext ) ( A : U) ( a : A) ( is-final-a : is-final A a) ( C : A \u2192 U) ( is-contravariant-C : is-contravariant A C) : is-equiv ( (x : A) \u2192 C x) (C a) (ev-pt A a C) := ( ( ( ind-final A a is-final-a C is-contravariant-C) , ( \\ s \u2192 eq-htpy funext ( A) ( C) ( ind-final A a is-final-a C is-contravariant-C (ev-pt A a C s)) ( s) ( ind-final-ev-pt-pointwise A a is-final-a C is-contravariant-C s))) , ( has-contra-section-ev-pt A a is-final-a C is-contravariant-C))","title":"Final objects"},{"location":"simplicial-hott/09-yoneda.rzk/#final-objects-in-slice-categories","text":"The type slice A a is the type of arrows in \\(A\\) with codomain \\(a\\) . #def slice ( A : U) ( a : A) : U := \u03a3 ( z : A) , (hom A z a) We now show that the slice over \\(a\\) in a Segal type \\(A\\) has a final object given by the identity arrow at \\(a\\) . This makes use of the following equivalence. #def equiv-hom-in-slice ( A : U) ( a x : A) ( f : hom A x a) : Equiv ( hom (slice A a) (x , f) (a , id-hom A a)) ( (t : \u0394\u00b9) \u2192 hom A (f t) a [t \u2261 1\u2082 \u21a6 id-hom A a]) := ( \\ h t s \u2192 ( second (h s)) t , (( \\ k s \u2192 ( k 0\u2082 s , \\ t \u2192 k t s) , \\ h \u2192 refl ) , ( \\ k s \u2192 ( k 0\u2082 s , \\ t \u2192 k t s) , \\ k \u2192 refl ))) Since \\(\\ z \u2192 hom A z a\\) is contravariant when \\(A\\) is Segal, this latter type is contractible. #def is-contr-is-segal-hom-in-slice ( A : U) ( is-segal-A : is-segal A) ( a x : A) ( f : hom A x a) : is-contr ( (t : \u0394\u00b9) \u2192 hom A (f t) a [t \u2261 1\u2082 \u21a6 id-hom A a]) := ( second (has-unique-fixed-codomain-lifts-iff-is-contravariant A ( \\ z \u2192 hom A z a))) ( is-contravariant-representable-is-segal A is-segal-A a) ( x) ( a) ( f) ( id-hom A a) This proves the finality of identity arrows in the slice of a Segal type. RS17, Lemma 9.8, dual #def is-final-id-hom-is-segal ( A : U) ( is-segal-A : is-segal A) ( a : A) : is-final (slice A a) (a , id-hom A a) := \\ (x , f) \u2192 is-contr-equiv-is-contr' ( hom (slice A a) (x , f) (a , id-hom A a)) ( (t : \u0394\u00b9) \u2192 hom A (f t) a [t \u2261 1\u2082 \u21a6 id-hom A a]) ( equiv-hom-in-slice A a x f) ( is-contr-is-segal-hom-in-slice A is-segal-A a x f)","title":"Final objects in slice categories"},{"location":"simplicial-hott/09-yoneda.rzk/#contravariant-dependent-yoneda-lemma","text":"The contravariant version of the dependent Yoneda lemma now follows by specializing these results. #def contra-dependent-evid ( A : U) ( a : A) ( C : (slice A a) \u2192 U) : ( (p : slice A a) \u2192 C p) \u2192 C (a , id-hom A a) := \\ s \u2192 s (a , id-hom A a) #def contra-dependent-yoneda-lemma' uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : (slice A a) \u2192 U) ( is-contravariant-C : is-contravariant (slice A a) C) : is-equiv ( (p : slice A a) \u2192 C p) ( C (a , id-hom A a)) ( contra-dependent-evid A a C) := is-equiv-contravariant-ev-final ( slice A a) ( (a , id-hom A a)) ( is-final-id-hom-is-segal A is-segal-A a) ( C) ( is-contravariant-C) The actual contravariant dependent Yoneda is equivalent to the result just proven, just with an equivalent type in the domain of the evaluation map. RS17, Theorem 9.5, dual #def contra-dependent-yoneda-lemma uses ( funext ) ( A : U) ( is-segal-A : is-segal A) ( a : A) ( C : (slice A a) \u2192 U) ( is-contravariant-C : is-contravariant (slice A a) C) : is-equiv ( (x : A) \u2192 ( f : hom A x a) \u2192 C (x , f)) ( C (a , id-hom A a)) ( \\ s \u2192 s a (id-hom A a)) := is-equiv-left-factor ( (p : slice A a) \u2192 C p) ( (x : A) \u2192 ( f : hom A x a) \u2192 C (x , f)) ( C (a , id-hom A a)) ( first (equiv-dependent-curry A ( \\ z \u2192 hom A z a) ( \\ x f \u2192 C (x , f)))) ( second (equiv-dependent-curry A ( \\ z \u2192 hom A z a) ( \\ x f \u2192 C (x , f)))) ( \\ s \u2192 s a (id-hom A a)) ( contra-dependent-yoneda-lemma' A is-segal-A a C is-contravariant-C)","title":"Contravariant Dependent Yoneda lemma"},{"location":"simplicial-hott/10-rezk-types.rzk/","text":"Rezk types \u00b6 This is a literate rzk file: #lang rzk-1 Some of the definitions in this file rely on extension extensionality: #assume extext : ExtExt Isomorphisms \u00b6 #def has-retraction-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) : U := ( comp-is-segal A is-segal-A x y x f g) =_{hom A x x} (id-hom A x) #def Retraction-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : U := \u03a3 ( g : hom A y x) , ( has-retraction-arrow A is-segal-A x y f g) #def has-section-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( h : hom A y x) : U := ( comp-is-segal A is-segal-A y x y h f) =_{hom A y y} (id-hom A y) #def Section-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : U := \u03a3 ( h : hom A y x) , (has-section-arrow A is-segal-A x y f h) #def is-iso-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : U := product ( Retraction-arrow A is-segal-A x y f) ( Section-arrow A is-segal-A x y f) #def Iso ( A : U) ( is-segal-A : is-segal A) ( x y : A) : U := \u03a3 ( f : hom A x y) , is-iso-arrow A is-segal-A x y f Invertible arrows \u00b6 We now show that f : hom A a x is an isomorphism if and only if it is invertible, meaning f has a two-sided composition inverse g : hom A x a . #def has-inverse-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : U := \u03a3 ( g : hom A y x) , product ( has-retraction-arrow A is-segal-A x y f g) ( has-section-arrow A is-segal-A x y f g) #def is-iso-arrow-has-inverse-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : ( has-inverse-arrow A is-segal-A x y f) \u2192 (is-iso-arrow A is-segal-A x y f) := ( \\ (g , (p , q)) \u2192 ((g , p) , (g , q))) #def has-inverse-arrow-is-iso-arrow uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : (is-iso-arrow A is-segal-A x y f) \u2192 (has-inverse-arrow A is-segal-A x y f) := ( \\ ((g , p) , (h , q)) \u2192 ( g , ( p , ( concat ( hom A y y) ( comp-is-segal A is-segal-A y x y g f) ( comp-is-segal A is-segal-A y x y h f) ( id-hom A y) ( postwhisker-homotopy-is-segal A is-segal-A y x y g h f ( alternating-quintuple-concat ( hom A y x) ( g) ( comp-is-segal A is-segal-A y y x (id-hom A y) g) ( rev ( hom A y x) ( comp-is-segal A is-segal-A y y x (id-hom A y) g) ( g) ( id-comp-is-segal A is-segal-A y x g)) ( comp-is-segal A is-segal-A y y x ( comp-is-segal A is-segal-A y x y h f) ( g)) ( postwhisker-homotopy-is-segal A is-segal-A y y x ( id-hom A y) ( comp-is-segal A is-segal-A y x y h f) ( g) ( rev ( hom A y y) ( comp-is-segal A is-segal-A y x y h f) ( id-hom A y) ( q))) ( comp-is-segal A is-segal-A y x x ( h) ( comp-is-segal A is-segal-A x y x f g)) ( associative-is-segal extext A is-segal-A y x y x h f g) ( comp-is-segal A is-segal-A y x x h (id-hom A x)) ( prewhisker-homotopy-is-segal A is-segal-A y x x h ( comp-is-segal A is-segal-A x y x f g) ( id-hom A x) p) ( h) ( comp-id-is-segal A is-segal-A y x h))) ( q))))) RS17, Proposition 10.1 #def inverse-iff-iso-arrow uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : iff (has-inverse-arrow A is-segal-A x y f) (is-iso-arrow A is-segal-A x y f) := ( is-iso-arrow-has-inverse-arrow A is-segal-A x y f , has-inverse-arrow-is-iso-arrow A is-segal-A x y f) Being an isomorphism is a proposition \u00b6 The predicate is-iso-arrow is a proposition. #def has-retraction-postcomp-has-retraction uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) : ( z : A) \u2192 has-retraction (hom A z x) (hom A z y) ( postcomp-is-segal A is-segal-A x y f z) := \\ z \u2192 ( ( postcomp-is-segal A is-segal-A y x g z) , \\ k \u2192 ( triple-concat ( hom A z x) ( comp-is-segal A is-segal-A z y x ( comp-is-segal A is-segal-A z x y k f) g) ( comp-is-segal A is-segal-A z x x k ( comp-is-segal A is-segal-A x y x f g)) ( comp-is-segal A is-segal-A z x x k (id-hom A x)) ( k) ( associative-is-segal extext A is-segal-A z x y x k f g) ( prewhisker-homotopy-is-segal A is-segal-A z x x k ( comp-is-segal A is-segal-A x y x f g) (id-hom A x) gg) ( comp-id-is-segal A is-segal-A z x k))) #def has-section-postcomp-has-section uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : ( z : A) \u2192 has-section (hom A z x) (hom A z y) (postcomp-is-segal A is-segal-A x y f z) := \\ z \u2192 ( ( postcomp-is-segal A is-segal-A y x h z) , \\ k \u2192 ( triple-concat ( hom A z y) ( comp-is-segal A is-segal-A z x y ( comp-is-segal A is-segal-A z y x k h) f) ( comp-is-segal A is-segal-A z y y k (comp-is-segal A is-segal-A y x y h f)) ( comp-is-segal A is-segal-A z y y k (id-hom A y)) ( k) ( associative-is-segal extext A is-segal-A z y x y k h f) ( prewhisker-homotopy-is-segal A is-segal-A z y y k ( comp-is-segal A is-segal-A y x y h f) (id-hom A y) hh) ( comp-id-is-segal A is-segal-A z y k))) #def is-equiv-postcomp-is-iso uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : ( z : A) \u2192 is-equiv (hom A z x) (hom A z y) (postcomp-is-segal A is-segal-A x y f z) := \\ z \u2192 ( ( has-retraction-postcomp-has-retraction A is-segal-A x y f g gg z) , ( has-section-postcomp-has-section A is-segal-A x y f h hh z)) #def has-retraction-precomp-has-section uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : ( z : A) \u2192 has-retraction (hom A y z) (hom A x z) ( precomp-is-segal A is-segal-A x y f z) := \\ z \u2192 ( ( precomp-is-segal A is-segal-A y x h z) , \\ k \u2192 ( triple-concat ( hom A y z) ( comp-is-segal A is-segal-A y x z h (comp-is-segal A is-segal-A x y z f k)) ( comp-is-segal A is-segal-A y y z ( comp-is-segal A is-segal-A y x y h f) k) ( comp-is-segal A is-segal-A y y z (id-hom A y) k) ( k) ( rev ( hom A y z) ( comp-is-segal A is-segal-A y y z ( comp-is-segal A is-segal-A y x y h f) k) ( comp-is-segal A is-segal-A y x z h (comp-is-segal A is-segal-A x y z f k)) ( associative-is-segal extext A is-segal-A y x y z h f k)) ( postwhisker-homotopy-is-segal A is-segal-A y y z ( comp-is-segal A is-segal-A y x y h f) ( id-hom A y) k hh) ( id-comp-is-segal A is-segal-A y z k) ) ) #def has-section-precomp-has-retraction uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) : ( z : A) \u2192 has-section (hom A y z) (hom A x z) (precomp-is-segal A is-segal-A x y f z) := \\ z \u2192 ( ( precomp-is-segal A is-segal-A y x g z) , \\ k \u2192 ( triple-concat ( hom A x z) ( comp-is-segal A is-segal-A x y z f (comp-is-segal A is-segal-A y x z g k)) ( comp-is-segal A is-segal-A x x z ( comp-is-segal A is-segal-A x y x f g) k) ( comp-is-segal A is-segal-A x x z ( id-hom A x) k) ( k) ( rev ( hom A x z) ( comp-is-segal A is-segal-A x x z ( comp-is-segal A is-segal-A x y x f g) k) ( comp-is-segal A is-segal-A x y z f (comp-is-segal A is-segal-A y x z g k)) ( associative-is-segal extext A is-segal-A x y x z f g k)) ( postwhisker-homotopy-is-segal A is-segal-A x x z ( comp-is-segal A is-segal-A x y x f g) ( id-hom A x) ( k) ( gg)) ( id-comp-is-segal A is-segal-A x z k))) #def is-equiv-precomp-is-iso uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : ( z : A) \u2192 is-equiv (hom A y z) (hom A x z) (precomp-is-segal A is-segal-A x y f z) := \\ z \u2192 ( ( has-retraction-precomp-has-section A is-segal-A x y f h hh z) , ( has-section-precomp-has-retraction A is-segal-A x y f g gg z)) #def is-contr-Retraction-arrow-is-iso uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : is-contr (Retraction-arrow A is-segal-A x y f) := ( is-contr-map-is-equiv ( hom A y x) ( hom A x x) ( precomp-is-segal A is-segal-A x y f x) ( is-equiv-precomp-is-iso A is-segal-A x y f g gg h hh x)) ( id-hom A x) #def is-contr-Section-arrow-is-iso uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : is-contr (Section-arrow A is-segal-A x y f) := ( is-contr-map-is-equiv ( hom A y x) ( hom A y y) ( postcomp-is-segal A is-segal-A x y f y) ( is-equiv-postcomp-is-iso A is-segal-A x y f g gg h hh y)) ( id-hom A y) #def is-contr-is-iso-arrow-is-iso uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : is-contr (is-iso-arrow A is-segal-A x y f) := ( is-contr-product ( Retraction-arrow A is-segal-A x y f) ( Section-arrow A is-segal-A x y f) ( is-contr-Retraction-arrow-is-iso A is-segal-A x y f g gg h hh) ( is-contr-Section-arrow-is-iso A is-segal-A x y f g gg h hh)) RS17, Proposition 10.2 #def is-prop-is-iso-arrow uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : (is-prop (is-iso-arrow A is-segal-A x y f)) := ( is-prop-is-contr-is-inhabited ( is-iso-arrow A is-segal-A x y f) ( \\ is-isof \u2192 ( is-contr-is-iso-arrow-is-iso A is-segal-A x y f ( first ( first is-isof)) ( second ( first is-isof)) ( first ( second is-isof)) ( second ( second is-isof))))) Rezk types \u00b6 A Segal type \\(A\\) is a Rezk type just when, for all x y : A , the natural map from x = y to Iso A is-segal-A x y is an equivalence. #def iso-id-arrow ( A : U) ( is-segal-A : is-segal A) : ( x : A) \u2192 Iso A is-segal-A x x := \\ x \u2192 ( (id-hom A x) , ( ( (id-hom A x) , (id-comp-is-segal A is-segal-A x x (id-hom A x)) ) , ( (id-hom A x) , (id-comp-is-segal A is-segal-A x x (id-hom A x)) ) ) ) #def iso-eq ( A : U) ( is-segal-A : is-segal A) ( x y : A) : (x = y) \u2192 Iso A is-segal-A x y := \\ p \u2192 ind-path ( A) ( x) ( \\ y' p' \u2192 Iso A is-segal-A x y') ( iso-id-arrow A is-segal-A x) ( y) ( p) RS17, Definition 10.6 #def is-rezk ( A : U) : U := \u03a3 ( is-segal-A : is-segal A) , ( x : A) \u2192 ( y : A) \u2192 is-equiv (x = y) (Iso A is-segal-A x y) (iso-eq A is-segal-A x y) Uniqueness of initial and final objects \u00b6 In a Segal type, initial objects are isomorphic. #def iso-initial ( A : U) ( is-segal-A : is-segal A) ( a b : A) ( is-initial-a : is-initial A a) ( is-initial-b : is-initial A b) : Iso A is-segal-A a b := ( first (is-initial-a b) , ( ( first (is-initial-b a) , eq-is-contr ( hom A a a) ( is-initial-a a) ( comp-is-segal A is-segal-A a b a ( first (is-initial-a b)) ( first (is-initial-b a))) ( id-hom A a)) , ( first (is-initial-b a) , eq-is-contr ( hom A b b) ( is-initial-b b) ( comp-is-segal A is-segal-A b a b ( first (is-initial-b a)) ( first (is-initial-a b))) ( id-hom A b)))) In a Segal type, final objects are isomorphic. #def iso-final ( A : U) ( is-segal-A : is-segal A) ( a b : A) ( is-final-a : is-final A a) ( is-final-b : is-final A b) ( iso : Iso A is-segal-A a b) : Iso A is-segal-A a b := ( first (is-final-b a) , ( ( first (is-final-a b) , eq-is-contr ( hom A a a) ( is-final-a a) ( comp-is-segal A is-segal-A a b a ( first (is-final-b a)) ( first (is-final-a b))) ( id-hom A a)) , ( first (is-final-a b) , eq-is-contr ( hom A b b) ( is-final-b b) ( comp-is-segal A is-segal-A b a b ( first (is-final-a b)) ( first (is-final-b a))) ( id-hom A b))))","title":"Rezk Types"},{"location":"simplicial-hott/10-rezk-types.rzk/#rezk-types","text":"This is a literate rzk file: #lang rzk-1 Some of the definitions in this file rely on extension extensionality: #assume extext : ExtExt","title":"Rezk types"},{"location":"simplicial-hott/10-rezk-types.rzk/#isomorphisms","text":"#def has-retraction-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) : U := ( comp-is-segal A is-segal-A x y x f g) =_{hom A x x} (id-hom A x) #def Retraction-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : U := \u03a3 ( g : hom A y x) , ( has-retraction-arrow A is-segal-A x y f g) #def has-section-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( h : hom A y x) : U := ( comp-is-segal A is-segal-A y x y h f) =_{hom A y y} (id-hom A y) #def Section-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : U := \u03a3 ( h : hom A y x) , (has-section-arrow A is-segal-A x y f h) #def is-iso-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : U := product ( Retraction-arrow A is-segal-A x y f) ( Section-arrow A is-segal-A x y f) #def Iso ( A : U) ( is-segal-A : is-segal A) ( x y : A) : U := \u03a3 ( f : hom A x y) , is-iso-arrow A is-segal-A x y f","title":"Isomorphisms"},{"location":"simplicial-hott/10-rezk-types.rzk/#invertible-arrows","text":"We now show that f : hom A a x is an isomorphism if and only if it is invertible, meaning f has a two-sided composition inverse g : hom A x a . #def has-inverse-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : U := \u03a3 ( g : hom A y x) , product ( has-retraction-arrow A is-segal-A x y f g) ( has-section-arrow A is-segal-A x y f g) #def is-iso-arrow-has-inverse-arrow ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : ( has-inverse-arrow A is-segal-A x y f) \u2192 (is-iso-arrow A is-segal-A x y f) := ( \\ (g , (p , q)) \u2192 ((g , p) , (g , q))) #def has-inverse-arrow-is-iso-arrow uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : (is-iso-arrow A is-segal-A x y f) \u2192 (has-inverse-arrow A is-segal-A x y f) := ( \\ ((g , p) , (h , q)) \u2192 ( g , ( p , ( concat ( hom A y y) ( comp-is-segal A is-segal-A y x y g f) ( comp-is-segal A is-segal-A y x y h f) ( id-hom A y) ( postwhisker-homotopy-is-segal A is-segal-A y x y g h f ( alternating-quintuple-concat ( hom A y x) ( g) ( comp-is-segal A is-segal-A y y x (id-hom A y) g) ( rev ( hom A y x) ( comp-is-segal A is-segal-A y y x (id-hom A y) g) ( g) ( id-comp-is-segal A is-segal-A y x g)) ( comp-is-segal A is-segal-A y y x ( comp-is-segal A is-segal-A y x y h f) ( g)) ( postwhisker-homotopy-is-segal A is-segal-A y y x ( id-hom A y) ( comp-is-segal A is-segal-A y x y h f) ( g) ( rev ( hom A y y) ( comp-is-segal A is-segal-A y x y h f) ( id-hom A y) ( q))) ( comp-is-segal A is-segal-A y x x ( h) ( comp-is-segal A is-segal-A x y x f g)) ( associative-is-segal extext A is-segal-A y x y x h f g) ( comp-is-segal A is-segal-A y x x h (id-hom A x)) ( prewhisker-homotopy-is-segal A is-segal-A y x x h ( comp-is-segal A is-segal-A x y x f g) ( id-hom A x) p) ( h) ( comp-id-is-segal A is-segal-A y x h))) ( q))))) RS17, Proposition 10.1 #def inverse-iff-iso-arrow uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : iff (has-inverse-arrow A is-segal-A x y f) (is-iso-arrow A is-segal-A x y f) := ( is-iso-arrow-has-inverse-arrow A is-segal-A x y f , has-inverse-arrow-is-iso-arrow A is-segal-A x y f)","title":"Invertible arrows"},{"location":"simplicial-hott/10-rezk-types.rzk/#being-an-isomorphism-is-a-proposition","text":"The predicate is-iso-arrow is a proposition. #def has-retraction-postcomp-has-retraction uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) : ( z : A) \u2192 has-retraction (hom A z x) (hom A z y) ( postcomp-is-segal A is-segal-A x y f z) := \\ z \u2192 ( ( postcomp-is-segal A is-segal-A y x g z) , \\ k \u2192 ( triple-concat ( hom A z x) ( comp-is-segal A is-segal-A z y x ( comp-is-segal A is-segal-A z x y k f) g) ( comp-is-segal A is-segal-A z x x k ( comp-is-segal A is-segal-A x y x f g)) ( comp-is-segal A is-segal-A z x x k (id-hom A x)) ( k) ( associative-is-segal extext A is-segal-A z x y x k f g) ( prewhisker-homotopy-is-segal A is-segal-A z x x k ( comp-is-segal A is-segal-A x y x f g) (id-hom A x) gg) ( comp-id-is-segal A is-segal-A z x k))) #def has-section-postcomp-has-section uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : ( z : A) \u2192 has-section (hom A z x) (hom A z y) (postcomp-is-segal A is-segal-A x y f z) := \\ z \u2192 ( ( postcomp-is-segal A is-segal-A y x h z) , \\ k \u2192 ( triple-concat ( hom A z y) ( comp-is-segal A is-segal-A z x y ( comp-is-segal A is-segal-A z y x k h) f) ( comp-is-segal A is-segal-A z y y k (comp-is-segal A is-segal-A y x y h f)) ( comp-is-segal A is-segal-A z y y k (id-hom A y)) ( k) ( associative-is-segal extext A is-segal-A z y x y k h f) ( prewhisker-homotopy-is-segal A is-segal-A z y y k ( comp-is-segal A is-segal-A y x y h f) (id-hom A y) hh) ( comp-id-is-segal A is-segal-A z y k))) #def is-equiv-postcomp-is-iso uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : ( z : A) \u2192 is-equiv (hom A z x) (hom A z y) (postcomp-is-segal A is-segal-A x y f z) := \\ z \u2192 ( ( has-retraction-postcomp-has-retraction A is-segal-A x y f g gg z) , ( has-section-postcomp-has-section A is-segal-A x y f h hh z)) #def has-retraction-precomp-has-section uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : ( z : A) \u2192 has-retraction (hom A y z) (hom A x z) ( precomp-is-segal A is-segal-A x y f z) := \\ z \u2192 ( ( precomp-is-segal A is-segal-A y x h z) , \\ k \u2192 ( triple-concat ( hom A y z) ( comp-is-segal A is-segal-A y x z h (comp-is-segal A is-segal-A x y z f k)) ( comp-is-segal A is-segal-A y y z ( comp-is-segal A is-segal-A y x y h f) k) ( comp-is-segal A is-segal-A y y z (id-hom A y) k) ( k) ( rev ( hom A y z) ( comp-is-segal A is-segal-A y y z ( comp-is-segal A is-segal-A y x y h f) k) ( comp-is-segal A is-segal-A y x z h (comp-is-segal A is-segal-A x y z f k)) ( associative-is-segal extext A is-segal-A y x y z h f k)) ( postwhisker-homotopy-is-segal A is-segal-A y y z ( comp-is-segal A is-segal-A y x y h f) ( id-hom A y) k hh) ( id-comp-is-segal A is-segal-A y z k) ) ) #def has-section-precomp-has-retraction uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) : ( z : A) \u2192 has-section (hom A y z) (hom A x z) (precomp-is-segal A is-segal-A x y f z) := \\ z \u2192 ( ( precomp-is-segal A is-segal-A y x g z) , \\ k \u2192 ( triple-concat ( hom A x z) ( comp-is-segal A is-segal-A x y z f (comp-is-segal A is-segal-A y x z g k)) ( comp-is-segal A is-segal-A x x z ( comp-is-segal A is-segal-A x y x f g) k) ( comp-is-segal A is-segal-A x x z ( id-hom A x) k) ( k) ( rev ( hom A x z) ( comp-is-segal A is-segal-A x x z ( comp-is-segal A is-segal-A x y x f g) k) ( comp-is-segal A is-segal-A x y z f (comp-is-segal A is-segal-A y x z g k)) ( associative-is-segal extext A is-segal-A x y x z f g k)) ( postwhisker-homotopy-is-segal A is-segal-A x x z ( comp-is-segal A is-segal-A x y x f g) ( id-hom A x) ( k) ( gg)) ( id-comp-is-segal A is-segal-A x z k))) #def is-equiv-precomp-is-iso uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : ( z : A) \u2192 is-equiv (hom A y z) (hom A x z) (precomp-is-segal A is-segal-A x y f z) := \\ z \u2192 ( ( has-retraction-precomp-has-section A is-segal-A x y f h hh z) , ( has-section-precomp-has-retraction A is-segal-A x y f g gg z)) #def is-contr-Retraction-arrow-is-iso uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : is-contr (Retraction-arrow A is-segal-A x y f) := ( is-contr-map-is-equiv ( hom A y x) ( hom A x x) ( precomp-is-segal A is-segal-A x y f x) ( is-equiv-precomp-is-iso A is-segal-A x y f g gg h hh x)) ( id-hom A x) #def is-contr-Section-arrow-is-iso uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : is-contr (Section-arrow A is-segal-A x y f) := ( is-contr-map-is-equiv ( hom A y x) ( hom A y y) ( postcomp-is-segal A is-segal-A x y f y) ( is-equiv-postcomp-is-iso A is-segal-A x y f g gg h hh y)) ( id-hom A y) #def is-contr-is-iso-arrow-is-iso uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) ( g : hom A y x) ( gg : has-retraction-arrow A is-segal-A x y f g) ( h : hom A y x) ( hh : has-section-arrow A is-segal-A x y f h) : is-contr (is-iso-arrow A is-segal-A x y f) := ( is-contr-product ( Retraction-arrow A is-segal-A x y f) ( Section-arrow A is-segal-A x y f) ( is-contr-Retraction-arrow-is-iso A is-segal-A x y f g gg h hh) ( is-contr-Section-arrow-is-iso A is-segal-A x y f g gg h hh)) RS17, Proposition 10.2 #def is-prop-is-iso-arrow uses ( extext ) ( A : U) ( is-segal-A : is-segal A) ( x y : A) ( f : hom A x y) : (is-prop (is-iso-arrow A is-segal-A x y f)) := ( is-prop-is-contr-is-inhabited ( is-iso-arrow A is-segal-A x y f) ( \\ is-isof \u2192 ( is-contr-is-iso-arrow-is-iso A is-segal-A x y f ( first ( first is-isof)) ( second ( first is-isof)) ( first ( second is-isof)) ( second ( second is-isof)))))","title":"Being an isomorphism is a proposition"},{"location":"simplicial-hott/10-rezk-types.rzk/#rezk-types_1","text":"A Segal type \\(A\\) is a Rezk type just when, for all x y : A , the natural map from x = y to Iso A is-segal-A x y is an equivalence. #def iso-id-arrow ( A : U) ( is-segal-A : is-segal A) : ( x : A) \u2192 Iso A is-segal-A x x := \\ x \u2192 ( (id-hom A x) , ( ( (id-hom A x) , (id-comp-is-segal A is-segal-A x x (id-hom A x)) ) , ( (id-hom A x) , (id-comp-is-segal A is-segal-A x x (id-hom A x)) ) ) ) #def iso-eq ( A : U) ( is-segal-A : is-segal A) ( x y : A) : (x = y) \u2192 Iso A is-segal-A x y := \\ p \u2192 ind-path ( A) ( x) ( \\ y' p' \u2192 Iso A is-segal-A x y') ( iso-id-arrow A is-segal-A x) ( y) ( p) RS17, Definition 10.6 #def is-rezk ( A : U) : U := \u03a3 ( is-segal-A : is-segal A) , ( x : A) \u2192 ( y : A) \u2192 is-equiv (x = y) (Iso A is-segal-A x y) (iso-eq A is-segal-A x y)","title":"Rezk types"},{"location":"simplicial-hott/10-rezk-types.rzk/#uniqueness-of-initial-and-final-objects","text":"In a Segal type, initial objects are isomorphic. #def iso-initial ( A : U) ( is-segal-A : is-segal A) ( a b : A) ( is-initial-a : is-initial A a) ( is-initial-b : is-initial A b) : Iso A is-segal-A a b := ( first (is-initial-a b) , ( ( first (is-initial-b a) , eq-is-contr ( hom A a a) ( is-initial-a a) ( comp-is-segal A is-segal-A a b a ( first (is-initial-a b)) ( first (is-initial-b a))) ( id-hom A a)) , ( first (is-initial-b a) , eq-is-contr ( hom A b b) ( is-initial-b b) ( comp-is-segal A is-segal-A b a b ( first (is-initial-b a)) ( first (is-initial-a b))) ( id-hom A b)))) In a Segal type, final objects are isomorphic. #def iso-final ( A : U) ( is-segal-A : is-segal A) ( a b : A) ( is-final-a : is-final A a) ( is-final-b : is-final A b) ( iso : Iso A is-segal-A a b) : Iso A is-segal-A a b := ( first (is-final-b a) , ( ( first (is-final-a b) , eq-is-contr ( hom A a a) ( is-final-a a) ( comp-is-segal A is-segal-A a b a ( first (is-final-b a)) ( first (is-final-a b))) ( id-hom A a)) , ( first (is-final-a b) , eq-is-contr ( hom A b b) ( is-final-b b) ( comp-is-segal A is-segal-A b a b ( first (is-final-a b)) ( first (is-final-b a))) ( id-hom A b))))","title":"Uniqueness of initial and final objects"},{"location":"simplicial-hott/12-cocartesian.rzk/","text":"Cocartesian families \u00b6 These formalizations capture cocartesian families as treated in BW23. The goal, for now, is not to give a general structural account as in the paper but rather to provide the definitions and results that are necessary to prove the cocartesian Yoneda Lemma. This is a literate rzk file: #lang rzk-1 Prerequisites \u00b6 hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 10-rezk-types.md - We use Rezk types. (Iso-)Inner families \u00b6 This is a (tentative and redundant) definition of (iso-)inner families. In the future, hopefully, these can be replaced by instances of orthogonal and LARI families. #def is-inner-family ( B : U) ( P : B \u2192 U) : U := product ( product (is-segal B) ( is-segal (\u03a3 (b : B) , P b))) ( (b : B) \u2192 (is-segal (P b))) #def is-isoinner-family ( B : U) ( P : B \u2192 U) : U := product ( product (is-rezk B) ( is-rezk (\u03a3 (b : B) , P b))) ( (b : B) \u2192 (is-rezk (P b))) Cocartesian arrows \u00b6 Here we define the proposition that a dependent arrow in a family is cocartesian. This is an alternative version using unpacked extension types, as this is preferred for usage. BW23, Definition 5.1.1 #def is-cocartesian-arrow ( B : U) ( b b' : B) ( u : hom B b b') ( P : B \u2192 U) ( e : P b) ( e' : P b') ( f : dhom B b b' u P e e') : U := ( b'' : B) \u2192 ( v : hom B b' b'') \u2192 ( w : hom B b b'') \u2192 ( sigma : hom2 B b b' b'' u v w) \u2192 ( e'' : P b'') \u2192 ( h : dhom B b b'' w P e e'') \u2192 is-contr ( \u03a3 ( g : dhom B b' b'' v P e' e'') , ( dhom2 B b b' b'' u v w sigma P e e' e'' f g h)) Cocartesian lifts \u00b6 The following is the type of cocartesian lifts of a fixed arrow in the base with a given starting point in the fiber. BW23, Definition 5.1.2 #def cocartesian-lift ( B : U) ( b b' : B) ( u : hom B b b') ( P : B \u2192 U) ( e : P b) : U := \u03a3 ( e' : P b') , \u03a3 ( f : dhom B b b' u P e e') , is-cocartesian-arrow B b b' u P e e' f Cocartesian family \u00b6 A family over cocartesian if it is isoinner and any arrow in the has a cocartesian lift, given a point in the fiber over the domain. BW23, Definition 5.2.1 #def has-cocartesian-lifts ( B : U) ( P : B \u2192 U) : U := ( b : B) \u2192 ( b' : B) \u2192 ( u : hom B b b') \u2192 ( e : P b) \u2192 ( \u03a3 (e' : P b'), ( \u03a3 (f : dhom B b b' u P e e'), is-cocartesian-arrow B b b' u P e e' f)) BW23, Definition 5.2.2 #def is-cocartesian-family ( B : U) ( P : B \u2192 U) : U := product (is-isoinner-family B P) (has-cocartesian-lifts B P)","title":"Cocartesian Families"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-families","text":"These formalizations capture cocartesian families as treated in BW23. The goal, for now, is not to give a general structural account as in the paper but rather to provide the definitions and results that are necessary to prove the cocartesian Yoneda Lemma. This is a literate rzk file: #lang rzk-1","title":"Cocartesian families"},{"location":"simplicial-hott/12-cocartesian.rzk/#prerequisites","text":"hott/* - We require various prerequisites from homotopy type theory, for instance the axiom of function extensionality. 3-simplicial-type-theory.md \u2014 We rely on definitions of simplicies and their subshapes. 4-extension-types.md \u2014 We use the fubini theorem and extension extensionality. 5-segal-types.md - We make heavy use of the notion of Segal types 10-rezk-types.md - We use Rezk types.","title":"Prerequisites"},{"location":"simplicial-hott/12-cocartesian.rzk/#iso-inner-families","text":"This is a (tentative and redundant) definition of (iso-)inner families. In the future, hopefully, these can be replaced by instances of orthogonal and LARI families. #def is-inner-family ( B : U) ( P : B \u2192 U) : U := product ( product (is-segal B) ( is-segal (\u03a3 (b : B) , P b))) ( (b : B) \u2192 (is-segal (P b))) #def is-isoinner-family ( B : U) ( P : B \u2192 U) : U := product ( product (is-rezk B) ( is-rezk (\u03a3 (b : B) , P b))) ( (b : B) \u2192 (is-rezk (P b)))","title":"(Iso-)Inner families"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-arrows","text":"Here we define the proposition that a dependent arrow in a family is cocartesian. This is an alternative version using unpacked extension types, as this is preferred for usage. BW23, Definition 5.1.1 #def is-cocartesian-arrow ( B : U) ( b b' : B) ( u : hom B b b') ( P : B \u2192 U) ( e : P b) ( e' : P b') ( f : dhom B b b' u P e e') : U := ( b'' : B) \u2192 ( v : hom B b' b'') \u2192 ( w : hom B b b'') \u2192 ( sigma : hom2 B b b' b'' u v w) \u2192 ( e'' : P b'') \u2192 ( h : dhom B b b'' w P e e'') \u2192 is-contr ( \u03a3 ( g : dhom B b' b'' v P e' e'') , ( dhom2 B b b' b'' u v w sigma P e e' e'' f g h))","title":"Cocartesian arrows"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-lifts","text":"The following is the type of cocartesian lifts of a fixed arrow in the base with a given starting point in the fiber. BW23, Definition 5.1.2 #def cocartesian-lift ( B : U) ( b b' : B) ( u : hom B b b') ( P : B \u2192 U) ( e : P b) : U := \u03a3 ( e' : P b') , \u03a3 ( f : dhom B b b' u P e e') , is-cocartesian-arrow B b b' u P e e' f","title":"Cocartesian lifts"},{"location":"simplicial-hott/12-cocartesian.rzk/#cocartesian-family","text":"A family over cocartesian if it is isoinner and any arrow in the has a cocartesian lift, given a point in the fiber over the domain. BW23, Definition 5.2.1 #def has-cocartesian-lifts ( B : U) ( P : B \u2192 U) : U := ( b : B) \u2192 ( b' : B) \u2192 ( u : hom B b b') \u2192 ( e : P b) \u2192 ( \u03a3 (e' : P b'), ( \u03a3 (f : dhom B b b' u P e e'), is-cocartesian-arrow B b b' u P e e' f)) BW23, Definition 5.2.2 #def is-cocartesian-family ( B : U) ( P : B \u2192 U) : U := product (is-isoinner-family B P) (has-cocartesian-lifts B P)","title":"Cocartesian family"}]}