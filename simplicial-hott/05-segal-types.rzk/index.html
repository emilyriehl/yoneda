<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Segal Types - yoneda</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
        <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css" rel="stylesheet" />
<link rel="apple-touch-icon" sizes="180x180" href="/yoneda/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/yoneda/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/yoneda/favicon-16x16.png">
<link rel="manifest" href="/yoneda/site.webmanifest">
<!-- <link rel="stylesheet" href="../../css/highlightjs-11.7.0.min.css" /> -->
<link rel="stylesheet" href="../../css/highlightjs-copy.css" />
<script src="../../js/highlight-11.7.0.min.js"></script>
<script src="../../js/rzk.js"></script>
<link rel="stylesheet" href="../../css/gruvbox-light.css" />
<!-- <link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" /> -->
<script src="../../js/highlightjs-copy.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  hljs.addPlugin(new CopyButtonPlugin());
  hljs.highlightAll();
</script>

    
      <script>
        // Current page data
        var mkdocs_page_name = "Segal Types";
        var mkdocs_page_input_path = "simplicial-hott/05-segal-types.rzk.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>
 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> yoneda
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">General</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../..">About</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">HoTT</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../hott/00-common.rzk/">Common</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../hott/01-paths.rzk/">Paths</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../hott/02-homotopies.rzk/">Homotopies</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../hott/03-equivalences.rzk/">Equivalences</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../hott/04-sigma.rzk/">Sigma types</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../hott/05-contractible.rzk.md">Contractible</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../hott/06-fibers.rzk/">Fibers</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../hott/07-trivial-fibrations.rzk/">Trivial fibrations</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Simplicial HoTT</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../03-simplicial-type-theory.rzk/">Simplicial Type Theory</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../04-extension-types.rzk/">Extension Types</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Segal Types</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#prerequisites">Prerequisites</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#hom-types">Hom types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#the-segal-condition">The Segal condition</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#characterizing-segal-types">Characterizing Segal types</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#segal-function-and-extension-types">Segal function and extension types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#identity">Identity</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#associativity">Associativity</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#homotopies">Homotopies</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../06-2cat-of-segal-types.rzk/">2-Category of Segal Types</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../07-discrete.rzk/">Discrete Types</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../08-covariant.rzk/">Covariantly Functorial Type Families</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../09-yoneda.rzk/">The Yoneda Lemma</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../12-cocartesian.rzk/">Cocartesian Families</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">yoneda</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Simplicial HoTT &raquo;</li>
      <li>Segal Types</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="segal-types">Segal Types</h1>
<p>These formalisations correspond to Section 5 of RS17 paper.</p>
<p>This is a literate <code>rzk</code> file:</p>
<pre><code class="language-rzk">#lang rzk-1
</code></pre>
<h2 id="prerequisites">Prerequisites</h2>
<ul>
<li><code>hott/1-paths.md</code> - We require basic path algebra.</li>
<li><code>hott/2-contractible.md</code> - We require the notion of contractible types and their data.</li>
<li><code>hott/total-space.md</code> — We rely on <code>contractible-fibers-projection-equiv</code> and <code>total-space-projection</code> in the proof of Theorem 5.5.</li>
<li><code>3-simplicial-type-theory.md</code> — We rely on definitions of simplicies and their subshapes.</li>
<li><code>4-extension-types.md</code> — We use the fubini theorem and extension extensionality.</li>
</ul>
<h2 id="hom-types">Hom types</h2>
<p>Extension types are used ∂to define the type of arrows between fixed terms:</p>
<p><svg style="float: right" viewBox="0 0 200 60" width="150" height="60">
  <polyline points="40,30 160,30" stroke="blue" stroke-width="3" marker-end="url(#arrow-blue)"></polyline>
  <text x="30" y="30">x</text>
  <text x="170" y="30">y</text>
</svg></p>
<pre><code class="language-rzk">-- [RS17, Definition 5.1]
-- The type of arrows in A from x to y.
#def hom
  (A : U)   -- A type.
  (x y : A) -- Two points in A.
  : U                   -- (hom A x y) is a 1-simplex (an arrow)
  := (t : Δ¹) -&gt; A [    -- in A where
    t === 0_2 |-&gt; x,    -- * the left endpoint is exactly x
    t === 1_2 |-&gt; y     -- * the right endpoint is exactly y
  ]
</code></pre>
<p>Extension types are also used to define the type of commutative triangles:</p>
<p><svg style="float: right" viewBox="0 0 200 200" width="150" height="200">
  <path style="fill: rgb(0,128,255,0.5); stroke-cap: round;" d="M 52 40 L 160 40 L 160 148 Z"></path>
  <polyline points="40,30 160,30" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="170,40 170,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="40,40 160,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <text x="30" y="30">x</text>
  <text x="170" y="30">y</text>
  <text x="170" y="170">z</text>
  <text x="100" y="15">f</text>
  <text x="185" y="100">g</text>
  <text x="90" y="110">h</text>
</svg></p>
<pre><code class="language-rzk">-- [RS17, Definition 5.2]
-- the type of commutative triangles in A
#def hom2
  (A : U)           -- A type.
  (x y z : A)       -- Three points in A.
  (f : hom A x y)   -- An arrow in A from x to y.
  (g : hom A y z)   -- An arrow in A from y to z.
  (h : hom A x z)   -- An arrow in A from x to z.
  : U                           -- (hom2 A x y z f g h) is a 2-simplex (triangle)
  := { (t1, t2) : Δ² } -&gt; A [   -- in A where
    t2 === 0_2 |-&gt; f t1,        -- * the top edge is exactly f,
    t1 === 1_2 |-&gt; g t2,        -- * the right edge is exactly g, and
    t2 === t1  |-&gt; h t2         -- * the diagonal is exactly h
  ]
</code></pre>
<h2 id="the-segal-condition">The Segal condition</h2>
<p>A type is Segal if every composable pair of arrows has a unique composite. Note this is a considerable simplification of the usual Segal condition, which also requires homotopical uniqueness of higher-order composites.</p>
<pre><code class="language-rzk">-- [RS17, Definition 5.3]
#def isSegal 
  (A : U)         -- A type.
  : U
  := (x : A) -&gt; (y : A) -&gt; (z : A) -&gt; 
      (f : hom A x y) -&gt; (g : hom A y z) -&gt; 
      isContr( ∑ (h : hom A x z), hom2 A x y z f g h)
</code></pre>
<p>Segal types have a composition functor and witnesses to the composition relation:</p>
<pre><code class="language-rzk">-- Composition is written in diagrammatic order to match the order of arguments in isSegal.
#def Segal-comp 
  (A : U)                       -- A type.
  (AisSegal : isSegal A)        -- A proof that A is Segal.
  (x y z : A)                   -- Three points in A.
  (f : hom A x y)               -- An arrow in A from x to y.
  (g : hom A y z)               -- An arrow in A from y to z.
  : hom A x z
  := first (first (AisSegal x y z f g))

-- Segal types have composition witnesses
#def Segal-comp-witness 
  (A : U)                       -- A type.
  (AisSegal : isSegal A)        -- A proof that A is Segal.
  (x y z : A)                   -- Three points in A.
  (f : hom A x y)               -- An arrow in A from x to y.
  (g : hom A y z)               -- An arrow in A from y to z.
  : hom2 A x y z f g (Segal-comp A AisSegal x y z f g)
  := second (first (AisSegal x y z f g))
</code></pre>
<p>Composition in a Segal type is unique in the following sense. If there is a witness that an arrow h is a composite of f and g, then the specified composite equals h.</p>
<p><svg style="float: right" viewBox="0 0 200 380" width="125">
  <path style="fill: rgb(175,175,175,0.5); stroke-cap: round;" d="M 52 40 L 160 40 L 160 148 Z"></path>
  <polyline points="40,30 160,30" stroke="grey" stroke-width="3" marker-end="url(#arrow-grey)"></polyline>
  <polyline points="170,45 170,160" stroke="grey" stroke-width="3" marker-end="url(#arrow-grey)"></polyline>
  <polyline points="40,40 160,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <text x="30" y="30" fill="grey">x</text>
  <text x="170" y="30" fill="grey">y</text>
  <text x="170" y="170" fill="grey">z</text>
  <text x="100" y="15" fill="grey">f</text>
  <text x="185" y="100" fill="grey">g</text>
  <text x="90" y="110">h</text>
  <text x="125" y="75" fill="grey">α</text>
  <text x="100" y="145" fill="red" rotate="90" style="font-size: 50px">=</text>
  <path style="fill: rgb(128,0,0,0.5); stroke-cap: round;" d="M 52 240 L 160 240 L 160 348 Z"></path>
  <polyline points="40,230 160,230" stroke="grey" stroke-width="3" marker-end="url(#arrow-grey)"></polyline>
  <polyline points="170,245 170,360" stroke="grey" stroke-width="3" marker-end="url(#arrow-grey)"></polyline>
  <polyline points="40,240 160,360" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <text x="30" y="230" fill="grey">x</text>
  <text x="170" y="230" fill="grey">y</text>
  <text x="170" y="370" fill="grey">z</text>
  <text x="100" y="215" fill="grey">f</text>
  <text x="185" y="300" fill="grey">g</text>
  <text x="90" y="310" transform="rotate(45, 90, 310)" fill="red">Segal-comp</text>
  <text x="120" y="280" fill="rgb(128,0,0)" transform="rotate(45, 120, 280)" style="font-size: 10px">Segal-comp-witness</text>
</svg></p>
<pre><code class="language-rzk">#def Segal-comp-uniqueness 
  (A : U)                       -- A type.
  (AisSegal : isSegal A)        -- A proof that A is Segal.
  (x y z : A)                   -- Three points in A.
  (f : hom A x y)               -- An arrow in A from x to y.
  (g : hom A y z)               -- An arrow in A from y to z.
  (h : hom A x z)               -- An arrow in A from x to z.
  (alpha : hom2 A x y z f g h)  -- A witness that h is a composite of f and g.
  : (Segal-comp A AisSegal x y z f g) = h
  := first-path-sigma 
      (hom A x z)
      (\k -&gt; hom2 A x y z f g k)
      (Segal-comp A AisSegal x y z f g, 
        Segal-comp-witness A AisSegal x y z f g)
      (h, alpha)
      (contracting-htpy 
        (∑ (k : hom A x z), hom2 A x y z f g k) 
        (AisSegal x y z f g) 
        (h, alpha))
</code></pre>
<h3 id="characterizing-segal-types">Characterizing Segal types</h3>
<p>Our aim is to prove that a type is Segal if and only if the horn-restriction map, defined below, is an equivalence.</p>
<p><svg style="float: right" viewBox="0 0 200 180" width="150" height="150">
  <polyline points="40,30 160,30" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="170,45 170,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <text x="30" y="30">x</text>
  <text x="170" y="30">y</text>
  <text x="170" y="170">z</text>
  <text x="100" y="15">f</text>
  <text x="185" y="100">g</text>
</svg></p>
<pre><code class="language-rzk">-- A pair of composable arrows form a horn.
#def horn
  (A : U)           -- A type.
  (x y z : A)       -- Three points in A.
  (f : hom A x y)   -- An arrow in A from x to y.
  (g : hom A y z)   -- An arrow in A from y to z.
  : Λ -&gt; A
  := \(t, s) -&gt; recOR(
    s === 0_2 |-&gt; f t, 
    t === 1_2 |-&gt; g s
  )
</code></pre>
<pre><code class="language-rzk">-- The underlying horn of a simplex
#def horn-restriction (A : U)
  : (Δ² -&gt; A) -&gt; (Λ -&gt; A)
  :=  \f t -&gt; f t

-- An alternate definition of Segal types.
#def isSegal' (A : U) : U
  := isEquiv (Δ² -&gt; A) (Λ -&gt; A) (horn-restriction A) 
</code></pre>
<p>Now we prove this definition is equivalent to the original one.</p>
<pre><code class="language-rzk">-- Here, we prove the equivalence used in [RS17, Theorem 5.5].
-- However, we do this by constructing the equivalence directly,
-- instead of using a composition of equivalences, as it is easier to write down
-- and it computes better (we can use refl for the witnesses of the equivalence).
#def compositions-are-horn-fillings
  (A : U)                       -- A type.
  (x y z : A)                   -- Three points in A.
  (f : hom A x y)               -- An arrow in A from x to y.
  (g : hom A y z)               -- An arrow in A from y to z.
  : Eq (∑ (h : hom A x z), hom2 A x y z f g h)
       &lt;{t : 2 * 2 | Δ² t } -&gt; A [ Λ t |-&gt; horn A x y z f g t ]&gt;
  := (\hh -&gt; \{t : 2 * 2 | Δ² t} -&gt; (second hh) t,
      ((\k -&gt; (\(t : 2) -&gt; k (t, t), \(t, s) -&gt; k (t, s)), \hh -&gt; refl),
       (\k -&gt; (\(t : 2) -&gt; k (t, t), \(t, s) -&gt; k (t, s)), \hh -&gt; refl)))

#def restriction-equiv
  (A : U)                       -- A type.
  : Eq (&lt;{t : 2 * 2 | Δ² t} -&gt; A &gt;)
      (∑ (k : &lt;{t : 2 * 2 | Λ t} -&gt; A &gt;),
        ∑ (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))),
          hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2))
                 (\t -&gt; k (t, 0_2)) (\t -&gt; k (1_2, t)) h)
  := (\k -&gt;
      (\{t : 2 * 2 | Λ t} -&gt; k t,
        (\(t : 2) -&gt; k (t, t),
         \{t : 2 * 2 | Δ² t} -&gt; k t)),
      ((\khh -&gt; \{t : 2 * 2 | Δ² t} -&gt; (second (second khh)) t, \k -&gt; refl_{k}),
        (\khh -&gt; \{t : 2 * 2 | Δ² t} -&gt; (second (second khh)) t, \k -&gt; refl_{k})))

-- [RS17, Theorem 5.5], the hard direction:
#def Segal-restriction-equiv 
  (A : U)                       -- A type.
  (AisSegal : isSegal A)        -- A proof that A is Segal.
  : Eq (&lt;{t : 2 * 2 | Δ² t} -&gt; A &gt;) (&lt;{t : 2 * 2 | Λ t} -&gt; A &gt;) -- (horn-restriction A)
  := compose_Eq
        (&lt;{t : 2 * 2 | Δ² t} -&gt; A &gt;)
        (∑ (k : &lt;{t : 2 * 2 | Λ t} -&gt; A &gt;),
            ∑ (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))),
            hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2))
                    (\t -&gt; k (t, 0_2)) (\t -&gt; k (1_2, t)) h)
        (&lt;{t : 2 * 2 | Λ t} -&gt; A &gt;)
        (restriction-equiv A)
        (total-space-projection
            (&lt;{t : 2 * 2 | Λ t} -&gt; A &gt;)
            (\k -&gt; ∑ (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))),
                        hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2))
                            (\t -&gt; k (t, 0_2)) (\t -&gt; k (1_2, t)) h),
        (contractible-fibers-projection-equiv
            (&lt;{t : 2 * 2 | Λ t} -&gt; A &gt;)
            (\k -&gt; ∑ (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))),
                        hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2))
                            (\t -&gt; k (t, 0_2)) (\t -&gt; k (1_2, t)) h)
            (\k -&gt; AisSegal (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2))
                            (\t -&gt; k (t, 0_2)) (\t -&gt; k (1_2, t)))))

-- Verify that the mapping in (Segal-restriction-equiv A AisSegal)
-- is exactly (horn-restriction A)
#def Segal-restriction-equiv-test
  (A : U)                       -- A type.
  (AisSegal : isSegal A)        -- A proof that A is Segal.
  : (first (Segal-restriction-equiv A AisSegal)) = (horn-restriction A)
  := refl

-- Segal types are Segal' types.
#def isSegal-isSegal' 
  (A : U)                       -- A type.
  (AisSegal : isSegal A)        -- A proof that A is Segal.
  : isSegal' A
  := second (Segal-restriction-equiv A AisSegal)  

-- Segal' types are Segal types.
#def isSegal'-isSegal 
  (A : U)                       -- A type.
  (AisSegal' : isSegal' A)      -- A proof that A is Segal'.
  : isSegal A
  := \x y z f g -&gt;
      (projection-equiv-contractible-fibers 
        (&lt;{t : 2 * 2 | Λ t} -&gt; A &gt;)
        (\k -&gt; ∑ (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))),
                        hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2))
                            (\t -&gt; k (t, 0_2)) (\t -&gt; k (1_2, t)) h)
        (second (compose_Eq
          (∑ (k : &lt;{t : 2 * 2 | Λ t} -&gt; A &gt;),
            ∑ (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))),
            hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2))
                    (\t -&gt; k (t, 0_2)) (\t -&gt; k (1_2, t)) h)
          (&lt;{t : 2 * 2 | Δ² t} -&gt; A &gt;)
          (&lt;{t : 2 * 2 | Λ t} -&gt; A &gt;)
          (sym_Eq
            (&lt;{t : 2 * 2 | Δ² t} -&gt; A &gt;)
            (∑ (k : &lt;{t : 2 * 2 | Λ t} -&gt; A &gt;),
              ∑ (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))),
              hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2))
                      (\t -&gt; k (t, 0_2)) (\t -&gt; k (1_2, t)) h)
            (restriction-equiv A))
          (horn-restriction A, AisSegal')
        )))
      (horn A x y z f g)  

-- [RS17, Theorem 5.5] proves that both notions of Segal types are logically equivalent.
#def isSegal-iff-isSegal' 
  (A : U)                       -- A type.
  : iff (isSegal A) (isSegal' A)      
  := (isSegal-isSegal' A , isSegal'-isSegal A)
</code></pre>
<h2 id="segal-function-and-extension-types">Segal function and extension types</h2>
<p>Using the new characterization of Segal types, we can show that the type of functions or extensions into a family of Segal types is again a Segal type.</p>
<pre><code class="language-rzk">-- [RS17, Corollary 5.6(i)] : if X is a type and A : X -&gt; U is such that
-- A(x) is a Segal type for all x then (x : X) -&gt; A x is a Segal type
#def Segal-function-types 
  (funext : FunExt)                                 -- This proof uses function extensionality.
  (X : U)                                           -- A type.
  (A : (_ : X) -&gt; U)                                -- A type family
  (fiberwiseAisSegal : (x : X) -&gt; isSegal' (A x))   -- An assumption that the fibers are Segal types.
  : isSegal' ((x : X) -&gt; A x) 
  := triple_compose_isEquiv
       (&lt;{t : 2 * 2 | Δ² t} -&gt; ((x : X) -&gt; A x) &gt;)
       ((x : X) -&gt; &lt;{t : 2 * 2 | Δ² t} -&gt; A x &gt;) 
       ((x : X) -&gt; &lt;{t : 2 * 2 | Λ t} -&gt; A x &gt;) 
       (&lt;{t : 2 * 2 | Λ t} -&gt; ((x : X) -&gt; A x) &gt;)
        (\g -&gt; \x -&gt; \{t : 2 * 2 | Δ² t} -&gt; g t x) -- first equivalence
            (second (flip-ext-fun
              (2 * 2)
              Δ² (\{t : 2 * 2 | Δ² t} -&gt; BOT)
              X
              (\{t : 2 * 2 | Δ² t} -&gt; A)
              (\{t : 2 * 2 | BOT} -&gt; recBOT)))
        (\h -&gt; \x -&gt; \{t : 2 * 2 | Λ t} -&gt; h x t) -- second equivalence
          (second (fibered-Eq-function-Eq 
              funext 
              X 
              (\x -&gt; &lt;{t : 2 * 2 | Δ² t} -&gt; A x &gt;) 
              (\x -&gt; &lt;{t : 2 * 2 | Λ t} -&gt; A x &gt;) 
              (\x -&gt; (horn-restriction (A x) , fiberwiseAisSegal x))))
        (\h -&gt; \{t : 2 * 2 | Λ t} -&gt; \x -&gt; (h x) t) -- third equivalence
          (second(flip-ext-fun-inv
            (2 * 2)
            Λ (\{t : 2 * 2 | Λ t} -&gt; BOT)
            X
            (\{t : 2 * 2 | Λ t} -&gt; A)
            (\{t : 2 * 2 | BOT} -&gt; recBOT)))

-- [RS17, Corollary 5.6(ii)] : if X is a shape and A : X -&gt; U is such that 
-- A(x) is a Segal type for all x then (x : X) -&gt; A x is a Segal type
#def Segal-extension-types 
  (extext : ExtExt)                                             -- This proof uses extension extensionality.
  (I : CUBE)                                                    -- A cube.
  (psi : (s : I) -&gt; TOPE)                                       -- A tope.
  (A : &lt;{s : I | psi s} -&gt; U &gt;)                                 -- An extension type.
  (fiberwiseAisSegal : &lt;{s : I | psi s} -&gt; isSegal' (A s) &gt;)    -- An assumption that the fibers are Segal types.
  : isSegal' (&lt;{s : I | psi s} -&gt; A s &gt;) 
  := triple_compose_isEquiv
        (&lt;{t : 2 * 2 | Δ² t} -&gt; &lt;{s : I | psi s} -&gt; A s &gt; &gt;) 
        (&lt;{s : I | psi s} -&gt; &lt;{t : 2 * 2 | Δ² t} -&gt; A s &gt; &gt;)
        (&lt;{s : I | psi s} -&gt; &lt;{t : 2 * 2 | Λ t} -&gt; A s &gt; &gt;)
        (&lt;{t : 2 * 2 | Λ t} -&gt; &lt;{s : I | psi s} -&gt; A s &gt; &gt;)
        (\g -&gt; \{s : I | psi s} -&gt; \{t : 2 * 2 | Δ² t} -&gt; g t s)  -- first equivalence
            (second(fubini
              (2 * 2)
              I 
              Δ²
              (\{t : 2 * 2 | Δ² t} -&gt; BOT)
              psi
              (\{s : I | psi s} -&gt; BOT)
              (\{t : 2 * 2 | Δ² t} -&gt; \{s : I | psi s} -&gt; A s)
              (\{u : (2 * 2) * I | BOT} -&gt; recBOT)))
        (\h -&gt; \{s : I | psi s} -&gt; \{t : 2 * 2 | Λ t} -&gt; h s t) -- second equivalence
          (second (fibered-equiv-extension-equiv extext I psi  
            (\{s : I | psi s} -&gt; &lt;{t : 2 * 2 | Δ² t} -&gt; A s &gt;)
            (\{s : I | psi s} -&gt; &lt;{t : 2 * 2 | Λ t} -&gt; A s &gt;)
            (\{s : I | psi s} -&gt; (horn-restriction (A s), fiberwiseAisSegal s))     ))
        (\h -&gt; \{t : 2 * 2 | Λ t} -&gt; \{s : I | psi s} -&gt; (h s) t) -- third equivalence
          (second(fubini
            I 
            (2 * 2)
            psi
            (\{s : I | psi s} -&gt; BOT)
            Λ
            (\{t : 2 * 2 | Λ t} -&gt; BOT)
            (\{s : I | psi s} -&gt; \{t : 2 * 2 | Λ t} -&gt; A s)
            (\{u : I * (2 * 2) | BOT} -&gt; recBOT)))        
</code></pre>
<p>In particular, the arrow type of a Segal type is Segal.</p>
<pre><code class="language-rzk">-- The type of arrows in a type.
#def arr        -- A type
  (A : U) 
  : U
  := (t : Δ¹) -&gt; A

-- A special case of [RS17, Corollary 5.6(ii)], using is-Segal'.
#def Segal'-arrow-types 
  (extext : ExtExt)                         -- This proof uses extension extensionality.
  (A : U)                                   -- A type.
  (AisSegal : isSegal' A)                   -- A proof that A isSegal'.
  : isSegal' (arr A)
  := Segal-extension-types
        extext
        2
        Δ¹
        (\{t : 2 | Δ¹ t} -&gt; A)
        (\{t : 2 | Δ¹ t} -&gt; AisSegal)  

-- A special case of [RS17, Corollary 5.6(ii)], using is-Segal.
#def Segal-arrow-types 
  (extext : ExtExt)                         -- This proof uses extension extensionality.
  (A : U)                                   -- A type.
  (AisSegal : isSegal A)                    -- A proof that A is Segal.
  : isSegal (arr A)
  := isSegal'-isSegal (arr A)
      (Segal-extension-types
        extext
        2
        Δ¹
        (\{t : 2 | Δ¹ t} -&gt; A)
        (\{t : 2 | Δ¹ t} -&gt; (isSegal-isSegal' A AisSegal)))
</code></pre>
<h2 id="identity">Identity</h2>
<p>All types have identity arrows and witnesses to the identity composition law.</p>
<p><svg style="float: right" viewBox="0 0 200 180" width="150" height="150">
  <polyline points="40,30 160,30" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <text x="30" y="30">x</text>
  <text x="170" y="30">x</text>
  <text x="100" y="15" fill="red">x</text>
</svg></p>
<pre><code class="language-rzk">-- [RS17, Definition 5.7]
-- all types have identity arrows
#def id-arr
  (A : U)               -- A type.
  (x : A)               -- A point in A.
  : hom A x x
  := \{t : 2 | Δ¹ t} -&gt; x 
</code></pre>
<p>Witness for the right identity law:</p>
<p><svg style="float: right" viewBox="0 0 200 180" width="150" height="150">
  <path style="fill: rgb(255,128,0,0.5); stroke-cap: round;" d="M 52 40 L 160 40 L 160 148 Z"></path>
  <polyline points="40,30 160,30" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="170,45 170,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="40,40 160,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <text x="30" y="30">x</text>
  <text x="170" y="30">y</text>
  <text x="170" y="170">y</text>
  <text x="100" y="15">f</text>
  <text x="185" y="100">y</text>
  <text x="90" y="110">f</text>
  <text x="125" y="75" stroke="red" fill="red">f</text>
</svg></p>
<pre><code class="language-rzk">-- [RS17, Proposition 5.8a]
-- the right unit law for identity
#def comp-id-witness 
  (A : U)                   -- A type.
  (x y : A)                 -- Two points in A.
  (f : hom A x y)           -- An arrow from x to y in A.
  : hom2 A x y y f (id-arr A y) f
  := \{(t, s) : 2 * 2 | Δ² (t, s)} -&gt; f t
</code></pre>
<p>Witness for the left identity law:</p>
<p><svg style="float: right" viewBox="0 0 200 180" width="150" height="150">
  <path style="fill: rgb(255,128,0,0.5); stroke-cap: round;" d="M 52 40 L 160 40 L 160 148 Z"></path>
  <polyline points="40,30 160,30" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="170,45 170,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="40,40 160,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <text x="30" y="30">x</text>
  <text x="170" y="30">x</text>
  <text x="170" y="170">y</text>
  <text x="100" y="15">x</text>
  <text x="185" y="100">f</text>
  <text x="90" y="110">f</text>
  <text x="125" y="75" stroke="red" fill="red">f</text>
</svg></p>
<pre><code class="language-rzk">-- [RS17, Proposition 5.8b]
-- the left unit law for identity
#def id-comp-witness 
  (A : U)                   -- A type.
  (x y : A)                 -- Two points in A.
  (f : hom A x y)           -- An arrow from x to y in A.
  : hom2 A x x y (id-arr A x) f f
  := \{(t, s) : 2 * 2 | Δ² (t, s)} -&gt; f s
</code></pre>
<p>In a Segal type, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. 
Thus, an identity axiom was not needed in the definition of Segal types.</p>
<pre><code class="language-rzk">-- If A is Segal then the right unit law holds
#def Segal-comp-id
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.
  (x y : A)                 -- Two points in A.
  (f : hom A x y)           -- An arrow from x to y in A.
  : (Segal-comp A AisSegal x y y f (id-arr A y)) =_{hom A x y} f
  := Segal-comp-uniqueness
      A
      AisSegal
      x y y
      f
      (id-arr A y)
      f
      (comp-id-witness A x y f)

-- If A is Segal then the left unit law holds
#def Segal-id-comp
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.
  (x y : A)                 -- Two points in A.
  (f : hom A x y)           -- An arrow from x to y in A.
  : (Segal-comp A AisSegal x x y (id-arr A x) f) =_{hom A x y} f
  := Segal-comp-uniqueness
      A
      AisSegal
      x x y
      (id-arr A x)
      f
      f
      (id-comp-witness A x y f)
</code></pre>
<h2 id="associativity">Associativity</h2>
<p>We now prove that composition in a Segal type is associative, by using the fact that the type of arrows in a Segal type is itself a Segal type.</p>
<p><svg style="float: right" viewBox="0 0 200 180" width="150" height="150">
  <path style="fill: rgb(128,128,128,0.5); stroke-cap: round;" d="M 52 40 L 160 40 L 160 148 Z"></path>
  <path style="fill: rgb(256,128,0,0.5); stroke-cap: round;" d="M 40 52 L 40 160 L 148 160 Z"></path>
  <polyline points="40,30 160,30" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="170,45 170,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="40,40 160,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="30,40 30,160" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <polyline points="45,170 160,170" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <text x="30" y="30">•</text>
  <text x="170" y="30">•</text>
  <text x="170" y="170">•</text>
  <text x="30" y="170" fill="red">•</text>
</svg></p>
<pre><code class="language-rzk">#def unfolding-square 
  (A : U)                         -- A type.
  (triangle : Δ² -&gt; A)            -- A triangle in A.
  : Δ¹×Δ¹ -&gt; A                    -- A square in A, defined by gluing
  := \(t, s) -&gt;                   -- two copies of the triangle along the common diagonal edge.
    recOR(t &lt;= s |-&gt; triangle (s , t), 
        s &lt;= t |-&gt; triangle (t , s))
</code></pre>
<p>For use in the proof of associativity:</p>
<p><svg style="float: right" viewBox="0 0 200 200" width="150" height="150">
  <path style="fill: rgb(256,128,0,0.5); stroke-cap: round;" d="M 52 40 L 160 40 L 160 148 Z"></path>
  <path style="fill: rgb(256,128,0,0.5); stroke-cap: round;" d="M 40 52 L 40 160 L 148 160 Z"></path>
  <polyline points="40,30 160,30" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="170,45 170,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="40,40 160,160" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <polyline points="30,40 30,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="45,170 160,170" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <text x="30" y="30">x</text>
  <text x="170" y="30">y</text>
  <text x="170" y="170">z</text>
  <text x="30" y="170">y</text>
  <text x="100" y="15">f</text>
  <text x="185" y="100">g</text>
  <text x="90" y="110" transform="rotate(45, 90, 110)" fill="red">Segal-comp</text>
  <text x="100" y="190">g</text>
  <text x="15" y="100">f</text>
</svg></p>
<pre><code class="language-rzk">#def Segal-comp-witness-square 
  (A : U)                       -- A type.
  (AisSegal : isSegal A)        -- A proof that A is Segal.
  (x y z : A)                   -- Three points in A.
  (f : hom A x y)               -- An arrow in A from x to y.
  (g : hom A y z)               -- An arrow in A from y to z.
  : Δ¹×Δ¹ -&gt; A 
  := unfolding-square A (Segal-comp-witness A AisSegal x y z f g)
</code></pre>
<p>The Segal-comp-witness-square as an arrow in the arrow type:</p>
<p><svg style="float: right" viewBox="0 0 200 200" width="150" height="150">
  <polyline points="170,45 170,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="30,40 30,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="40,100 160,100" stroke="red" stroke-width="6" marker-end="url(#arrow-red)"></polyline>
  <text x="30" y="30">x</text>
  <text x="170" y="30">y</text>
  <text x="170" y="170">z</text>
  <text x="30" y="170">y</text>
  <text x="15" y="100">f</text>
  <text x="185" y="100">g</text>
</svg></p>
<pre><code class="language-rzk">#def Segal-arr-in-arr 
  (A : U)                       -- A type.
  (AisSegal : isSegal A)        -- A proof that A is Segal.
  (x y z : A)                   -- Three points in A.
  (f : hom A x y)               -- An arrow in A from x to y.
  (g : hom A y z)               -- An arrow in A from y to z.
  : hom (arr A) f g
  := \t -&gt; \s -&gt; (Segal-comp-witness-square A AisSegal x y z f g) (t, s)
</code></pre>
<p><svg style="float: right" viewBox="0 0 200 250" width="150" height="200">
  <polyline points="170,45 170,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="30,40 30,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="40,100 160,100" stroke="red" stroke-width="6" marker-end="url(#arrow-red)"></polyline>
  <polyline points="40,30 160,30" stroke="lightgrey" stroke-width="3"></polyline>
  <polyline points="40,170 160,170" stroke="lightgrey" stroke-width="3"></polyline>
  <path style="fill: rgb(256,128,0,0.5); stroke-cap: round;" d="M 40 100 L 160 100 L 100 130 Z"></path>
  <polyline points="100,70 100,190" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="155,105 105,130" stroke="red" stroke-width="6" marker-end="url(#arrow-red)"></polyline>
  <polyline points="45,105 95,130" stroke="red" stroke-width="6" marker-end="url(#arrow-red)"></polyline>
  <polyline points="155,35 105,55" stroke="lightgrey" stroke-width="3"></polyline>
  <polyline points="45,35 95,55" stroke="lightgrey" stroke-width="3"></polyline>
  <polyline points="155,175 105,195" stroke="lightgrey" stroke-width="3"></polyline>
  <polyline points="45,175 95,195" stroke="lightgrey" stroke-width="3"></polyline>
  <text x="30" y="30">w</text>
  <text x="170" y="30">x</text>
  <text x="30" y="170">x</text>
  <text x="170" y="170">y</text>
  <text x="100" y="60">y</text>
  <text x="100" y="200">z</text>
  <text x="15" y="100">f</text>
  <text x="185" y="100">g</text>
  <text x="90" y="150">h</text>
</svg></p>
<pre><code class="language-rzk">#def Segal-associativity-witness 
  (extext : ExtExt)         -- This proof uses extension extensionality.
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (w x y z : A)             -- Four points in A.
  (f : hom A w x)           -- An arrow in A from w to x.
  (g : hom A x y)           -- An arrow in A from x to y.
  (h : hom A y z)           -- An arrow in A from y to z.
  : hom2 (arr A) f g h
      (Segal-arr-in-arr A AisSegal w x y f g)
      (Segal-arr-in-arr A AisSegal x y z g h)
      (Segal-comp (arr A) (Segal-arrow-types extext A AisSegal) 
      f g h 
      (Segal-arr-in-arr A AisSegal w x y f g) 
      (Segal-arr-in-arr A AisSegal x y z g h))
  := (Segal-comp-witness (arr A) (Segal-arrow-types extext A AisSegal) 
      f g h
      (Segal-arr-in-arr A AisSegal w x y f g) 
      (Segal-arr-in-arr A AisSegal x y z g h))
</code></pre>
<p><svg style="float: right" viewBox="0 0 200 250" width="150" height="200">
  <path style="fill: rgb(256,128,0,0.5); stroke-cap: round;"
    d="M 35 35 L 165 35 L 165 165 L 102 190 Z"></path>
  <polyline points="170,45 170,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="30,40 95,190" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <polyline points="40,40 160,160" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <polyline points="160,40 110,180" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <polyline points="40,30 160,30" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="155,175 110,195" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <text x="30" y="30">w</text>
  <text x="170" y="30">x</text>
  <text x="170" y="170">y</text>
  <text x="100" y="200">z</text>
  <text x="185" y="100">g</text>
  <text x="100" y="15">f</text>
  <text x="140" y="205">h</text>
</svg></p>
<pre><code class="language-rzk">-- The Segal-associativity-witness curries to define a diagram Δ²×Δ¹ -&gt; A.
-- The Segal-associativity-tetrahedron is extracted via the middle-simplex map \((t, s), r) -&gt; ((t, r), s) from Δ³ to Δ²×Δ¹
#def Segal-associativity-tetrahedron 
  (extext : ExtExt)         -- This proof uses extension extensionality.
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (w x y z : A)             -- Four points in A.
  (f : hom A w x)           -- An arrow in A from w to x.
  (g : hom A x y)           -- An arrow in A from x to y.
  (h : hom A y z)           -- An arrow in A from y to z.
  : Δ³ -&gt; A
  := \((t, s), r) -&gt; 
    (Segal-associativity-witness extext A AisSegal w x y z f g h) (t, r) s
</code></pre>
<p><svg style="float: right" viewBox="0 0 200 250" width="150" height="200">
  <path style="fill: rgb(128,128,128,0.5); stroke-cap: round;"
    d="M 35 35 L 165 35 L 165 165 L 102 190 Z"></path>
  <polyline points="170,45 170,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="30,40 95,190" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <polyline points="40,40 160,160" stroke="grey" stroke-width="3" marker-end="url(#arrow-grey)"></polyline>
  <polyline points="160,40 110,180" stroke="grey" stroke-width="3" marker-end="url(#arrow-grey)"></polyline>
  <polyline points="40,30 160,30" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="155,175 110,195" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <text x="30" y="30">w</text>
  <text x="170" y="30">x</text>
  <text x="170" y="170">y</text>
  <text x="100" y="200">z</text>
  <text x="185" y="100">g</text>
  <text x="100" y="15">f</text>
  <text x="140" y="205">h</text>
</svg></p>
<pre><code class="language-rzk">-- the diagonal composite of three arrows extracted from the Segal-associativity-tetrahedron
#def Segal-triple-composite 
  (extext : ExtExt)         -- This proof uses extension extensionality.
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (w x y z : A)             -- Four points in A.
  (f : hom A w x)           -- An arrow in A from w to x.
  (g : hom A x y)           -- An arrow in A from x to y.
  (h : hom A y z)           -- An arrow in A from y to z.
  : hom A w z 
  := \t -&gt; 
    (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), t)
</code></pre>
<p><svg style="float: right" viewBox="0 0 200 250" width="150" height="200">
  <path style="fill: rgb(128,128,128,0.5); stroke-cap: round;"
    d="M 40 35 L 165 35 L 165 160 Z"></path>
  <path style="fill: rgb(256,128,0,0.5); stroke-cap: round;"
    d="M 35 40 L 160 165 L 102 190 Z"></path>
  <polyline points="170,45 170,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="30,40 95,190" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <polyline points="40,40 160,160" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <polyline points="160,40 110,180" stroke="grey" stroke-width="3" marker-end="url(#arrow-grey)"></polyline>
  <polyline points="40,30 160,30" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="155,175 110,195" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <text x="30" y="30">w</text>
  <text x="170" y="30">x</text>
  <text x="170" y="170">y</text>
  <text x="100" y="200">z</text>
  <text x="185" y="100">g</text>
  <text x="100" y="15">f</text>
  <text x="140" y="205">h</text>
</svg></p>
<pre><code class="language-rzk">#def Segal-left-associativity-witness 
  (extext : ExtExt)         -- This proof uses extension extensionality.
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (w x y z : A)             -- Four points in A.
  (f : hom A w x)           -- An arrow in A from w to x.
  (g : hom A x y)           -- An arrow in A from x to y.
  (h : hom A y z)           -- An arrow in A from y to z.
  : hom2 A w y z 
    (Segal-comp A AisSegal w x y f g) 
    h 
    (Segal-triple-composite extext A AisSegal w x y z f g h)
  := \(t, s) -&gt; 
    (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), s)
</code></pre>
<p>The front face:</p>
<p><svg style="float: right" viewBox="0 0 200 250" width="150" height="200">
  <path style="fill: rgb(256,128,0,0.5); stroke-cap: round;"
    d="M 35 35 L 155 35 L 100 185 Z"></path>
  <path style="fill: rgb(128,128,128,0.5); stroke-cap: round;"
    d="M 165 40 L 165 165 L 115 185 Z"></path>
  <polyline points="170,45 170,160" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="30,40 95,190" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <polyline points="40,40 160,160" stroke="grey" stroke-width="3" marker-end="url(#arrow-grey)"></polyline>
  <polyline points="160,40 110,180" stroke="red" stroke-width="3" marker-end="url(#arrow-red)"></polyline>
  <polyline points="40,30 160,30" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <polyline points="155,175 110,195" stroke="black" stroke-width="3" marker-end="url(#arrow)"></polyline>
  <text x="30" y="30">w</text>
  <text x="170" y="30">x</text>
  <text x="170" y="170">y</text>
  <text x="100" y="200">z</text>
  <text x="185" y="100">g</text>
  <text x="100" y="15">f</text>
  <text x="140" y="205">h</text>
</svg></p>
<pre><code class="language-rzk">#def Segal-right-associativity-witness 
  (extext : ExtExt)         -- This proof uses extension extensionality.
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (w x y z : A)             -- Four points in A.
  (f : hom A w x)           -- An arrow in A from w to x.
  (g : hom A x y)           -- An arrow in A from x to y.
  (h : hom A y z)           -- An arrow in A from y to z.
  : hom2 A w x z 
    f 
    (Segal-comp A AisSegal x y z g h) 
    (Segal-triple-composite extext A AisSegal w x y z f g h)
  := \(t, s) -&gt; 
    (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, s), s)
</code></pre>
<pre><code class="language-rzk">#def Segal-left-associativity 
  (extext : ExtExt)         -- This proof uses extension extensionality.
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (w x y z : A)             -- Four points in A.
  (f : hom A w x)           -- An arrow in A from w to x.
  (g : hom A x y)           -- An arrow in A from x to y.
  (h : hom A y z)           -- An arrow in A from y to z.
  : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) =
      (Segal-triple-composite extext A AisSegal w x y z f g h)
  := Segal-comp-uniqueness 
        A AisSegal w y z (Segal-comp A AisSegal w x y f g) h
        (Segal-triple-composite extext A AisSegal w x y z f g h)
        (Segal-left-associativity-witness extext A AisSegal w x y z f g h)

#def Segal-right-associativity 
  (extext : ExtExt)         -- This proof uses extension extensionality.
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (w x y z : A)             -- Four points in A.
  (f : hom A w x)           -- An arrow in A from w to x.
  (g : hom A x y)           -- An arrow in A from x to y.
  (h : hom A y z)           -- An arrow in A from y to z.
  : (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) =
      (Segal-triple-composite extext A AisSegal w x y z f g h)
  := Segal-comp-uniqueness 
        A AisSegal w x z f (Segal-comp A AisSegal x y z g h)
        (Segal-triple-composite extext A AisSegal w x y z f g h)
        (Segal-right-associativity-witness extext A AisSegal w x y z f g h)

#def Segal-associativity 
  (extext : ExtExt)         -- This proof uses extension extensionality.
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (w x y z : A)             -- Four points in A.
  (f : hom A w x)           -- An arrow in A from w to x.
  (g : hom A x y)           -- An arrow in A from x to y.
  (h : hom A y z)           -- An arrow in A from y to z.
  : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) =
      (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) 
  := zig-zag-concat (hom A w z) 
      (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h)
      (Segal-triple-composite extext A AisSegal w x y z f g h)
      (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h))
      (Segal-left-associativity extext A AisSegal w x y z f g h) 
      (Segal-right-associativity extext A AisSegal w x y z f g h)
</code></pre>
<h2 id="homotopies">Homotopies</h2>
<p>We may define a "homotopy" to be a path between parallel arrows. In a Segal type, homotopies are equivalent to terms in hom2 types involving an identity arrow.</p>
<pre><code class="language-rzk">#def homotopy-to-hom2
  (A : U)
  (x y : A)
  (f g : hom A x y)
  (p : f = g)
  : (hom2 A x x y (id-arr A x) f g)
  := idJ(hom A x y, f, 
          \g' p' -&gt; (hom2 A x x y (id-arr A x) f g'), 
          (id-comp-witness A x y f), g, p)

#def homotopy-to-hom2-total-map
  (A : U)
  (x y : A)
  (f : hom A x y)
  : (∑ (g : hom A x y), f = g) -&gt; 
      (∑ (g : hom A x y), (hom2 A x x y (id-arr A x) f g))
  := \(g, p) -&gt; (g, homotopy-to-hom2 A x y f g p)

#def Segal-homotopy-to-hom2-total-map-isEquiv
  (A : U)
  (AisSegal : isSegal A)
  (x y : A)
  (f : hom A x y)
  : isEquiv 
      (∑ (g : hom A x y), f = g)
      (∑ (g : hom A x y), (hom2 A x x y (id-arr A x) f g))
      (homotopy-to-hom2-total-map A x y f)
  := areContr-isEquiv 
        (∑ (g : hom A x y), f = g)
        (∑ (g : hom A x y), (hom2 A x x y (id-arr A x) f g))
        (based-paths-contractible (hom A x y) f)
        (AisSegal x x y (id-arr A x) f)
        (homotopy-to-hom2-total-map A x y f)

-- [RS17, Proposition 5.10]
#def Eq-Segal-homotopy-hom2
  (A : U)
  (AisSegal : isSegal A)
  (x y : A)
  (f g : hom A x y)
  : Eq (f = g) (hom2 A x x y (id-arr A x) f g)
  := (homotopy-to-hom2 A x y f g, 
    total-equiv-family-of-equiv (hom A x y) 
      (\g -&gt; (f = g))
      (\g -&gt; (hom2 A x x y (id-arr A x) f g))
      (homotopy-to-hom2 A x y f)
      (Segal-homotopy-to-hom2-total-map-isEquiv A AisSegal x y f)
      g)
</code></pre>
<p>More generally, a homotopy between a composite and another map is equivalent to the data provided by a commutative triangle with that boundary.</p>
<pre><code class="language-rzk">#def Segal-eq-to-hom2
  (A : U)
  (AisSegal : isSegal A)
  (x y z : A)
  (f : hom A x y)
  (g : hom A y z)
  (h : hom A x z)
  (p : (Segal-comp A AisSegal x y z f g) = h)
  : (hom2 A x y z f g h)
  := idJ(hom A x z, (Segal-comp A AisSegal x y z f g), 
          \h' p' -&gt; (hom2 A x y z f g h'), 
          Segal-comp-witness A AisSegal x y z f g, h, p)

#def Segal-eq-to-hom2-total-map
  (A : U)
  (AisSegal : isSegal A)
  (x y z : A)
  (f : hom A x y)
  (g : hom A y z)
  : (∑ (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h) -&gt; 
      (∑ (h : hom A x z), (hom2 A x y z f g h))
  := \(h, p) -&gt; (h, Segal-eq-to-hom2 A AisSegal x y z f g h p)

#def Segal-eq-to-hom2-total-map-isEquiv
  (A : U)
  (AisSegal : isSegal A)
  (x y z : A)
  (f : hom A x y)
  (g : hom A y z)
  : isEquiv 
      (∑ (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h)
      (∑ (h : hom A x z), (hom2 A x y z f g h))
      (Segal-eq-to-hom2-total-map A AisSegal x y z f g)
  := areContr-isEquiv 
        (∑ (h : hom A x z), (Segal-comp A AisSegal x y z f g) = h)
        (∑ (h : hom A x z), (hom2 A x y z f g h))
        (based-paths-contractible (hom A x z) (Segal-comp A AisSegal x y z f g) )
        (AisSegal x y z f g)
        (Segal-eq-to-hom2-total-map A AisSegal x y z f g)

-- [RS17, Proposition 5.12]
#def Eq-Segal-eq-hom2
  (A : U)
  (AisSegal : isSegal A)
  (x y z : A)
  (f : hom A x y)
  (g : hom A y z)
  (h : hom A x z)
  : Eq ((Segal-comp A AisSegal x y z f g) = h) (hom2 A x y z f g h)
  := (Segal-eq-to-hom2 A AisSegal x y z f g h, 
    total-equiv-family-of-equiv (hom A x z) 
      (\h -&gt; (Segal-comp A AisSegal x y z f g) = h)
      (\h -&gt; hom2 A x y z f g h)
      (Segal-eq-to-hom2 A AisSegal x y z f g)
      (Segal-eq-to-hom2-total-map-isEquiv A AisSegal x y z f g)
      h)
</code></pre>
<p>Homotopies form a congruence, meaning that homotopies are respected by composition:</p>
<pre><code class="language-rzk">-- [RS17, Proposition 5.13]
#def Segal-homotopy-congruence  
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (x y z : A)
  (f g : hom A x y)
  (h k : hom A y z)
  (p : f = g)
  (q : h = k)
  : (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g k)
  := idJ(hom A y z, h, \k' q' -&gt; (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g k'),
    idJ(hom A x y, f, \g' p' -&gt; (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g' h), refl, g, p)
    , k, q)

-- As a special case of the above:
#def Segal-homotopy-postwhisker 
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (x y z : A)
  (f g : hom A x y)
  (h : hom A y z)
  (p : f = g)
  : (Segal-comp A AisSegal x y z f h) = (Segal-comp A AisSegal x y z g h)
  := Segal-homotopy-congruence A AisSegal x y z f g h h p refl

-- As a special case of the above:
#def Segal-homotopy-prewhisker 
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (w x y : A)
  (k : hom A w x)
  (f g : hom A x y)
  (p : f = g)
  : (Segal-comp A AisSegal w x y k f) = (Segal-comp A AisSegal w x y k g)
  := Segal-homotopy-congruence A AisSegal w x y k k f g refl p

-- [RS17, Proposition 5.14(a)]
#def Segal-homotopy-postwhisker-is-ap 
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (x y z : A)
  (f g : hom A x y)
  (h : hom A y z)
  (p : f = g)
  : (Segal-homotopy-postwhisker A AisSegal x y z f g h p) = 
    ap (hom A x y) (hom A x z) f g (\k -&gt; Segal-comp A AisSegal x y z k h) p
  := idJ(hom A x y, f, \g' p' -&gt; (Segal-homotopy-postwhisker A AisSegal x y z f g' h p') = 
    ap (hom A x y) (hom A x z) f g' (\k -&gt; Segal-comp A AisSegal x y z k h) p', refl, g, p)

-- [RS17, Proposition 5.14(b)]
#def Segal-homotopy-prewhisker-is-ap 
  (A : U)                   -- A type.
  (AisSegal : isSegal A)    -- A proof that A is Segal.  
  (w x y : A)
  (k : hom A w x)
  (f g : hom A x y)
  (p : f = g)
  : (Segal-homotopy-prewhisker A AisSegal w x y k f g p) = 
    ap (hom A x y) (hom A w y) f g (Segal-comp A AisSegal w x y k) p
  := idJ(hom A x y, f, \g' p' -&gt; (Segal-homotopy-prewhisker A AisSegal w x y k f g' p') = 
    ap (hom A x y) (hom A w y) f g' (Segal-comp A AisSegal w x y k) p', refl, g, p)
</code></pre>
<!-- Definitions for the SVG images above -->
<p><svg width="0" height="0">
  <defs>
    <style data-bx-fonts="Noto Serif">@import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap);</style>
    <marker
      id="arrow-blue"
      viewBox="0 0 10 10"
      refX="5"
      refY="5"
      markerWidth="5"
      markerHeight="5"
      orient="auto-start-reverse">
      <path d="M 0 2 L 5 5 L 0 8 z" stroke="blue" fill="blue" />
    </marker>
    <marker
      id="arrow-red"
      viewBox="0 0 10 10"
      refX="5"
      refY="5"
      markerWidth="5"
      markerHeight="5"
      orient="auto-start-reverse">
      <path d="M 0 2 L 5 5 L 0 8 z" stroke="red" fill="red" />
    </marker>
    <marker
      id="arrow-grey"
      viewBox="0 0 10 10"
      refX="5"
      refY="5"
      markerWidth="5"
      markerHeight="5"
      orient="auto-start-reverse">
      <path d="M 0 2 L 5 5 L 0 8 z" stroke="grey" fill="grey" />
    </marker>
    <marker
      id="arrow"
      viewBox="0 0 10 10"
      refX="5"
      refY="5"
      markerWidth="5"
      markerHeight="5"
      orient="auto-start-reverse">
      <path d="M 0 2 L 5 5 L 0 8 z" stroke="black" fill="black" />
    </marker>
  </defs>
<br />
<style>
    text, textPath {
      font-family: Noto Serif;
      font-size: 20px;
      dominant-baseline: middle;
      text-anchor: middle;
    }
  </style></p>
<p></svg></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../04-extension-types.rzk/" class="btn btn-neutral float-left" title="Extension Types"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../06-2cat-of-segal-types.rzk/" class="btn btn-neutral float-right" title="2-Category of Segal Types">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../04-extension-types.rzk/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../06-2cat-of-segal-types.rzk/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
